package application;

public class ModernizedCProgram {
	public static int Curl_inet_pton;
	public static Object curl_llist_dtor;
	public static Object Curl_llist_init;
	public static Object Curl_llist_insert_next;
	public static Object Curl_llist_remove;
	public static size_t Curl_llist_count = new size_t();
	public static Object Curl_llist_destroy;
	public static Object Curl_llist_move;
	public static bool Curl_is_absolute_url = new bool();
	public static byte ipv_inuse = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*
	 * curl's test suite Real Time Streaming Protocol (RTSP) server.
	 *
	 * This source file was started based on curl's HTTP test suite server.
	 *//* for TCP_NODELAY *//* make the curlx header define all printf() functions to use the curlx_*
	   versions instead *//* from the private lib dir *//* include memdebug.h last *//* errno.h value *//* errno.h value */"IPv4";
	public static int serverlogslocked = 0;
	public static long prevtestno = -/* previous test number we served */1;
	public static long prevpartno = -/* previous part number we served */1;
	public static bool prevbounce = /* instructs the server to increase the part
	                                   number for a test in case the identical
	                                   testno+partno request shows up again */0/* default request, use the tests file normally */;
	public static int ProcessRequest;
	public static Object storerequest;
	public static byte serverlogfile = "log/rtspd.log"/* very-big-path support */;
	public static byte docquit = /* sent as reply to a QUIT */"HTTP/1.1 200 Goodbye\r\n\r\n";
	public static byte docconnect = /* sent as reply to a CONNECT */"HTTP/1.1 200 Mighty fine indeed\r\n\r\n";
	public static byte docbadconnect = /* sent as reply to a "bad" CONNECT */"HTTP/1.1 501 Forbidden you fool\r\n\r\n";
	public static byte doc404_HTTP = /* send back this on HTTP 404 file not found */"HTTP/1.1 404 Not Found\r\nServer: curl test suite RTSP server/0.1\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML><HEAD>\n<TITLE>404 Not Found</TITLE>\n</HEAD><BODY>\n<H1>Not Found</H1>\nThe requested URL was not found on this server.\n<P><HR><ADDRESS>curl test suite RTSP server/0.1</ADDRESS>\n</BODY></HTML>\n";
	public static byte doc404_RTSP = /* send back this on RTSP 404 file not found */"RTSP/1.0 404 Not Found\r\nServer: curl test suite RTSP server/0.1\r\n\r\n";
	public static byte RTP_DATA = /* Default size to send away fake RTP data */"$_1234\n\0asdf"/* do-nothing macro replacement for systems which lack siginterrupt() *//* vars used to keep around previous signal handlers */;
	public static Object SIGHANDLER_T;
	public static SIGHANDLER_T old_sigint_handler = ((__p_sig_fn_t)-1);
	public static SIGHANDLER_T old_sigterm_handler = ((__p_sig_fn_t)-1);
	public static SIGHANDLER_T old_sigbreak_handler = ((__p_sig_fn_t)-1);
	public static sig_atomic_t got_exit_signal = /* var which if set indicates that the program should finish execution */0;
	public static int exit_signal = /* if next is set indicates the first signal handled in exit_signal_handler */0/* signal handler that will be triggered to indicate that the program
	  should finish its execution in a controlled manner as soon as possible.
	  The first time this is called it will set got_exit_signal to one and
	  store in exit_signal the signal that triggered its execution. */;
	public static  Curl_is_connected = new ();
	public static  Curl_connecthost = new ();
	public static timediff_t Curl_timeleft = new timediff_t();
	public static  Curl_getconnectinfo = new ();
	public static bool Curl_addr2string = new bool();
	public static bool Curl_connalive = new bool();
	public static Object Curl_sndbufset;
	public static Object Curl_updateconninfo;
	public static Object Curl_persistconninfo;
	public static int Curl_closesocket;
	public static  Curl_socket = new ();
	public static Object Curl_conncontrol;
	public static bool Curl_conn_data_pending = new bool();
	public static  create_dir_hierarchy = new ();
	public static byte[] min_err_table = new byte[]{"stub-gss: no error", "stub-gss: no memory", "stub-gss: invalid arguments", "stub-gss: invalid credentials", "stub-gss: invalid context", "stub-gss: server returned error", "stub-gss: cannot find a mechanism", ((Object)0)};
	public static Curl_handler Curl_handler_file = new Curl_handler();
	public static Curl_addrinfo Curl_doh = new Curl_addrinfo();
	public static  Curl_doh_is_resolved = new ();
	public static int Curl_doh_getsock;
	public static byte fifo = /* Create a named pipe and tell libevent to monitor it */"hiper.fifo";
	public static  Curl_init_do = new ();
	public static  Curl_open = new ();
	public static  Curl_init_userdefined = new ();
	public static Object Curl_freeset;
	public static  Curl_uc_to_curlcode = new ();
	public static  Curl_close = new ();
	public static  Curl_connect = new ();
	public static  Curl_disconnect = new ();
	public static  Curl_setup_conn = new ();
	public static Object Curl_free_request_state;
	public static  Curl_parse_login_details = new ();
	public static Curl_handler Curl_builtin_scheme = new Curl_handler();
	public static Object Curl_verboseconnect;
	public static curl_malloc_callback Curl_cmalloc = (curl_malloc_callback)/* MSVC extension, dllimport identity */malloc;
	public static curl_free_callback Curl_cfree = (curl_free_callback)free;
	public static curl_realloc_callback Curl_crealloc = (curl_realloc_callback)realloc;
	public static curl_strdup_callback Curl_cstrdup = (curl_strdup_callback)strdup;
	public static curl_calloc_callback Curl_ccalloc = (curl_calloc_callback)calloc/* MSVC extension, dllimport identity */;
	public static  Curl_convert_clone = new ();
	public static size_t tool_read_cb = new size_t();
	public static  Curl_isunreserved = new ();
	public static  Curl_urldecode = new ();
	public static int[] urltime = new int[/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2013 - 2019, Linus Nielsen Feltzing, <linus@haxx.se>
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/200];
	public static byte[] urlstring = new byte[200];
	public static [] handles = new ();
	public static byte[] site_blacklist = new byte[20];
	public static byte[] server_blacklist = new byte[20];
	public static int num_handles;
	public static int blacklist_num_servers;
	public static int blacklist_num_sites;
	public static Object CURL;
	public static Object CURLSH;
	public static SOCKET curl_socket_t = new SOCKET();
	public static int curl_progress_callback;
	public static int curl_xferinfo_callback;
	public static size_t curl_write_callback = new size_t();
	public static int curl_resolver_start_callback;
	public static long curl_chunk_bgn_callback;
	public static long curl_chunk_end_callback;
	public static int curl_fnmatch_callback;
	public static int curl_seek_callback;
	public static size_t curl_read_callback = new size_t();
	public static int curl_trailer_callback;
	public static int curl_sockopt_callback;
	public static curl_socket_t curl_opensocket_callback = new curl_socket_t();
	public static int curl_closesocket_callback;
	public static curlioerr curl_ioctl_callback = new curlioerr();
	public static Object curl_malloc_callback;
	public static Object curl_free_callback;
	public static Object curl_realloc_callback;
	public static byte curl_strdup_callback;
	public static Object curl_calloc_callback;
	public static int curl_debug_callback;
	public static CURLcode curl_conv_callback = new CURLcode();
	public static CURLcode curl_ssl_ctx_callback = new CURLcode();
	public static int curl_sshkeycallback;
	public static int curl_strequal;
	public static int curl_strnequal;
	public static curl_mime_s curl_mime = new curl_mime_s();
	public static curl_mimepart_s curl_mimepart = new curl_mimepart_s();
	public static curl_mime curl_mime_init = new curl_mime();
	public static Object curl_mime_free;
	public static curl_mimepart curl_mime_addpart = new curl_mimepart();
	public static CURLcode curl_mime_name = new CURLcode();
	public static CURLcode curl_mime_filename = new CURLcode();
	public static CURLcode curl_mime_type = new CURLcode();
	public static CURLcode curl_mime_encoder = new CURLcode();
	public static CURLcode curl_mime_data = new CURLcode();
	public static CURLcode curl_mime_filedata = new CURLcode();
	public static CURLcode curl_mime_data_cb = new CURLcode();
	public static CURLcode curl_mime_subparts = new CURLcode();
	public static CURLcode curl_mime_headers = new CURLcode();
	public static CURLFORMcode curl_formadd = new CURLFORMcode();
	public static size_t curl_formget_callback = new size_t();
	public static int curl_formget;
	public static Object curl_formfree;
	public static byte curl_getenv;
	public static byte curl_version;
	public static byte curl_easy_escape;
	public static byte curl_escape;
	public static byte curl_easy_unescape;
	public static byte curl_unescape;
	public static Object curl_free;
	public static CURLcode curl_global_init = new CURLcode();
	public static CURLcode curl_global_init_mem = new CURLcode();
	public static Object curl_global_cleanup;
	public static CURLsslset curl_global_sslset = new CURLsslset();
	public static curl_slist curl_slist_append = new curl_slist();
	public static Object curl_slist_free_all;
	public static time_t curl_getdate = new time_t();
	public static Object curl_lock_function;
	public static Object curl_unlock_function;
	public static CURLSH curl_share_init = new CURLSH();
	public static CURLSHcode curl_share_setopt = new CURLSHcode();
	public static CURLSHcode curl_share_cleanup = new CURLSHcode();
	public static curl_version_info_data curl_version_info = new curl_version_info_data();
	public static byte curl_easy_strerror;
	public static byte curl_share_strerror;
	public static CURLcode curl_easy_pause = new CURLcode();
	public static variable[] replacements = new variable[]{new variable("url_effective", .VAR_EFFECTIVE_URL), new variable("http_code", .VAR_HTTP_CODE), new variable("response_code", .VAR_HTTP_CODE), new variable("http_connect", .VAR_HTTP_CODE_PROXY), new variable("time_total", .VAR_TOTAL_TIME), new variable("time_namelookup", .VAR_NAMELOOKUP_TIME), new variable("time_connect", .VAR_CONNECT_TIME), new variable("time_appconnect", .VAR_APPCONNECT_TIME), new variable("time_pretransfer", .VAR_PRETRANSFER_TIME), new variable("time_starttransfer", .VAR_STARTTRANSFER_TIME), new variable("size_header", .VAR_HEADER_SIZE), new variable("size_request", .VAR_REQUEST_SIZE), new variable("size_download", .VAR_SIZE_DOWNLOAD), new variable("size_upload", .VAR_SIZE_UPLOAD), new variable("speed_download", .VAR_SPEED_DOWNLOAD), new variable("speed_upload", .VAR_SPEED_UPLOAD), new variable("content_type", .VAR_CONTENT_TYPE), new variable("num_connects", .VAR_NUM_CONNECTS), new variable("time_redirect", .VAR_REDIRECT_TIME), new variable("num_redirects", .VAR_REDIRECT_COUNT), new variable("ftp_entry_path", .VAR_FTP_ENTRY_PATH), new variable("redirect_url", .VAR_REDIRECT_URL), new variable("ssl_verify_result", .VAR_SSL_VERIFY_RESULT), new variable("proxy_ssl_verify_result", .VAR_PROXY_SSL_VERIFY_RESULT), new variable("filename_effective", .VAR_EFFECTIVE_FILENAME), new variable("remote_ip", .VAR_PRIMARY_IP), new variable("remote_port", .VAR_PRIMARY_PORT), new variable("local_ip", .VAR_LOCAL_IP), new variable("local_port", .VAR_LOCAL_PORT), new variable("http_version", .VAR_HTTP_VERSION), new variable("scheme", .VAR_SCHEME), new variable("stdout", .VAR_STDOUT), new variable("stderr", .VAR_STDERR), new variable(((Object)0), .VAR_NONE)};
	public static size_t hash_function = new size_t();
	public static size_t comp_function = new size_t();
	public static Object curl_hash_dtor;
	public static int Curl_hash_init;
	public static Object Curl_hash_add;
	public static int Curl_hash_delete;
	public static Object Curl_hash_pick;
	public static Object Curl_hash_apply;
	public static Object Curl_hash_destroy;
	public static Object Curl_hash_clean;
	public static Object Curl_hash_clean_with_criterium;
	public static size_t Curl_hash_str = new size_t();
	public static size_t Curl_str_key_compare = new size_t();
	public static Object Curl_hash_start_iterate;
	public static curl_hash_element Curl_hash_next_element = new curl_hash_element();
	public static Object Curl_hash_print;
	public static byte[] payload_text = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* <DESC>
	 * Send e-mail on behalf of another user with SMTP
	 * </DESC>
	 *//*
	 * This is a simple example show how to send an email using libcurl's SMTP
	 * capabilities.
	 *
	 * Note that this example requires libcurl 7.66.0 or above.
	 *//* The libcurl options want plain addresses, the viewable headers in the mail
	 * can very well get a full name as well.
	 */"Date: Mon, 29 Nov 2010 21:54:29 +1100\r\n", "To: A Receiver <addressee@example.net>\r\n", "From: Ursel <ursel@example.org>\r\n", "Sender: Kurt <kurt@example.org>\r\n", "Message-ID: <dcd7cb36-11db-487a-9f3a-e652a9458efd@rfcpedant.example.org>\r\n", "Subject: SMTP example message\r\n", /* empty line to divide headers from body, see RFC5322 */"\r\n", "The body of the message starts here.\r\n", "\r\n", "It could be a lot of lines, could be MIME encoded, whatever.\r\n", "Check RFC5322.\r\n", ((Object)0)};
	public static byte[] data = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* ASCII representation with escape sequences for non-ASCII platforms */"this is what we post to the silly web server\n";
	public static byte bool;
	public static LARGE_INTEGER Curl_freq = new LARGE_INTEGER();
	public static bool Curl_isVistaOrGreater = new bool();
	public static HMODULE s_hIpHlpApiDll = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2016 - 2019, Steve Holme, <steve_holme@hotmail.com>.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/((Object)/* The last #include files should be: *//* Handle of iphlpapp.dll */0);
	public static IF_NAMETOINDEX_FN Curl_if_nametoindex = ((Object)/* Pointer to the if_nametoindex function */0);
	public static HMODULE LOADLIBRARYEX_FN = new HMODULE();
	public static LongShort[] aliases = new LongShort[]{new LongShort("*@", "url", .ARG_STRING), new LongShort("*4", "dns-ipv4-addr", .ARG_STRING), new LongShort("*6", "dns-ipv6-addr", .ARG_STRING), new LongShort("*a", "random-file", .ARG_FILENAME), new LongShort("*b", "egd-file", .ARG_STRING), new LongShort("*B", "oauth2-bearer", .ARG_STRING), new LongShort("*c", "connect-timeout", .ARG_STRING), new LongShort("*C", "doh-url", .ARG_STRING), new LongShort("*d", "ciphers", .ARG_STRING), new LongShort("*D", "dns-interface", .ARG_STRING), new LongShort("*e", "disable-epsv", .ARG_BOOL), new LongShort("*f", "disallow-username-in-url", .ARG_BOOL), new LongShort("*E", "epsv", .ARG_BOOL/* 'epsv' made like this to make --no-epsv and --epsv to work
	             although --disable-epsv is the documented option */), new LongShort("*F", "dns-servers", .ARG_STRING), new LongShort("*g", "trace", .ARG_FILENAME), new LongShort("*G", "npn", .ARG_BOOL), new LongShort("*h", "trace-ascii", .ARG_FILENAME), new LongShort("*H", "alpn", .ARG_BOOL), new LongShort("*i", "limit-rate", .ARG_STRING), new LongShort("*j", "compressed", .ARG_BOOL), new LongShort("*J", "tr-encoding", .ARG_BOOL), new LongShort("*k", "digest", .ARG_BOOL), new LongShort("*l", "negotiate", .ARG_BOOL), new LongShort("*m", "ntlm", .ARG_BOOL), new LongShort("*M", "ntlm-wb", .ARG_BOOL), new LongShort("*n", "basic", .ARG_BOOL), new LongShort("*o", "anyauth", .ARG_BOOL), new LongShort("*q", "ftp-create-dirs", .ARG_BOOL), new LongShort("*r", "create-dirs", .ARG_BOOL), new LongShort("*s", "max-redirs", .ARG_STRING), new LongShort("*t", "proxy-ntlm", .ARG_BOOL), new LongShort("*u", "crlf", .ARG_BOOL), new LongShort("*v", "stderr", .ARG_FILENAME), new LongShort("*w", "interface", .ARG_STRING), new LongShort("*x", "krb", .ARG_STRING), new LongShort("*x", "krb4", .ARG_STRING), new LongShort("*X", "haproxy-protocol", /* 'krb4' is the previous name */.ARG_BOOL), new LongShort("*y", "max-filesize", .ARG_STRING), new LongShort("*z", "disable-eprt", .ARG_BOOL), new LongShort("*Z", "eprt", .ARG_BOOL/* 'eprt' made like this to make --no-eprt and --eprt to work
	             although --disable-eprt is the documented option */), new LongShort("*~", "xattr", .ARG_BOOL), new LongShort("$a", "ftp-ssl", .ARG_BOOL), new LongShort("$a", "ssl", /* 'ftp-ssl' deprecated name since 7.20.0 */.ARG_BOOL), new LongShort("$b", "ftp-pasv", /* 'ssl' new option name in 7.20.0, previously this was ftp-ssl */.ARG_BOOL), new LongShort("$c", "socks5", .ARG_STRING), new LongShort("$d", "tcp-nodelay", .ARG_BOOL), new LongShort("$e", "proxy-digest", .ARG_BOOL), new LongShort("$f", "proxy-basic", .ARG_BOOL), new LongShort("$g", "retry", .ARG_STRING), new LongShort("$V", "retry-connrefused", .ARG_BOOL), new LongShort("$h", "retry-delay", .ARG_STRING), new LongShort("$i", "retry-max-time", .ARG_STRING), new LongShort("$k", "proxy-negotiate", .ARG_BOOL), new LongShort("$m", "ftp-account", .ARG_STRING), new LongShort("$n", "proxy-anyauth", .ARG_BOOL), new LongShort("$o", "trace-time", .ARG_BOOL), new LongShort("$p", "ignore-content-length", .ARG_BOOL), new LongShort("$q", "ftp-skip-pasv-ip", .ARG_BOOL), new LongShort("$r", "ftp-method", .ARG_STRING), new LongShort("$s", "local-port", .ARG_STRING), new LongShort("$t", "socks4", .ARG_STRING), new LongShort("$T", "socks4a", .ARG_STRING), new LongShort("$u", "ftp-alternative-to-user", .ARG_STRING), new LongShort("$v", "ftp-ssl-reqd", .ARG_BOOL), new LongShort("$v", "ssl-reqd", /* 'ftp-ssl-reqd' deprecated name since 7.20.0 */.ARG_BOOL), new LongShort("$w", "sessionid", /* 'ssl-reqd' new in 7.20.0, previously this was ftp-ssl-reqd */.ARG_BOOL), new LongShort("$x", "ftp-ssl-control", /* 'sessionid' listed as --no-sessionid in the help */.ARG_BOOL), new LongShort("$y", "ftp-ssl-ccc", .ARG_BOOL), new LongShort("$j", "ftp-ssl-ccc-mode", .ARG_STRING), new LongShort("$z", "libcurl", .ARG_STRING), new LongShort("$#", "raw", .ARG_BOOL), new LongShort("$0", "post301", .ARG_BOOL), new LongShort("$1", "keepalive", .ARG_BOOL), new LongShort("$2", "socks5-hostname", /* 'keepalive' listed as --no-keepalive in the help */.ARG_STRING), new LongShort("$3", "keepalive-time", .ARG_STRING), new LongShort("$4", "post302", .ARG_BOOL), new LongShort("$5", "noproxy", .ARG_STRING), new LongShort("$7", "socks5-gssapi-nec", .ARG_BOOL), new LongShort("$8", "proxy1.0", .ARG_STRING), new LongShort("$9", "tftp-blksize", .ARG_STRING), new LongShort("$A", "mail-from", .ARG_STRING), new LongShort("$B", "mail-rcpt", .ARG_STRING), new LongShort("$C", "ftp-pret", .ARG_BOOL), new LongShort("$D", "proto", .ARG_STRING), new LongShort("$E", "proto-redir", .ARG_STRING), new LongShort("$F", "resolve", .ARG_STRING), new LongShort("$G", "delegation", .ARG_STRING), new LongShort("$H", "mail-auth", .ARG_STRING), new LongShort("$I", "post303", .ARG_BOOL), new LongShort("$J", "metalink", .ARG_BOOL), new LongShort("$6", "sasl-authzid", .ARG_STRING), new LongShort("$K", "sasl-ir", .ARG_BOOL), new LongShort("$L", "test-event", .ARG_BOOL), new LongShort("$M", "unix-socket", .ARG_FILENAME), new LongShort("$N", "path-as-is", .ARG_BOOL), new LongShort("$O", "socks5-gssapi-service", .ARG_STRING/* 'socks5-gssapi-service' merged with'proxy-service-name' and
	            deprecated since 7.49.0 */), new LongShort("$O", "proxy-service-name", .ARG_STRING), new LongShort("$P", "service-name", .ARG_STRING), new LongShort("$Q", "proto-default", .ARG_STRING), new LongShort("$R", "expect100-timeout", .ARG_STRING), new LongShort("$S", "tftp-no-options", .ARG_BOOL), new LongShort("$U", "connect-to", .ARG_STRING), new LongShort("$W", "abstract-unix-socket", .ARG_FILENAME), new LongShort("$X", "tls-max", .ARG_STRING), new LongShort("$Y", "suppress-connect-headers", .ARG_BOOL), new LongShort("$Z", "compressed-ssh", .ARG_BOOL), new LongShort("$~", "happy-eyeballs-timeout-ms", .ARG_STRING), new LongShort("0", "http1.0", .ARG_NONE), new LongShort("01", "http1.1", .ARG_NONE), new LongShort("02", "http2", .ARG_NONE), new LongShort("03", "http2-prior-knowledge", .ARG_NONE), new LongShort("04", "http3", .ARG_NONE), new LongShort("09", "http0.9", .ARG_BOOL), new LongShort("1", "tlsv1", .ARG_NONE), new LongShort("10", "tlsv1.0", .ARG_NONE), new LongShort("11", "tlsv1.1", .ARG_NONE), new LongShort("12", "tlsv1.2", .ARG_NONE), new LongShort("13", "tlsv1.3", .ARG_NONE), new LongShort("1A", "tls13-ciphers", .ARG_STRING), new LongShort("1B", "proxy-tls13-ciphers", .ARG_STRING), new LongShort("2", "sslv2", .ARG_NONE), new LongShort("3", "sslv3", .ARG_NONE), new LongShort("4", "ipv4", .ARG_NONE), new LongShort("6", "ipv6", .ARG_NONE), new LongShort("a", "append", .ARG_BOOL), new LongShort("A", "user-agent", .ARG_STRING), new LongShort("b", "cookie", .ARG_STRING), new LongShort("ba", "alt-svc", .ARG_STRING), new LongShort("B", "use-ascii", .ARG_BOOL), new LongShort("c", "cookie-jar", .ARG_STRING), new LongShort("C", "continue-at", .ARG_STRING), new LongShort("d", "data", .ARG_STRING), new LongShort("dr", "data-raw", .ARG_STRING), new LongShort("da", "data-ascii", .ARG_STRING), new LongShort("db", "data-binary", .ARG_STRING), new LongShort("de", "data-urlencode", .ARG_STRING), new LongShort("D", "dump-header", .ARG_FILENAME), new LongShort("e", "referer", .ARG_STRING), new LongShort("E", "cert", .ARG_FILENAME), new LongShort("Ea", "cacert", .ARG_FILENAME), new LongShort("Eb", "cert-type", .ARG_STRING), new LongShort("Ec", "key", .ARG_FILENAME), new LongShort("Ed", "key-type", .ARG_STRING), new LongShort("Ee", "pass", .ARG_STRING), new LongShort("Ef", "engine", .ARG_STRING), new LongShort("Eg", "capath", .ARG_FILENAME), new LongShort("Eh", "pubkey", .ARG_STRING), new LongShort("Ei", "hostpubmd5", .ARG_STRING), new LongShort("Ej", "crlfile", .ARG_FILENAME), new LongShort("Ek", "tlsuser", .ARG_STRING), new LongShort("El", "tlspassword", .ARG_STRING), new LongShort("Em", "tlsauthtype", .ARG_STRING), new LongShort("En", "ssl-allow-beast", .ARG_BOOL), new LongShort("Ep", "pinnedpubkey", /* Eo */.ARG_STRING), new LongShort("EP", "proxy-pinnedpubkey", .ARG_STRING), new LongShort("Eq", "cert-status", .ARG_BOOL), new LongShort("Er", "false-start", .ARG_BOOL), new LongShort("Es", "ssl-no-revoke", .ARG_BOOL), new LongShort("Et", "tcp-fastopen", .ARG_BOOL), new LongShort("Eu", "proxy-tlsuser", .ARG_STRING), new LongShort("Ev", "proxy-tlspassword", .ARG_STRING), new LongShort("Ew", "proxy-tlsauthtype", .ARG_STRING), new LongShort("Ex", "proxy-cert", .ARG_FILENAME), new LongShort("Ey", "proxy-cert-type", .ARG_STRING), new LongShort("Ez", "proxy-key", .ARG_FILENAME), new LongShort("E0", "proxy-key-type", .ARG_STRING), new LongShort("E1", "proxy-pass", .ARG_STRING), new LongShort("E2", "proxy-ciphers", .ARG_STRING), new LongShort("E3", "proxy-crlfile", .ARG_FILENAME), new LongShort("E4", "proxy-ssl-allow-beast", .ARG_BOOL), new LongShort("E5", "login-options", .ARG_STRING), new LongShort("E6", "proxy-cacert", .ARG_FILENAME), new LongShort("E7", "proxy-capath", .ARG_FILENAME), new LongShort("E8", "proxy-insecure", .ARG_BOOL), new LongShort("E9", "proxy-tlsv1", .ARG_NONE), new LongShort("EA", "socks5-basic", .ARG_BOOL), new LongShort("EB", "socks5-gssapi", .ARG_BOOL), new LongShort("f", "fail", .ARG_BOOL), new LongShort("fa", "fail-early", .ARG_BOOL), new LongShort("fb", "styled-output", .ARG_BOOL), new LongShort("F", "form", .ARG_STRING), new LongShort("Fs", "form-string", .ARG_STRING), new LongShort("g", "globoff", .ARG_BOOL), new LongShort("G", "get", .ARG_NONE), new LongShort("Ga", "request-target", .ARG_STRING), new LongShort("h", "help", .ARG_BOOL), new LongShort("H", "header", .ARG_STRING), new LongShort("Hp", "proxy-header", .ARG_STRING), new LongShort("i", "include", .ARG_BOOL), new LongShort("I", "head", .ARG_BOOL), new LongShort("j", "junk-session-cookies", .ARG_BOOL), new LongShort("J", "remote-header-name", .ARG_BOOL), new LongShort("k", "insecure", .ARG_BOOL), new LongShort("K", "config", .ARG_FILENAME), new LongShort("l", "list-only", .ARG_BOOL), new LongShort("L", "location", .ARG_BOOL), new LongShort("Lt", "location-trusted", .ARG_BOOL), new LongShort("m", "max-time", .ARG_STRING), new LongShort("M", "manual", .ARG_BOOL), new LongShort("n", "netrc", .ARG_BOOL), new LongShort("no", "netrc-optional", .ARG_BOOL), new LongShort("ne", "netrc-file", .ARG_FILENAME), new LongShort("N", "buffer", .ARG_BOOL), new LongShort("o", "output", /* 'buffer' listed as --no-buffer in the help */.ARG_FILENAME), new LongShort("O", "remote-name", .ARG_NONE), new LongShort("Oa", "remote-name-all", .ARG_BOOL), new LongShort("p", "proxytunnel", .ARG_BOOL), new LongShort("P", "ftp-port", .ARG_STRING), new LongShort("q", "disable", .ARG_BOOL), new LongShort("Q", "quote", .ARG_STRING), new LongShort("r", "range", .ARG_STRING), new LongShort("R", "remote-time", .ARG_BOOL), new LongShort("s", "silent", .ARG_BOOL), new LongShort("S", "show-error", .ARG_BOOL), new LongShort("t", "telnet-option", .ARG_STRING), new LongShort("T", "upload-file", .ARG_FILENAME), new LongShort("u", "user", .ARG_STRING), new LongShort("U", "proxy-user", .ARG_STRING), new LongShort("v", "verbose", .ARG_BOOL), new LongShort("V", "version", .ARG_BOOL), new LongShort("w", "write-out", .ARG_STRING), new LongShort("x", "proxy", .ARG_STRING), new LongShort("xa", "preproxy", .ARG_STRING), new LongShort("X", "request", .ARG_STRING), new LongShort("Y", "speed-limit", .ARG_STRING), new LongShort("y", "speed-time", .ARG_STRING), new LongShort("z", "time-cond", .ARG_STRING), new LongShort("Z", "parallel", .ARG_BOOL), new LongShort("Zb", "parallel-max", .ARG_STRING), new LongShort("#", "progress-bar", .ARG_BOOL), new LongShort("#m", "progress-meter", .ARG_BOOL), new LongShort(":", "next", .ARG_NONE/* Split the argument of -E to 'certname' and 'passphrase' separated by colon.
	 * We allow ':' and '\' to be escaped by '\' so that we can use certificate
	 * nicknames containing ':'.  See <https://sourceforge.net/p/curl/bugs/1196/>
	 * for details. */)};
	public static int _ldap_url_parse;
	public static Object _ldap_free_urldesc;
	public static  Curl_ldap = new ();
	public static Curl_handler Curl_handler_ldap = new Curl_handler(/* scheme */"LDAP", /* setup_connection */0, /* do_it */Curl_ldap, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */389, /* protocol */CURLPROTO_LDAP, /* flags */0/*
	 * LDAPS protocol handler.
	 */);
	public static Curl_handler Curl_handler_ldaps = new Curl_handler(/* scheme */"LDAPS", /* setup_connection */0, /* do_it */Curl_ldap, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */636, /* protocol */CURLPROTO_LDAPS, (1 << /* flags */0));
	public static Object Curl_updatesocket;
	public static Object Curl_expire;
	public static Object Curl_expire_clear;
	public static Object Curl_expire_done;
	public static Object Curl_update_timer;
	public static Object Curl_attach_connnection;
	public static  Curl_multiplex_wanted = new ();
	public static Object Curl_set_in_callback;
	public static  Curl_is_in_callback = new ();
	public static Curl_multi Curl_multi_handle = new Curl_multi();
	public static  Curl_multi_max_host_connections = new ();
	public static  Curl_multi_max_total_connections = new ();
	public static Object Curl_multiuse_state;
	public static Object Curl_multi_closed;
	public static  Curl_multi_add_perform = new ();
	public static  Curl_multi_max_concurrent_streams = new ();
	public static int Curl_cert_hostcheck;
	public static NameValue[] setopt_nv_CURLPROXY = new NameValue[]{new NameValue("CURLPROXY_HTTP", /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* Lookup tables for converting setopt values back to symbols *//* For enums, values may be in any order. *//* For bit masks, put combinations first, then single bits, *//* and finally any "NONE" value. *//* sentinel to mark end of list */CURLPROXY_HTTP), new NameValue("CURLPROXY_HTTP_1_0", CURLPROXY_HTTP_1_0), new NameValue("CURLPROXY_HTTPS", CURLPROXY_HTTPS), new NameValue("CURLPROXY_SOCKS4", CURLPROXY_SOCKS4), new NameValue("CURLPROXY_SOCKS5", CURLPROXY_SOCKS5), new NameValue("CURLPROXY_SOCKS4A", CURLPROXY_SOCKS4A), new NameValue("CURLPROXY_SOCKS5_HOSTNAME", CURLPROXY_SOCKS5_HOSTNAME), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_SOCKS_PROXY = new NameValue[]{new NameValue("CURLPROXY_SOCKS4", CURLPROXY_SOCKS4), new NameValue("CURLPROXY_SOCKS5", CURLPROXY_SOCKS5), new NameValue("CURLPROXY_SOCKS4A", CURLPROXY_SOCKS4A), new NameValue("CURLPROXY_SOCKS5_HOSTNAME", CURLPROXY_SOCKS5_HOSTNAME), new NameValue(((Object)0), 0)};
	public static NameValueUnsigned[] setopt_nv_CURLAUTH = new NameValueUnsigned[]{new NameValueUnsigned("CURLAUTH_ANY", /* combination */CURLAUTH_ANY), new NameValueUnsigned("CURLAUTH_ANYSAFE", /* combination */CURLAUTH_ANYSAFE), new NameValueUnsigned("CURLAUTH_BASIC", CURLAUTH_BASIC), new NameValueUnsigned("CURLAUTH_DIGEST", CURLAUTH_DIGEST), new NameValueUnsigned("CURLAUTH_GSSNEGOTIATE", CURLAUTH_GSSNEGOTIATE), new NameValueUnsigned("CURLAUTH_NTLM", CURLAUTH_NTLM), new NameValueUnsigned("CURLAUTH_DIGEST_IE", CURLAUTH_DIGEST_IE), new NameValueUnsigned("CURLAUTH_NTLM_WB", CURLAUTH_NTLM_WB), new NameValueUnsigned("CURLAUTH_ONLY", CURLAUTH_ONLY), new NameValueUnsigned("CURLAUTH_NONE", CURLAUTH_NONE), new NameValueUnsigned(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_HTTP_VERSION = new NameValue[]{new NameValue("CURL_HTTP_VERSION_NONE", CURL_HTTP_VERSION_NONE), new NameValue("CURL_HTTP_VERSION_1_0", CURL_HTTP_VERSION_1_0), new NameValue("CURL_HTTP_VERSION_1_1", CURL_HTTP_VERSION_1_1), new NameValue("CURL_HTTP_VERSION_2_0", CURL_HTTP_VERSION_2_0), new NameValue("CURL_HTTP_VERSION_2TLS", CURL_HTTP_VERSION_2TLS), new NameValue("CURL_HTTP_VERSION_3", CURL_HTTP_VERSION_3), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_SSLVERSION = new NameValue[]{new NameValue("CURL_SSLVERSION_DEFAULT", CURL_SSLVERSION_DEFAULT), new NameValue("CURL_SSLVERSION_TLSv1", CURL_SSLVERSION_TLSv1), new NameValue("CURL_SSLVERSION_SSLv2", CURL_SSLVERSION_SSLv2), new NameValue("CURL_SSLVERSION_SSLv3", CURL_SSLVERSION_SSLv3), new NameValue("CURL_SSLVERSION_TLSv1_0", CURL_SSLVERSION_TLSv1_0), new NameValue("CURL_SSLVERSION_TLSv1_1", CURL_SSLVERSION_TLSv1_1), new NameValue("CURL_SSLVERSION_TLSv1_2", CURL_SSLVERSION_TLSv1_2), new NameValue("CURL_SSLVERSION_TLSv1_3", CURL_SSLVERSION_TLSv1_3), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_TIMECOND = new NameValue[]{new NameValue("CURL_TIMECOND_IFMODSINCE", CURL_TIMECOND_IFMODSINCE), new NameValue("CURL_TIMECOND_IFUNMODSINCE", CURL_TIMECOND_IFUNMODSINCE), new NameValue("CURL_TIMECOND_LASTMOD", CURL_TIMECOND_LASTMOD), new NameValue("CURL_TIMECOND_NONE", CURL_TIMECOND_NONE), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLFTPSSL_CCC = new NameValue[]{new NameValue("CURLFTPSSL_CCC_NONE", CURLFTPSSL_CCC_NONE), new NameValue("CURLFTPSSL_CCC_PASSIVE", CURLFTPSSL_CCC_PASSIVE), new NameValue("CURLFTPSSL_CCC_ACTIVE", CURLFTPSSL_CCC_ACTIVE), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLUSESSL = new NameValue[]{new NameValue("CURLUSESSL_NONE", CURLUSESSL_NONE), new NameValue("CURLUSESSL_TRY", CURLUSESSL_TRY), new NameValue("CURLUSESSL_CONTROL", CURLUSESSL_CONTROL), new NameValue("CURLUSESSL_ALL", CURLUSESSL_ALL), new NameValue(((Object)0), 0)};
	public static NameValueUnsigned[] setopt_nv_CURLSSLOPT = new NameValueUnsigned[]{new NameValueUnsigned("CURLSSLOPT_ALLOW_BEAST", CURLSSLOPT_ALLOW_BEAST), new NameValueUnsigned("CURLSSLOPT_NO_REVOKE", CURLSSLOPT_NO_REVOKE), new NameValueUnsigned(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_NETRC = new NameValue[]{new NameValue("CURL_NETRC_IGNORED", CURL_NETRC_IGNORED), new NameValue("CURL_NETRC_OPTIONAL", CURL_NETRC_OPTIONAL), new NameValue("CURL_NETRC_REQUIRED", CURL_NETRC_REQUIRED), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLPROTO = new NameValue[]{new NameValue("CURLPROTO_ALL", /* These mappings essentially triplicated - see
	 * tool_libinfo.c and tool_paramhlp.c *//* combination */CURLPROTO_ALL), new NameValue("CURLPROTO_DICT", CURLPROTO_DICT), new NameValue("CURLPROTO_FILE", CURLPROTO_FILE), new NameValue("CURLPROTO_FTP", CURLPROTO_FTP), new NameValue("CURLPROTO_FTPS", CURLPROTO_FTPS), new NameValue("CURLPROTO_GOPHER", CURLPROTO_GOPHER), new NameValue("CURLPROTO_HTTP", CURLPROTO_HTTP), new NameValue("CURLPROTO_HTTPS", CURLPROTO_HTTPS), new NameValue("CURLPROTO_IMAP", CURLPROTO_IMAP), new NameValue("CURLPROTO_IMAPS", CURLPROTO_IMAPS), new NameValue("CURLPROTO_LDAP", CURLPROTO_LDAP), new NameValue("CURLPROTO_LDAPS", CURLPROTO_LDAPS), new NameValue("CURLPROTO_POP3", CURLPROTO_POP3), new NameValue("CURLPROTO_POP3S", CURLPROTO_POP3S), new NameValue("CURLPROTO_RTSP", CURLPROTO_RTSP), new NameValue("CURLPROTO_SCP", CURLPROTO_SCP), new NameValue("CURLPROTO_SFTP", CURLPROTO_SFTP), new NameValue("CURLPROTO_SMB", CURLPROTO_SMB), new NameValue("CURLPROTO_SMBS", CURLPROTO_SMBS), new NameValue("CURLPROTO_SMTP", CURLPROTO_SMTP), new NameValue("CURLPROTO_SMTPS", CURLPROTO_SMTPS), new NameValue("CURLPROTO_TELNET", CURLPROTO_TELNET), new NameValue("CURLPROTO_TFTP", CURLPROTO_TFTP), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLNONZERODEFAULTS = new NameValue[]{new NameValue("CURLOPT_SSL_VERIFYPEER", (/* These options have non-zero default values. */true)), new NameValue("CURLOPT_SSL_VERIFYHOST", (true)), new NameValue("CURLOPT_SSL_ENABLE_NPN", (true)), new NameValue("CURLOPT_SSL_ENABLE_ALPN", (true)), new NameValue("CURLOPT_TCP_NODELAY", (true)), new NameValue("CURLOPT_PROXY_SSL_VERIFYPEER", (true)), new NameValue("CURLOPT_PROXY_SSL_VERIFYHOST", (true)), new NameValue("CURLOPT_SOCKS5_AUTH", (true)), new NameValue(((Object)0), 0/* Format and add code; jump to nomem on malloc error */)};
	public static  libcurl_generate_mime = new ();
	public static  curl_easy_init = new ();
	public static  curl_easy_setopt = new ();
	public static  curl_easy_perform = new ();
	public static Object curl_easy_cleanup;
	public static  curl_easy_getinfo = new ();
	public static  curl_easy_duphandle = new ();
	public static Object curl_easy_reset;
	public static  curl_easy_recv = new ();
	public static  curl_easy_send = new ();
	public static  curl_easy_upkeep = new ();
	public static  smtp_regular_transfer = new ();
	public static  smtp_do = new ();
	public static  smtp_done = new ();
	public static  smtp_connect = new ();
	public static  smtp_disconnect = new ();
	public static  smtp_multi_statemach = new ();
	public static int smtp_getsock;
	public static  smtp_doing = new ();
	public static  smtp_setup_connection = new ();
	public static  smtp_parse_url_options = new ();
	public static  smtp_parse_url_path = new ();
	public static  smtp_parse_custom_request = new ();
	public static  smtp_perform_auth = new ();
	public static  smtp_continue_auth = new ();
	public static Object smtp_get_message;
	public static Curl_handler Curl_handler_smtp = new Curl_handler(/* scheme */"SMTP", /* setup_connection */smtp_setup_connection, /* do_it */smtp_do, /* done */smtp_done, /* do_more */0, /* connect_it */smtp_connect, /* connecting */smtp_multi_statemach, /* doing */smtp_doing, /* proto_getsock */smtp_getsock, /* doing_getsock */smtp_getsock, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */smtp_disconnect, /* readwrite */0, /* connection_check */0, /* defport */25, /* protocol */CURLPROTO_SMTP, (1 << 2) | (1 << /* flags */6) | (1 << 10/*
	 * SMTPS protocol handler.
	 *//* scheme *//* setup_connection */)/* do_it *//* done *//* do_more *//* connect_it *//* connecting */);
	public static SASLproto saslsmtp = new SASLproto(/* The service name */"smtp", /* Code received when continuation is expected */334, /* Code to receive upon authentication success */235, 512 - /* Maximum initial response length (no max) */8, /* Send authentication command */smtp_perform_auth, /* Send authentication continuation */smtp_continue_auth, /* Get SASL response message */smtp_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static  timediff_t = new ();
	public static curltime Curl_now = new curltime();
	public static timediff_t Curl_timediff = new timediff_t();
	public static timediff_t Curl_timediff_us = new timediff_t();
	public static byte[] errorBuffer = new byte[CURL_ERROR_SIZE];
	public static string buffer = new string();
	public static htmlSAXHandler saxHandler = new htmlSAXHandler(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, StartElement, EndElement, 0, Characters, 0, 0, 0, 0, 0, 0, 0, cdata, 0);
	public static testparams[] params = new testparams[]{new testparams(0, CURLE_OK), new testparams((1 << 3), CURLE_OK), new testparams((1 << 2), CURLE_OK), new testparams((1 << 2) | (1 << 3), CURLE_OK), new testparams((1 << 1), CURLE_OK), new testparams((1 << 1) | (1 << 3), CURLE_OK), new testparams((1 << 1) | (1 << 2) | (1 << 4), CURLE_HTTP_RETURNED_ERROR), new testparams((1 << 1) | (1 << 2) | (1 << 3) | (1 << 4), CURLE_HTTP_RETURNED_ERROR), new testparams((1 << 0) | (1 << 4), CURLE_RANGE_ERROR), new testparams((1 << 0) | (1 << 3), CURLE_OK), new testparams((1 << 0) | (1 << 2) | (1 << 4), CURLE_RANGE_ERROR), new testparams((1 << 0) | (1 << 2) | (1 << 3), CURLE_OK), new testparams((1 << 0) | (1 << 1) | (1 << 4), CURLE_OK), new testparams((1 << 0) | (1 << 1) | (1 << 3) | (1 << 4), CURLE_OK), new testparams((1 << 0) | (1 << 1) | (1 << 2) | (1 << 4), CURLE_HTTP_RETURNED_ERROR), new testparams((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4), CURLE_HTTP_RETURNED_ERROR)};
	public static int hasbody;
	public static int rtp_packet_count = 0;
	public static byte homedir;
	public static  curl = new ();
	public static Object CURLM;
	public static CURLMsg CURLMsg = new CURLMsg();
	public static CURLM curl_multi_init = new CURLM();
	public static CURLMcode curl_multi_add_handle = new CURLMcode();
	public static CURLMcode curl_multi_remove_handle = new CURLMcode();
	public static CURLMcode curl_multi_fdset = new CURLMcode();
	public static CURLMcode curl_multi_wait = new CURLMcode();
	public static CURLMcode curl_multi_poll = new CURLMcode();
	public static CURLMcode curl_multi_perform = new CURLMcode();
	public static CURLMcode curl_multi_cleanup = new CURLMcode();
	public static CURLMsg curl_multi_info_read = new CURLMsg();
	public static byte curl_multi_strerror;
	public static int curl_socket_callback;
	public static int curl_multi_timer_callback;
	public static CURLMcode curl_multi_socket = new CURLMcode();
	public static CURLMcode curl_multi_socket_action = new CURLMcode();
	public static CURLMcode curl_multi_socket_all = new CURLMcode();
	public static CURLMcode curl_multi_timeout = new CURLMcode();
	public static CURLMcode curl_multi_setopt = new CURLMcode();
	public static CURLMcode curl_multi_assign = new CURLMcode();
	public static byte curl_pushheader_bynum;
	public static byte curl_pushheader_byname;
	public static int curl_push_callback;
	public static timeval tutil_tvnow = new timeval();
	public static long tutil_tvdiff;
	public static double tutil_tvdiff_secs;
	public static int Curl_strcasecompare;
	public static int Curl_safe_strcasecompare;
	public static int Curl_strncasecompare;
	public static byte Curl_raw_toupper;
	public static byte Curl_raw_tolower;
	public static Object Curl_strntoupper;
	public static Object Curl_strntolower;
	public static Curl_handler Curl_handler_telnet = new Curl_handler();
	public static Object Curl_version_init;
	public static int initialized;
	public static long init_flags;
	public static Curl_handler Curl_handler_http = new Curl_handler();
	public static bool Curl_compareheader = new bool();
	public static byte Curl_copy_header_value;
	public static byte Curl_checkProxyheaders;
	public static Curl_send_buffer Curl_send_buffer = new Curl_send_buffer();
	public static Curl_send_buffer Curl_add_buffer_init = new Curl_send_buffer();
	public static Object Curl_add_buffer_free;
	public static  Curl_add_bufferf = new ();
	public static  Curl_add_buffer = new ();
	public static  Curl_add_buffer_send = new ();
	public static  Curl_add_timecondition = new ();
	public static  Curl_add_custom_headers = new ();
	public static  Curl_http_compile_trailers = new ();
	public static  Curl_http = new ();
	public static  Curl_http_done = new ();
	public static  Curl_http_connect = new ();
	public static  Curl_http_input_auth = new ();
	public static  Curl_http_auth_act = new ();
	public static  Curl_http_readwrite_headers = new ();
	public static  Curl_http_output_auth = new ();
	public static byte Curl_strtok_r;
	public static byte Curl_auth_build_spn;
	public static  Curl_auth_user_contains_domain = new ();
	public static  Curl_auth_create_plain_message = new ();
	public static  Curl_auth_create_login_message = new ();
	public static  Curl_auth_create_external_message = new ();
	public static  Curl_auth_decode_cram_md5_message = new ();
	public static  Curl_auth_create_cram_md5_message = new ();
	public static  Curl_auth_is_digest_supported = new ();
	public static  Curl_auth_create_digest_md5_message = new ();
	public static  Curl_auth_decode_digest_http_message = new ();
	public static  Curl_auth_create_digest_http_message = new ();
	public static Object Curl_auth_digest_cleanup;
	public static  Curl_auth_create_oauth_bearer_message = new ();
	public static  Curl_auth_create_xoauth_bearer_message = new ();
	public static socklen_t curl_socklen_t = new socklen_t();
	public static long curl_off_t;
	public static byte[] uploadthis = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* This test case is supposed to be identical to 547 except that this uses the
	 * multi interface and 547 is easy interface.
	 *
	 * argv1 = URL
	 * argv2 = proxy
	 * argv3 = proxyuser:password
	 *//* ASCII representation with escape sequences for non-ASCII platforms */"this is the blurb we want to upload\n";
	public static HMAC_params[] Curl_HMAC_MD5 = new HMAC_params[]{new HMAC_params(/* Round 3 *//* Round 4 */(HMAC_hinit_func)(Object)(/* CRYPTO LIBS *//* Hash initialization function. */MD5_Init), (HMAC_hupdate_func)(Object)(/* Hash update function. */MD5_Update), (HMAC_hfinal_func)(Object)(/* Hash computation end function. */MD5_Final), /* Size of hash context structure. */, /* Maximum key length. */64, /* Result size. */16)};
	public static MD5_params[] Curl_DIGEST_MD5 = new MD5_params[]{new MD5_params((Curl_MD5_init_func)(Object)(/* Digest initialization function */MD5_Init), (Curl_MD5_update_func)(Object)(/* Digest update function */MD5_Update), (Curl_MD5_final_func)(Object)(/* Digest computation end function */MD5_Final), /* Size of digest context struct */, /* Result size */16)};
	public static slist_wc easysrc_decl = new slist_wc();
	public static slist_wc easysrc_data = new slist_wc();
	public static slist_wc easysrc_code = new slist_wc();
	public static slist_wc easysrc_toohard = new slist_wc();
	public static slist_wc easysrc_clean = new slist_wc();
	public static int easysrc_mime_count;
	public static int easysrc_slist_count;
	public static  easysrc_init = new ();
	public static  easysrc_add = new ();
	public static  easysrc_addf = new ();
	public static  easysrc_perform = new ();
	public static  easysrc_cleanup = new ();
	public static Object dumpeasysrc;
	public static  gopher_do = new ();
	public static Curl_handler Curl_handler_gopher = new Curl_handler(/* scheme */"GOPHER", /* setup_connection */0, /* do_it */gopher_do, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */70, /* protocol */CURLPROTO_GOPHER, /* flags */0);
	public static byte TEST_DATA_STRING = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/"Test data";
	public static int cb_count = 0;
	public static long[] K = new long[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Various logical functions */};
	public static byte[] Curl_wkday = new byte[/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/7];
	public static byte[] Curl_month = new byte[12];
	public static  Curl_gmtime = new ();
	public static byte[] telnetoptions = new byte[]{"BINARY", "ECHO", "RCP", /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*
	 * Telnet option defines. Add more here if in need.
	 *//*
	 * Telnet option defines. Add more here if in need.
	 *//* binary 8bit data *//* just echo! *//* Suppress Go Ahead *//* EXtended OPtions List *//* Terminal TYPE *//* Negotiate About Window Size *//* X DISPlay LOCation *//* NEW ENVIRONment variables *//*
	 * The telnet options represented as strings
	 *//*
	 * The telnet options represented as strings
	 */"SUPPRESS GO AHEAD", "NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP", "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS", "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO", "DE TERMINAL", "SUPDUP", "SUPDUP OUTPUT", "SEND LOCATION", "TERM TYPE", "END OF RECORD", "TACACS UID", "OUTPUT MARKING", "TTYLOC", "3270 REGIME", "X3 PAD", "NAWS", "TERM SPEED", "LFLOW", "LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION", "ENCRYPT", "NEW-ENVIRON"/*
	 * First some defines
	 *//* End Of File *//* Sub negotiation End */};
	public static byte[] telnetcmds = new byte[]{"EOF", "SUSP", "ABORT", "EOR", /* No OPeration *//* Data Mark *//* Go Ahead, reverse the line *//* SuBnegotiation *//* Our side WILL use this option *//* Our side WON'T use this option *//* DO use this option! *//* DON'T use this option! *//* Interpret As Command *//*
	 * Then those numbers represented as strings:
	 *//*
	 * Then those numbers represented as strings:
	 */"SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC", "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC"/* the first one *//* surprise, 255 is the last one! ;-) *//* CURL_DISABLE_TELNET *//* HEADER_CURL_ARPA_TELNET_H */};
	public static pthread_mutex_t connlock = new pthread_mutex_t();
	public static pthread_mutex_t lock = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* <DESC>
	 * A multi threaded application that uses a progress bar to show
	 * status.  It uses Gtk+ to make a smooth pulse.
	 * </DESC>
	 *//*
	 * Written by Jud Bishop after studying the other examples provided with
	 * libcurl.
	 *
	 * To compile (on a single line):
	 * gcc -ggdb `pkg-config --cflags  --libs gtk+-2.0` -lcurl -lssl -lcrypto
	 *   -lgthread-2.0 -dl  smooth-gtk-thread.c -o smooth-gtk-thread
	 */(pthread_mutex_t)((Object)(size_t)-1);
	public static int j = 0;
	public static  num_urls = /* Just make sure this is less than urls[]*/9;
	public static byte[] urls = new byte[]{"90022", "90023", "90024", "90025", "90026", "90027", "90028", "90029", "90030"};
	public static int parseconfig;
	public static Object conn_free;
	public static Object free_idnconverted_hostname;
	public static int get_protocol_family;
	public static Curl_handler[] protocols = new Curl_handler[]{Curl_handler_http, Curl_handler_ftp, Curl_handler_telnet, Curl_handler_dict, Curl_handler_ldap, Curl_handler_ldaps, Curl_handler_file, Curl_handler_tftp, Curl_handler_imap, Curl_handler_pop3, Curl_handler_smb, Curl_handler_smtp, Curl_handler_rtsp, Curl_handler_gopher, (Curl_handler)((Object)0/*
	 * Dummy handler for undefined protocol schemes.
	 */)};
	public static Curl_handler Curl_handler_dummy = new Curl_handler(/* scheme */"<no protocol>", /* setup_connection */0, /* do_it */0, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */0, /* protocol */0, /* flags */0);
	public static Curl_handler Curl_handler_pop3 = new Curl_handler();
	public static Curl_handler Curl_handler_pop3s = new Curl_handler();
	public static  Curl_pop3_write = new ();
	public static byte Curl_get_line;
	public static  Curl_sendf = new ();
	public static Object Curl_infof;
	public static Object Curl_failf;
	public static  Curl_client_write = new ();
	public static bool Curl_recv_has_postponed_data = new bool();
	public static  Curl_read_plain = new ();
	public static ssize_t Curl_recv_plain = new ssize_t();
	public static ssize_t Curl_send_plain = new ssize_t();
	public static  Curl_read = new ();
	public static  Curl_write = new ();
	public static  Curl_write_plain = new ();
	public static int Curl_debug;
	public static [] eh = new ();
	public static content_encoding identity_encoding = new content_encoding("identity", "none", identity_init_writer, identity_unencode_write, identity_close_writer, 0);
	public static content_encoding[] encodings = new content_encoding[]{/* supported content encodings table. */identity_encoding, ((Object)0)};
	public static content_encoding client_encoding = new content_encoding(((Object)0), ((Object)0), client_init_writer, client_unencode_write, client_close_writer, 0);
	public static content_encoding error_encoding = new content_encoding(((Object)0), ((Object)0), error_init_writer, error_unencode_write, error_close_writer, 0);
	public static Curl_handler Curl_handler_ftp = new Curl_handler();
	public static  Curl_ftpsend = new ();
	public static  Curl_GetFTPResponse = new ();
	public static dcheck[] dates = new dcheck[]{new dcheck("Sun, 06 Nov 1994 08:49:37 GMT", 784111777), new dcheck("Sunday, 06-Nov-94 08:49:37 GMT", 784111777), new dcheck("Sun Nov  6 08:49:37 1994", 784111777), new dcheck("06 Nov 1994 08:49:37 GMT", 784111777), new dcheck("06-Nov-94 08:49:37 GMT", 784111777), new dcheck("Nov  6 08:49:37 1994", 784111777), new dcheck("06 Nov 1994 08:49:37", 784111777), new dcheck("06-Nov-94 08:49:37", 784111777), new dcheck("1994 Nov 6 08:49:37", 784111777), new dcheck("GMT 08:49:37 06-Nov-94 Sunday", 784111777), new dcheck("94 6 Nov 08:49:37", 784111777), new dcheck("1994 Nov 6", 784080000), new dcheck("06-Nov-94", 784080000), new dcheck("Sun Nov 6 94", 784080000), new dcheck("1994.Nov.6", 784080000), new dcheck("Sun/Nov/6/94/GMT", 784080000), new dcheck("Sun, 06 Nov 1994 08:49:37 CET", 784108177), new dcheck("06 Nov 1994 08:49:37 EST", 784129777), new dcheck("Sun, 06 Nov 1994 08:49:37 UT", 784111777), new dcheck("Sun, 12 Sep 2004 15:05:58 -0700", 1095026758), new dcheck("Sat, 11 Sep 2004 21:32:11 +0200", 1094931131), new dcheck("20040912 15:05:58 -0700", 1095026758), new dcheck("20040911 +0200", 1094853600), new dcheck("Thu, 01-Jan-1970 00:59:59 GMT", 3599), new dcheck("Thu, 01-Jan-1970 01:00:00 GMT", 3600), new dcheck("Sat, 15-Apr-17 21:01:22 GMT", 1492290082), new dcheck("Thu, 19-Apr-2007 16:00:00 GMT", 1176998400), new dcheck("Wed, 25 Apr 2007 21:02:13 GMT", 1177534933), new dcheck("Thu, 19/Apr\\2007 16:00:00 GMT", 1176998400), new dcheck("Fri, 1 Jan 2010 01:01:50 GMT", 1262307710), new dcheck("Wednesday, 1-Jan-2003 00:00:00 GMT", 1041379200), new dcheck(", 1-Jan-2003 00:00:00 GMT", 1041379200), new dcheck("1-Jan-2003 00:00:00 GMT", 1041379200), new dcheck("1-Jan-2003 00:00:00 GMT", 1041379200), new dcheck("Wed,18-Apr-07 22:50:12 GMT", 1176936612), new dcheck("WillyWonka  , 18-Apr-07 22:50:12 GMT", -1), new dcheck("WillyWonka  , 18-Apr-07 22:50:12", -1), new dcheck("WillyWonka  ,  18-apr-07   22:50:12", -1), new dcheck("Mon, 18-Apr-1977 22:50:13 GMT", 230251813), new dcheck("Mon, 18-Apr-77 22:50:13 GMT", 230251813), new dcheck("Sat, 15-Apr-17\"21:01:22\"GMT", 1492290082), new dcheck("Partyday, 18- April-07 22:50:12", -1), new dcheck("Partyday, 18 - Apri-07 22:50:12", -1), new dcheck("Wednes, 1-Januar-2003 00:00:00 GMT", -1), new dcheck("Sat, 15-Apr-17 21:01:22", 1492290082), new dcheck("Sat, 15-Apr-17 21:01:22 GMT-2", 1492290082), new dcheck("Sat, 15-Apr-17 21:01:22 GMT BLAH", 1492290082), new dcheck("Sat, 15-Apr-17 21:01:22 GMT-0400", 1492290082), new dcheck("Sat, 15-Apr-17 21:01:22 GMT-0400 (EDT)", 1492290082), new dcheck("Sat, 15-Apr-17 21:01:22 DST", -1), new dcheck("Sat, 15-Apr-17 21:01:22 -0400", 1492304482), new dcheck("Sat, 15-Apr-17 21:01:22 (hello there)", -1), new dcheck("Sat, 15-Apr-17 21:01:22 11:22:33", -1), new dcheck("Sat, 15-Apr-17 ::00 21:01:22", -1), new dcheck("Sat, 15-Apr-17 boink:z 21:01:22", -1), new dcheck("Sat, 15-Apr-17 91:22:33 21:01:22", -1), new dcheck("Thu Apr 18 22:50:12 2007 GMT", 1176936612), new dcheck("22:50:12 Thu Apr 18 2007 GMT", 1176936612), new dcheck("Thu 22:50:12 Apr 18 2007 GMT", 1176936612), new dcheck("Thu Apr 22:50:12 18 2007 GMT", 1176936612), new dcheck("Thu Apr 18 22:50:12 2007 GMT", 1176936612), new dcheck("Thu Apr 18 2007 22:50:12 GMT", 1176936612), new dcheck("Thu Apr 18 2007 GMT 22:50:12", 1176936612), new dcheck("Sat, 15-Apr-17 21:01:22 GMT", 1492290082), new dcheck("15-Sat, Apr-17 21:01:22 GMT", 1492290082), new dcheck("15-Sat, Apr 21:01:22 GMT 17", 1492290082), new dcheck("15-Sat, Apr 21:01:22 GMT 2017", 1492290082), new dcheck("15 Apr 21:01:22 2017", 1492290082), new dcheck("15 17 Apr 21:01:22", 1492290082), new dcheck("Apr 15 17 21:01:22", 1492290082), new dcheck("Apr 15 21:01:22 17", 1492290082), new dcheck("2017 April 15 21:01:22", -1), new dcheck("15 April 2017 21:01:22", -1), new dcheck("98 April 17 21:01:22", -1), new dcheck("Thu, 012-Aug-2008 20:49:07 GMT", 1218574147), new dcheck("Thu, 999999999999-Aug-2007 20:49:07 GMT", -1), new dcheck("Thu, 12-Aug-2007 20:61:99999999999 GMT", -1), new dcheck("IAintNoDateFool", -1), new dcheck("Thu Apr 18 22:50 2007 GMT", 1176936600), new dcheck("20110623 12:34:56", 1308832496), new dcheck("20110632 12:34:56", -1), new dcheck("20110623 56:34:56", -1), new dcheck("20111323 12:34:56", -1), new dcheck("20110623 12:34:79", -1), new dcheck("Wed, 31 Dec 2008 23:59:60 GMT", 1230768000), new dcheck("20110623 12:3", 1308830580), new dcheck("20110623 1:3", 1308790980), new dcheck("20110623 1:30", 1308792600), new dcheck("20110623 12:12:3", 1308831123), new dcheck("20110623 01:12:3", 1308791523), new dcheck("20110623 01:99:30", -1), new dcheck("Thu, 01-Jan-1970 00:00:00 GMT", 0), new dcheck("Thu, 31-Dec-1969 23:59:58 GMT", -2), new dcheck("Thu, 31-Dec-1969 23:59:59 GMT", /* avoids -1 ! */0/* causes warning on MSVC */), new dcheck("Sun, 06 Nov 2044 08:49:37 GMT", -1), new dcheck("Sun, 06 Nov 1968 08:49:37 GMT", -36342623), new dcheck(((Object)0), 0)};
	public static byte[] post = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/"one", "two", "three", "and a final longer crap: four", ((Object)0)};
	public static size_t consumed = 0;
	public static size_t data_size =  / ;
	public static byte hmac_ipad = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC2104 Keyed-Hashing for Message Authentication
	 *
	 ***************************************************************************//* The last #include file should be: *//*
	 * Generic HMAC algorithm.
	 *
	 *   This module computes HMAC digests based on any hash function. Parameters
	 * and computing procedures are set-up dynamically at HMAC computation
	 * context initialisation.
	 */-1024;
	public static byte hmac_opad = -1024;
	public static  version_info = new (CURLVERSION_NOW, LIBCURL_VERSION, LIBCURL_VERSION_NUM, /* as found by configure or set by hand at build-time */"i386-pc-win32", /* features is 0 by default */0 | CURL_VERSION_NTLM | CURL_VERSION_ASYNCHDNS | CURL_VERSION_LARGEFILE, ((Object)/* ssl_version */0), /* ssl_version_num, this is kept at zero */0, ((Object)/* zlib_version */0), protocols, ((Object)/* c-ares version */0), /* c-ares version numerical */0, ((Object)/* libidn version */0), /* iconv version */0, ((Object)/* ssh lib version */0), /* brotli_ver_num */0, ((Object)/* brotli version */0), /* nghttp2 version number */0, ((Object)/* nghttp2 version string */0), ((Object)/* quic library string */0));
	public static int Curl_none_init;
	public static Object Curl_none_cleanup;
	public static int Curl_none_shutdown;
	public static int Curl_none_check_cxn;
	public static  Curl_none_random = new ();
	public static Object Curl_none_close_all;
	public static Object Curl_none_session_free;
	public static bool Curl_none_data_pending = new bool();
	public static bool Curl_none_cert_status_request = new bool();
	public static  Curl_none_set_engine = new ();
	public static  Curl_none_set_engine_default = new ();
	public static curl_slist Curl_none_engines_list = new curl_slist();
	public static bool Curl_none_false_start = new bool();
	public static bool Curl_ssl_tls13_ciphersuites = new bool();
	public static  Curl_none_md5sum = new ();
	public static bool Curl_ssl_config_matches = new bool();
	public static bool Curl_clone_primary_ssl_config = new bool();
	public static Object Curl_free_primary_ssl_config;
	public static int Curl_ssl_getsock;
	public static int Curl_ssl_backend;
	public static  Curl_input_ntlm = new ();
	public static  Curl_output_ntlm = new ();
	public static Object Curl_http_auth_cleanup_ntlm;
	public static byte[] g_Data = new byte[40 * /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* test case and code based on https://github.com/curl/curl/issues/2847 *//* POST 40KB */1024];
	public static int _CRT_glob = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//*
	 * This is low-level hard-hacking memory leak tracking and similar. Using
	 * the library level code from this client-side is ugly, but we do this
	 * anyway for convenience.
	 *//* keep this as LAST include *//*
	 * vms_show is a global variable, used in main() as parameter for
	 * function vms_special_exit() to allow proper curl tool exiting.
	 * Its value may be set in other tool_*.c source files thanks to
	 * forward declaration present in tool_vms.h
	 *//*
	 * There seems to be no way to escape "*" in command-line arguments with MinGW
	 * when command-line argument globbing is enabled under the MSYS shell, so turn
	 * it off.
	 */0/* __MINGW32__ *//* if we build a static library for unit tests, there is no main() function *//*
	 * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are
	 * open before starting to run.  Otherwise, the first three network
	 * sockets opened by curl could be used for input sources, downloaded data
	 * or error logs as they will effectively be stdin, stdout and/or stderr.
	 *//*
	 * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are
	 * open before starting to run.  Otherwise, the first three network
	 * sockets opened by curl could be used for input sources, downloaded data
	 * or error logs as they will effectively be stdin, stdout and/or stderr.
	 */;
	public static long u_int32_t;
	public static int Curl_getaddrinfo_a;
	public static int Curl_getnameinfo_a;
	public static int Curl_gsk_environment_open;
	public static int Curl_gsk_secure_soc_open;
	public static int Curl_gsk_environment_close;
	public static int Curl_gsk_secure_soc_close;
	public static int Curl_gsk_environment_init;
	public static int Curl_gsk_secure_soc_init;
	public static int Curl_gsk_attribute_set_buffer_a;
	public static int Curl_gsk_attribute_set_enum;
	public static int Curl_gsk_attribute_set_numeric_value;
	public static int Curl_gsk_attribute_set_callback;
	public static int Curl_gsk_attribute_get_buffer_a;
	public static int Curl_gsk_attribute_get_enum;
	public static int Curl_gsk_attribute_get_numeric_value;
	public static int Curl_gsk_attribute_get_cert_info;
	public static int Curl_gsk_secure_soc_misc;
	public static int Curl_gsk_secure_soc_read;
	public static int Curl_gsk_secure_soc_write;
	public static byte Curl_gsk_strerror_a;
	public static int Curl_gsk_secure_soc_startInit;
	public static  Curl_gss_import_name_a = new ();
	public static  Curl_gss_display_status_a = new ();
	public static  Curl_gss_init_sec_context_a = new ();
	public static  Curl_gss_delete_sec_context_a = new ();
	public static int Curl_os400_connect;
	public static int Curl_os400_bind;
	public static int Curl_os400_sendto;
	public static int Curl_os400_recvfrom;
	public static int Curl_os400_getpeername;
	public static int Curl_os400_getsockname;
	public static Curl_handler Curl_handler_imap = new Curl_handler();
	public static Curl_handler Curl_handler_imaps = new Curl_handler();
	public static byte HOSTHEADER = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/"Host: www.host.foo.com";
	public static byte JAR = "log/jar506";
	public static int[] locks = new int[3];
	public static size_t Curl_ftp_parselist = new size_t();
	public static  Curl_ftp_parselist_geterror = new ();
	public static ftp_parselist_data Curl_ftp_parselist_data_alloc = new ftp_parselist_data();
	public static Object Curl_ftp_parselist_data_free;
	public static Curl_URL CURLU = new Curl_URL();
	public static CURLU curl_url = new CURLU();
	public static Object curl_url_cleanup;
	public static CURLU curl_url_dup = new CURLU();
	public static CURLUcode curl_url_get = new CURLUcode();
	public static CURLUcode curl_url_set = new CURLUcode();
	public static  operate = new ();
	public static per_transfer transfers = new per_transfer();
	public static Memory[] files = new Memory();
	public static int pushindex = 1;
	public static  single_transfer = new ();
	public static  create_transfer = new ();
	public static per_transfer transfersl = new per_transfer();
	public static long all_added;
	public static int Curl_ipv6_scope;
	public static if2ip_result_t Curl_if2ip = new if2ip_result_t();
	public static testcase[] tests = new testcase[]{{/* spaces aren't allowed, for now */"test.com:80:127.0.0.1", "test.com", 80, new testcase("127.0.0.1")}, {"test.com:80:127.0.0.2", "test.com", 80, new testcase("127.0.0.2")}};
	public static byte buffer_undef;
	public static byte buffer_threaded;
	public static byte buffer_unthreaded;
	public static pthread_mutex_t mutex = (pthread_mutex_t)((Object)(size_t)-1);
	public static pthread_key_t thdkey = new pthread_key_t();
	public static buffer_t locbufs = new buffer_t();
	public static byte Curl_thread_buffer = buffer_undef;
	public static  smb_setup_connection = new ();
	public static  smb_connect = new ();
	public static  smb_connection_state = new ();
	public static  smb_do = new ();
	public static  smb_request_state = new ();
	public static  smb_done = new ();
	public static  smb_disconnect = new ();
	public static int smb_getsock;
	public static  smb_parse_url_path = new ();
	public static Curl_handler Curl_handler_smb = new Curl_handler(/* scheme */"SMB", /* setup_connection */smb_setup_connection, /* do_it */smb_do, /* done */smb_done, /* do_more */0, /* connect_it */smb_connect, /* connecting */smb_connection_state, /* doing */smb_request_state, /* proto_getsock */smb_getsock, /* doing_getsock */smb_getsock, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */smb_disconnect, /* readwrite */0, /* connection_check */0, /* defport */445, /* protocol */CURLPROTO_SMB, /* flags */0/*
	 * SMBS handler interface
	 *//* scheme *//* setup_connection *//* do_it *//* done *//* do_more *//* connect_it *//* connecting *//* doing *//* proto_getsock *//* doing_getsock *//* domore_getsock *//* perform_getsock *//* disconnect *//* readwrite *//* connection_check *//* defport *//* protocol *//* flags *//* Append a string to an SMB message */);
	public static byte Curl_strerror;
	public static curl_hash Curl_global_host_cache_init = new curl_hash();
	public static int Curl_resolv;
	public static int Curl_resolv_timeout;
	public static bool Curl_ipvalid = new bool();
	public static Curl_addrinfo Curl_getaddrinfo = new Curl_addrinfo();
	public static Object Curl_resolv_unlock;
	public static int Curl_mk_dnscache;
	public static Object Curl_hostcache_prune;
	public static int Curl_num_addresses;
	public static Curl_addrinfo Curl_ipv4_resolve_r = new Curl_addrinfo();
	public static  Curl_once_resolved = new ();
	public static  Curl_addrinfo_callback = new ();
	public static byte Curl_printable_address;
	public static Curl_dns_entry Curl_fetch_addr = new Curl_dns_entry();
	public static Curl_dns_entry Curl_cache_addr = new Curl_dns_entry();
	public static  Curl_set_dns_servers = new ();
	public static  Curl_set_dns_interface = new ();
	public static  Curl_set_dns_local_ip4 = new ();
	public static  Curl_set_dns_local_ip6 = new ();
	public static Object Curl_hostcache_clean;
	public static  Curl_loadhostpairs = new ();
	public static  Curl_resolv_check = new ();
	public static int Curl_resolv_getsock;
	public static  imap_regular_transfer = new ();
	public static  imap_do = new ();
	public static  imap_done = new ();
	public static  imap_connect = new ();
	public static  imap_disconnect = new ();
	public static  imap_multi_statemach = new ();
	public static int imap_getsock;
	public static  imap_doing = new ();
	public static  imap_setup_connection = new ();
	public static byte imap_atom;
	public static  imap_sendf = new ();
	public static  imap_parse_url_options = new ();
	public static  imap_parse_url_path = new ();
	public static  imap_parse_custom_request = new ();
	public static  imap_perform_authenticate = new ();
	public static  imap_continue_authenticate = new ();
	public static Object imap_get_message;
	public static SASLproto saslimap = new SASLproto(/* The service name */"imap", /* Code received when continuation is expected */(byte)'+', /* Code to receive upon authentication success */1, /* Maximum initial response length (no max) */0, /* Send authentication command */imap_perform_authenticate, /* Send authentication continuation */imap_continue_authenticate, /* Get SASL response message */imap_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static byte param2text;
	public static int SetHTTPrequest;
	public static Object customrequest_helper;
	public static curl_hash hash_static = new curl_hash();
	public static int slots = 3;
	public static timeval tvnow = new timeval();
	public static byte path = /* set by the main code to point to where the test dir is */".";
	public static Curl_handler Curl_handler_rtsp = new Curl_handler();
	public static  Curl_rtsp_parseheader = new ();
	public static int Curl_parsenetrc;
	public static int inet_pton4;
	public static fileinfo Curl_fileinfo_alloc = new fileinfo();
	public static Object Curl_fileinfo_cleanup;
	public static  _curl_read_callback1 = new ();
	public static  _curl_read_callback2 = new ();
	public static  _curl_read_callback3 = new ();
	public static  _curl_read_callback4 = new ();
	public static  _curl_read_callback5 = new ();
	public static  _curl_read_callback6 = new ();
	public static  _curl_write_callback1 = new ();
	public static  _curl_write_callback2 = new ();
	public static  _curl_write_callback3 = new ();
	public static  _curl_write_callback4 = new ();
	public static  _curl_write_callback5 = new ();
	public static  _curl_write_callback6 = new ();
	public static  _curl_ioctl_callback1 = new ();
	public static  _curl_ioctl_callback2 = new ();
	public static  _curl_ioctl_callback3 = new ();
	public static  _curl_ioctl_callback4 = new ();
	public static int _curl_sockopt_callback1;
	public static int _curl_sockopt_callback2;
	public static  _curl_opensocket_callback1 = new ();
	public static  _curl_opensocket_callback2 = new ();
	public static  _curl_opensocket_callback3 = new ();
	public static  _curl_opensocket_callback4 = new ();
	public static int _curl_progress_callback1;
	public static int _curl_progress_callback2;
	public static int _curl_debug_callback1;
	public static int _curl_debug_callback2;
	public static int _curl_debug_callback3;
	public static int _curl_debug_callback4;
	public static int _curl_debug_callback5;
	public static int _curl_debug_callback6;
	public static int _curl_debug_callback7;
	public static int _curl_debug_callback8;
	public static  _curl_ssl_ctx_callback1 = new ();
	public static  _curl_ssl_ctx_callback2 = new ();
	public static  _curl_ssl_ctx_callback3 = new ();
	public static  _curl_ssl_ctx_callback4 = new ();
	public static _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback5 = new _curl_ssl_ctx_callback1();
	public static _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback6 = new _curl_ssl_ctx_callback1();
	public static _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback7 = new _curl_ssl_ctx_callback1();
	public static _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback8 = new _curl_ssl_ctx_callback1();
	public static  _curl_conv_callback1 = new ();
	public static  _curl_conv_callback2 = new ();
	public static  _curl_conv_callback3 = new ();
	public static  _curl_conv_callback4 = new ();
	public static  _curl_seek_callback1 = new ();
	public static  _curl_seek_callback2 = new ();
	public static  Curl_range = new ();
	public static  Curl_getformdata = new ();
	public static Object config_init;
	public static Object config_free;
	public static size_t encoder_nop_read = new size_t();
	public static  encoder_nop_size = new ();
	public static size_t encoder_7bit_read = new size_t();
	public static size_t encoder_base64_read = new size_t();
	public static  encoder_base64_size = new ();
	public static size_t encoder_qp_read = new size_t();
	public static  encoder_qp_size = new ();
	public static mime_encoder[] encoders = new mime_encoder[]{new mime_encoder("binary", encoder_nop_read, encoder_nop_size), new mime_encoder("8bit", encoder_nop_read, encoder_nop_size), new mime_encoder("7bit", encoder_7bit_read, encoder_nop_size), new mime_encoder("base64", encoder_base64_read, encoder_base64_size), new mime_encoder("quoted-printable", encoder_qp_read, encoder_qp_size), new mime_encoder(0, 0, 0)};
	public static byte[] base64 = /* Base64 encoding table */"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"/* Quoted-printable character class table.
	 *
	 * We cannot rely on ctype functions since quoted-printable input data
	 * is assumed to be ascii-compatible, even on non-ascii platforms. */;
	public static byte[] qp_class = new byte[]{0, 0, 0, 0, 0, 0, 0, /* Can be represented by itself. *//* Space or tab. *//* Carriage return. *//* Line-feed. *//* 00 - 07 */0, 0, 2, 4, 0, 0, 3, 0, /* 08 - 0F */0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 17 */0, 0, 0, 0, 0, 0, 0, 0, /* 18 - 1F */0, 2, 1, 1, 1, 1, 1, 1, /* 20 - 27 */1, 1, 1, 1, 1, 1, 1, 1, /* 28 - 2F */1, 1, 1, 1, 1, 1, 1, 1, /* 30 - 37 */1, 1, 1, 1, 1, 1, 0, 1, /* 38 - 3F */1, 1, 1, 1, 1, 1, 1, 1, /* 40 - 47 */1, 1, 1, 1, 1, 1, 1, 1, /* 48 - 4F */1, 1, 1, 1, 1, 1, 1, 1, /* 50 - 57 */1, 1, 1, 1, 1, 1, 1, 1, /* 58 - 5F */1, 1, 1, 1, 1, 1, 1, 1, /* 60 - 67 */1, 1, 1, 1, 1, 1, 1, 1, /* 68 - 6F */1, 1, 1, 1, 1, 1, 1, 1, /* 70 - 77 */1, 1, 1, 1, 1, 1, 1, 1, /* 78 - 7F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 80 - 8F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 90 - 9F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* A0 - AF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* B0 - BF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* C0 - CF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* D0 - DF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* E0 - EF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* F0 - FF */0};
	public static byte[] aschex = /* Binary --> hexadecimal ASCII table. */"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"/*
	 * get_vms_file_size does what it takes to get the real size of the file
	 *
	 * For fixed files, find out the size of the EOF block and adjust.
	 *
	 * For all others, have to read the entire file in, discarding the contents.
	 * Most posted text files will be small, and binary files like zlib archives
	 * and CD/DVD images should be either a STREAM_LF format or a fixed format.
	 *
	 *//* VMS *//*
	 *
	 *  VmsSpecialSize checks to see if the stat st_size can be trusted and
	 *  if not to call a routine to get the correct size.
	 *
	 */;
	public static Curl_handler Curl_handler_smtps = new Curl_handler();
	public static  Curl_smtp_escape_eob = new ();
	public static int getpart;
	public static helptxt[] helptext = new helptxt[]{new helptxt("    --abstract-unix-socket <path>", "Connect via abstract Unix domain socket"), new helptxt("    --alt-svc <file name>", "Enable alt-svc with this cache file"), new helptxt("    --anyauth", "Pick any authentication method"), new helptxt("-a, --append", "Append to target file when uploading"), new helptxt("    --basic", "Use HTTP Basic Authentication"), new helptxt("    --cacert <file>", "CA certificate to verify peer against"), new helptxt("    --capath <dir>", "CA directory to verify peer against"), new helptxt("-E, --cert <certificate[:password]>", "Client certificate file and password"), new helptxt("    --cert-status", "Verify the status of the server certificate"), new helptxt("    --cert-type <type>", "Certificate file type (DER/PEM/ENG)"), new helptxt("    --ciphers <list of ciphers>", "SSL ciphers to use"), new helptxt("    --compressed", "Request compressed response"), new helptxt("    --compressed-ssh", "Enable SSH compression"), new helptxt("-K, --config <file>", "Read config from a file"), new helptxt("    --connect-timeout <seconds>", "Maximum time allowed for connection"), new helptxt("    --connect-to <HOST1:PORT1:HOST2:PORT2>", "Connect to host"), new helptxt("-C, --continue-at <offset>", "Resumed transfer offset"), new helptxt("-b, --cookie <data|filename>", "Send cookies from string/file"), new helptxt("-c, --cookie-jar <filename>", "Write cookies to <filename> after operation"), new helptxt("    --create-dirs", "Create necessary local directory hierarchy"), new helptxt("    --crlf", "Convert LF to CRLF in upload"), new helptxt("    --crlfile <file>", "Get a CRL list in PEM format from the given file"), new helptxt("-d, --data <data>", "HTTP POST data"), new helptxt("    --data-ascii <data>", "HTTP POST ASCII data"), new helptxt("    --data-binary <data>", "HTTP POST binary data"), new helptxt("    --data-raw <data>", "HTTP POST data, '@' allowed"), new helptxt("    --data-urlencode <data>", "HTTP POST data url encoded"), new helptxt("    --delegation <LEVEL>", "GSS-API delegation permission"), new helptxt("    --digest", "Use HTTP Digest Authentication"), new helptxt("-q, --disable", "Disable .curlrc"), new helptxt("    --disable-eprt", "Inhibit using EPRT or LPRT"), new helptxt("    --disable-epsv", "Inhibit using EPSV"), new helptxt("    --disallow-username-in-url", "Disallow username in url"), new helptxt("    --dns-interface <interface>", "Interface to use for DNS requests"), new helptxt("    --dns-ipv4-addr <address>", "IPv4 address to use for DNS requests"), new helptxt("    --dns-ipv6-addr <address>", "IPv6 address to use for DNS requests"), new helptxt("    --dns-servers <addresses>", "DNS server addrs to use"), new helptxt("    --doh-url <URL>", "Resolve host names over DOH"), new helptxt("-D, --dump-header <filename>", "Write the received headers to <filename>"), new helptxt("    --egd-file <file>", "EGD socket path for random data"), new helptxt("    --engine <name>", "Crypto engine to use"), new helptxt("    --expect100-timeout <seconds>", "How long to wait for 100-continue"), new helptxt("-f, --fail", "Fail silently (no output at all) on HTTP errors"), new helptxt("    --fail-early", "Fail on first transfer error, do not continue"), new helptxt("    --false-start", "Enable TLS False Start"), new helptxt("-F, --form <name=content>", "Specify multipart MIME data"), new helptxt("    --form-string <name=string>", "Specify multipart MIME data"), new helptxt("    --ftp-account <data>", "Account data string"), new helptxt("    --ftp-alternative-to-user <command>", "String to replace USER [name]"), new helptxt("    --ftp-create-dirs", "Create the remote dirs if not present"), new helptxt("    --ftp-method <method>", "Control CWD usage"), new helptxt("    --ftp-pasv", "Use PASV/EPSV instead of PORT"), new helptxt("-P, --ftp-port <address>", "Use PORT instead of PASV"), new helptxt("    --ftp-pret", "Send PRET before PASV"), new helptxt("    --ftp-skip-pasv-ip", "Skip the IP address for PASV"), new helptxt("    --ftp-ssl-ccc", "Send CCC after authenticating"), new helptxt("    --ftp-ssl-ccc-mode <active/passive>", "Set CCC mode"), new helptxt("    --ftp-ssl-control", "Require SSL/TLS for FTP login, clear for transfer"), new helptxt("-G, --get", "Put the post data in the URL and use GET"), new helptxt("-g, --globoff", "Disable URL sequences and ranges using {} and []"), new helptxt("    --happy-eyeballs-timeout-ms <milliseconds>", "How long to wait in milliseconds for IPv6 before trying IPv4"), new helptxt("    --haproxy-protocol", "Send HAProxy PROXY protocol v1 header"), new helptxt("-I, --head", "Show document info only"), new helptxt("-H, --header <header/@file>", "Pass custom header(s) to server"), new helptxt("-h, --help", "This help text"), new helptxt("    --hostpubmd5 <md5>", "Acceptable MD5 hash of the host public key"), new helptxt("    --http0.9", "Allow HTTP 0.9 responses"), new helptxt("-0, --http1.0", "Use HTTP 1.0"), new helptxt("    --http1.1", "Use HTTP 1.1"), new helptxt("    --http2", "Use HTTP 2"), new helptxt("    --http2-prior-knowledge", "Use HTTP 2 without HTTP/1.1 Upgrade"), new helptxt("    --http3", "Use HTTP v3"), new helptxt("    --ignore-content-length", "Ignore the size of the remote resource"), new helptxt("-i, --include", "Include protocol response headers in the output"), new helptxt("-k, --insecure", "Allow insecure server connections when using SSL"), new helptxt("    --interface <name>", "Use network INTERFACE (or address)"), new helptxt("-4, --ipv4", "Resolve names to IPv4 addresses"), new helptxt("-6, --ipv6", "Resolve names to IPv6 addresses"), new helptxt("-j, --junk-session-cookies", "Ignore session cookies read from file"), new helptxt("    --keepalive-time <seconds>", "Interval time for keepalive probes"), new helptxt("    --key <key>", "Private key file name"), new helptxt("    --key-type <type>", "Private key file type (DER/PEM/ENG)"), new helptxt("    --krb <level>", "Enable Kerberos with security <level>"), new helptxt("    --libcurl <file>", "Dump libcurl equivalent code of this command line"), new helptxt("    --limit-rate <speed>", "Limit transfer speed to RATE"), new helptxt("-l, --list-only", "List only mode"), new helptxt("    --local-port <num/range>", "Force use of RANGE for local port numbers"), new helptxt("-L, --location", "Follow redirects"), new helptxt("    --location-trusted", "Like --location, and send auth to other hosts"), new helptxt("    --login-options <options>", "Server login options"), new helptxt("    --mail-auth <address>", "Originator address of the original email"), new helptxt("    --mail-from <address>", "Mail from this address"), new helptxt("    --mail-rcpt <address>", "Mail to this address"), new helptxt("-M, --manual", "Display the full manual"), new helptxt("    --max-filesize <bytes>", "Maximum file size to download"), new helptxt("    --max-redirs <num>", "Maximum number of redirects allowed"), new helptxt("-m, --max-time <seconds>", "Maximum time allowed for the transfer"), new helptxt("    --metalink", "Process given URLs as metalink XML file"), new helptxt("    --negotiate", "Use HTTP Negotiate (SPNEGO) authentication"), new helptxt("-n, --netrc", "Must read .netrc for user name and password"), new helptxt("    --netrc-file <filename>", "Specify FILE for netrc"), new helptxt("    --netrc-optional", "Use either .netrc or URL"), new helptxt("-:, --next", "Make next URL use its separate set of options"), new helptxt("    --no-alpn", "Disable the ALPN TLS extension"), new helptxt("-N, --no-buffer", "Disable buffering of the output stream"), new helptxt("    --no-keepalive", "Disable TCP keepalive on the connection"), new helptxt("    --no-npn", "Disable the NPN TLS extension"), new helptxt("    --no-progress-meter", "Do not show the progress meter"), new helptxt("    --no-sessionid", "Disable SSL session-ID reusing"), new helptxt("    --noproxy <no-proxy-list>", "List of hosts which do not use proxy"), new helptxt("    --ntlm", "Use HTTP NTLM authentication"), new helptxt("    --ntlm-wb", "Use HTTP NTLM authentication with winbind"), new helptxt("    --oauth2-bearer <token>", "OAuth 2 Bearer Token"), new helptxt("-o, --output <file>", "Write to file instead of stdout"), new helptxt("-Z, --parallel", "Perform transfers in parallel"), new helptxt("    --parallel-max", "Maximum concurrency for parallel transfers"), new helptxt("    --pass <phrase>", "Pass phrase for the private key"), new helptxt("    --path-as-is", "Do not squash .. sequences in URL path"), new helptxt("    --pinnedpubkey <hashes>", "FILE/HASHES Public key to verify peer against"), new helptxt("    --post301", "Do not switch to GET after following a 301"), new helptxt("    --post302", "Do not switch to GET after following a 302"), new helptxt("    --post303", "Do not switch to GET after following a 303"), new helptxt("    --preproxy [protocol://]host[:port]", "Use this proxy first"), new helptxt("-#, --progress-bar", "Display transfer progress as a bar"), new helptxt("    --proto <protocols>", "Enable/disable PROTOCOLS"), new helptxt("    --proto-default <protocol>", "Use PROTOCOL for any URL missing a scheme"), new helptxt("    --proto-redir <protocols>", "Enable/disable PROTOCOLS on redirect"), new helptxt("-x, --proxy [protocol://]host[:port]", "Use this proxy"), new helptxt("    --proxy-anyauth", "Pick any proxy authentication method"), new helptxt("    --proxy-basic", "Use Basic authentication on the proxy"), new helptxt("    --proxy-cacert <file>", "CA certificate to verify peer against for proxy"), new helptxt("    --proxy-capath <dir>", "CA directory to verify peer against for proxy"), new helptxt("    --proxy-cert <cert[:passwd]>", "Set client certificate for proxy"), new helptxt("    --proxy-cert-type <type>", "Client certificate type for HTTPS proxy"), new helptxt("    --proxy-ciphers <list>", "SSL ciphers to use for proxy"), new helptxt("    --proxy-crlfile <file>", "Set a CRL list for proxy"), new helptxt("    --proxy-digest", "Use Digest authentication on the proxy"), new helptxt("    --proxy-header <header/@file>", "Pass custom header(s) to proxy"), new helptxt("    --proxy-insecure", "Do HTTPS proxy connections without verifying the proxy"), new helptxt("    --proxy-key <key>", "Private key for HTTPS proxy"), new helptxt("    --proxy-key-type <type>", "Private key file type for proxy"), new helptxt("    --proxy-negotiate", "Use HTTP Negotiate (SPNEGO) authentication on the proxy"), new helptxt("    --proxy-ntlm", "Use NTLM authentication on the proxy"), new helptxt("    --proxy-pass <phrase>", "Pass phrase for the private key for HTTPS proxy"), new helptxt("    --proxy-pinnedpubkey <hashes>", "FILE/HASHES public key to verify proxy with"), new helptxt("    --proxy-service-name <name>", "SPNEGO proxy service name"), new helptxt("    --proxy-ssl-allow-beast", "Allow security flaw for interop for HTTPS proxy"), new helptxt("    --proxy-tls13-ciphers <list>", "TLS 1.3 ciphersuites for proxy (OpenSSL)"), new helptxt("    --proxy-tlsauthtype <type>", "TLS authentication type for HTTPS proxy"), new helptxt("    --proxy-tlspassword <string>", "TLS password for HTTPS proxy"), new helptxt("    --proxy-tlsuser <name>", "TLS username for HTTPS proxy"), new helptxt("    --proxy-tlsv1", "Use TLSv1 for HTTPS proxy"), new helptxt("-U, --proxy-user <user:password>", "Proxy user and password"), new helptxt("    --proxy1.0 <host[:port]>", "Use HTTP/1.0 proxy on given port"), new helptxt("-p, --proxytunnel", "Operate through an HTTP proxy tunnel (using CONNECT)"), new helptxt("    --pubkey <key>", "SSH Public key file name"), new helptxt("-Q, --quote", "Send command(s) to server before transfer"), new helptxt("    --random-file <file>", "File for reading random data from"), new helptxt("-r, --range <range>", "Retrieve only the bytes within RANGE"), new helptxt("    --raw", "Do HTTP \"raw\"; no transfer decoding"), new helptxt("-e, --referer <URL>", "Referrer URL"), new helptxt("-J, --remote-header-name", "Use the header-provided filename"), new helptxt("-O, --remote-name", "Write output to a file named as the remote file"), new helptxt("    --remote-name-all", "Use the remote file name for all URLs"), new helptxt("-R, --remote-time", "Set the remote file's time on the local output"), new helptxt("-X, --request <command>", "Specify request command to use"), new helptxt("    --request-target", "Specify the target for this request"), new helptxt("    --resolve <host:port:address[,address]...>", "Resolve the host+port to this address"), new helptxt("    --retry <num>", "Retry request if transient problems occur"), new helptxt("    --retry-connrefused", "Retry on connection refused (use with --retry)"), new helptxt("    --retry-delay <seconds>", "Wait time between retries"), new helptxt("    --retry-max-time <seconds>", "Retry only within this period"), new helptxt("    --sasl-authzid <identity> ", "Use this identity to act as during SASL PLAIN authentication"), new helptxt("    --sasl-ir", "Enable initial response in SASL authentication"), new helptxt("    --service-name <name>", "SPNEGO service name"), new helptxt("-S, --show-error", "Show error even when -s is used"), new helptxt("-s, --silent", "Silent mode"), new helptxt("    --socks4 <host[:port]>", "SOCKS4 proxy on given host + port"), new helptxt("    --socks4a <host[:port]>", "SOCKS4a proxy on given host + port"), new helptxt("    --socks5 <host[:port]>", "SOCKS5 proxy on given host + port"), new helptxt("    --socks5-basic", "Enable username/password auth for SOCKS5 proxies"), new helptxt("    --socks5-gssapi", "Enable GSS-API auth for SOCKS5 proxies"), new helptxt("    --socks5-gssapi-nec", "Compatibility with NEC SOCKS5 server"), new helptxt("    --socks5-gssapi-service <name>", "SOCKS5 proxy service name for GSS-API"), new helptxt("    --socks5-hostname <host[:port]>", "SOCKS5 proxy, pass host name to proxy"), new helptxt("-Y, --speed-limit <speed>", "Stop transfers slower than this"), new helptxt("-y, --speed-time <seconds>", "Trigger 'speed-limit' abort after this time"), new helptxt("    --ssl", "Try SSL/TLS"), new helptxt("    --ssl-allow-beast", "Allow security flaw to improve interop"), new helptxt("    --ssl-no-revoke", "Disable cert revocation checks (Schannel)"), new helptxt("    --ssl-reqd", "Require SSL/TLS"), new helptxt("-2, --sslv2", "Use SSLv2"), new helptxt("-3, --sslv3", "Use SSLv3"), new helptxt("    --stderr", "Where to redirect stderr"), new helptxt("    --styled-output", "Enable styled output for HTTP headers"), new helptxt("    --suppress-connect-headers", "Suppress proxy CONNECT response headers"), new helptxt("    --tcp-fastopen", "Use TCP Fast Open"), new helptxt("    --tcp-nodelay", "Use the TCP_NODELAY option"), new helptxt("-t, --telnet-option <opt=val>", "Set telnet option"), new helptxt("    --tftp-blksize <value>", "Set TFTP BLKSIZE option"), new helptxt("    --tftp-no-options", "Do not send any TFTP options"), new helptxt("-z, --time-cond <time>", "Transfer based on a time condition"), new helptxt("    --tls-max <VERSION>", "Set maximum allowed TLS version"), new helptxt("    --tls13-ciphers <list>", "TLS 1.3 ciphersuites (OpenSSL)"), new helptxt("    --tlsauthtype <type>", "TLS authentication type"), new helptxt("    --tlspassword", "TLS password"), new helptxt("    --tlsuser <name>", "TLS user name"), new helptxt("-1, --tlsv1", "Use TLSv1.0 or greater"), new helptxt("    --tlsv1.0", "Use TLSv1.0 or greater"), new helptxt("    --tlsv1.1", "Use TLSv1.1 or greater"), new helptxt("    --tlsv1.2", "Use TLSv1.2 or greater"), new helptxt("    --tlsv1.3", "Use TLSv1.3 or greater"), new helptxt("    --tr-encoding", "Request compressed transfer encoding"), new helptxt("    --trace <file>", "Write a debug trace to FILE"), new helptxt("    --trace-ascii <file>", "Like --trace, but without hex output"), new helptxt("    --trace-time", "Add time stamps to trace/verbose output"), new helptxt("    --unix-socket <path>", "Connect through this Unix domain socket"), new helptxt("-T, --upload-file <file>", "Transfer local FILE to destination"), new helptxt("    --url <url>", "URL to work with"), new helptxt("-B, --use-ascii", "Use ASCII/text transfer"), new helptxt("-u, --user <user:password>", "Server user and password"), new helptxt("-A, --user-agent <name>", "Send User-Agent <name> to server"), new helptxt("-v, --verbose", "Make the operation more talkative"), new helptxt("-V, --version", "Show version number and quit"), new helptxt("-w, --write-out <format>", "Use output FORMAT after completion"), new helptxt("    --xattr", "Store metadata in extended file attributes"), new helptxt(((Object)0), ((Object)0))};
	public static feat[] feats = new feat[]{new feat("AsynchDNS", CURL_VERSION_ASYNCHDNS), new feat("Debug", CURL_VERSION_DEBUG), new feat("TrackMemory", CURL_VERSION_CURLDEBUG), new feat("IDN", CURL_VERSION_IDN), new feat("IPv6", CURL_VERSION_IPV6), new feat("Largefile", CURL_VERSION_LARGEFILE), new feat("SSPI", CURL_VERSION_SSPI), new feat("GSS-API", CURL_VERSION_GSSAPI), new feat("Kerberos", CURL_VERSION_KERBEROS5), new feat("SPNEGO", CURL_VERSION_SPNEGO), new feat("NTLM", CURL_VERSION_NTLM), new feat("NTLM_WB", CURL_VERSION_NTLM_WB), new feat("SSL", CURL_VERSION_SSL), new feat("libz", CURL_VERSION_LIBZ), new feat("brotli", CURL_VERSION_BROTLI), new feat("CharConv", CURL_VERSION_CONV), new feat("TLS-SRP", CURL_VERSION_TLSAUTH_SRP), new feat("HTTP2", CURL_VERSION_HTTP2), new feat("HTTP3", CURL_VERSION_HTTP3), new feat("UnixSockets", CURL_VERSION_UNIX_SOCKETS), new feat("HTTPS-proxy", CURL_VERSION_HTTPS_PROXY), new feat("MultiSSL", CURL_VERSION_MULTI_SSL), new feat("PSL", CURL_VERSION_PSL), new feat("alt-svc", CURL_VERSION_ALTSVC), new feat("ESNI", CURL_VERSION_ESNI)};
	public static Object Curl_memrchr;
	public static bool verifyconnect = new bool();
	public static  singleipconnect = new ();
	public static byte[] name = "fieldname"/* This test attempts to use all form API features that are not
	 * used elsewhere.
	 */;
	public static int Curl_socket_check;
	public static int Curl_poll;
	public static int Curl_ack_eintr;
	public static int Curl_wait_ms;
	public static byte[] disabled = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*
	 * The purpose of this tool is to figure out which, if any, features that are
	 * disabled which should otherwise exist and work. These aren't visible in
	 * regular curl -V output.
	 *
	 * Disabled protocols are visible in curl_version_info() and are not included
	 * in this table.
	 */((Object)0)};
	public static Object warnf;
	public static Object notef;
	public static Object helpf;
	public static  Curl_base64_encode = new ();
	public static  Curl_base64url_encode = new ();
	public static  Curl_base64_decode = new ();
	public static Object Curl_speedinit;
	public static  Curl_speedcheck = new ();
	public static byte data_to_hex;
	public static Object logmsg;
	public static long timediff;
	public static Object win32_perror;
	public static Object win32_init;
	public static Object win32_cleanup;
	public static byte test2file;
	public static int wait_ms;
	public static int write_pidfile;
	public static Object set_advisor_read_lock;
	public static Object clear_advisor_read_lock;
	public static int strncasecompare;
	public static curl_hash hp = new curl_hash();
	public static byte data_key;
	public static Curl_dns_entry data_node = new Curl_dns_entry();
	public static pthread_mutex_t mutex_buf = ((Object)/* This array will store all of the mutexes available to OpenSSL. */0);
	public static byte skip = /* In builds without IPv6 support CURLOPT_RESOLVE should skip over those
	   addresses, so we have to do that as well. */0;
	public static byte[] buf = new byte[5000 + 100];
	public static byte backendaddr = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* Function
	 *
	 * Accepts a TCP connection on a custom port (IPv4 or IPv6). Connects to a
	 * given addr + port backend (that is NOT extracted form the client's
	 * request). The backend server default to connect to can be set with
	 * --backend and --backendport.
	 *
	 * Read commands from FILE (set with --config). The commands control how to
	 * act and is reset to defaults each client TCP connect.
	 *
	 * Config file keywords:
	 *
	 * "version [number: 5]" - requires the communication to use this version.
	 * "nmethods_min [number: 1]" - the minimum numberf NMETHODS the client must
	 *                              state
	 * "nmethods_max [number: 3]" - the minimum numberf NMETHODS the client must
	 *                              state
	 * "user [string]" - the user name that must match (if method is 2)
	 * "password [string]" - the password that must match (if method is 2)
	 * "backend [IPv4]" - numerical IPv4 address of backend to connect to
	 * "backendport [number:0]" - TCP port of backend to connect to. 0 means use
	                              the client's specified port number.
	 * "method [number: 0]" - connect method to respond with:
	 *                        0 - no auth
	 *                        1 - GSSAPI (not supported)
	 *                        2 - user + password
	 * "response [number]" - the decimal number to repsond to a connect
	 *                       SOCKS5: 0 is OK, SOCKS4: 90 is ok
	 *
	 *//* based on sockfilt.c *//* make the curlx header define all printf() functions to use the curlx_*
	   versions instead *//* from the private lib dir *//* include memdebug.h last *//* errno.h value *//* errno.h value *//* errno.h value *//* errno.h value */"127.0.0.1";
	public static int backendport = /* default is use client's */0;
	public static configurable config = new configurable();
	public static byte configfile = "socksd.config";
	public static int port = 8905;
	public static int seen_malloc = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*
	 * This test uses these funny custom memory callbacks for the only purpose
	 * of verifying that curl_global_init_mem() functionality is present in
	 * libcurl and that it works unconditionally no matter how libcurl is built,
	 * nothing more.
	 *
	 * Do not include memdebug.h in this source file, and do not use directly
	 * memory related functions in this file except those used inside custom
	 * memory callbacks which should be calling 'the real thing'.
	 *//*
	#include "memdebug.h"
	*/0;
	public static int seen_free = 0;
	public static int seen_realloc = 0;
	public static int seen_strdup = 0;
	public static int seen_calloc = 0;
	public static Object custom_malloc;
	public static Object custom_free;
	public static Object custom_realloc;
	public static byte custom_strdup;
	public static Object custom_calloc;
	public static int curlx_nonblock;
	public static long[] vms_cond = new long[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*                                                                          *//* CURLMSG_VMS.H                                                            *//*                                                                          *//* This defines the necessary bits to change CURLE_* error codes to VMS     *//* style error codes.  CURLMSG.H is built from CURLMSG.SDL which is built   *//* from CURLMSG.MSG.  The vms_cond array is used to return VMS errors by    *//* putting the VMS error codes into the array offset based on CURLE_* code. *//*                                                                          *//* If you update CURLMSG.MSG make sure to update this file to match.        *//*                                                                          *//*
	#define   FAC_CURL      0xC01
	#define   FAC_SYSTEM    0
	#define   MSG_NORMAL    0
	*//*
	#define   SEV_WARNING   0
	#define   SEV_SUCCESS   1
	#define   SEV_ERROR     2
	#define   SEV_INFO      3
	#define   SEV_FATAL     4
	*/251756553, 251756562, 251756570, 251756578, 251756586, 251756594, 251756602, 251756610, 251756618, 251756626, 251756634, 251756642, 251756650, 251756658, 251756666, 251756674, 251756682, 251756690, 251756698, 251756706, 251756714, 251756722, 251756730, 251756738, 251756746, 251756754, 251756762, 251756770, 251756778, 251756786, 251756794, 251756802, 251756810, 251756818, 251756826, 251756834, 251756842, 251756850, 251756858, 251756866, 251756874, 251756882, 251756890, 251756898, 251756906, 251756914, 251756922, 251756930, 251756938, 251756946, 251756954, 251756962, 251756970, 251756978, 251756986, 251756994, 251757002, 251757010, 251757018, 251757026, 251757034, 251757042, 251757050, 251757058, 251757066, 251757074, 251757082, 251757090, 251757098, 251757106, 251757114, 251757122, 251757130, 251757138, 251757146, 251757154, 251757162, 251757170, 251757178, 251757186, 251757194, 251757202, CURLE_SSL_CRL_BADFILE, CURLE_SSL_ISSUER_ERROR, 251757226/* HEADER_CURLMSG_VMS_H */};
	public static  glob_url = new ();
	public static  glob_next_url = new ();
	public static  glob_match_url = new ();
	public static Object glob_cleanup;
	public static curl_slist Curl_slist_duplicate = new curl_slist();
	public static curl_slist Curl_slist_append_nodup = new curl_slist();
	public static CURLofft curlx_strtoofft = new CURLofft();
	public static ParameterError getparameter = new ParameterError();
	public static ParameterError parse_args = new ParameterError();
	public static byte[] ascii = new byte[]{(1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 3) | (1 << 7), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 5)};
	public static  Curl_pp_statemach = new ();
	public static Object Curl_pp_init;
	public static time_t Curl_pp_state_timeout = new time_t();
	public static  Curl_pp_sendf = new ();
	public static  Curl_pp_vsendf = new ();
	public static  Curl_pp_readresp = new ();
	public static  Curl_pp_flushsend = new ();
	public static  Curl_pp_disconnect = new ();
	public static int Curl_pp_getsock;
	public static bool Curl_pp_moredata = new bool();
	public static  singlesocket = new ();
	public static  add_next_timeout = new ();
	public static  multi_timeout = new ();
	public static Object process_pending_handles;
	public static Object detach_connnection;
	public static Object init_multistate_func;
	public static  Curl_getinfo = new ();
	public static  Curl_initinfo = new ();
	public static Object dump;
	public static Object Curl_ntlm_core_lm_resp;
	public static  Curl_ntlm_core_mk_lm_hash = new ();
	public static  Curl_ntlm_core_mk_nt_hash = new ();
	public static  Curl_hmac_md5 = new ();
	public static  Curl_ntlm_core_mk_ntlmv2_hash = new ();
	public static  Curl_ntlm_core_mk_ntlmv2_resp = new ();
	public static  Curl_ntlm_core_mk_lmv2_resp = new ();
	public static  loop = new ();
	public static  curl_handle = new ();
	public static  timeout = new ();
	public static event_base base = new event_base();
	public static Object curl_perform;
	public static bool tool_setopt_skip = new bool();
	public static  tool_setopt_enum = new ();
	public static  tool_setopt_flags = new ();
	public static  tool_setopt_bitmask = new ();
	public static  tool_setopt_mimepost = new ();
	public static  tool_setopt_slist = new ();
	public static  tool_setopt = new ();
	public static  Curl_shuffle_addr = new ();
	public static Curl_addrinfo[] addrs = new Curl_addrinfo();
	public static  easy = new ();
	public static int Curl_socketpair;
	public static ssize_t Curl_send = new ssize_t();
	public static ssize_t Curl_recv = new ssize_t();
	public static int bit;
	public static  Curl_do_more_func = new ();
	public static  Curl_done_func = new ();
	public static int multidone_func;
	public static int http_getsock_do;
	public static int http_should_fail;
	public static  add_haproxy_protocol_header = new ();
	public static  http_setup_conn = new ();
	public static int Curl_conncache_init;
	public static Object Curl_conncache_destroy;
	public static connectbundle Curl_conncache_find_bundle = new connectbundle();
	public static Object Curl_conncache_unlock;
	public static  Curl_conncache_size = new ();
	public static  Curl_conncache_bundle_size = new ();
	public static  Curl_conncache_return_conn = new ();
	public static  Curl_conncache_add_conn = new ();
	public static int WARN_UNUSED_RESULT;
	public static Object Curl_conncache_remove_conn;
	public static  Curl_conncache_foreach = new ();
	public static connectdata Curl_conncache_find_first_connection = new connectdata();
	public static connectdata Curl_conncache_extract_bundle = new connectdata();
	public static connectdata Curl_conncache_extract_oldest = new connectdata();
	public static Object Curl_conncache_close_all_connections;
	public static Object Curl_conncache_print;
	public static  Curl_input_digest = new ();
	public static  Curl_output_digest = new ();
	public static Object Curl_http_auth_cleanup_digest;
	public static byte Curl_chunked_strerror;
	public static Object Curl_httpchunk_init;
	public static CHUNKcode Curl_httpchunk_read = new CHUNKcode();
	public static size_t current_offset = 0;
	public static byte[] databuf = new byte[/* MUST be more than 64k OR
	                               MAX_INITIAL_POST_SIZE */70000];
	public static int Curl_pgrsDone;
	public static Object Curl_pgrsStartNow;
	public static Object Curl_pgrsSetDownloadSize;
	public static Object Curl_pgrsSetUploadSize;
	public static Object Curl_pgrsSetDownloadCounter;
	public static Object Curl_pgrsSetUploadCounter;
	public static Object Curl_ratelimit;
	public static int Curl_pgrsUpdate;
	public static Object Curl_pgrsResetTransferSizes;
	public static Object Curl_pgrsTime;
	public static timediff_t Curl_pgrsLimitWaitTime = new timediff_t();
	public static Object Curl_sha256it;
	public static int curlx_ultous;
	public static byte curlx_ultouc;
	public static int curlx_ultosi;
	public static int curlx_uztosi;
	public static  curlx_uztoso = new ();
	public static long curlx_uztoul;
	public static int curlx_uztoui;
	public static int curlx_sltosi;
	public static int curlx_sltoui;
	public static int curlx_sltous;
	public static  curlx_uztosz = new ();
	public static  curlx_sotouz = new ();
	public static int curlx_sztosi;
	public static int curlx_uitous;
	public static  curlx_sitouz = new ();
	public static  curlx_read = new ();
	public static  curlx_write = new ();
	public static curl_llist llist = new curl_llist();
	public static curl_llist llist_destination = new curl_llist();
	public static Cookie Curl_cookie_add = new Cookie();
	public static Cookie Curl_cookie_getlist = new Cookie();
	public static Object Curl_cookie_freelist;
	public static Object Curl_cookie_clearall;
	public static Object Curl_cookie_clearsess;
	public static Object Curl_flush_cookies;
	public static Object Curl_cookie_cleanup;
	public static CookieInfo Curl_cookie_init = new CookieInfo();
	public static curl_slist Curl_cookie_list = new curl_slist();
	public static Object Curl_cookie_loadfiles;
	public static  Curl_setstropt = new ();
	public static  Curl_vsetopt = new ();
	public static byte login;
	public static byte password;
	public static byte[] filename = new byte[/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* LAST include file */64];
	public static libtest_trace_cfg libtest_debug_config = new libtest_trace_cfg();
	public static time_t epoch_offset = new time_t();
	public static int known_offset;
	public static long file_is_coming;
	public static long file_is_downloaded;
	public static size_t write_it = new size_t();
	public static Object Curl_sasl_cleanup;
	public static int Curl_sasl_decode_mech;
	public static  Curl_sasl_parse_url_auth_option = new ();
	public static Object Curl_sasl_init;
	public static  Curl_sasl_can_authenticate = new ();
	public static  Curl_sasl_start = new ();
	public static  Curl_sasl_continue = new ();
	public static byte[][] DefaultTimeServer = new byte[][]{"https://nist.time.gov/", "https://www.google.com/"};
	public static byte[] DayStr = new byte[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	public static byte[] MthStr = new byte[]{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	public static int ShowAllHeader;
	public static int AutoSyncTime;
	public static SYSTEMTIME SYSTime = new SYSTEMTIME();
	public static SYSTEMTIME LOCALTime = new SYSTEMTIME();
	public static byte Curl_dedotdotify;
	public static  pop3_regular_transfer = new ();
	public static  pop3_do = new ();
	public static  pop3_done = new ();
	public static  pop3_connect = new ();
	public static  pop3_disconnect = new ();
	public static  pop3_multi_statemach = new ();
	public static int pop3_getsock;
	public static  pop3_doing = new ();
	public static  pop3_setup_connection = new ();
	public static  pop3_parse_url_options = new ();
	public static  pop3_parse_url_path = new ();
	public static  pop3_parse_custom_request = new ();
	public static  pop3_perform_auth = new ();
	public static  pop3_continue_auth = new ();
	public static Object pop3_get_message;
	public static SASLproto saslpop3 = new SASLproto(/* The service name */"pop", /* Code received when continuation is expected */(byte)'*', /* Code to receive upon authentication success */(byte)'+', 255 - /* Maximum initial response length (no max) */8, /* Send authentication command */pop3_perform_auth, /* Send authentication continuation */pop3_continue_auth, /* Get SASL response message */pop3_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static uint32_t OM_uint32 = new uint32_t();
	public static OM_uint32 gss_qop_t = new OM_uint32();
	public static gss_cred_id_t_desc_struct gss_cred_id_t = new gss_cred_id_t_desc_struct();
	public static gss_cred_id_t_desc_struct gss_const_cred_id_t = new gss_cred_id_t_desc_struct();
	public static gss_ctx_id_t_desc_struct gss_ctx_id_t = new gss_ctx_id_t_desc_struct();
	public static gss_ctx_id_t_desc_struct gss_const_ctx_id_t = new gss_ctx_id_t_desc_struct();
	public static gss_name_t_desc_struct gss_name_t = new gss_name_t_desc_struct();
	public static gss_name_t_desc_struct gss_const_name_t = new gss_name_t_desc_struct();
	public static OM_uint32 gss_release_buffer = new OM_uint32();
	public static OM_uint32 gss_init_sec_context = new OM_uint32();
	public static OM_uint32 gss_delete_sec_context = new OM_uint32();
	public static OM_uint32 gss_inquire_context = new OM_uint32();
	public static OM_uint32 gss_wrap = new OM_uint32();
	public static OM_uint32 gss_unwrap = new OM_uint32();
	public static OM_uint32 gss_seal = new OM_uint32();
	public static OM_uint32 gss_unseal = new OM_uint32();
	public static OM_uint32 gss_import_name = new OM_uint32();
	public static OM_uint32 gss_release_name = new OM_uint32();
	public static OM_uint32 gss_display_name = new OM_uint32();
	public static OM_uint32 gss_display_status = new OM_uint32();
	public static Object progressbarinit;
	public static int tool_progress_cb;
	public static  u = new ();
	public static getout new_getout = new getout();
	public static  file2string = new ();
	public static  file2memory = new ();
	public static Object cleanarg;
	public static  str2num = new ();
	public static  str2unum = new ();
	public static  str2unummax = new ();
	public static  str2udouble = new ();
	public static long proto2num;
	public static int check_protocol;
	public static  str2offset = new ();
	public static  get_args = new ();
	public static  add2list = new ();
	public static int ftpfilemethod;
	public static int ftpcccmethod;
	public static long delegation;
	public static  str2tls_max = new ();
	public static tool_mime tool_mime = new tool_mime();
	public static size_t tool_mime_stdin_read = new size_t();
	public static int tool_mime_stdin_seek;
	public static int formparse;
	public static  tool2curlmime = new ();
	public static Object tool_mime_free;
	public static int Curl_read16_le;
	public static int Curl_read32_le;
	public static int Curl_read16_be;
	public static byte Curl_inet_ntop;
	public static contenc_writer_s contenc_writer = new contenc_writer_s();
	public static content_encoding_s content_encoding = new content_encoding_s();
	public static  Curl_build_unencoding_stack = new ();
	public static  Curl_unencode_write = new ();
	public static Object Curl_unencode_cleanup;
	public static byte Curl_all_content_encodings;
	public static long LIB$SET_SYMBOL;
	public static Object HMAC_hinit_func;
	public static Object HMAC_hupdate_func;
	public static Object HMAC_hfinal_func;
	public static HMAC_context Curl_HMAC_init = new HMAC_context();
	public static int Curl_HMAC_update;
	public static int Curl_HMAC_final;
	public static byte libtest_arg2;
	public static byte libtest_arg3;
	public static int test_argc;
	public static byte test_argv;
	public static timeval tv_test_start = new timeval();
	public static int select_wrapper;
	public static int test;
	public static byte hexdump;
	public static byte[] lower_digits = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1999 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 *
	 * Purpose:
	 *  A merge of Bjorn Reese's format() function and Daniel's dsprintf()
	 *  1.0. A full blooded printf() clone with full support for <num>$
	 *  everywhere (parameters, widths and precisions) including variabled
	 *  sized parameters (like doubles, long longs, long doubles and even
	 *  void * in 64-bit architectures).
	 *
	 * Current restrictions:
	 * - Max 128 parameters
	 * - No 'long double' support.
	 *
	 * If you ever want truly portable and good *printf() clones, the project that
	 * took on from here is named 'Trio' and you find more details on the trio web
	 * page at https://daniel.haxx.se/projects/trio/
	 *//* The last #include file should be: *//*
	 * If SIZEOF_SIZE_T has not been defined, default to the size of long.
	 *//*
	 * Non-ANSI integer extensions
	 *//*
	 * Max integer data types that mprintf.c is capable
	 *//* buffer for long-to-str and float-to-str calcs, should
	                        fit negative DBL_MAX (317 letters) *//* lame static limit *//* Lower-case digits.  */"0123456789abcdefghijklmnopqrstuvwxyz";
	public static byte[] upper_digits = /* Upper-case digits.  */"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	public static Object Curl_MD5_init_func;
	public static Object Curl_MD5_update_func;
	public static Object Curl_MD5_final_func;
	public static Object Curl_md5it;
	public static MD5_context Curl_MD5_init = new MD5_context();
	public static  Curl_MD5_update = new ();
	public static  Curl_MD5_final = new ();
	public static  tftp_rx = new ();
	public static  tftp_tx = new ();
	public static  tftp_connect = new ();
	public static  tftp_disconnect = new ();
	public static  tftp_do = new ();
	public static  tftp_done = new ();
	public static  tftp_setup_connection = new ();
	public static  tftp_multi_statemach = new ();
	public static  tftp_doing = new ();
	public static int tftp_getsock;
	public static  tftp_translate_code = new ();
	public static Curl_handler Curl_handler_tftp = new Curl_handler(/* scheme */"TFTP", /* setup_connection */tftp_setup_connection, /* do_it */tftp_do, /* done */tftp_done, /* do_more */0, /* connect_it */tftp_connect, /* connecting */tftp_multi_statemach, /* doing */tftp_doing, /* proto_getsock */tftp_getsock, /* doing_getsock */tftp_getsock, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */tftp_disconnect, /* readwrite */0, /* connection_check */0, /* defport */69, /* protocol */CURLPROTO_TFTP, 0 | (1 << /* flags */6/**********************************************************
	 *
	 * tftp_set_timeouts -
	 *
	 * Set timeouts based on state machine state.
	 * Use user provided connect timeouts until DATA or ACK
	 * packet is received, then use user-provided transfer timeouts
	 *
	 *
	 **********************************************************/));
	public static  Curl_auth_digest_get_pair = new ();
	public static Object set_binmode;
	public static fcurl_data URL_FILE = new fcurl_data();
	public static URL_FILE url_fopen = new URL_FILE();
	public static int url_fclose;
	public static int url_feof;
	public static size_t url_fread = new size_t();
	public static byte url_fgets;
	public static Object url_rewind;
	public static  multi_handle = new ();
	public static int stat;
	public static byte curl_version_ccsid;
	public static byte curl_easy_escape_ccsid;
	public static byte curl_easy_unescape_ccsid;
	public static curl_slist curl_slist_append_ccsid = new curl_slist();
	public static time_t curl_getdate_ccsid = new time_t();
	public static curl_version_info_data curl_version_info_ccsid = new curl_version_info_data();
	public static byte curl_easy_strerror_ccsid;
	public static byte curl_share_strerror_ccsid;
	public static byte curl_multi_strerror_ccsid;
	public static CURLcode curl_easy_getinfo_ccsid = new CURLcode();
	public static CURLFORMcode curl_formadd_ccsid = new CURLFORMcode();
	public static byte curl_form_long_value;
	public static int curl_formget_ccsid;
	public static CURLcode curl_easy_setopt_ccsid = new CURLcode();
	public static Object curl_certinfo_free_all;
	public static byte curl_pushheader_bynum_cssid;
	public static byte curl_pushheader_byname_ccsid;
	public static CURLcode curl_mime_name_ccsid = new CURLcode();
	public static CURLcode curl_mime_filename_ccsid = new CURLcode();
	public static CURLcode curl_mime_type_ccsid = new CURLcode();
	public static CURLcode curl_mime_encoder_ccsid = new CURLcode();
	public static CURLcode curl_mime_filedata_ccsid = new CURLcode();
	public static CURLcode curl_mime_data_ccsid = new CURLcode();
	public static CURLUcode curl_url_get_ccsid = new CURLUcode();
	public static CURLUcode curl_url_set_ccsid = new CURLUcode();
	public static int usec_magnitude = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/1000000;
	public static int Curl_isspace;
	public static int Curl_isdigit;
	public static int Curl_isalnum;
	public static int Curl_isxdigit;
	public static int Curl_isgraph;
	public static int Curl_isprint;
	public static int Curl_isalpha;
	public static int Curl_isupper;
	public static int Curl_islower;
	public static int Curl_iscntrl;
	public static long tvdiff;
	public static int tool_ftruncate64;
	public static int tool_seek_cb;
	public static byte[] base64url = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	public static int parsedate;
	public static byte[] weekday = new byte[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
	public static tzinfo[] tz = new tzinfo[]{new tzinfo("GMT", /* Greenwich Mean */0), new tzinfo("UT", /* Universal Time */0), new tzinfo("UTC", /* Universal (Coordinated) */0), new tzinfo("WET", /* Western European */0), new tzinfo("BST", 0 - /* British Summer */60), new tzinfo("WAT", /* West Africa */60), new tzinfo("AST", /* Atlantic Standard */240), new tzinfo("ADT", 240 - /* Atlantic Daylight */60), new tzinfo("EST", /* Eastern Standard */300), new tzinfo("EDT", 300 - /* Eastern Daylight */60), new tzinfo("CST", /* Central Standard */360), new tzinfo("CDT", 360 - /* Central Daylight */60), new tzinfo("MST", /* Mountain Standard */420), new tzinfo("MDT", 420 - /* Mountain Daylight */60), new tzinfo("PST", /* Pacific Standard */480), new tzinfo("PDT", 480 - /* Pacific Daylight */60), new tzinfo("YST", /* Yukon Standard */540), new tzinfo("YDT", 540 - /* Yukon Daylight */60), new tzinfo("HST", /* Hawaii Standard */600), new tzinfo("HDT", 600 - /* Hawaii Daylight */60), new tzinfo("CAT", /* Central Alaska */600), new tzinfo("AHST", /* Alaska-Hawaii Standard */600), new tzinfo("NT", /* Nome */660), new tzinfo("IDLW", /* International Date Line West */720), new tzinfo("CET", -/* Central European */60), new tzinfo("MET", -/* Middle European */60), new tzinfo("MEWT", -/* Middle European Winter */60), new tzinfo("MEST", -60 - /* Middle European Summer */60), new tzinfo("CEST", -60 - /* Central European Summer */60), new tzinfo("MESZ", -60 - /* Middle European Summer */60), new tzinfo("FWT", -/* French Winter */60), new tzinfo("FST", -60 - /* French Summer */60), new tzinfo("EET", -/* Eastern Europe, USSR Zone 1 */120), new tzinfo("WAST", -/* West Australian Standard */420), new tzinfo("WADT", -420 - /* West Australian Daylight */60), new tzinfo("CCT", -/* China Coast, USSR Zone 7 */480), new tzinfo("JST", -/* Japan Standard, USSR Zone 8 */540), new tzinfo("EAST", -/* Eastern Australian Standard */600), new tzinfo("EADT", -600 - /* Eastern Australian Daylight */60), new tzinfo("GST", -/* Guam Standard, USSR Zone 9 */600), new tzinfo("NZT", -/* New Zealand */720), new tzinfo("NZST", -/* New Zealand Standard */720), new tzinfo("NZDT", -720 - /* New Zealand Daylight */60), new tzinfo("IDLE", -/* International Date Line East */720/* Next up: Military timezone names. RFC822 allowed these, but (as noted in
	     RFC 1123) had their signs wrong. Here we use the correct signs to match
	     actual military usage.
	   */), new tzinfo("A", 1 * /* Alpha */60), new tzinfo("B", 2 * /* Bravo */60), new tzinfo("C", 3 * /* Charlie */60), new tzinfo("D", 4 * /* Delta */60), new tzinfo("E", 5 * /* Echo */60), new tzinfo("F", 6 * /* Foxtrot */60), new tzinfo("G", 7 * /* Golf */60), new tzinfo("H", 8 * /* Hotel */60), new tzinfo("I", 9 * /* India */60/* "J", Juliet is not used as a timezone, to indicate the observer's local
	     time */), new tzinfo("K", 10 * /* Kilo */60), new tzinfo("L", 11 * /* Lima */60), new tzinfo("M", 12 * /* Mike */60), new tzinfo("N", -1 * /* November */60), new tzinfo("O", -2 * /* Oscar */60), new tzinfo("P", -3 * /* Papa */60), new tzinfo("Q", -4 * /* Quebec */60), new tzinfo("R", -5 * /* Romeo */60), new tzinfo("S", -6 * /* Sierra */60), new tzinfo("T", -7 * /* Tango */60), new tzinfo("U", -8 * /* Uniform */60), new tzinfo("V", -9 * /* Victor */60), new tzinfo("W", -10 * /* Whiskey */60), new tzinfo("X", -11 * /* X-ray */60), new tzinfo("Y", -12 * /* Yankee */60), new tzinfo("Z", /* Zulu, zero meridian, a.k.a. UTC */0/* returns:
	   -1 no day
	   0 monday - 6 sunday
	*/)};
	public static  dict_do = new ();
	public static Curl_handler Curl_handler_dict = new Curl_handler(/* scheme */"DICT", /* setup_connection */0, /* do_it */dict_do, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */2628, /* protocol */CURLPROTO_DICT, 0 | (1 << /* flags */6));
	public static errmsg[] errmsgs = new errmsg[]{new errmsg(0, "Undefined error code"), new errmsg(1, "File not found"), new errmsg(2, "Access violation"), new errmsg(3, "Disk full or allocation exceeded"), new errmsg(4, "Illegal TFTP operation"), new errmsg(5, "Unknown transfer ID"), new errmsg(6, "File already exists"), new errmsg(7, "No such user"), new errmsg(-1, 0)};
	public static formats[] formata = new formats[]{new formats("netascii", 1), new formats("octet", 0), new formats(((Object)0), 0)};
	public static bf[] bfs = new bf();
	public static int nextone;
	public static int current;
	public static int newline = /* index of buffer in use *//* control flags for crlf conversions *//* fillbuf: in middle of newline expansion */0;
	public static int prevchar = -/* putbuf: previous char (cr check) */1;
	public static tftphdr_storage_t ackbuf = new tftphdr_storage_t();
	public static srvr_sockaddr_union_t from = new srvr_sockaddr_union_t();
	public static  fromlen = new ();
	public static  peer = CURL_SOCKET_BAD;
	public static int maxtimeout = 5 * 5;
	public static byte pidname = ".tftpd.pid";
	public static int wrotepidfile = 0/* do-nothing macro replacement for systems which lack siginterrupt() */;
	public static tftphdr rw_init = new tftphdr();
	public static tftphdr w_init = new tftphdr();
	public static tftphdr r_init = new tftphdr();
	public static Object read_ahead;
	public static ssize_t write_behind = new ssize_t();
	public static int synchnet;
	public static int do_tftp;
	public static int validate_access;
	public static Object sendtftp;
	public static Object recvtftp;
	public static Object nak;
	public static Object exit_signal_handler;
	public static Object install_signal_handlers;
	public static Object restore_signal_handlers;
	public static byte[] teststring = new byte[]{(byte)'T', (byte)'h', (byte)'i', (byte)'s', (byte)'\0', (byte)' ', (byte)'i', (byte)'s', (byte)' ', (byte)'t', (byte)'e', (byte)'s', (byte)'t', /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* ASCII representation with escape sequences for non-ASCII platforms */(byte)' ', (byte)'b', (byte)'i', (byte)'n', (byte)'a', (byte)'r', (byte)'y', (byte)' ', (byte)'d', (byte)'a', (byte)'t', (byte)'a', (byte)' ', (byte)'w', (byte)'i', (byte)'t', (byte)'h', (byte)' ', (byte)'a', (byte)'n', (byte)' ', (byte)'e', (byte)'m', (byte)'b', (byte)'e', (byte)'d', (byte)'d', (byte)'e', (byte)'d', (byte)' ', (byte)'N', (byte)'U', (byte)'L'};
	public static byte tool_basename;
	public static int Curl_fnmatch;
	public static Object _state;
	public static  ftp_sendquote = new ();
	public static  ftp_quit = new ();
	public static  ftp_parse_url_path = new ();
	public static  ftp_regular_transfer = new ();
	public static Object ftp_pasv_verbose;
	public static  ftp_state_prepare_transfer = new ();
	public static  ftp_state_mdtm = new ();
	public static  ftp_state_quote = new ();
	public static  ftp_nb_type = new ();
	public static int ftp_need_type;
	public static  ftp_do = new ();
	public static  ftp_done = new ();
	public static  ftp_connect = new ();
	public static  ftp_disconnect = new ();
	public static  ftp_do_more = new ();
	public static  ftp_multi_statemach = new ();
	public static int ftp_getsock;
	public static int ftp_domore_getsock;
	public static  ftp_doing = new ();
	public static  ftp_setup_connection = new ();
	public static  init_wc_data = new ();
	public static  wc_statemach = new ();
	public static Object wc_data_dtor;
	public static  ftp_state_retr = new ();
	public static  ftp_readresp = new ();
	public static  ftp_dophase_done = new ();
	public static int[] sinus = new int[]{5157, 5313, 5470, 5626, 5782, 5936, 6090, 6243, 6394, 6545, 6693, 6840, /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* 200 values generated by this perl code:
	
	   my $pi = 3.1415;
	   foreach my $i (1 .. 200) {
	     printf "%d, ", sin($i/200 * 2 * $pi) * 5000 + 5000;
	   }
	*/6985, 7128, 7269, 7408, 7545, 7679, 7810, 7938, 8064, 8187, 8306, 8422, 8535, 8644, 8750, 8852, 8950, 9045, 9135, 9221, 9303, 9381, 9454, 9524, 9588, 9648, 9704, 9755, 9801, 9842, 9879, 9911, 9938, 9960, 9977, 9990, 9997, 9999, 9997, 9990, 9977, 9960, 9938, 9911, 9879, 9842, 9801, 9755, 9704, 9648, 9588, 9524, 9455, 9381, 9303, 9221, 9135, 9045, 8950, 8852, 8750, 8645, 8535, 8422, 8306, 8187, 8064, 7939, 7810, 7679, 7545, 7409, 7270, 7129, 6986, 6841, 6694, 6545, 6395, 6243, 6091, 5937, 5782, 5627, 5470, 5314, 5157, 5000, 4843, 4686, 4529, 4373, 4218, 4063, 3909, 3757, 3605, 3455, 3306, 3159, 3014, 2871, 2730, 2591, 2455, 2321, 2190, 2061, 1935, 1813, 1693, 1577, 1464, 1355, 1249, 1147, 1049, 955, 864, 778, 696, 618, 545, 476, 411, 351, 295, 244, 198, 157, 120, 88, 61, 39, 22, 9, 2, 0, 2, 9, 22, 39, 61, 88, 120, 156, 198, 244, 295, 350, 410, 475, 544, 618, 695, 777, 864, 954, 1048, 1146, 1248, 1354, 1463, 1576, 1692, 1812, 1934, 2060, 2188, 2320, 2454, 2590, 2729, 2870, 3013, 3158, 3305, 3454, 3604, 3755, 3908, 4062, 4216, 4372, 4528, 4685, 4842, 4999};
	public static int Curl_digest_init_func;
	public static Object Curl_digest_update_func;
	public static Object Curl_digest_final_func;
	public static digest_context Curl_digest_init = new digest_context();
	public static int Curl_digest_update;
	public static int Curl_digest_final;
	public static int xferinfo_cb;
	public static bool progress_meter = new bool();
	public static Object progress_finalize;
	public static  all_xfers = new ();
	public static  getfiletime = new ();
	public static Object setfiletime;
	public static HANDLE Curl_thread_create = new HANDLE();
	public static Object Curl_thread_destroy;
	public static int Curl_thread_join;
	public static Object freednsentry;
	public static byte Curl_checkheaders;
	public static Object Curl_init_CONNECT;
	public static  Curl_pretransfer = new ();
	public static  Curl_posttransfer = new ();
	public static  Curl_follow = new ();
	public static  Curl_readwrite = new ();
	public static int Curl_single_getsock;
	public static  Curl_readrewind = new ();
	public static  Curl_fillreadbuffer = new ();
	public static  Curl_retry_request = new ();
	public static  Curl_meets_timecondition = new ();
	public static  Curl_get_upload_buffer = new ();
	public static  Curl_done_sending = new ();
	public static Object Curl_setup_transfer;
	public static int max_con = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Web crawler based on curl and libxml2.
	 * Copyright (C) 2018 Jeroen Ooms <jeroenooms@gmail.com>
	 * License: MIT
	 *
	 * To compile:
	 *   gcc crawler.c $(pkg-config --cflags --libs libxml-2.0 libcurl)
	 *
	 *//* <DESC>
	 * Web crawler based on curl and libxml2 to stress-test curl with
	 * hundreds of concurrent connections to various servers.
	 * </DESC>
	 *//* Parameters */200;
	public static int max_total = 20000;
	public static int max_requests = 500;
	public static int max_link_per_page = 5;
	public static int follow_relative_links = 0;
	public static byte start_page = "https://www.reuters.com";
	public static int pending_interrupt = 0;
	public static unsshort_st[] us_test = new unsshort_st();
	public static sigshort_st[] ss_test = new sigshort_st();
	public static unsint_st[] ui_test = new unsint_st();
	public static sigint_st[] si_test = new sigint_st();
	public static unslong_st[] ul_test = new unslong_st();
	public static siglong_st[] sl_test = new siglong_st();
	public static curloff_st[] co_test = new curloff_st();
	public static  Curl_getworkingpath = new ();
	public static  Curl_get_pathname = new ();
	public static  all_dltotal = 0;
	public static  all_ultotal = 0;
	public static  all_dlalready = 0;
	public static  all_ulalready = 0;
	public static int speedindex;
	public static bool indexwrapped = new bool();
	public static speedcount[] speedstore = new speedcount();
	public static byte decc$getenv;
	public static passwd decc$getpwuid = new passwd();
	public static passwd vms_passwd_cache = new passwd();
	public static Object GUSIwithInetSockets;
	public static Object GUSIwithLocalSockets;
	public static Object GUSIwithMTInetSockets;
	public static Object GUSIwithMTTcpSockets;
	public static Object GUSIwithMTUdpSockets;
	public static Object GUSIwithOTInetSockets;
	public static Object GUSIwithOTTcpSockets;
	public static Object GUSIwithOTUdpSockets;
	public static Object GUSIwithPPCSockets;
	public static Object GUSISetupFactories;
	public static Object GUSIwithNullSockets;
	public static Object GUSISetupDevices;
	public static testcase[] get_parts_list = new testcase[]{new testcase("file:/C:\\programs\\foo", "file | [11] | [12] | [13] | [14] | [15] | C:\\programs\\foo | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("file://C:\\programs\\foo", "file | [11] | [12] | [13] | [14] | [15] | C:\\programs\\foo | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("file:///C:\\programs\\foo", "file | [11] | [12] | [13] | [14] | [15] | C:\\programs\\foo | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com/color/#green?no-black", "https | [11] | [12] | [13] | example.com | [15] | /color/ | [16] | green?no-black", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com/color/#green#no-black", "https | [11] | [12] | [13] | example.com | [15] | /color/ | [16] | green#no-black", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com/color/?green#no-black", "https | [11] | [12] | [13] | example.com | [15] | /color/ | green | no-black", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com/#color/?green#no-black", "https | [11] | [12] | [13] | example.com | [15] | / | [16] | color/?green#no-black", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.#com/color/?green#no-black", "https | [11] | [12] | [13] | example. | [15] | / | [16] | com/color/?green#no-black", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://[ab.be:1]/x", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new testcase("http://[ab.be]/x", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new testcase("http://a:b@/x", /* URL without host name */"", CURLU_DEFAULT_SCHEME, 0, CURLUE_NO_HOST), new testcase("boing:80", "https | [11] | [12] | [13] | boing | 80 | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://[fd00:a41::50]:8080", "http | [11] | [12] | [13] | [fd00:a41::50] | 8080 | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://[fd00:a41::50]/", "http | [11] | [12] | [13] | [fd00:a41::50] | [15] | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://[fd00:a41::50]", "http | [11] | [12] | [13] | [fd00:a41::50] | [15] | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://[::1%252]:1234", "https | [11] | [12] | [13] | [::1] | 1234 | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase(/* here's "bad" zone id */"https://[fe80::20c:29ff:fe9c:409b%eth0]:1234", "https | [11] | [12] | [13] | [fe80::20c:29ff:fe9c:409b] | 1234 | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://127.0.0.1:443", "https | [11] | [12] | [13] | 127.0.0.1 | [15] | / | [16] | [17]", 0, CURLU_NO_DEFAULT_PORT, CURLUE_OK), new testcase("http://%3a:%3a@ex%0ample/%3f+?+%3f+%23#+%23%3f%g7", "http | : | : | [13] | [6] | [15] | /?+ |  ? # | +#?%g7", 0, CURLU_URLDECODE, CURLUE_OK), new testcase("http://%3a:%3a@ex%0ample/%3f?%3f%35#%35%3f%g7", "http | %3a | %3a | [13] | ex%0ample | [15] | /%3f | %3f%35 | %35%3f%g7", 0, 0, CURLUE_OK), new testcase("http://HO0_-st%41/", "http | [11] | [12] | [13] | HO0_-st%41 | [15] | / | [16] | [17]", 0, 0, CURLUE_OK), new testcase("file://hello.html", "", 0, 0, CURLUE_MALFORMED_INPUT), new testcase("http://HO0_-st/", "http | [11] | [12] | [13] | HO0_-st | [15] | / | [16] | [17]", 0, 0, CURLUE_OK), new testcase("imap://user:pass;option@server/path", "imap | user | pass | option | server | [15] | /path | [16] | [17]", 0, 0, CURLUE_OK), new testcase("http://user:pass;option@server/path", "http | user | pass;option | [13] | server | [15] | /path | [16] | [17]", 0, 0, CURLUE_OK), new testcase("file:/hello.html", "file | [11] | [12] | [13] | [14] | [15] | /hello.html | [16] | [17]", 0, 0, CURLUE_OK), new testcase("file://127.0.0.1/hello.html", "file | [11] | [12] | [13] | [14] | [15] | /hello.html | [16] | [17]", 0, 0, CURLUE_OK), new testcase("file:////hello.html", "file | [11] | [12] | [13] | [14] | [15] | //hello.html | [16] | [17]", 0, 0, CURLUE_OK), new testcase("file:///hello.html", "file | [11] | [12] | [13] | [14] | [15] | /hello.html | [16] | [17]", 0, 0, CURLUE_OK), new testcase("https://127.0.0.1", "https | [11] | [12] | [13] | 127.0.0.1 | 443 | / | [16] | [17]", 0, CURLU_DEFAULT_PORT, CURLUE_OK), new testcase("https://127.0.0.1", "https | [11] | [12] | [13] | 127.0.0.1 | [15] | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://[::1]:1234", "https | [11] | [12] | [13] | [::1] | 1234 | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://127abc.com", "https | [11] | [12] | [13] | 127abc.com | [15] | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https:// example.com?check", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new testcase("https://e x a m p l e.com?check", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new testcase("https://example.com?check", "https | [11] | [12] | [13] | example.com | [15] | / | check | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com:65536", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_BAD_PORT_NUMBER), new testcase("https://example.com:0#moo", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_BAD_PORT_NUMBER), new testcase("https://example.com:01#moo", "https | [11] | [12] | [13] | example.com | 1 | / | [16] | moo", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://example.com:1#moo", "https | [11] | [12] | [13] | example.com | 1 | / | [16] | moo", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com#moo", "http | [11] | [12] | [13] | example.com | [15] | / | [16] | moo", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com", "http | [11] | [12] | [13] | example.com | [15] | / | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com/path/html", "http | [11] | [12] | [13] | example.com | [15] | /path/html | [16] | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com/path/html?query=name", "http | [11] | [12] | [13] | example.com | [15] | /path/html | query=name | [17]", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com/path/html?query=name#anchor", "http | [11] | [12] | [13] | example.com | [15] | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://example.com:1234/path/html?query=name#anchor", "http | [11] | [12] | [13] | example.com | 1234 | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http:///user:password@example.com:1234/path/html?query=name#anchor", "http | user | password | [13] | example.com | 1234 | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("https://user:password@example.com:1234/path/html?query=name#anchor", "https | user | password | [13] | example.com | 1234 | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http://user:password@example.com:1234/path/html?query=name#anchor", "http | user | password | [13] | example.com | 1234 | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http:/user:password@example.com:1234/path/html?query=name#anchor", "http | user | password | [13] | example.com | 1234 | /path/html | query=name | anchor", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new testcase("http:////user:password@example.com:1234/path/html?query=name#anchor", "", CURLU_DEFAULT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new testcase(((Object)0), ((Object)0), 0, 0, CURLUE_OK)};
	public static urltestcase[] get_url_list = new urltestcase[]{new urltestcase(/* 40 bytes scheme is the max allowed */"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA://hostname/path", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa://hostname/path", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_OK), new urltestcase(/* 41 bytes scheme is not allowed */"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA://hostname/path", "", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new urltestcase("https://[fe80::20c:29ff:fe9c:409b%]:1234", "", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase("https://[fe80::20c:29ff:fe9c:409b%25]:1234", "https://[fe80::20c:29ff:fe9c:409b%2525]:1234/", 0, 0, CURLUE_OK), new urltestcase("https://[fe80::20c:29ff:fe9c:409b%eth0]:1234", "https://[fe80::20c:29ff:fe9c:409b%25eth0]:1234/", 0, 0, CURLUE_OK), new urltestcase("https://[::%25fakeit]/moo", "https://[::%25fakeit]/moo", 0, 0, CURLUE_OK), new urltestcase("smtp.example.com/path/html", "smtp://smtp.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("https.example.com/path/html", "http://https.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("dict.example.com/path/html", "dict://dict.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("pop3.example.com/path/html", "pop3://pop3.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("ldap.example.com/path/html", "ldap://ldap.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("imap.example.com/path/html", "imap://imap.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("ftp.example.com/path/html", "ftp://ftp.example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("example.com/path/html", "http://example.com/path/html", CURLU_GUESS_SCHEME, 0, CURLUE_OK), new urltestcase("HTTP://test/", "http://test/", 0, 0, CURLUE_OK), new urltestcase("http://HO0_-st..~./", "http://HO0_-st..~./", 0, 0, CURLUE_OK), new urltestcase("http:/@example.com: 123/", "", 0, 0, CURLUE_BAD_PORT_NUMBER), new urltestcase("http:/@example.com:123 /", "", 0, 0, CURLUE_BAD_PORT_NUMBER), new urltestcase("http:/@example.com:123a/", "", 0, 0, CURLUE_BAD_PORT_NUMBER), new urltestcase("http://host/file\r", "", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase("http://host/file\n\x03", "", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase("htt\x02://host/file", "", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new urltestcase(" http://host/file", "", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase(/* here the password ends at the semicolon and options is 'word' */"imap://user:pass;word@host/file", "imap://user:pass;word@host/file", 0, 0, CURLUE_OK), new urltestcase(/* here the password has the semicolon */"http://user:pass;word@host/file", "http://user:pass;word@host/file", 0, 0, CURLUE_OK), new urltestcase("file:///file.txt#moo", "file:///file.txt#moo", 0, 0, CURLUE_OK), new urltestcase("file:////file.txt", "file:////file.txt", 0, 0, CURLUE_OK), new urltestcase("file:///file.txt", "file:///file.txt", 0, 0, CURLUE_OK), new urltestcase("file:./", "file://", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase("http://example.com/hello/../here", "http://example.com/hello/../here", CURLU_PATH_AS_IS, 0, CURLUE_OK), new urltestcase("http://example.com/hello/../here", "http://example.com/here", 0, 0, CURLUE_OK), new urltestcase("http://example.com:80", "http://example.com/", 0, CURLU_NO_DEFAULT_PORT, CURLUE_OK), new urltestcase("tp://example.com/path/html", "", 0, 0, CURLUE_UNSUPPORTED_SCHEME), new urltestcase("http://hello:fool@example.com", "", CURLU_DISALLOW_USER, 0, CURLUE_USER_NOT_ALLOWED), new urltestcase("http:/@example.com:123", "http://example.com:123/", 0, 0, CURLUE_OK), new urltestcase("http:/:password@example.com", "http://:password@example.com/", 0, 0, CURLUE_OK), new urltestcase("http://user@example.com?#", "http://user@example.com/", 0, 0, CURLUE_OK), new urltestcase("http://user@example.com?", "http://user@example.com/", 0, 0, CURLUE_OK), new urltestcase("http://user@example.com#anchor", "http://user@example.com/#anchor", 0, 0, CURLUE_OK), new urltestcase("example.com/path/html", "https://example.com/path/html", CURLU_DEFAULT_SCHEME, 0, CURLUE_OK), new urltestcase("example.com/path/html", "", 0, 0, CURLUE_MALFORMED_INPUT), new urltestcase("http://user:password@example.com:1234/path/html?query=name#anchor", "http://user:password@example.com:1234/path/html?query=name#anchor", 0, 0, CURLUE_OK), new urltestcase("http://example.com:1234/path/html?query=name#anchor", "http://example.com:1234/path/html?query=name#anchor", 0, 0, CURLUE_OK), new urltestcase("http://example.com/path/html?query=name#anchor", "http://example.com/path/html?query=name#anchor", 0, 0, CURLUE_OK), new urltestcase("http://example.com/path/html?query=name", "http://example.com/path/html?query=name", 0, 0, CURLUE_OK), new urltestcase("http://example.com/path/html", "http://example.com/path/html", 0, 0, CURLUE_OK), new urltestcase("tp://example.com/path/html", "tp://example.com/path/html", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_OK), new urltestcase("custom-scheme://host?expected=test-good", "custom-scheme://host/?expected=test-good", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_OK), new urltestcase("custom-scheme://?expected=test-bad", "", CURLU_NON_SUPPORT_SCHEME, 0, CURLUE_MALFORMED_INPUT), new urltestcase("custom-scheme://?expected=test-new-good", "custom-scheme:///?expected=test-new-good", CURLU_NON_SUPPORT_SCHEME | CURLU_NO_AUTHORITY, 0, CURLUE_OK), new urltestcase("custom-scheme://host?expected=test-still-good", "custom-scheme://host/?expected=test-still-good", CURLU_NON_SUPPORT_SCHEME | CURLU_NO_AUTHORITY, 0, CURLUE_OK), new urltestcase(((Object)0), ((Object)0), 0, 0, 0)};
	public static setcase[] set_parts_list = new setcase[]{new setcase("https://example.com/", /* Set a 41 bytes scheme. That's too long so the old scheme remains set. */"scheme=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc,", "https://example.com/", 0, CURLU_NON_SUPPORT_SCHEME, CURLUE_OK, CURLUE_MALFORMED_INPUT), new setcase("https://example.com/", /* set a 40 bytes scheme */"scheme=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb://example.com/", 0, CURLU_NON_SUPPORT_SCHEME, CURLUE_OK, CURLUE_OK), new setcase("https://[::1%25fake]:1234/", "zoneid=NULL,", "https://[::1]:1234/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("https://host:1234/", "port=NULL,", "https://host/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("https://host:1234/", "port=\"\",", "https://host:1234/", 0, 0, CURLUE_OK, CURLUE_BAD_PORT_NUMBER), new setcase("https://host:1234/", "port=56 78,", "https://host:1234/", 0, 0, CURLUE_OK, CURLUE_MALFORMED_INPUT), new setcase("https://host:1234/", "port=0,", "https://host:1234/", 0, 0, CURLUE_OK, CURLUE_BAD_PORT_NUMBER), new setcase("https://host:1234/", "port=65535,", "https://host:65535/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("https://host:1234/", "port=65536,", "https://host:1234/", 0, 0, CURLUE_OK, CURLUE_BAD_PORT_NUMBER), new setcase("https://host/", "path=%4A%4B%4C,", "https://host/%4a%4b%4c", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("https://host/mooo?q#f", "path=NULL,query=NULL,fragment=NULL,", "https://host/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("https://user:secret@host/", "user=NULL,password=NULL,", "https://host/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase(((Object)0), "scheme=https,user=   @:,host=foobar,", "https://%20%20%20%40%3a@foobar/", 0, CURLU_URLENCODE, CURLUE_OK, CURLUE_OK), new setcase(((Object)0), "scheme=https,host=  ,path= ,user= ,password= ,query= ,fragment= ,", "https://%20:%20@%20%20/%20?+#%20", 0, CURLU_URLENCODE, CURLUE_OK, CURLUE_OK), new setcase(((Object)0), "scheme=https,host=foobar,path=/this /path /is /here,", "https://foobar/this%20/path%20/is%20/here", 0, CURLU_URLENCODE, CURLUE_OK, CURLUE_OK), new setcase(((Object)0), "scheme=https,host=foobar,path=\xc3\xa4\xc3\xb6\xc3\xbc,", "https://foobar/%c3%a4%c3%b6%c3%bc", 0, CURLU_URLENCODE, CURLUE_OK, CURLUE_OK), new setcase("imap://user:secret;opt@host/", "options=updated,scheme=imaps,password=p4ssw0rd,", "imaps://user:p4ssw0rd;updated@host/", 0, 0, CURLUE_NO_HOST, CURLUE_OK), new setcase("imap://user:secret;optit@host/", "scheme=https,", "https://user:secret@host/", 0, 0, CURLUE_NO_HOST, CURLUE_OK), new setcase("file:///file#anchor", "scheme=https,host=example,", "https://example/file#anchor", 0, 0, CURLUE_NO_HOST, CURLUE_OK), new setcase(((Object)/* start fresh! */0), "scheme=file,host=127.0.0.1,path=/no,user=anonymous,", "file:///no", 0, 0, CURLUE_OK, CURLUE_OK), new setcase(((Object)/* start fresh! */0), "scheme=ftp,host=127.0.0.1,path=/no,user=anonymous,", "ftp://anonymous@127.0.0.1/no", 0, 0, CURLUE_OK, CURLUE_OK), new setcase(((Object)/* start fresh! */0), "scheme=https,host=example.com,", "https://example.com/", 0, CURLU_NON_SUPPORT_SCHEME, CURLUE_OK, CURLUE_OK), new setcase("http://user:foo@example.com/path?query#frag", "fragment=changed,", "http://user:foo@example.com/path?query#changed", 0, CURLU_NON_SUPPORT_SCHEME, CURLUE_OK, CURLUE_OK), new setcase("http://example.com/", /* not accepted */"scheme=foo,", "http://example.com/", 0, 0, CURLUE_OK, CURLUE_UNSUPPORTED_SCHEME), new setcase("http://example.com/", "scheme=https,path=/hello,fragment=snippet,", "https://example.com/hello#snippet", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("http://example.com:80", "user=foo,port=1922,", "http://foo@example.com:1922/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("http://example.com:80", "user=foo,password=bar,", "http://foo:bar@example.com:80/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("http://example.com:80", "user=foo,", "http://foo@example.com:80/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("http://example.com", "host=www.example.com,", "http://www.example.com/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("http://example.com:80", "scheme=ftp,", "ftp://example.com:80/", 0, 0, CURLUE_OK, CURLUE_OK), new setcase("custom-scheme://host", "host=\"\",", "custom-scheme://host/", CURLU_NON_SUPPORT_SCHEME, CURLU_NON_SUPPORT_SCHEME, CURLUE_OK, CURLUE_MALFORMED_INPUT), new setcase("custom-scheme://host", "host=\"\",", "custom-scheme:///", CURLU_NON_SUPPORT_SCHEME, CURLU_NON_SUPPORT_SCHEME | CURLU_NO_AUTHORITY, CURLUE_OK, CURLUE_OK), new setcase(((Object)0), ((Object)0), ((Object)0), 0, 0, 0, 0)};
	public static redircase[] set_url_list = new redircase[]{new redircase("file://localhost/path?query#frag", "foo#another", "file:///foo#another", 0, 0, 0), new redircase("http://example.com/path?query#frag", "https://two.example.com/bradnew", "https://two.example.com/bradnew", 0, 0, 0), new redircase("http://example.com/path?query#frag", "../../newpage#foo", "http://example.com/newpage#foo", 0, 0, 0), new redircase("http://user:foo@example.com/path?query#frag", "../../newpage", "http://user:foo@example.com/newpage", 0, 0, 0), new redircase("http://user:foo@example.com/path?query#frag", "../newpage", "http://user:foo@example.com/newpage", 0, 0, 0), new redircase(((Object)0), ((Object)0), ((Object)0), 0, 0, 0)};
	public static querycase[] append_list = new querycase[]{new querycase("HTTP://test/?s", "name=joe\x02", "http://test/?s&name=joe%02", 0, CURLU_URLENCODE, CURLUE_OK), new querycase("HTTP://test/?size=2#f", "name=joe=", "http://test/?size=2&name=joe%3d#f", 0, CURLU_URLENCODE, CURLUE_OK), new querycase("HTTP://test/?size=2#f", "name=joe doe", "http://test/?size=2&name=joe+doe#f", 0, CURLU_URLENCODE, CURLUE_OK), new querycase("HTTP://test/", "name=joe", "http://test/?name=joe", 0, 0, CURLUE_OK), new querycase("HTTP://test/?size=2", "name=joe", "http://test/?size=2&name=joe", 0, 0, CURLUE_OK), new querycase("HTTP://test/?size=2&", "name=joe", "http://test/?size=2&name=joe", 0, 0, CURLUE_OK), new querycase("HTTP://test/?size=2#f", "name=joe", "http://test/?size=2&name=joe#f", 0, 0, CURLUE_OK), new querycase(((Object)0), ((Object)0), ((Object)0), 0, 0, 0)};
	public static Object clean_getout;
	public static bool output_expected = new bool();
	public static bool stdin_upload = new bool();
	public static byte add_file_name_to_url;
	public static  get_url_file_name = new ();
	public static slist_wc slist_wc_append = new slist_wc();
	public static Object slist_wc_free_all;
	public static Object timer_cb;
	public static int g_should_exit_ = 0;
	public static int unitfail;
	public static int decc$feature_get_index;
	public static int decc$feature_set_value;
	public static int SYS$TRNLNM;
	public static int SYS$CRELNM;
	public static Object iniarray = {/* Set our contribution to the LIB$INITIALIZE array */set_features};
	public static int LIB$INITIALIZE;
	public static int lib_init_ref = (int)LIB$INITIALIZE;
	public static Object tool_go_sleep;
	public static Object Curl_memdup;
	public static Object Curl_saferealloc;
	public static byte[] srchead = new byte[]{"/********* Sample code generated by the curl command line tool **********", " * All curl_easy_setopt() options are documented at:", " * https://curl.haxx.se/libcurl/c/curl_easy_setopt.html", " ************************************************************************/", "#include <curl/curl.h>", "", "int main(int argc, char *argv[])", "{", "  CURLcode ret;", "  CURL *hnd;", ((Object)0/* easysrc_decl declarations come here */)};
	public static byte[] srchard = new byte[]{/* easysrc_data initialisations come here *//* easysrc_code statements come here */"/* Here is a list of options the curl code used that cannot get generated", "   as source easily. You may select to either not use them or implement", "   them yourself.", "", ((Object)0)};
	public static byte[] srcend = new byte[]{"", "  return (int)ret;", "}", "/**** End of sample code ****/", ((Object)0)};
	public static io_service io_service = new io_service();
	public static deadline_timer timer = ;
	public static map socket_map = new map();
	public static  curlinfo = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/((Object)/* use our own printf() functions *//* keep this as LAST include *//* global variable definitions, for libcurl run-time info */0);
	public static long built_in_protos = 0/*
	 * libcurl_info_init: retrieves run-time information about libcurl,
	 * setting a global pointer 'curlinfo' to libcurl's run-time info
	 * struct, and a global bit pattern 'built_in_protos' composed of
	 * CURLPROTO_* bits indicating which protocols are actually built
	 * into library being used.
	 */;
	public static Object tool_help;
	public static Object tool_list_engines;
	public static Object tool_version_info;
	public static Object hugehelp;
	public static int Curl_resolver_global_init;
	public static Object Curl_resolver_global_cleanup;
	public static  Curl_resolver_init = new ();
	public static Object Curl_resolver_cleanup;
	public static  Curl_resolver_duphandle = new ();
	public static Object Curl_resolver_cancel;
	public static Object Curl_resolver_kill;
	public static int Curl_resolver_getsock;
	public static  Curl_resolver_is_resolved = new ();
	public static  Curl_resolver_wait_resolv = new ();
	public static Curl_addrinfo Curl_resolver_getaddrinfo = new Curl_addrinfo();
	public static SANITIZEcode truncate_dryrun = new SANITIZEcode();
	public static SANITIZEcode rename_if_reserved_dos_device_name = new SANITIZEcode();
	public static Object Curl_des_set_odd_parity;
	public static  Curl_mime_add_header = new ();
	public static Object Curl_mime_initpart;
	public static Object Curl_mime_cleanpart;
	public static  Curl_mime_duppart = new ();
	public static  Curl_mime_set_subparts = new ();
	public static  Curl_mime_prepare_headers = new ();
	public static  Curl_mime_size = new ();
	public static size_t Curl_mime_read = new size_t();
	public static  Curl_mime_rewind = new ();
	public static byte Curl_mime_contenttype;
	public static long chunk_bgn;
	public static long chunk_end;
	public static  hnd = new ();
	public static  Curl_share_lock = new ();
	public static  Curl_share_unlock = new ();
	public static int fwrite_xattr;
	public static int gethostname;
	public static  get_libcurl_info = new ();
	public static Object ourWriteOut;
	public static size_t tool_header_cb = new size_t();
	public static int[] counter = new int[/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2012 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/3];
	public static [] sockets = new ();
	public static int res = 0;
	public static byte[] input = new byte[4096];
	public static byte[] result = new byte[4096];
	public static int debugf_cb;
	public static  Curl_proxyCONNECT = new ();
	public static  Curl_proxy_connect = new ();
	public static bool Curl_connect_complete = new bool();
	public static bool Curl_connect_ongoing = new bool();
	public static Object Curl_connect_free;
	public static bool verbose = 0;
	public static bool bind_only = 0;
	public static int connectport = /* if non-zero, we activate this mode */0;
	public static int curl_mprintf;
	public static int curl_mfprintf;
	public static int curl_msprintf;
	public static int curl_msnprintf;
	public static int curl_mvprintf;
	public static int curl_mvfprintf;
	public static int curl_mvsprintf;
	public static int curl_mvsnprintf;
	public static byte curl_maprintf;
	public static byte curl_mvaprintf;
	public static byte[] errors = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2018 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* The last 3 #include files should be in this order *//* bytes */"", "Bad label", "Out of range", "Label loop", "Too small", "Out of memory", "RDATA length", "Malformat", "Bad RCODE", "Unexpected TYPE", "Unexpected CLASS", "No content", "Bad ID"};
	public static size_t fread = new size_t();
	public static size_t fwrite = new size_t();
	public static int strcasecmp;
	public static int strncasecmp;
	public static pthread_mutex_t lockarray = new pthread_mutex_t();
	public static SANITIZEcode sanitize_file_name = new SANITIZEcode();
	public static  FindWin32CACert = new ();
	public static curl_slist GetLoadedModulePaths = new curl_slist();
	public static Curl_tree Curl_splay = new Curl_tree();
	public static Curl_tree Curl_splayinsert = new Curl_tree();
	public static Curl_tree Curl_splaygetbest = new Curl_tree();
	public static int Curl_splayremovebyaddr;
	public static byte[] testData = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/".abc\0xyz";
	public static off_t testDataSize =  - 1;
	public static int tool_debug_cb;
	public static  Missing_definition_of_macro_sread = new ();
	public static  Missing_definition_of_macro_swrite = new ();
	public static  file_do = new ();
	public static  file_done = new ();
	public static  file_connect = new ();
	public static  file_disconnect = new ();
	public static  file_setup_connection = new ();
	public static byte parse_filename;
	public static Curl_addrinfo Curl_addrinfo = new Curl_addrinfo();
	public static Object Curl_freeaddrinfo;
	public static Curl_addrinfo Curl_he2ai = new Curl_addrinfo();
	public static Curl_addrinfo Curl_ip2addr = new Curl_addrinfo();
	public static Curl_addrinfo Curl_str2addr = new Curl_addrinfo();
	public static Object Curl_md4it;
	public static  Curl_win32_init = new ();
	public static Object Curl_win32_cleanup;
	public static int IF_NAMETOINDEX_FN;
	public static bool Curl_verify_windows_version = new bool();
	public static HMODULE Curl_load_library = new HMODULE();
	public static int Curl_blockread_all;
	public static  Curl_SOCKS4 = new ();
	public static  Curl_SOCKS5 = new ();
	public static  Curl_rand = new ();
	public static  Curl_rand_hex = new ();
	public static Object destroy_async_data;
	public static bool init_resolve_thread = new bool();
	public static byte[] curlx_usage = new byte[]{/*
	  curlx.c  Authors: Peter Sylvester, Jean-Paul Merlin
	
	  This is a little program to demonstrate the usage of
	
	  - an ssl initialisation callback setting a user key and trustbases
	  coming from a pkcs12 file
	  - using an ssl application callback to find a URI in the
	  certificate presented during ssl session establishment.
	
	*//* <DESC>
	 * demonstrates use of SSL context callback, requires OpenSSL
	 * </DESC>
	 *//*
	 * Copyright (c) 2003 The OpenEvidence Project.  All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions, the following disclaimer,
	 *    and the original OpenSSL and SSLeay Licences below.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions, the following disclaimer
	 *    and the original OpenSSL and SSLeay Licences below in
	 *    the documentation and/or other materials provided with the
	 *    distribution.
	 *
	 * 3. All advertising materials mentioning features or use of this
	 *    software must display the following acknowledgments:
	 *    "This product includes software developed by the Openevidence Project
	 *    for use in the OpenEvidence Toolkit. (http://www.openevidence.org/)"
	 *    This product includes software developed by the OpenSSL Project
	 *    for use in the OpenSSL Toolkit (https://www.openssl.org/)"
	 *    This product includes cryptographic software written by Eric Young
	 *    (eay@cryptsoft.com).  This product includes software written by Tim
	 *    Hudson (tjh@cryptsoft.com)."
	 *
	 * 4. The names "OpenEvidence Toolkit" and "OpenEvidence Project" must not be
	 *    used to endorse or promote products derived from this software without
	 *    prior written permission. For written permission, please contact
	 *    openevidence-core@openevidence.org.
	 *
	 * 5. Products derived from this software may not be called "OpenEvidence"
	 *    nor may "OpenEvidence" appear in their names without prior written
	 *    permission of the OpenEvidence Project.
	 *
	 * 6. Redistributions of any form whatsoever must retain the following
	 *    acknowledgments:
	 *    "This product includes software developed by the OpenEvidence Project
	 *    for use in the OpenEvidence Toolkit (http://www.openevidence.org/)
	 *    This product includes software developed by the OpenSSL Project
	 *    for use in the OpenSSL Toolkit (https://www.openssl.org/)"
	 *    This product includes cryptographic software written by Eric Young
	 *    (eay@cryptsoft.com).  This product includes software written by Tim
	 *    Hudson (tjh@cryptsoft.com)."
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE OpenEvidence PROJECT ``AS IS'' AND ANY
	 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenEvidence PROJECT OR
	 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
	 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 * ====================================================================
	 *
	 * This product includes software developed by the OpenSSL Project
	 * for use in the OpenSSL Toolkit (https://www.openssl.org/)
	 * This product includes cryptographic software written by Eric Young
	 * (eay@cryptsoft.com).  This product includes software written by Tim
	 * Hudson (tjh@cryptsoft.com).
	 *
	 */"usage: curlx args\n", " -p12 arg         - tia  file ", " -envpass arg     - environment variable which content the tia private key password", " -out arg         - output file (response)- default stdout", " -in arg          - input file (request)- default stdin", " -connect arg     - URL of the server for the connection ex: www.openevidence.org", " -mimetype arg    - MIME type for data in ex : application/timestamp-query or application/dvcs -default application/timestamp-query", " -acceptmime arg  - MIME type acceptable for the response ex : application/timestamp-response or application/dvcs -default none", " -accesstype arg  - an Object identifier in an AIA/SIA method, e.g. AD_DVCS or ad_timestamping", ((Object)0/*
	
	./curlx -p12 psy.p12 -envpass XX -in request -verbose -accesstype AD_DVCS
	-mimetype application/dvcs -acceptmime application/dvcs -out response
	
	*/)};
	public static int libtest_debug_cb;
	public static size_t WriteOutput = new size_t();
	public static size_t WriteHeader = new size_t();
	public static long realHeaderSize = 0;
	public static byte getpass_r;
	public static  Bar = new ();
	public static Object curl_wildcard_dtor;
	public static  Curl_wildcard_init = new ();
	public static Object Curl_wildcard_dtor;
	public static HANDLE WSOCK2_EVENT = new HANDLE();
	public static FARPROC WSOCK2_FUNC = new FARPROC();
	public static  check_wsock2 = new ();
	public static  telrcv = new ();
	public static Object printoption;
	public static Object negotiate;
	public static Object send_negotiation;
	public static Object set_local_option;
	public static Object set_remote_option;
	public static Object printsub;
	public static Object suboption;
	public static Object sendsuboption;
	public static  telnet_do = new ();
	public static  telnet_done = new ();
	public static  send_telnet_data = new ();
	public static int Curl_gethostname;
	public static bool use_gopher = 0;
	public static bool is_proxy = 0;
	public static [] all_sockets = new ();
	public static size_t num_sockets = 0;
	public static byte end_of_headers = "\r\n\r\n";
	public static byte doc404 = /* send back this on 404 file not found */"HTTP/1.1 404 Not Found\r\nServer: curl test suite HTTP server/0.1\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML><HEAD>\n<TITLE>404 Not Found</TITLE>\n</HEAD><BODY>\n<H1>Not Found</H1>\nThe requested URL was not found on this server.\n<P><HR><ADDRESS>curl test suite HTTP server/0.1</ADDRESS>\n</BODY></HTML>\n"/* do-nothing macro replacement for systems which lack siginterrupt() */;
	public static int already_recv_zeroed_chunk = /* work around for handling trailing headers */0/* signal handler that will be triggered to indicate that the program
	  should finish its execution in a controlled manner as soon as possible.
	  The first time this is called it will set got_exit_signal to one and
	  store in exit_signal the signal that triggered its execution. */;
	public static size_t tool_write_cb = new size_t();
	public static bool tool_create_output_file = new bool();
	public static byte[] headers_text = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* <DESC>
	 * SMTP example showing how to send mime e-mails
	 * </DESC>
	 *//* This is a simple example showing how to send mime mail using libcurl's SMTP
	 * capabilities. For an example of using the multi interface please see
	 * smtp-multi.c.
	 *
	 * Note that this example requires libcurl 7.56.0 or above.
	 */"Date: Tue, 22 Aug 2017 14:08:43 +0100", "To: <addressee@example.net>", "From: <sender@example.org> (Example User)", "Cc: <info@example.org> (Another example User)", "Message-ID: <dcd7cb36-11db-487a-9f3a-e652a9458efd@rfcpedant.example.org>", "Subject: example sending a MIME-formatted message", ((Object)0)};
	public static byte[] inline_text = "This is the inline text message of the e-mail.\r\n\r\n  It could be a lot of lines that would be displayed in an e-mail\r\nviewer that is not able to handle HTML.\r\n";
	public static byte[] inline_html = "<html><body>\r\n<p>This is the inline <b>HTML</b> message of the e-mail.</p><br />\r\n<p>It could be a lot of HTML data that would be displayed by e-mail viewers able to handle HTML.</p></body></html>\r\n";
	public static byte unslashquote;
	public static byte my_get_line;
	
	
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2015, 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Test case converted from bug report #1318 by Petr Novak.
	 *
	 * Before the fix, this test program returned 52 (CURLE_GOT_NOTHING) instead
	 * of 42 (CURLE_ABORTED_BY_CALLBACK).
	 */
	public static int progressKiller(Object arg, double dltotal, double dlnow, double ultotal, double ulnow) {
		(Object)arg;
		(Object)dltotal;
		(Object)dlnow;
		(Object)ultotal;
		(Object)ulnow;
		ModernizedCProgram.curl_mprintf("PROGRESSFUNCTION called\n");
		return 1;
	}
	public static int test(Byte URL) {
		 curl = new ();
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMEOUT))), ((((long)7))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_NOSIGNAL))), ((((long)1))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROGRESSFUNCTION))), (((progressKiller))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROGRESSDATA))), (((((Object)0)))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_NOPROGRESS))), ((((long)0))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1513.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		 m = ((Object)0);
		(Object)URL;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1508.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1508.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.curl_mprintf("We are done\n");
		return res;
		byte[] a = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		 res = CURLE_OK;
		byte ptr = ((Object)0);
		int asize;
		int outlen = 0;
		byte raw;
		(Object)/* we don't use this */URL;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		asize = (int);
		ptr = ((Object)0).curl_easy_escape((byte)a, asize);
		ModernizedCProgram.curl_mprintf("%s\n", ptr);
		ModernizedCProgram.curl_free(ptr);
		ptr = ModernizedCProgram.curl_escape((byte)a, /* deprecated API */asize);
		ModernizedCProgram.curl_mprintf("%s\n", ptr);
		if (!ptr) {
			res = 126;
			;
		} 
		raw = ((Object)0).curl_easy_unescape(ptr, (int).strlen(ptr), outlen);
		ModernizedCProgram.curl_mprintf("outlen == %d\n", outlen);
		ModernizedCProgram.curl_mprintf("unescape == original? %s\n", .memcmp(raw, a, outlen) ? "no" : "YES");
		ModernizedCProgram.curl_free(raw);
		raw = ModernizedCProgram.curl_unescape(ptr, (int).strlen(/* deprecated API */ptr));
		if (!raw) {
			res = 126;
			;
		} 
		outlen = (int).strlen(raw);
		ModernizedCProgram.curl_mprintf("[old] outlen == %d\n", outlen);
		ModernizedCProgram.curl_mprintf("[old] unescape == original? %s\n", .memcmp(raw, a, outlen) ? "no" : "YES");
		ModernizedCProgram.curl_free(raw);
		ModernizedCProgram.curl_free(ptr);
		ptr = ((Object)0).curl_easy_escape((byte)a, -/* weird input length */1);
		ModernizedCProgram.curl_mprintf("escape -1 length: %s\n", ptr);
		outlen = /* weird input length *//* just a value */2017;
		ptr = ((Object)0).curl_easy_unescape((byte)"moahahaha", -1, outlen);
		ModernizedCProgram.curl_mprintf("unescape -1 length: %s %d\n", ptr, outlen);
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		curl_slist hhl = ((Object)/* http header list*/0);
		curl_slist phl = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		hhl = hhl.curl_slist_append("User-Agent: Http Agent");
		phl = phl.curl_slist_append("Proxy-User-Agent: Http Agent2");
		if (!hhl) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYHEADER), (phl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADEROPT), (CURLHEADER_SEPARATE))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYTYPE), (CURLPROXY_HTTP))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		hhl.curl_slist_free_all();
		phl.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 multi = ((Object)0);
		int res = 0;
		byte address = ModernizedCProgram.libtest_arg2;
		byte port = ModernizedCProgram.libtest_arg3;
		byte path = URL;
		byte[] dns_entry = new byte[256];
		int i;
		int count = 2;
		ModernizedCProgram.curl_msnprintf(dns_entry, , "testserver.example.com:%s:%s", port, address);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (i = 1; i <= count; i++) {
			byte[] target_url = new byte[256];
			ModernizedCProgram.curl_msnprintf(target_url, , "http://testserver.example.com:%s/%s%04d", port, path, i);
			res = ModernizedCProgram.do_one_request(multi, target_url, /* second request must succeed like the first one */dns_entry);
			if (res) {
				;
			} 
			if (i < count) {
				.Sleep(1 + 1 * 1000);
			} 
		}
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 res = 0;
		 curl = ((Object)0);
		long protocol = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1558.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1558.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1558.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("curl_easy_perform() returned %d (%s)\n", res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_PROTOCOL, protocol);
		if (res) {
			(_iob[2]).curl_mfprintf("curl_easy_getinfo() returned %d (%s)\n", res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		ModernizedCProgram.curl_mprintf("Protocol: %x\n", protocol);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		ModernizedCProgram.curl_global_cleanup();
		return /* return the final return code */res;
		int res = 0;
		 m = ((Object)0);
		/* for picking up messages with the transfer status */ msg = new ();
		/* how many messages are left */int msgs_left;
		int running = 0;
		int handlenum = 0;
		timeval last_handle_add = new timeval();
		if (ModernizedCProgram.parse_url_file(ModernizedCProgram.libtest_arg2) <= 0) {
			;
		} 
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		ModernizedCProgram.create_handles();
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_PIPELINING))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_MAX_HOST_CONNECTIONS))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_MAX_PIPELINE_LENGTH))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_PIPELINING_SITE_BL))), (((ModernizedCProgram.site_blacklist))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_PIPELINING_SERVER_BL))), (((ModernizedCProgram.server_blacklist))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		last_handle_add = timeval.tutil_tvnow();
		for (; ; ) {
			timeval interval = new timeval();
			timeval now = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			long timeout;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			if (handlenum < ModernizedCProgram.num_handles) {
				now = timeval.tutil_tvnow();
				if (now.tutil_tvdiff(last_handle_add) >= ModernizedCProgram.urltime[handlenum]) {
					(_iob[1]).curl_mfprintf("Adding handle %d\n", handlenum);
					ModernizedCProgram.setup_handle(URL, m, handlenum);
					last_handle_add = now;
					handlenum++;
				} 
			} 
			m.curl_multi_perform(running);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				msg = m.curl_multi_info_read(msgs_left);
				if (msg && msg.getMsg() == CURLMSG_DONE) {
					int i;
					for (i = 0; i < ModernizedCProgram.num_handles; /* Find out which handle this message is about */i++) {
						int found = (msg.getEasy_handle() == ModernizedCProgram.handles[i]);
						if (found) {
							break;
						} 
					}
					ModernizedCProgram.curl_mprintf("Handle %d Completed with status %d\n", i, msg.getData().getResult());
					ModernizedCProgram.curl_multi_remove_handle(m, ModernizedCProgram.handles[i]);
				} 
			} while (msg);
			if (handlenum == ModernizedCProgram.num_handles && !running) {
				break;
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			ModernizedCProgram.curl_multi_fdset(m, rd, wr, exc, maxfd);
			m.curl_multi_timeout(/* At this point, maxfd is guaranteed to be greater or equal than -1. */ModernizedCProgram.timeout);
			if (ModernizedCProgram.timeout < 0) {
				ModernizedCProgram.timeout = 1;
			} 
			interval.setTv_sec(ModernizedCProgram.timeout / 1000);
			interval.setTv_usec((ModernizedCProgram.timeout % 1000) * 1000);
			interval.setTv_sec(0);
			interval.setTv_usec(1000);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1900.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		/* undocumented cleanup sequence - type UB */m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.free_urls();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1551.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, URL);
			curl.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, -1024);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = curl.curl_easy_perform();
			(_iob[2]).curl_mfprintf("****************************** Do it again\n");
			res = curl.curl_easy_perform();
			curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res = 0;
		 curl = ((Object)0);
		FILE hd_src = ((Object)0);
		int hd;
		_stati64 file_info = new _stati64();
		 m = ((Object)0);
		ReadWriteSockets sockets = new ReadWriteSockets(new ReadWriteSockets(((Object)0), 0, 0), new ReadWriteSockets(((Object)0), 0, 0));
		timeval timeout = new timeval(-1, 0);
		int success = 0;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		if (!ModernizedCProgram.libtest_arg3) {
			(_iob[2]).curl_mfprintf("Usage: lib582 [url] [filename] [username]\n");
			return 118;
		} 
		hd_src = .fopen(ModernizedCProgram.libtest_arg2, "rb");
		if (((Object)0) == hd_src) {
			(_iob[2]).curl_mfprintf("fopen() failed with error: %d (%s)\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("Error opening file: (%s)\n", ModernizedCProgram.libtest_arg2);
			return 117;
		} 
		Object generated_file = (hd_src).get_file();
		hd = ._fstati64((generated_file), /* get the file size of the local file */file_info);
		if (hd == -1) {
			(_iob[2]).curl_mfprintf(/* can't open file, bail out */"fstat() failed with error: %d (%s)\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("ERROR: cannot open file (%s)\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 116;
		} 
		Object generatedSt_size = file_info.getSt_size();
		(_iob[2]).curl_mfprintf("Set to upload %d bytes\n", (int)generatedSt_size);
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			.fclose(hd_src);
			return res;
		} 
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_UPLOAD))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* enable uploading */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* specify target */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* go verbose */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READDATA))), (((hd_src))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* now specify which file to upload */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_USERPWD))), (((ModernizedCProgram.libtest_arg3))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_SSH_PUBLIC_KEYFILE))), ((("curl_client_key.pub"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_SSH_PRIVATE_KEYFILE))), ((("curl_client_key"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_SSL_VERIFYHOST))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_INFILESIZE_LARGE))), (((()generatedSt_size))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_SOCKETFUNCTION))), (((curlSocketCallback))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_SOCKETDATA))), (((sockets))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_TIMERFUNCTION))), (((curlTimerCallback))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_TIMERDATA))), (((timeout))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Sockets generatedRead = sockets.getRead();
		Sockets generatedWrite = sockets.getWrite();
		long generatedTv_sec = timeout.getTv_sec();
		while (!ModernizedCProgram.checkForCompletion(m, success)) {
			fd_set readSet = new fd_set();
			fd_set writeSet = new fd_set();
			 maxFd = 0;
			timeval tv = new timeval(10, 0);
			(((fd_set)(readSet)).setFd_count(0));
			(((fd_set)(writeSet)).setFd_count(0));
			ModernizedCProgram.updateFdSet(generatedRead, readSet, maxFd);
			ModernizedCProgram.updateFdSet(generatedWrite, writeSet, maxFd);
			if (generatedTv_sec != -1) {
				int usTimeout = timeout.getMicroSecondTimeout();
				tv.setTv_sec(usTimeout / 1000000);
				tv.setTv_usec(usTimeout % 1000000);
			}  else if (maxFd <= 0) {
				tv.setTv_sec(0);
				tv.setTv_usec(100000);
			} 
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper(((((int)maxFd))), (((readSet))), (((writeSet))), (((((Object)0)))), (((tv)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			ModernizedCProgram.checkFdSet(m, generatedRead, readSet, CURL_CSELECT_IN, /* Check the sockets for reading / writing */"read");
			ModernizedCProgram.checkFdSet(m, generatedWrite, writeSet, CURL_CSELECT_OUT, "write");
			if (generatedTv_sec != -1 && timeout.getMicroSecondTimeout() == 0) {
				ModernizedCProgram.notifyCurl(m, CURL_SOCKET_TIMEOUT, 0, /* Curl's timer has elapsed. */"timeout");
			} 
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib582.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		if (!success) {
			(_iob[2]).curl_mfprintf("Error uploading file.\n");
			res = 126;
		} 
		curl.curl_easy_cleanup();
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		.fclose(/* close the local file */hd_src);
		Object generatedSockets = generatedRead.getSockets();
		.free(generatedSockets);
		.free(generatedSockets);
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_CONNECT_ONLY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (!res/* we are connected, now get a HTTP document the raw way */) {
			byte request = "GET /556 HTTP/1.2\r\nHost: ninja\r\n\r\n";
			size_t iolen = 0;
			res = curl.curl_easy_send(request, .strlen(request), iolen);
			if (!res/* we assume that sending always work */) {
				do {
					byte[] buf = new byte[1024];
					res = curl.curl_easy_recv(ModernizedCProgram.buf, , /* busy-read like crazy */iolen);
					if (/* avoid ctl-10 dump */iolen) {
						if (!ModernizedCProgram.curlx_write(1, ModernizedCProgram.buf, /* send received stuff to stdout */iolen)) {
							break;
						} 
					} 
				} while ((res == CURLE_OK && iolen != 0) || (res == CURLE_AGAIN));
			} 
			if (iolen != 0) {
				res = 119;
			} 
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 easy = ((Object)0);
		 easy2 = ((Object)0);
		 mime = ((Object)0);
		 part = new ();
		curl_slist hdrs = ((Object)0);
		 result = new ();
		int res = 119;
		WriteThis pooh = new WriteThis();
		/*
		   * Check proper copy/release of mime post data bound to a duplicated
		   * easy handle.
		   */
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		easy = curl_easy.curl_easy_init();
		if ((res = (easy).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (easy).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (easy).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		pooh.setReadptr(/* Prepare the callback structure. */ModernizedCProgram.data);
		pooh.setSizeleft(().strlen(ModernizedCProgram.data));
		pooh.setFreecount(0);
		mime = /* Build the mime tree. */easy.curl_mime_init();
		part = ModernizedCProgram.curl_mime_addpart(mime);
		ModernizedCProgram.curl_mime_data(part, "hello", CURL_ZERO_TERMINATED);
		ModernizedCProgram.curl_mime_name(part, "greeting");
		ModernizedCProgram.curl_mime_type(part, "application/X-Greeting");
		ModernizedCProgram.curl_mime_encoder(part, "base64");
		hdrs = hdrs.curl_slist_append("X-Test-Number: 654");
		hdrs.curl_mime_headers(part, 1);
		part = ModernizedCProgram.curl_mime_addpart(mime);
		ModernizedCProgram.curl_mime_filedata(part, "log/file654.txt");
		part = ModernizedCProgram.curl_mime_addpart(mime);
		ModernizedCProgram.curl_mime_data_cb(part, (ModernizedCProgram.curl_off_t) - 1, read_callback, ((Object)0), free_callback, pooh);
		if ((res = (easy).curl_easy_setopt((CURLOPT_MIMEPOST), (mime))) != /* Bind mime data to its easy handle. */CURLE_OK) {
			;
		} 
		easy2 = /* Duplicate the handle. */easy.curl_easy_duphandle();
		if (!easy2) {
			(_iob[2]).curl_mfprintf("curl_easy_duphandle() failed\n");
			res = 119;
			;
		} 
		ModernizedCProgram.curl_mime_free(/* Now free the mime structure: it should unbind it from the first
		     easy handle. */mime);
		mime = ((Object)/* Already cleaned up. */0);
		result = /* Perform on the first handle: should not send any data. */easy.curl_easy_perform();
		if (result) {
			(_iob[2]).curl_mfprintf("curl_easy_perform(original) failed\n");
			res = (int)result;
			;
		} 
		result = /* Perform on the second handle: if the bound mime structure has not been
		     duplicated properly, it should cause a valgrind error. */easy2.curl_easy_perform();
		if (result) {
			(_iob[2]).curl_mfprintf("curl_easy_perform(duplicated) failed\n");
			res = (int)result;
			;
		} 
		/* Free the duplicated handle: it should call free_callback again.
		     If the mime copy was bad or not automatically released, valgrind
		     will signal it. */easy2.curl_easy_cleanup();
		easy2 = ((Object)/* Already cleaned up. */0);
		int generatedFreecount = pooh.getFreecount();
		if (generatedFreecount != 2) {
			(_iob[2]).curl_mfprintf("free_callback() called %d times instead of 2\n", generatedFreecount);
			res = 119;
			;
		} 
		easy2.curl_easy_cleanup();
		ModernizedCProgram.curl_mime_free(mime);
		ModernizedCProgram.curl_global_cleanup();
		return res;
		byte url_after;
		 curl = new ();
		 curl_code = new ();
		byte[] error_buffer = "";
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		curl.curl_easy_setopt(CURLOPT_URL, URL);
		curl.curl_easy_setopt(CURLOPT_ERRORBUFFER, error_buffer);
		curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		curl_code = curl.curl_easy_perform();
		if (!curl_code) {
			(_iob[2]).curl_mfprintf("failure expected, curl_easy_perform returned %ld: <%s>, <%s>\n", (long)curl_code, ModernizedCProgram.curl_easy_strerror(curl_code), error_buffer);
		} 
		if (!curl.curl_easy_getinfo(CURLINFO_EFFECTIVE_URL, /* print the used url */url_after)) {
			ModernizedCProgram.curl_mprintf("Effective URL: %s\n", url_after);
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 easy = ((Object)0);
		 multi = ((Object)0);
		int res = 0;
		int running;
		int msgs_left;
		 msg = new ();
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((easy))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* go verbose */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* specify target */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_CONNECT_ONLY))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((easy))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval interval = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			long timeout = -99;
			int maxfd = -99;
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 5 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_timeout((((ModernizedCProgram.timeout))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((ModernizedCProgram.timeout)))) < --1024) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() succeeded, but returned invalid timeout value (%ld)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (long)((((ModernizedCProgram.timeout)))));
						res = 115;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0/* At this point, timeout is guaranteed to be greater or equal than
			       -1. */);
			if (ModernizedCProgram.timeout != --1024) {
				int itimeout = (ModernizedCProgram.timeout > (long)2147483647) ? 2147483647 : (int)ModernizedCProgram.timeout;
				interval.setTv_sec(itimeout / 1000);
				interval.setTv_usec((itimeout % 1000) * 1000);
			} else {
					interval.setTv_sec(5 * 1000 / 1000 + 1);
					interval.setTv_usec(0);
			} 
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 5 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		msg = multi.curl_multi_info_read(msgs_left);
		if (msg) {
			res = msg.getData().getResult();
		} 
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_remove_handle((((multi))), (((easy))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_remove_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib597.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res;
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WILDCARDMATCH), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FNMATCH_FUNCTION), (new_fnmatch))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("curl_easy_perform() failed %d\n", res);
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("curl_easy_perform() failed %d\n", res);
			;
		} 
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 dupe = ((Object)0);
		long protocol;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0/* Test that protocol is properly initialized on curl_easy_init.
		  */);
		res = curl.curl_easy_getinfo(CURLINFO_PROTOCOL, protocol);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 44, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (protocol != 0) {
			(_iob[2]).curl_mfprintf("%s:%d protocol init failed; expected 0 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 49, protocol);
			res = CURLE_FAILED_INIT;
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 59, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_PROTOCOL, /* Test that a protocol is properly set after receiving an HTTP resource.
		  */protocol);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 69, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (protocol != CURLPROTO_HTTP) {
			(_iob[2]).curl_mfprintf("%s:%d protocol of http resource is incorrect; expected %d but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 75, CURLPROTO_HTTP, protocol);
			res = CURLE_HTTP_RETURNED_ERROR;
			;
		} 
		dupe = /* Test that a protocol is properly initialized on curl_easy_duphandle.
		  */curl.curl_easy_duphandle();
		if (!dupe) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_duphandle() failed\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 86);
			res = CURLE_FAILED_INIT;
			;
		} 
		res = dupe.curl_easy_getinfo(CURLINFO_PROTOCOL, protocol);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 94, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (protocol != 0) {
			(_iob[2]).curl_mfprintf("%s:%d protocol init failed; expected 0 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 99, protocol);
			res = CURLE_FAILED_INIT;
			;
		} 
		/* Test that a protocol is properly initialized on curl_easy_reset.
		  */curl.curl_easy_reset();
		res = curl.curl_easy_getinfo(CURLINFO_PROTOCOL, protocol);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 113, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (protocol != 0) {
			(_iob[2]).curl_mfprintf("%s:%d protocol init failed; expected 0 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1535.c", 118, protocol);
			res = CURLE_FAILED_INIT;
			;
		} 
		dupe.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		size_t i = new size_t();
		int status = 0;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (writedata))) != CURLE_OK) {
			;
		} 
		for (i = 0; i <  / ; i++) {
			status |=  ModernizedCProgram.onetest(curl, URL, ModernizedCProgram.params + i);
		}
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return status;
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res;
		 curl = new ();
		byte stream_uri = ((Object)0);
		int request = 1;
		FILE protofile = .fopen(ModernizedCProgram.libtest_arg2, "wb");
		if (protofile == ((Object)0)) {
			(_iob[2]).curl_mfprintf("Couldn't open the protocol dump file\n");
			return 126;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			.fclose(protofile);
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			.fclose(protofile);
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_INTERLEAVEFUNCTION), (rtp_write))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_TIMEOUT), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), (protofile))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_TRANSPORT), ("RTP/AVP/TCP;interleaved=0-1"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_SETUP))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* This PLAY starts the interleave */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_PLAY))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* The DESCRIBE request will try to consume data after the Content */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_DESCRIBE))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_PLAY))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		(_iob[2]).curl_mfprintf("PLAY COMPLETE\n");
		while (!res && ModernizedCProgram.rtp_packet_count < /* Use Receive to get the rest of the data */13) {
			(_iob[2]).curl_mfprintf("LOOPY LOOP!\n");
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_RECEIVE))) != CURLE_OK) {
				;
			} 
			res = curl.curl_easy_perform();
		}
		if (protofile) {
			.fclose(protofile);
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((ModernizedCProgram.curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_TIMEOUT))), ((((long)7))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_NOSIGNAL))), ((((long)1))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_PROGRESSFUNCTION))), (((progressCallback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_PROGRESSDATA))), (((((Object)0)))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((ModernizedCProgram.curl))).curl_easy_setopt((((CURLOPT_NOPROGRESS))), ((((long)0))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = ModernizedCProgram.curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		 curl = ((Object)0);
		int counter = 0;
		 m = ((Object)0);
		int running = 1;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_IOCTLFUNCTION))), (((ioctlcallback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* read the POST data from a callback */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_IOCTLDATA))), (((counter))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READFUNCTION))), (((readcallback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READDATA))), (((counter))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0/* We CANNOT do the POST fine without setting the size (or choose
		     chunked)! */);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_POSTFIELDSIZE))), ((((long).strlen(ModernizedCProgram.uploadthis)))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_POST))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXY))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXYUSERPWD))), (((ModernizedCProgram.libtest_arg3))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXYAUTH))), ((((long)(CURLAUTH_NTLM | CURLAUTH_DIGEST | CURLAUTH_BASIC)))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			ModernizedCProgram.timeout.setTv_sec(0);
			ModernizedCProgram.timeout.setTv_usec(/* 100 ms */-1024);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!/* avoid ctl-10 dump */running) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib555.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our request. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RESOLVER_START_DATA), (ModernizedCProgram.TEST_DATA_STRING))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RESOLVER_START_FUNCTION), (resolver_alloc_cb_fail))) != CURLE_OK) {
			;
		} 
		res = /* this should fail */curl.curl_easy_perform();
		if (res != CURLE_COULDNT_RESOLVE_HOST) {
			(_iob[2]).curl_mfprintf("curl_easy_perform should have returned CURLE_COULDNT_RESOLVE_HOST but instead returned error %d\n", res);
			if (res == CURLE_OK) {
				res = 119;
			} 
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RESOLVER_START_FUNCTION), (resolver_alloc_cb_pass))) != CURLE_OK) {
			;
		} 
		res = /* this should succeed */curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("curl_easy_perform failed.\n");
			;
		} 
		if (ModernizedCProgram.cb_count != 2) {
			(_iob[2]).curl_mfprintf("Unexpected number of callbacks: %d\n", ModernizedCProgram.cb_count);
			res = 119;
			;
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res;
		 curl = new ();
		int sdp;
		FILE sdpf = ((Object)0);
		_stati64 file_info = new _stati64();
		byte stream_uri = ((Object)0);
		int request = 1;
		curl_slist custom_headers = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		sdp = .open("log/file568.txt", 0);
		._fstati64(sdp, file_info);
		.close(sdp);
		sdpf = .fopen("log/file568.txt", "rb");
		if (sdpf == ((Object)0)) {
			(_iob[2]).curl_mfprintf("can't open log/file568.txt\n");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_ANNOUNCE))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (sdpf))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		Object generatedSt_size = file_info.getSt_size();
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE_LARGE), (()generatedSt_size))) != CURLE_OK) {
			;
		} 
		res = /* Do the ANNOUNCE */curl.curl_easy_perform();
		if (res) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		.fclose(sdpf);
		sdpf = ((Object)0);
		stream_uri = ModernizedCProgram.suburl(URL, /* Make sure we can do a normal request now */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_DESCRIBE))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* Now do a POST style one */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		custom_headers = custom_headers.curl_slist_append("Content-Type: posty goodness");
		if (!custom_headers) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSPHEADER), (custom_headers))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_ANNOUNCE))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), ("postyfield=postystuff&project=curl\n"))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), (((Object)0)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSPHEADER), (((Object)0)))) != CURLE_OK) {
			;
		} 
		custom_headers.curl_slist_free_all();
		custom_headers = ((Object)0);
		stream_uri = ModernizedCProgram.suburl(URL, /* Make sure we can do a normal request now */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_OPTIONS))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(stream_uri);
		if (custom_headers) {
			custom_headers.curl_slist_free_all();
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		(Object)URL;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), ("http://99.99.99.99:9999"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_OPENSOCKETFUNCTION), (opensocket))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 dupe = ((Object)0);
		byte scheme;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0/* Test that scheme is properly initialized on curl_easy_init.
		  */);
		res = curl.curl_easy_getinfo(CURLINFO_SCHEME, scheme);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 44, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (scheme != ((Object)0)) {
			(_iob[2]).curl_mfprintf("%s:%d scheme init failed; expected NULL\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 49);
			res = CURLE_FAILED_INIT;
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 59, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_SCHEME, /* Test that a scheme is properly set after receiving an HTTP resource.
		  */scheme);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 69, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (.memcmp(scheme, "HTTP", 5) != 0) {
			(_iob[2]).curl_mfprintf("%s:%d scheme of http resource is incorrect; expected 'HTTP' but is %s\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 75, (scheme == ((Object)0) ? "NULL" : "invalid"));
			res = CURLE_HTTP_RETURNED_ERROR;
			;
		} 
		dupe = /* Test that a scheme is properly initialized on curl_easy_duphandle.
		  */curl.curl_easy_duphandle();
		if (!dupe) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_duphandle() failed\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 87);
			res = CURLE_FAILED_INIT;
			;
		} 
		res = dupe.curl_easy_getinfo(CURLINFO_SCHEME, scheme);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 95, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (scheme != 0) {
			(_iob[2]).curl_mfprintf("%s:%d scheme init failed; expected NULL\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 100);
			res = CURLE_FAILED_INIT;
			;
		} 
		/* Test that a scheme is properly initialized on curl_easy_reset.
		  */curl.curl_easy_reset();
		res = curl.curl_easy_getinfo(CURLINFO_SCHEME, scheme);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 114, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (scheme != 0) {
			(_iob[2]).curl_mfprintf("%s:%d scheme init failed; expected NULL\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1536.c", 119);
			res = CURLE_FAILED_INIT;
			;
		} 
		dupe.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)URL;
		ModernizedCProgram.curl_mprintf("system lacks necessary system function(s)");
		return /* skip test */1/* defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT) */;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* enable verbose */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PORT), (.strtol(ModernizedCProgram.libtest_arg2, ((Object)0), 10)))) != /* set port number */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* specify target */CURLE_OK) {
			;
		} 
		res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = ((Object)0);
		 res = CURLE_OK;
		 mime = ((Object)0);
		 part = new ();
		curl_slist recipients = ((Object)0);
		/* create a buffer with AAAA...BBBBB...CCCC...etc */int i;
		int size = (int) / 10;
		for (i = 0; i < size; i++) {
			.memset(ModernizedCProgram.buffer[i * 10], 65 + (i % 26), 10);
		}
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = ()126;
			;
		} 
		mime = /* Build mime structure. */curl.curl_mime_init();
		if (!mime) {
			(_iob[2]).curl_mfprintf("curl_mime_init() failed\n");
			res = ()126;
			;
		} 
		part = ModernizedCProgram.curl_mime_addpart(mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart() failed\n");
			res = ()126;
			;
		} 
		res = ModernizedCProgram.curl_mime_filename(part, "myfile.jpg");
		if (res) {
			(_iob[2]).curl_mfprintf("curl_mime_filename() failed\n");
			;
		} 
		res = ModernizedCProgram.curl_mime_type(part, "image/jpeg");
		if (res) {
			(_iob[2]).curl_mfprintf("curl_mime_type() failed\n");
			;
		} 
		res = ModernizedCProgram.curl_mime_data(part, ModernizedCProgram.buffer, );
		if (res) {
			(_iob[2]).curl_mfprintf("curl_mime_data() failed\n");
			;
		} 
		res = ModernizedCProgram.curl_mime_encoder(part, "base64");
		if (res) {
			(_iob[2]).curl_mfprintf("curl_mime_encoder() failed\n");
			;
		} 
		recipients = ((Object)0).curl_slist_append(/* Prepare recipients. */"someone@example.com");
		if (!recipients) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our mime mail. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MAIL_FROM), ("somebody@example.com"))) != /* Set sender. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MAIL_RCPT), (recipients))) != /* Set recipients. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MIMEPOST), (mime))) != /* send a multi-part mail */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_mime_free(/* now cleanup the mime structure */mime);
		/* cleanup the recipients. */recipients.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 cm = ((Object)0);
		curl_slist headers = ((Object)0);
		byte[] buffer = new byte[/* naively fixed-size */246];
		int res = 0;
		int i;
		for (i = 0; i < 2; i++) {
			ModernizedCProgram.eh[i] = ((Object)0);
		}
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		if (ModernizedCProgram.test_argc < 4) {
			return 99;
		} 
		ModernizedCProgram.curl_msnprintf(buffer, , "Host: %s", ModernizedCProgram.test_argv[4]);
		headers = headers.curl_slist_append(/* now add a custom Host: header */buffer);
		if (!headers) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			return 126;
		} 
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			headers.curl_slist_free_all();
			return res;
		} 
		Curl_multi curl_multi = new Curl_multi();
		do {
			if ((((cm)) = curl_multi.curl_multi_init()) == ((Object)0)) {
				(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)));
				res = 123;
			} 
		} while (0);
		if (res) {
			ModernizedCProgram.curl_global_cleanup();
			headers.curl_slist_free_all();
			return res;
		} 
		res = ModernizedCProgram.loop(0, cm, URL, ModernizedCProgram.libtest_arg3, headers);
		if (res) {
			;
		} 
		(_iob[2]).curl_mfprintf("lib540: now we do the request again\n");
		res = ModernizedCProgram.loop(1, cm, URL, ModernizedCProgram.libtest_arg3, headers);
		cm.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		headers.curl_slist_free_all();
		return res;
		 res = new ();
		 curl = ((Object)0);
		byte newURL = ((Object)0);
		curl_slist slist = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = 126;
			;
		} 
		newURL = ModernizedCProgram.curl_maprintf("%s/folderA/661", /* test: CURLFTPMETHOD_SINGLECWD with absolute path should
		            skip CWD to entry path */URL);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_IGNORE_CONTENT_LENGTH), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_SINGLECWD))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(newURL);
		newURL = ModernizedCProgram.curl_maprintf("%s/folderB/661", URL);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		/* test: CURLFTPMETHOD_NOCWD with absolute path should
		      never emit CWD (for both new and reused easy handle) */curl.curl_easy_cleanup();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = 126;
			;
		} 
		.free(newURL);
		newURL = ModernizedCProgram.curl_maprintf("%s/folderA/661", URL);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_IGNORE_CONTENT_LENGTH), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_NOCWD))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(/* curve ball: CWD /folderB before reusing connection with _NOCWD */newURL);
		newURL = ModernizedCProgram.curl_maprintf("%s/folderB/661", URL);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_SINGLECWD))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(newURL);
		newURL = ModernizedCProgram.curl_maprintf("%s/folderA/661", URL);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_NOCWD))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		/* test: CURLFTPMETHOD_NOCWD with home-relative path should
		      not emit CWD for first FTP access after login */curl.curl_easy_cleanup();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = 126;
			;
		} 
		slist = ((Object)0).curl_slist_append("SYST");
		if (slist == ((Object)0)) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_NOCWD))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_QUOTE), (slist))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		/* test: CURLFTPMETHOD_SINGLECWD with home-relative path should
		      not emit CWD for first FTP access after login */curl.curl_easy_cleanup();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_SINGLECWD))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_QUOTE), (slist))) != CURLE_OK) {
			;
		} 
		res = curl/* test: CURLFTPMETHOD_NOCWD with home-relative path should
		      not emit CWD for second FTP access when not needed +
		      bonus: see if path buffering survives curl_easy_reset() */.curl_easy_perform();
		curl.curl_easy_reset();
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_NOCWD))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_QUOTE), (slist))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(newURL);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		int i;
		int error = 0;
		(Object)/* not used */URL;
		for (i = 0; ModernizedCProgram.dates[i].getInput(); i++) {
			time_t out = ModernizedCProgram.curl_getdate(ModernizedCProgram.dates[i].getInput(), ((Object)0));
			if (out != ModernizedCProgram.dates[i].getOutput()) {
				ModernizedCProgram.curl_mprintf("WRONGLY %s => %ld (instead of %ld)\n", ModernizedCProgram.dates[i].getInput(), out, ModernizedCProgram.dates[i].getOutput());
				error++;
			} 
		}
		return error;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist slist = ((Object)0);
		WriteThis pooh = new WriteThis();
		pooh.setCounter(0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		slist = slist.curl_slist_append("Transfer-Encoding: chunked");
		if (slist == ((Object)0)) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (pooh))) != /* pointer to pass to our read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (slist))) != /* enforce chunked transfer by setting the header */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPAUTH), ((long)CURLAUTH_DIGEST))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), ("foo:bar"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOPROGRESS), (true))) != /* we want to use our own progress function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROGRESSFUNCTION), (progress_callback))) != CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		/* always cleanup */curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 handle = ((Object)0);
		 mhandle = ((Object)0);
		int res = 0;
		int still_running = 0;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((handle))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((mhandle))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((mhandle))), (((handle))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((mhandle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 30 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			timeval before = new timeval();
			timeval after = new timeval();
			long e;
			ModernizedCProgram.timeout.setTv_sec(0);
			ModernizedCProgram.timeout.setTv_usec(/* 100 ms */-1024);
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((mhandle))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 30 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			(_iob[2]).curl_mfprintf("ping\n");
			before = timeval.tutil_tvnow();
			do {
				do {
					 ec = new ();
					if ((ec = (((mhandle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 30 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1501.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			after = timeval.tutil_tvnow();
			e = after.tutil_tvdiff(before);
			(_iob[2]).curl_mfprintf("pong = %ld\n", e);
			if (e > 500) {
				res = 100;
				break;
			} 
		}
		handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		byte[] a = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		 easy = new ();
		int asize;
		byte s;
		 res = CURLE_OK;
		(Object)URL;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib543.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		easy = curl_easy.curl_easy_init();
		if (!easy) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			return 126;
		} 
		asize = (int);
		s = easy.curl_easy_escape((byte)a, asize);
		if (s) {
			ModernizedCProgram.curl_mprintf("%s\n", s);
		} 
		if (s) {
			ModernizedCProgram.curl_free(s);
		} 
		easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		curl_slist hhl = ((Object)/* http and proxy header list*/0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		hhl = hhl.curl_slist_append("Trailer: my-super-awesome-trailer, my-other-awesome-trailer");
		if (!hhl) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PUT), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_TRAILERFUNCTION), (trailers_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_TRAILERDATA), (((Object)0)))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		hhl.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)ModernizedCProgram.data_size))) != /* Set the expected POST size */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), (ModernizedCProgram.data))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOPROGRESS), (true))) != /* we want to use our own progress function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROGRESSFUNCTION), (progress_callback))) != CURLE_OK/* pointer to pass to our read function */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int stillRunning;
		 multiHandle = ((Object)0);
		 curl = ((Object)0);
		 res = CURLM_OK;
		int timeout;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multiHandle))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		if (curl.curl_easy_setopt(CURLOPT_DNS_SERVERS, "0.0.0.0") == /* Set a DNS server that hopefully will not respond when using c-ares. */CURLE_OK/* Since we could set the DNS server, presume we are working with a
		       resolver that can be cancelled (i.e. c-ares).  Thus,
		       curl_multi_remove_handle() should not block even when the resolver
		       request is outstanding.  So, set a request timeout _longer_ than the
		       test hang timeout so we will fail if the handle removal call incorrectly
		       blocks. */) {
			timeout = 2 * 1000 * 2/* If we can't set the DNS server, presume that we are configured to use a
			       resolver that can't be cancelled (i.e. the threaded resolver or the
			       non-threaded blocking resolver).  So, we just test that the
			       curl_multi_remove_handle() call does finish well within our test
			       timeout.
			
			       But, it is very unlikely that the resolver request will take any time at
			       all because we haven't been able to configure the resolver to use an
			       non-responsive DNS server.  At least we exercise the flow.
			       */;
		} else {
				(_iob[2]).curl_mfprintf("CURLOPT_DNS_SERVERS not supported; assuming curl_multi_remove_handle() will block\n");
				timeout = 2 * 1000 / 2/* Setting a timeout on the request should ensure that even if we have to
				     wait for the resolver during curl_multi_remove_handle(), it won't take
				     longer than this, because the resolver request inherits its timeout from
				     this. */;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMEOUT_MS))), (((timeout))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multiHandle))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf(/* This should move the handle from INIT => CONNECT => WAITRESOLVE. */"curl_multi_perform()...\n");
		do {
			do {
				 ec = new ();
				if ((ec = (((multiHandle))).curl_multi_perform((((stillRunning))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((stillRunning)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c"))), (((true))), (int)((((stillRunning)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("curl_multi_perform() succeeded\n");
		(_iob[2]).curl_mfprintf(/* Start measuring how long it takes to remove the handle. */"curl_multi_remove_handle()...\n");
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		res = ModernizedCProgram.curl_multi_remove_handle(multiHandle, curl);
		if (res) {
			(_iob[2]).curl_mfprintf("curl_multi_remove_handle() failed, with code %d\n", (int)res);
			;
		} 
		(_iob[2]).curl_mfprintf("curl_multi_remove_handle() succeeded\n"/* Fail the test if it took too long to remove.  This happens after the fact,
		     and says "it seems that it would have run forever", which isn't true, but
		     it's close enough, and simple to do. */);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 2 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1592.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		multiHandle.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 code = new ();
		curl_slist pHeaderList = ((Object)0);
		Curl_easy curl_easy = new Curl_easy();
		 pCurl = curl_easy.curl_easy_init();
		.memset(ModernizedCProgram.g_Data, (byte)'A', );
		pCurl.curl_easy_setopt(CURLOPT_SOCKOPTFUNCTION, sockopt_callback);
		pCurl.curl_easy_setopt(CURLOPT_URL, URL);
		pCurl.curl_easy_setopt(CURLOPT_POSTFIELDS, ModernizedCProgram.g_Data);
		pCurl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long));
		pHeaderList = pHeaderList.curl_slist_append(/* Remove "Expect: 100-continue" */"Expect:");
		pCurl.curl_easy_setopt(CURLOPT_HTTPHEADER, pHeaderList);
		code = pCurl.curl_easy_perform();
		if (code == CURLE_OK) {
			 uploadSize = new ();
			pCurl.curl_easy_getinfo(CURLINFO_SIZE_UPLOAD_T, uploadSize);
			ModernizedCProgram.curl_mprintf("uploadSize = %ld\n", (long)uploadSize);
			if ((size_t)uploadSize == ) {
				ModernizedCProgram.curl_mprintf("!!!!!!!!!! PASS\n");
			} else {
					ModernizedCProgram.curl_mprintf("!!!!!!!!!! FAIL\n");
			} 
		} else {
				ModernizedCProgram.curl_mprintf("curl_easy_perform() failed. e = %d\n", code);
		} 
		pHeaderList.curl_slist_free_all();
		pCurl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 c = ((Object)0);
		 m = ((Object)0);
		int res = 0;
		int running = 1;
		double connect_time = 0.0;
		double dbl_epsilon;
		dbl_epsilon = 1.0;
		do {
			dbl_epsilon /= 2.0;
		} while ((double)(1.0 + (dbl_epsilon / 2.0)) > (double)1.0);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((c))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		ModernizedCProgram.libtest_debug_config.setNohex(1);
		ModernizedCProgram.libtest_debug_config.setTracetime(1);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_DEBUGDATA))), (((ModernizedCProgram.libtest_debug_config))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_DEBUGFUNCTION))), (((ModernizedCProgram.libtest_debug_cb))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((c))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			ModernizedCProgram.timeout.setTv_sec(0);
			ModernizedCProgram.timeout.setTv_usec(/* 100 ms */-1024);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib573.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		c.curl_easy_getinfo(CURLINFO_CONNECT_TIME, connect_time);
		if (connect_time < dbl_epsilon) {
			(_iob[2]).curl_mfprintf("connect time %e is < epsilon %e\n", connect_time, dbl_epsilon);
			res = 126;
		} 
		m.curl_multi_cleanup();
		c.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 handle = new ();
		int res = CURLE_OK;
		byte[] bl_servers = new byte[]{"Microsoft-IIS/6.0", "nginx/0.8.54", ((Object)0)};
		byte[] bl_sites = new byte[]{"curl.haxx.se:443", "example.com:80", ((Object)0)};
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1550.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		handle = curl_multi.curl_multi_init();
		(Object)/* unused */URL;
		handle.curl_multi_setopt(CURLMOPT_PIPELINING_SERVER_BL, bl_servers);
		handle.curl_multi_setopt(CURLMOPT_PIPELINING_SITE_BL, bl_sites);
		handle.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 handle = ((Object)0);
		 res = 0;
		 urlp = ((Object)0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((handle))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		urlp = .curl_url();
		if (!urlp) {
			(_iob[2]).curl_mfprintf("problem init URL api.");
			;
		} 
		if (.curl_url_set(urlp, CURLUPART_HOST, "www.example.com", /* this doesn't set the PATH part */0) || .curl_url_set(urlp, CURLUPART_SCHEME, "http", 0) || .curl_url_set(urlp, CURLUPART_PORT, "80", 0)) {
			(_iob[2]).curl_mfprintf("problem setting CURLUPART");
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_CURLU))), (((urlp))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_PROXY))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = handle.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib659.c", 64, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FILETIME), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res;
		 scode = CURLSHE_OK;
		 code = CURLE_OK;
		byte url = ((Object)0);
		Tdata tdata = new Tdata();
		 curl = new ();
		 share = new ();
		curl_slist headers = ((Object)0);
		curl_slist cookies = ((Object)0);
		curl_slist next_cookie = ((Object)0);
		int i;
		userdata user = new userdata();
		user.setText("Pigs in space");
		user.setCounter(0);
		ModernizedCProgram.curl_mprintf("GLOBAL_INIT\n");
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		ModernizedCProgram.curl_mprintf(/* prepare share */"SHARE_INIT\n");
		Curl_share curl_share = new Curl_share();
		share = curl_share.curl_share_init();
		if (!share) {
			(_iob[2]).curl_mfprintf("curl_share_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_LOCKFUNC\n");
			scode = share.curl_share_setopt(CURLSHOPT_LOCKFUNC, my_lock);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_UNLOCKFUNC\n");
			scode = share.curl_share_setopt(CURLSHOPT_UNLOCKFUNC, my_unlock);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_USERDATA\n");
			scode = share.curl_share_setopt(CURLSHOPT_USERDATA, user);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURL_LOCK_DATA_COOKIE\n");
			scode = share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURL_LOCK_DATA_DNS\n");
			scode = share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);
		} 
		if (CURLSHE_OK != scode) {
			(_iob[2]).curl_mfprintf("curl_share_setopt() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_SHARE), (share))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST injected_and_clobbered\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("Set-Cookie: injected_and_clobbered=yes; domain=host.foo.com; expires=Sat Feb 2 11:56:27 GMT 2030"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST ALL\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("ALL"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST session\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("Set-Cookie: session=elephants"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST injected\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("Set-Cookie: injected=yes; domain=host.foo.com; expires=Sat Feb 2 11:56:27 GMT 2030"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST SESS\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("SESS"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CLEANUP\n");
		curl.curl_easy_cleanup();
		res = 0;
		Byte generatedUrl = tdata.getUrl();
		for (i = 1; i <= 2; /* start treads */i++) {
			tdata.setUrl(ModernizedCProgram.suburl(URL, /* set thread data *//* must be curl_free()d */i));
			tdata.setShare(share);
			ModernizedCProgram.curl_mprintf("*** run %d\n", /* simulate thread, direct call of "thread" function */i);
			ModernizedCProgram.fire(tdata);
			ModernizedCProgram.curl_free(generatedUrl);
		}
		ModernizedCProgram.curl_mprintf("*** run %d\n", /* fetch a another one and save cookies */i);
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		url = ModernizedCProgram.suburl(URL, i);
		headers = ((Object)0).sethost();
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (headers))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (url))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_SHARE), (share))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIEJAR\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIEJAR), (ModernizedCProgram.JAR))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST FLUSH\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("FLUSH"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("PERFORM\n");
		curl.curl_easy_perform();
		ModernizedCProgram.curl_mprintf("CLEANUP\n");
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_free(url);
		headers.curl_slist_free_all();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		url = ModernizedCProgram.suburl(URL, i);
		headers = ((Object)0).sethost();
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (headers))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (url))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_SHARE), (share))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST ALL\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("ALL"))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIEJAR\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIEFILE), (ModernizedCProgram.JAR))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_COOKIELIST RELOAD\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIELIST), ("RELOAD"))) != CURLE_OK) {
			;
		} 
		code = curl.curl_easy_getinfo(CURLINFO_COOKIELIST, cookies);
		if (code != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_easy_getinfo() failed\n");
			res = 126;
			;
		} 
		ModernizedCProgram.curl_mprintf("loaded cookies:\n");
		if (!cookies) {
			(_iob[2]).curl_mfprintf("  reloading cookies from '%s' failed\n", ModernizedCProgram.JAR);
			res = 126;
			;
		} 
		ModernizedCProgram.curl_mprintf("-----------------\n");
		next_cookie = cookies;
		Object generatedCurl_slist = next_cookie.getCurl_slist();
		while (next_cookie) {
			ModernizedCProgram.curl_mprintf("  %s\n", generatedCurl_slist);
			next_cookie = generatedCurl_slist;
		}
		ModernizedCProgram.curl_mprintf("-----------------\n");
		cookies.curl_slist_free_all();
		ModernizedCProgram.curl_mprintf(/* try to free share, expect to fail because share is in use*/"try SHARE_CLEANUP...\n");
		scode = share.curl_share_cleanup();
		if (scode == CURLSHE_OK) {
			(_iob[2]).curl_mfprintf("curl_share_cleanup succeed but error expected\n");
			share = ((Object)0);
		} else {
				ModernizedCProgram.curl_mprintf("SHARE_CLEANUP failed, correct\n");
		} 
		curl.curl_easy_cleanup();
		headers.curl_slist_free_all();
		ModernizedCProgram.curl_free(url);
		ModernizedCProgram.curl_mprintf(/* free share */"SHARE_CLEANUP\n");
		scode = share.curl_share_cleanup();
		if (scode != CURLSHE_OK) {
			(_iob[2]).curl_mfprintf("curl_share_cleanup failed, code errno %d\n", (int)scode);
		} 
		ModernizedCProgram.curl_mprintf("GLOBAL_CLEANUP\n");
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		[] curl = new []{0};
		int running;
		 m = ((Object)0);
		int i;
		byte[] target_url = new byte[256];
		byte[] dnsentry = new byte[256];
		curl_slist slist = ((Object)0);
		curl_slist slist2 = new curl_slist();
		byte port = ModernizedCProgram.libtest_arg3;
		byte address = ModernizedCProgram.libtest_arg2;
		(Object)URL;
		for (i = 0; i < 4; /* Create fake DNS entries for serverX.example.com for all handles */i++) {
			ModernizedCProgram.curl_msnprintf(dnsentry, , "server%d.example.com:%s:%s", i + 1, port, address);
			ModernizedCProgram.curl_mprintf("%s\n", dnsentry);
			slist2 = slist.curl_slist_append(dnsentry);
			if (!slist2) {
				(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
				;
			} 
			slist = slist2;
		}
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_MAXCONNECTS))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (i = 0; i < 4; /* get NUM_HANDLES easy handles */i++) {
			do {
				do {
					if (((((curl[i]))) = curl_easy.curl_easy_init()) == ((Object)0)) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))));
						res = 124;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* get an easy handle */0);
			ModernizedCProgram.curl_msnprintf(target_url, , "http://server%d.example.com:%s/path/1506%04i", i + 1, port, i + 1);
			target_url[ - 1] = (byte)'\0';
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_URL))), (((target_url))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* go verbose */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* include headers */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_RESOLVE))), (((slist))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		(_iob[2]).curl_mfprintf("Start at URL 0\n");
		for (i = 0; i < 4; i++) {
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl[i]))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* add handle to multi */0);
			for (; ; ) {
				timeval interval = new timeval();
				fd_set rd = new fd_set();
				fd_set wr = new fd_set();
				fd_set exc = new fd_set();
				int maxfd = -99;
				interval.setTv_sec(1);
				interval.setTv_usec(0);
				do {
					do {
						 ec = new ();
						if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
							res = (int)ec;
						}  else if (((((running)))) < 0) {
							(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)((((running)))));
							res = 122;
						} 
					} while (0);
					if (res) {
						;
					} 
				} while (0);
				do {
					do {
						if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
							(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c")), ((true)));
							res = 125;
						} 
					} while (0);
					if (res) {
						;
					} 
				} while (0);
				if (!running) {
					break;
				} 
				(((fd_set)(rd)).setFd_count(0));
				(((fd_set)(wr)).setFd_count(0));
				(((fd_set)(exc)).setFd_count(0));
				do {
					do {
						 ec = new ();
						if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
							res = (int)ec;
						}  else if (((((maxfd)))) < -1) {
							(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), (int)((((maxfd)))));
							res = 122;
						} 
					} while (0);
					if (res) {
						;
					} 
				} while (0);
				do {
					do {
						int ec;
						if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
							ec = ((int).WSAGetLastError());
							(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c"))), (((true))), ec, .strerror(ec));
							res = 121;
						} 
					} while (0);
					if (res) {
						;
					} 
				} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
				do {
					do {
						if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
							(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1506.c")), ((true)));
							res = 125;
						} 
					} while (0);
					if (res) {
						;
					} 
				} while (0);
			}
			ModernizedCProgram.wait_ms(/* to ensure different end times */1);
		}
		slist.curl_slist_free_all();
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MIMEPOST), (((Object)0)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* show verbose for debug */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include header */CURLE_OK) {
			;
		} 
		res = /* Now, we should be making a zero byte POST request */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		curl_slist header = ((Object)0);
		 retry = new ();
		 curl = ((Object)0);
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1594.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1594.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1594.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_RETRY_AFTER, retry);
		if (res) {
			;
		} 
		header.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), (true))) != /* Set the expected POST size */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (((Object)0)))) != /* pointer to pass to our read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPOST), (((Object)0)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* show verbose for debug */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include header */CURLE_OK) {
			;
		} 
		res = /* Now, we should be making a zero byte POST request */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		Curl_easy curl_easy = new Curl_easy();
		Curl_multi curl_multi = new Curl_multi();
		Curl_addrinfo generatedAddr = dns.getAddr();
		sockaddr generatedAi_addr = addr.getAi_addr();
		Object generatedAi_addrlen = addr.getAi_addrlen();
		Curl_addrinfo generatedAi_next = addr.getAi_next();
		curl_hash generatedHostcache = multi.getHostcache();
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		curl_slist header = ((Object)0);
		long unmet;
		 curl = ((Object)0);
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMECONDITION))), ((((long)CURL_TIMECOND_IFMODSINCE))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMEVALUE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* Some TIMEVALUE; it doesn't matter. */0);
		header = ((Object)0).curl_slist_append("If-Modified-Since:");
		if (!header) {
			res = 126;
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HTTPHEADER))), (((header))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1593.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_CONDITION_UNMET, unmet);
		if (res) {
			;
		} 
		if (unmet != -1024) {
			res = 119;
			;
		} 
		header.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		FILE hd_src = new FILE();
		int hd;
		_stati64 file_info = new _stati64();
		curl_slist hl = new curl_slist();
		curl_slist headerlist = ((Object)0);
		byte buf_1 = "RNFR 505";
		byte buf_2 = "RNTO 505-forreal";
		if (!ModernizedCProgram.libtest_arg2) {
			(_iob[2]).curl_mfprintf("Usage: <url> <file-to-upload>\n");
			return 118;
		} 
		hd_src = .fopen(ModernizedCProgram.libtest_arg2, "rb");
		if (((Object)0) == hd_src) {
			(_iob[2]).curl_mfprintf("fopen failed with error: %d %s\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("Error opening file: %s\n", ModernizedCProgram.libtest_arg2);
			return /* if this happens things are major weird */126;
		} 
		Object generated_file = (hd_src).get_file();
		hd = ._fstati64((generated_file), /* get the file size of the local file */file_info);
		if (hd == -1) {
			(_iob[2]).curl_mfprintf(/* can't open file, bail out */"fstat() failed with error: %d %s\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("ERROR: cannot open file %s\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 126;
		} 
		Object generatedSt_size = file_info.getSt_size();
		if (!generatedSt_size) {
			(_iob[2]).curl_mfprintf("ERROR: file %s has zero size!\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 126;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			.fclose(hd_src);
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			.fclose(hd_src);
			return 126;
		} 
		hl = headerlist.curl_slist_append(/* build a list of commands to pass to libcurl */buf_1);
		if (!hl) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			.fclose(hd_src);
			return 126;
		} 
		headerlist = hl.curl_slist_append(buf_2);
		if (!headerlist) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			hl.curl_slist_free_all();
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			.fclose(hd_src);
			return 126;
		} 
		headerlist = hl;
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != /* enable uploading */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* enable verbose */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* specify target */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTQUOTE), (headerlist))) != /* pass in that last of FTP commands to run after the transfer */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (hd_src))) != /* now specify which file to upload */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE_LARGE), (()generatedSt_size))) != /* and give the size of the upload (optional) */CURLE_OK) {
			;
		} 
		res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
		.fclose(/* close the local file */hd_src);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 res = 0;
		 curl = ((Object)0);
		byte longurl = .malloc(10 * 1000 * 1000);
		 u = new ();
		(Object)URL;
		.memset(longurl, (byte)'a', 10 * 1000 * 1000);
		longurl[10 * 1000 * 1000 - 1] = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1559.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1559.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_setopt(CURLOPT_URL, longurl);
		ModernizedCProgram.curl_mprintf("CURLOPT_URL %d bytes URL == %d\n", 10 * 1000 * 1000, (int)res);
		res = curl.curl_easy_setopt(CURLOPT_POSTFIELDS, longurl);
		ModernizedCProgram.curl_mprintf("CURLOPT_POSTFIELDS %d bytes data == %d\n", 10 * 1000 * 1000, (int)res);
		u = .curl_url();
		if (u) {
			 uc = .curl_url_set(u, CURLUPART_URL, longurl, 0);
			ModernizedCProgram.curl_mprintf("CURLUPART_URL %d bytes URL == %d\n", 10 * 1000 * 1000, (int)uc);
			uc = .curl_url_set(u, CURLUPART_SCHEME, longurl, CURLU_NON_SUPPORT_SCHEME);
			ModernizedCProgram.curl_mprintf("CURLUPART_SCHEME %d bytes scheme == %d\n", 10 * 1000 * 1000, (int)uc);
			uc = .curl_url_set(u, CURLUPART_USER, longurl, 0);
			ModernizedCProgram.curl_mprintf("CURLUPART_USER %d bytes user == %d\n", 10 * 1000 * 1000, (int)uc);
			.curl_url_cleanup(u);
		} 
		.free(longurl);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		ModernizedCProgram.curl_global_cleanup();
		return /* return the final return code */res;
		 easy = ((Object)0);
		ModernizedCProgram.CURL * dup;
		 multi = ((Object)0);
		int still_running;
		int res = 0;
		byte[] redirect = new byte[160];
		/* DNS cache injection */curl_slist dns_cache_list = new curl_slist();
		ModernizedCProgram.curl_msnprintf(redirect, , "google.com:%s:%s", ModernizedCProgram.libtest_arg2, ModernizedCProgram.libtest_arg3);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		dns_cache_list = ((Object)0).curl_slist_append(redirect);
		if (!dns_cache_list) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			return 126;
		} 
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			dns_cache_list.curl_slist_free_all();
			return res;
		} 
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((easy))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_RESOLVE))), (((dns_cache_list))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		dup = easy.curl_easy_duphandle();
		if (dup) {
			easy.curl_easy_cleanup();
			easy = dup;
		} else {
				dns_cache_list.curl_slist_free_all();
				easy.curl_easy_cleanup();
				return CURLE_OUT_OF_MEMORY;
		} 
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((easy))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(1);
			ModernizedCProgram.timeout.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1502.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		return res;
		 curl = ((Object)0);
		 res = 126;
		 formrc = new ();
		curl_slist headers = new curl_slist();
		curl_slist headers2 = ((Object)0);
		curl_httppost formpost = ((Object)0);
		curl_httppost lastptr = ((Object)0);
		curl_forms[] formarray = new curl_forms();
		size_t formlength = 0;
		byte[] flbuf = new byte[32];
		long contentlength = 0;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		headers = ((Object)0).curl_slist_append(/* Check proper name and data copying, as well as headers. */"X-customheader-1: Header 1 data");
		if (!headers) {
			;
		} 
		headers2 = headers.curl_slist_append("X-customheader-2: Header 2 data");
		if (!headers2) {
			;
		} 
		headers = headers2;
		headers2 = headers.curl_slist_append("Content-Type: text/plain");
		if (!headers2) {
			;
		} 
		headers = headers2;
		formrc = formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, ModernizedCProgram.name, CURLFORM_COPYCONTENTS, ModernizedCProgram.data, CURLFORM_CONTENTHEADER, headers, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(1) = %d\n", (int)formrc);
			;
		} 
		contentlength = (long)(.strlen(ModernizedCProgram.data) - 1);
		formarray[0].setCurl_forms(/* Use a form array for the non-copy test. */CURLFORM_PTRCONTENTS);
		formarray[0].setCurl_forms(ModernizedCProgram.data);
		formarray[1].setCurl_forms(CURLFORM_CONTENTSLENGTH);
		formarray[1].setCurl_forms((byte)(size_t)contentlength);
		formarray[2].setCurl_forms(CURLFORM_END);
		formarray[2].setCurl_forms(((Object)0));
		formrc = formpost.curl_formadd(lastptr, CURLFORM_PTRNAME, ModernizedCProgram.name, CURLFORM_NAMELENGTH, .strlen(ModernizedCProgram.name) - 1, CURLFORM_ARRAY, formarray, CURLFORM_FILENAME, "remotefile.txt", CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(2) = %d\n", (int)formrc);
			;
		} 
		ModernizedCProgram.data[/* Now change in-memory data to affect CURLOPT_PTRCONTENTS value.
		     Copied values (first field) must not be affected.
		     CURLOPT_PTRNAME actually copies the name thus we do not test this here. */0]++;
		formrc = /* Check multi-files and content type propagation. */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "multifile", CURLFORM_FILE, /* Set in first.c. */ModernizedCProgram.libtest_arg2, CURLFORM_FILE, ModernizedCProgram.libtest_arg2, CURLFORM_CONTENTTYPE, "text/whatever", CURLFORM_FILE, ModernizedCProgram.libtest_arg2, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(3) = %d\n", (int)formrc);
			;
		} 
		formrc = /* Check data from file content. */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "filecontents", CURLFORM_FILECONTENT, ModernizedCProgram.libtest_arg2, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(4) = %d\n", (int)formrc);
			;
		} 
		formpost.curl_formget((Object)formlength, count_chars);
		ModernizedCProgram.curl_msnprintf(flbuf, , "%lu", (long)/* Include length in data for external check. */formlength);
		formrc = formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "formlength", CURLFORM_COPYCONTENTS, flbuf, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(5) = %d\n", (int)formrc);
			;
		} 
		formrc = /* Check stdin (may be problematic on some platforms). */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "standardinput", CURLFORM_FILE, "-", CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(6) = %d\n", (int)formrc);
			;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPOST), (formpost))) != /* send a multi-part formpost */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		/* now cleanup the formpost chain */formpost.curl_formfree();
		headers.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		[] curl = new ();
		int running;
		 m = ((Object)0);
		int current = 0;
		int i;
		for (i = 0; i < 4; i++) {
			curl[i] = ((Object)0);
		}
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		for (i = 0; i < 4; /* get NUM_HANDLES easy handles */i++) {
			do {
				do {
					if (((((curl[i]))) = curl_easy.curl_easy_init()) == ((Object)0)) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))));
						res = 124;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* specify target */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* go verbose */0);
		}
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl[current]))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("Start at URL 0\n");
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running/* NOTE: this code does not remove the handle from the multi handle
			         here, which would be the nice, sane and documented way of working.
			         This however tests that the API survives this abuse gracefully. */) {
				if (++current < 4) {
					(_iob[2]).curl_mfprintf("Advancing to URL %d\n", current/* first remove the only handle we use *//* make us re-use the same handle all the time, and try resetting
					           the handle first too */);
					do {
						do {
							 ec = new ();
							if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl[current]))))) != CURLM_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (/* go verbose *//* re-add it */0);
				} else {
						break;
				} 
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib526.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		int res = 0;
		 curl = ((Object)0);
		FILE hd_src = ((Object)0);
		int hd;
		_stati64 file_info = new _stati64();
		 m = ((Object)0);
		int running;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		if (!ModernizedCProgram.libtest_arg2/* test 529 */) {
			(_iob[2]).curl_mfprintf(/* test 525 */"Usage: lib525 [url] [uploadfile]\n");
			return 118;
		} 
		hd_src = .fopen(ModernizedCProgram.libtest_arg2, "rb");
		if (((Object)0) == hd_src) {
			(_iob[2]).curl_mfprintf("fopen failed with error: %d (%s)\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("Error opening file: (%s)\n", ModernizedCProgram.libtest_arg2);
			return 117;
		} 
		Object generated_file = (hd_src).get_file();
		hd = ._fstati64((generated_file), /* get the file size of the local file */file_info);
		if (hd == -1) {
			(_iob[2]).curl_mfprintf(/* can't open file, bail out */"fstat() failed with error: %d (%s)\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("ERROR: cannot open file (%s)\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 116;
		} 
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			.fclose(hd_src);
			return res;
		} 
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_UPLOAD))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* enable uploading */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* specify target */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* go verbose */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_FTPPORT))), ((("-"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* use active FTP */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READDATA))), (((hd_src))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* now specify which file to upload */0/* NOTE: if you want this code to work on Windows with libcurl as a DLL, you
		     MUST also provide a read callback with CURLOPT_READFUNCTION. Failing to
		     do so will give you a crash since a DLL may not use the variable's memory
		     when passed in to it from an app like this. */);
		Object generatedSt_size = file_info.getSt_size();
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_INFILESIZE_LARGE))), (((()generatedSt_size))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* Set the size of the file to upload (optional).  If you give a *_LARGE
		     option you MUST make sure that the type of the passed-in argument is a
		     curl_off_t. If you use CURLOPT_INFILESIZE (without _LARGE) you must
		     make sure that to pass in a type 'long' argument. */0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib525.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		curl.curl_easy_cleanup();
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		.fclose(/* close the local file */hd_src);
		return res;
		(Object)arg;
		Object generatedDohbuffer = victim.getDohbuffer();
		byte generatedCanary1 = victim.getCanary1();
		byte generatedCanary2 = victim.getCanary2();
		byte generatedCanary3 = victim.getCanary3();
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		Curl_easy curl_easy = new Curl_easy();
		Curl_multi curl_multi = new Curl_multi();
		Curl_addrinfo generatedAddr = dns.getAddr();
		sockaddr generatedAi_addr = addr.getAi_addr();
		Object generatedAi_addrlen = addr.getAi_addrlen();
		Object generatedTimestamp = dns.getTimestamp();
		Curl_addrinfo generatedAi_next = addr.getAi_next();
		return ModernizedCProgram.unitfail;
		 curl = new ();
		 res = CURLE_FAILED_INIT;
		int i;
		curl_slist headerlist = ((Object)0);
		curl_slist hl = new curl_slist();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		for (i = 0; i < 8; i++) {
			int len = ModernizedCProgram.curl_msnprintf(ModernizedCProgram.buf, , "Header%d: ", i);
			.memset(ModernizedCProgram.buf[len], (byte)'A', 5000);
			ModernizedCProgram.buf[len + 5000] = /* zero terminate */0;
			hl = headerlist.curl_slist_append(ModernizedCProgram.buf);
			if (!hl) {
				;
			} 
			headerlist = hl;
		}
		hl = headerlist.curl_slist_append("Expect: ");
		if (!hl) {
			;
		} 
		headerlist = hl;
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (headerlist))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)40960))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (myreadfunc))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		headerlist.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		byte[] a = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		 res = new ();
		 curl = new ();
		int asize;
		byte str = ((Object)0);
		(Object)URL;
		res = ModernizedCProgram.curl_global_init_mem(CURL_GLOBAL_ALL, ModernizedCProgram.custom_malloc, ModernizedCProgram.custom_free, ModernizedCProgram.custom_realloc, ModernizedCProgram.custom_strdup, ModernizedCProgram.custom_calloc);
		if (res != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init_mem() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERAGENT), ("test509"))) != /* uses strdup() */CURLE_OK) {
			;
		} 
		asize = (int);
		str = curl.curl_easy_escape((byte)a, /* uses realloc() */asize);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		WriteThis pooh = new WriteThis();
		pooh.setReadptr(ModernizedCProgram.data);
		pooh.setSizeleft(.strlen(ModernizedCProgram.data));
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL)) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)generatedSizeleft))) != /* Set the expected POST size */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (pooh))) != /* pointer to pass to our read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK/* detect HTTP error codes >= 400 *//* test_setopt(curl, CURLOPT_FAILONERROR, 1L); */) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 dupe = ((Object)0);
		long filetime;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0/* Test that a filetime is properly initialized on curl_easy_init.
		  */);
		res = curl.curl_easy_getinfo(CURLINFO_FILETIME, filetime);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 44, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (filetime != -1) {
			(_iob[2]).curl_mfprintf("%s:%d filetime init failed; expected -1 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 49, filetime);
			res = CURLE_FAILED_INIT;
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_FILETIME))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 60, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_FILETIME, /* Test that a filetime is properly set after receiving an HTTP resource.
		  */filetime);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 70, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (filetime != 30) {
			(_iob[2]).curl_mfprintf("%s:%d filetime of http resource is incorrect; expected 30 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 76, filetime);
			res = CURLE_HTTP_RETURNED_ERROR;
			;
		} 
		dupe = /* Test that a filetime is properly initialized on curl_easy_duphandle.
		  */curl.curl_easy_duphandle();
		if (!dupe) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_duphandle() failed\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 87);
			res = CURLE_FAILED_INIT;
			;
		} 
		res = dupe.curl_easy_getinfo(CURLINFO_FILETIME, filetime);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 95, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (filetime != -1) {
			(_iob[2]).curl_mfprintf("%s:%d filetime init failed; expected -1 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 100, filetime);
			res = CURLE_FAILED_INIT;
			;
		} 
		/* Test that a filetime is properly initialized on curl_easy_reset.
		  */curl.curl_easy_reset();
		res = curl.curl_easy_getinfo(CURLINFO_FILETIME, filetime);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 114, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (filetime != -1) {
			(_iob[2]).curl_mfprintf("%s:%d filetime init failed; expected -1 but is %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1534.c", 119, filetime);
			res = CURLE_FAILED_INIT;
			;
		} 
		dupe.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res;
		 curl = new ();
		int params;
		FILE paramsf = ((Object)0);
		_stati64 file_info = new _stati64();
		byte stream_uri = ((Object)0);
		int request = 1;
		curl_slist custom_headers = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* SETUP */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_TRANSPORT), ("Planes/Trains/Automobiles"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_SETUP))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		params = .open("log/file572.txt", /* PUT style GET_PARAMETERS */0);
		._fstati64(params, file_info);
		.close(params);
		paramsf = .fopen("log/file572.txt", "rb");
		if (paramsf == ((Object)0)) {
			(_iob[2]).curl_mfprintf("can't open log/file572.txt\n");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_GET_PARAMETER))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (paramsf))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		Object generatedSt_size = file_info.getSt_size();
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE_LARGE), (()generatedSt_size))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		.fclose(paramsf);
		paramsf = ((Object)0);
		stream_uri = ModernizedCProgram.suburl(URL, /* Heartbeat GET_PARAMETERS */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* POST GET_PARAMETERS */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_GET_PARAMETER))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), ("packets_received\njitter\n"))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), (((Object)0)))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, /* Make sure we can do a normal request now */request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_OPTIONS))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(stream_uri);
		if (custom_headers) {
			custom_headers.curl_slist_free_all();
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 handle = ((Object)0);
		 res = 0;
		 urlp = ((Object)0);
		 uc = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((handle))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		urlp = .curl_url();
		if (!urlp) {
			(_iob[2]).curl_mfprintf("problem init URL api.");
			;
		} 
		uc = .curl_url_set(urlp, CURLUPART_URL, URL, 0);
		if (uc) {
			(_iob[2]).curl_mfprintf("problem setting CURLUPART_URL.");
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_URL))), ((("http://www.example.com"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* demonstrate override behavior */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_CURLU))), (((urlp))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = handle.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib658.c", 65, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		 curl = ((Object)0);
		int running;
		 m = ((Object)0);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXY))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXYTYPE))), ((((long)CURLPROXY_SOCKS4))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("Start at URL 0\n");
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib564.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 handle = ((Object)0);
		 duphandle = ((Object)0);
		 mhandle = ((Object)0);
		int res = 0;
		int still_running = 0;
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((handle))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_WILDCARDMATCH))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((handle))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = handle.curl_easy_perform();
		if (res) {
			;
		} 
		res = handle.curl_easy_perform();
		if (res) {
			;
		} 
		duphandle = handle.curl_easy_duphandle();
		if (!duphandle) {
			;
		} 
		handle.curl_easy_cleanup();
		handle = duphandle;
		do {
			do {
				if (((((mhandle))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((mhandle))), (((handle))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((mhandle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			ModernizedCProgram.timeout.setTv_sec(0);
			ModernizedCProgram.timeout.setTv_usec(/* 100 ms */-1024);
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((mhandle))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((mhandle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib575.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		res = ModernizedCProgram.once(URL, /* old */1);
		if (!res) {
			res = ModernizedCProgram.once(URL, /* new */0);
		} 
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = ((Object)0);
		long main_auth_scheme = ModernizedCProgram.parse_auth_name(ModernizedCProgram.libtest_arg2);
		long fallback_auth_scheme = ModernizedCProgram.parse_auth_name(ModernizedCProgram.libtest_arg3);
		if (main_auth_scheme == CURLAUTH_NONE || fallback_auth_scheme == CURLAUTH_NONE) {
			(_iob[2]).curl_mfprintf("auth schemes not found on commandline\n");
			return 126;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.send_wrong_password(curl, url, 100, main_auth_scheme);
		if (res != CURLE_OK) {
			;
		} 
		res = ModernizedCProgram.send_right_password(curl, url, 200, fallback_auth_scheme);
		if (res != CURLE_OK) {
			;
		} 
		curl.curl_easy_cleanup();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.send_wrong_password(curl, url, 300, main_auth_scheme);
		if (res != CURLE_OK) {
			;
		} 
		res = ModernizedCProgram.send_wrong_password(curl, url, 400, fallback_auth_scheme);
		if (res != CURLE_OK) {
			;
		} 
		res = ModernizedCProgram.send_right_password(curl, url, 500, fallback_auth_scheme);
		if (res != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res = 0;
		[] curl = new []{((Object)0), ((Object)0)};
		byte port = ModernizedCProgram.libtest_arg3;
		byte address = ModernizedCProgram.libtest_arg2;
		byte[] dnsentry = new byte[256];
		curl_slist slist = ((Object)0);
		int i;
		byte[] target_url = new byte[256];
		(Object)/* URL is setup in the code */URL;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		ModernizedCProgram.curl_msnprintf(dnsentry, , "server.example.curl:%s:%s", port, address);
		ModernizedCProgram.curl_mprintf("%s\n", dnsentry);
		slist = slist.curl_slist_append(dnsentry);
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < 2; /* get NUM_HANDLES easy handles */i++) {
			do {
				do {
					if (((((curl[i]))) = curl_easy.curl_easy_init()) == ((Object)0)) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))));
						res = 124;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* get an easy handle */0);
			ModernizedCProgram.curl_msnprintf(target_url, , "http://server.example.curl:%s/path/1512%04i", port, i + 1);
			target_url[ - 1] = (byte)'\0';
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_URL))), (((target_url))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* go verbose */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* include headers */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_DNS_USE_GLOBAL_CACHE))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		do {
			do {
				 ec = new ();
				if ((ec = (((curl[0]))).curl_easy_setopt((((CURLOPT_RESOLVE))), (((slist))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1512.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* make the first one populate the GLOBAL cache */0);
		for (i = 0; (i < 2) && !res; /* run NUM_HANDLES transfers */i++) {
			res = curl[i].curl_easy_perform();
		}
		curl[1].curl_easy_cleanup();
		slist.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 http_handle = ((Object)0);
		 multi_handle = ((Object)0);
		int res = 0;
		/* keep number of running handles */int still_running;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0/*
		  ** curl_global_init called indirectly from curl_easy_init.
		  */);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((http_handle))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((http_handle))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* set options */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((http_handle))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((http_handle))).curl_easy_setopt((((CURLOPT_SSL_VERIFYPEER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((http_handle))).curl_easy_setopt((((CURLOPT_SSL_VERIFYHOST))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi_handle))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* init a multi stack */0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi_handle))), (((http_handle))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* add the individual transfers */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi_handle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* we start some action by calling perform right away */0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi_handle))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* get file descriptors from the transfers */0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi_handle))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* timeout or readable/writable sockets */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib560.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		http_handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res;
		 curl = new ();
		int request = 1;
		byte stream_uri = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_OPTIONS))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		res = curl.curl_easy_perform();
		if (res != (int)CURLE_RTSP_CSEQ_ERROR) {
			(_iob[2]).curl_mfprintf("Failed to detect CSeq mismatch");
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_CLIENT_CSEQ), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_TRANSPORT), ("RAW/RAW/UDP;unicast;client_port=3056-3057"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_SETUP))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_PLAY))) != CURLE_OK) {
			;
		} 
		stream_uri = ModernizedCProgram.suburl(URL, request++);
		if (!stream_uri) {
			res = 126;
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
			;
		} 
		.free(stream_uri);
		stream_uri = ((Object)0);
		res = curl.curl_easy_perform();
		if (res != CURLE_RTSP_SESSION_ERROR) {
			(_iob[2]).curl_mfprintf("Failed to detect a Session ID mismatch");
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist slist = ((Object)0);
		WriteThis pooh = new WriteThis();
		pooh.setCounter(0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		slist = slist.curl_slist_append("Transfer-Encoding: chunked");
		if (slist == ((Object)0)) {
			(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (pooh))) != /* pointer to pass to our read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (slist))) != /* enforce chunked transfer by setting the header */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		/* always cleanup */curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 res = CURLE_OK;
		 share = new ();
		int i;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1554.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_share curl_share = new Curl_share();
		share = curl_share.curl_share_init();
		if (!share) {
			(_iob[2]).curl_mfprintf("curl_share_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_CONNECT);
		share.curl_share_setopt(CURLSHOPT_LOCKFUNC, my_lock);
		share.curl_share_setopt(CURLSHOPT_UNLOCKFUNC, my_unlock/* Loop the transfer and cleanup the handle properly every lap. This will
		     still reuse connections since the pool is in the shared object! */);
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < 3; i++) {
			 curl = curl_easy.curl_easy_init();
			if (ModernizedCProgram.curl) {
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, URL);
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SHARE, /* use the share object */share);
				res = /* Perform the request, res will get the return code */ModernizedCProgram.curl.curl_easy_perform();
				if (res != /* Check for errors */CURLE_OK) {
					(_iob[2]).curl_mfprintf("curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				} 
				/* always cleanup */ModernizedCProgram.curl.curl_easy_cleanup();
			} 
		}
		share.curl_share_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 res = new ();
		 curl = new ();
		int counter = 0;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK/* set the data to POST with a mere pointer to a zero-terminated string */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_IOCTLFUNCTION), (ioctlcallback))) != /* 547 style, which means reading the POST data from a callback */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_IOCTLDATA), (counter))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (readcallback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (counter))) != CURLE_OK/* We CANNOT do the POST fine without setting the size (or choose
		     chunked)! */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long).strlen("this is the blurb we want to upload\n")))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYUSERPWD), (ModernizedCProgram.libtest_arg3))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYAUTH), ((long)(CURLAUTH_NTLM | CURLAUTH_DIGEST | CURLAUTH_BASIC)))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		curl_slist hhl = ((Object)0);
		curl_slist tmp = ((Object)/* http header list*/0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		hhl = hhl.curl_slist_append("User-Agent: Http Agent");
		if (!hhl) {
			;
		} 
		tmp = hhl.curl_slist_append("Expect: 100-continue");
		if (!tmp) {
			;
		} 
		hhl = tmp;
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYTYPE), (CURLPROXY_HTTP))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (ModernizedCProgram.fwrite))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPROXYTUNNEL), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE), ((long).strlen(ModernizedCProgram.data)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADEROPT), (CURLHEADER_UNIFIED))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		hhl.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = new ();
		 res = CURLE_OK;
		data config = new data();
		size_t i = new size_t();
		byte[] fill = "test data";
		config.setTrace_ascii(/* enable ascii tracing */1);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib552.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		if ((res = (curl).curl_easy_setopt((CURLOPT_DEBUGFUNCTION), (my_trace))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_DEBUGDATA), (config))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* the DEBUGFUNCTION has no effect until we enable VERBOSE */CURLE_OK) {
			;
		} 
		for (i = 0; i < ; ++/* setup repeated data string */i) {
			ModernizedCProgram.databuf[i] = fill[i % ];
		}
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Post */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)))) != /* Setup read callback */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (write_callback))) != /* Write callback */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_IOCTLFUNCTION), (ioctl_callback))) != /* Ioctl function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYAUTH), ((long)CURLAUTH_ANY))) != /* Accept any auth. But for this bug configure proxy with DIGEST, basic
		     might work too, not NTLM */CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		(_iob[2]).curl_mfprintf("curl_easy_perform = %d\n", (int)res);
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		curl_llist_element generatedNext = head.getNext();
		curl_llist_element generatedPrev = to_remove.getPrev();
		return ModernizedCProgram.unitfail;
		int res = 0;
		 easyret = new ();
		 multiret = new ();
		 shareret = new ();
		(Object)URL;
		ModernizedCProgram.curl_easy_strerror(INT_MAX);
		ModernizedCProgram.curl_multi_strerror(INT_MAX);
		ModernizedCProgram.curl_share_strerror(INT_MAX);
		ModernizedCProgram.curl_easy_strerror(-INT_MAX);
		ModernizedCProgram.curl_multi_strerror(-INT_MAX);
		ModernizedCProgram.curl_share_strerror(-INT_MAX);
		for (easyret = CURLE_OK; easyret <= CURL_LAST; easyret++) {
			ModernizedCProgram.curl_mprintf("e%d: %s\n", (int)easyret, ModernizedCProgram.curl_easy_strerror(easyret));
		}
		for (multiret = CURLM_CALL_MULTI_PERFORM; multiret <= CURLM_LAST; multiret++) {
			ModernizedCProgram.curl_mprintf("m%d: %s\n", (int)multiret, ModernizedCProgram.curl_multi_strerror(multiret));
		}
		for (shareret = CURLSHE_OK; shareret <= CURLSHE_LAST; shareret++) {
			ModernizedCProgram.curl_mprintf("s%d: %s\n", (int)shareret, ModernizedCProgram.curl_share_strerror(shareret));
		}
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY_TRANSFER_MODE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if (ModernizedCProgram.libtest_arg3) {
			if ((res = (curl).curl_easy_setopt((CURLOPT_TRANSFERTEXT), (true))) != /* enable ascii/text mode */CURLE_OK) {
				;
			} 
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 sh = ((Object)0);
		 ch = ((Object)0);
		int unfinished;
		Curl_multi curl_multi = new Curl_multi();
		 cm = curl_multi.curl_multi_init();
		if (!cm) {
			return 1;
		} 
		Curl_share curl_share = new Curl_share();
		sh = curl_share.curl_share_init();
		if (!sh) {
			;
		} 
		sh.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);
		sh.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);
		Curl_easy curl_easy = new Curl_easy();
		ch = curl_easy.curl_easy_init();
		if (!ch) {
			;
		} 
		ch.curl_easy_setopt(CURLOPT_SHARE, sh);
		ch.curl_easy_setopt(CURLOPT_URL, URL);
		ch.curl_easy_setopt(CURLOPT_COOKIEFILE, "log/cookies1905");
		ch.curl_easy_setopt(CURLOPT_COOKIEJAR, "log/cookies1905");
		ModernizedCProgram.curl_multi_add_handle(cm, ch);
		unfinished = 1;
		while (unfinished) {
			int MAX = 0;
			long max_tout;
			fd_set R = new fd_set();
			fd_set W = new fd_set();
			fd_set E = new fd_set();
			timeval timeout = new timeval();
			(((fd_set)(R)).setFd_count(0));
			(((fd_set)(W)).setFd_count(0));
			(((fd_set)(E)).setFd_count(0));
			cm.curl_multi_perform(unfinished);
			ModernizedCProgram.curl_multi_fdset(cm, R, W, E, MAX);
			cm.curl_multi_timeout(max_tout);
			if (max_tout > 0) {
				ModernizedCProgram.timeout.setTv_sec(max_tout / 1000);
				ModernizedCProgram.timeout.setTv_usec((max_tout % 1000) * 1000);
			} else {
					ModernizedCProgram.timeout.setTv_sec(0);
					ModernizedCProgram.timeout.setTv_usec(1000);
			} 
			.select(MAX + 1, R, W, E, ModernizedCProgram.timeout);
		}
		ch.curl_easy_setopt(CURLOPT_COOKIELIST, "FLUSH");
		ch.curl_easy_setopt(CURLOPT_SHARE, ((Object)0));
		ModernizedCProgram.curl_multi_remove_handle(cm, ch);
		sh.curl_share_cleanup();
		cm.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK/* Based on a bug report by Niels van Tongeren on June 29, 2004:
		
		  A weird situation occurs when request 1 is a POST request and the request
		  2 is a HEAD request. For the POST request we set the CURLOPT_POSTFIELDS,
		  CURLOPT_POSTFIELDSIZE and CURLOPT_POST options. For the HEAD request we
		  set the CURLOPT_NOBODY option to '1'.
		
		  */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), ("moo"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK/* this is where transfer 1 would take place, but skip that and change
		     options right away instead */) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* show verbose for debug */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include header */CURLE_OK/* Now, we should be making a fine HEAD request */) {
			;
		} 
		res = /* Perform the request 2, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 result = CURLE_OK;
		int res = 0;
		WriteThis pooh = new WriteThis(ModernizedCProgram.data,  - 1);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_POST))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READFUNCTION))), (((read_callback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* Purposely omit to set CURLOPT_POSTFIELDSIZE */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_READDATA))), (((pooh))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1514.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		result = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)result;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)arg;
		int generatedTv_usec = key.getTv_usec();
		Object generatedPayload = removed.getPayload();
		return ModernizedCProgram.unitfail;
		long unmet;
		 curl = ((Object)0);
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMECONDITION))), ((((long)CURL_TIMECOND_IFMODSINCE))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMEVALUE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* TIMEVALUE in the future */0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		curl.curl_easy_getinfo(CURLINFO_CONDITION_UNMET, unmet);
		if (unmet != -1024) {
			res = /* not correct */119;
			;
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_TIMEVALUE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1511.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* TIMEVALUE in the past */0);
		res = curl.curl_easy_perform();
		if (res) {
			;
		} 
		curl.curl_easy_getinfo(CURLINFO_CONDITION_UNMET, unmet);
		if (unmet != -1024) {
			res = /* not correct */119;
			;
		} 
		res = /* this is where we should be */120;
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		curl_slist hhl = ((Object)/* http and proxy header list*/0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		hhl = hhl.curl_slist_append("User-Agent: Http Agent");
		if (!hhl) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADEROPT), (CURLHEADER_UNIFIED))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYTYPE), (CURLPROXY_HTTP))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (ModernizedCProgram.fwrite))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPROXYTUNNEL), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE), ((long).strlen(ModernizedCProgram.data)))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		hhl.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDS), (((Object)0)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* show verbose for debug */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include header */CURLE_OK) {
			;
		} 
		res = /* Now, we should be making a zero byte POST request */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		byte[] bURL = new byte[512];
		ModernizedCProgram.curl_msnprintf(bURL, , "%s HTTP/1.1\r\nGET http://1529.com/1529", URL);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (bURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYTYPE), (CURLPROXY_HTTP))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curls = ((Object)0);
		 multi = ((Object)0);
		int still_running;
		int i = -1;
		int res = 0;
		 msg = new ();
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((curls))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(1);
			ModernizedCProgram.timeout.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib507.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		msg = multi.curl_multi_info_read(still_running);
		if (msg/* this should now contain a result code from the easy handle,
		       get it */) {
			i = msg.getData().getResult();
		} 
		curls.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (res) {
			i = res;
		} 
		return /* return the final return code */i;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = new ();
		 res = CURLE_OK;
		long curlResponseCode;
		long curlRedirectCount;
		byte effectiveUrl = ((Object)0);
		byte redirectUrl = ((Object)0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FOLLOWLOCATION), (true))) != /* just to make it explicit and visible in this test: */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		curl.curl_easy_getinfo(CURLINFO_RESPONSE_CODE, curlResponseCode);
		curl.curl_easy_getinfo(CURLINFO_REDIRECT_COUNT, curlRedirectCount);
		curl.curl_easy_getinfo(CURLINFO_EFFECTIVE_URL, effectiveUrl);
		curl.curl_easy_getinfo(CURLINFO_REDIRECT_URL, redirectUrl);
		ModernizedCProgram.curl_mprintf("res: %d\nstatus: %d\nredirects: %d\neffectiveurl: %s\nredirecturl: %s\n", (int)res, (int)curlResponseCode, (int)curlRedirectCount, effectiveUrl, redirectUrl);
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		curltime curltime = new curltime();
		Object generatedTv_sec = now.getTv_sec();
		int generatedTv_usec = now.getTv_usec();
		return ModernizedCProgram.unitfail;
		 curl = new ();
		long httpcode;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c", 43, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_RESPONSE_CODE, httpcode);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c", 50, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (httpcode != 200) {
			(_iob[2]).curl_mfprintf("%s:%d unexpected response code %ld\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c", 55, httpcode);
			res = CURLE_HTTP_RETURNED_ERROR;
			;
		} 
		/* Test for a regression of github bug 1017 (response code does not reset) */curl.curl_easy_reset();
		res = curl.curl_easy_getinfo(CURLINFO_RESPONSE_CODE, httpcode);
		if (res) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c", 66, res, ModernizedCProgram.curl_easy_strerror(res));
			;
		} 
		if (httpcode != 0) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_reset failed to zero the response code\npossible regression of github bug 1017\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1532.c", 71);
			res = CURLE_HTTP_RETURNED_ERROR;
			;
		} 
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int stillRunning;
		 multiHandle = ((Object)0);
		 curl = ((Object)0);
		 res = CURLM_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multiHandle))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_USERPWD))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_SSH_PUBLIC_KEYFILE))), ((("curl_client_key.pub"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_SSH_PRIVATE_KEYFILE))), ((("curl_client_key"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_UPLOAD))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_INFILESIZE))), ((((long)5))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multiHandle))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0/* this tests if removing an easy handle immediately after multi
		     perform has been called succeeds or not. */);
		(_iob[2]).curl_mfprintf("curl_multi_perform()...\n");
		do {
			do {
				 ec = new ();
				if ((ec = (((multiHandle))).curl_multi_perform((((stillRunning))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((stillRunning)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib583.c"))), (((true))), (int)((((stillRunning)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("curl_multi_perform() succeeded\n");
		(_iob[2]).curl_mfprintf("curl_multi_remove_handle()...\n");
		res = ModernizedCProgram.curl_multi_remove_handle(multiHandle, curl);
		if (res) {
			(_iob[2]).curl_mfprintf("curl_multi_remove_handle() failed, with code %d\n", (int)res);
		} else {
				(_iob[2]).curl_mfprintf("curl_multi_remove_handle() succeeded\n");
		} 
		multiHandle.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* enable verbose */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOBODY), (true))) != /* enable NOBODY */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* disable HEADER */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* specify target */CURLE_OK) {
			;
		} 
		res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		[] curl = new ();
		int running;
		 m = ((Object)0);
		int i;
		byte[] target_url = new byte[256];
		int handles_added = 0;
		for (i = 0; i < 4; i++) {
			curl[i] = ((Object)0);
		}
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < 4; /* get NUM_HANDLES easy handles */i++) {
			do {
				do {
					if (((((curl[i]))) = curl_easy.curl_easy_init()) == ((Object)0)) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))));
						res = 124;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* get an easy handle */0);
			ModernizedCProgram.curl_msnprintf(target_url, , "%s%04i", URL, i + /* specify target */1);
			target_url[ - 1] = (byte)'\0';
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_URL))), (((target_url))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* go verbose */0);
			do {
				do {
					 ec = new ();
					if ((ec = (((curl[i]))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* include headers */0);
		}
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl[handles_added++]))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* Add the first handle to multi. We do this to let libcurl detect
		     that the server can do pipelining. The rest of the handles will be
		     added later. */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_setopt((((CURLMOPT_PIPELINING))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("Start at URL 0\n");
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				if (handles_added >= 4) {
					break;
				} 
				while (handles_added < /* Add the rest of the handles now that the first handle has completed
				         its request. */4) {
					do {
						do {
							 ec = new ();
							if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl[handles_added++]))))) != CURLM_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (0);
				}
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib530.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 ret = new ();
		Curl_easy curl_easy = new Curl_easy();
		 hnd = curl_easy.curl_easy_init();
		byte[] buffer = new byte[CURL_ERROR_SIZE];
		hnd.curl_easy_setopt(CURLOPT_URL, URL);
		hnd.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_cb);
		hnd.curl_easy_setopt(CURLOPT_ERRORBUFFER, buffer);
		hnd.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
		hnd.curl_easy_setopt(CURLOPT_XFERINFOFUNCTION, dload_progress_cb);
		ModernizedCProgram.curl_mprintf("Start: %d\n", .time(((Object)0)));
		ret = ModernizedCProgram.run(hnd, 1, 2);
		if (ret) {
			(_iob[2]).curl_mfprintf("error %d: %s\n", ret, buffer);
		} 
		ret = ModernizedCProgram.run(hnd, 12000, 1);
		if (ret != CURLE_OPERATION_TIMEDOUT) {
			(_iob[2]).curl_mfprintf("error %d: %s\n", ret, buffer);
		} else {
				ret = 0;
		} 
		ModernizedCProgram.curl_mprintf("End: %d\n", .time(((Object)0)));
		hnd.curl_easy_cleanup();
		return (int)ret;
		int res;
		 scode = CURLSHE_OK;
		byte url;
		Tdata tdata = new Tdata();
		 curl = new ();
		 share = new ();
		int i;
		userdata user = new userdata();
		user.setText("Pigs in space");
		user.setCounter(0);
		ModernizedCProgram.curl_mprintf("GLOBAL_INIT\n");
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		ModernizedCProgram.curl_mprintf(/* prepare share */"SHARE_INIT\n");
		Curl_share curl_share = new Curl_share();
		share = curl_share.curl_share_init();
		if (!share) {
			(_iob[2]).curl_mfprintf("curl_share_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_LOCKFUNC\n");
			scode = share.curl_share_setopt(CURLSHOPT_LOCKFUNC, my_lock);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_UNLOCKFUNC\n");
			scode = share.curl_share_setopt(CURLSHOPT_UNLOCKFUNC, my_unlock);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURLSHOPT_USERDATA\n");
			scode = share.curl_share_setopt(CURLSHOPT_USERDATA, user);
		} 
		if (CURLSHE_OK == scode) {
			ModernizedCProgram.curl_mprintf("CURL_LOCK_DATA_SSL_SESSION\n");
			scode = share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_SSL_SESSION);
		} 
		if (CURLSHE_OK != scode) {
			(_iob[2]).curl_mfprintf("curl_share_setopt() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = 0;
		for (i = 1; i <= 2; /* start treads */i++) {
			tdata.setUrl(/* set thread data */URL);
			tdata.setShare(share);
			ModernizedCProgram.curl_mprintf("*** run %d\n", /* simulate thread, direct call of "thread" function */i);
			ModernizedCProgram.fire(tdata);
		}
		ModernizedCProgram.curl_mprintf("*** run %d\n", /* fetch a another one */i);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			share.curl_share_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		url = URL;
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (url))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		if ((res = (curl).curl_easy_setopt((CURLOPT_SHARE), (share))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.curl_mprintf("PERFORM\n");
		curl.curl_easy_perform();
		ModernizedCProgram.curl_mprintf(/* try to free share, expect to fail because share is in use*/"try SHARE_CLEANUP...\n");
		scode = share.curl_share_cleanup();
		if (scode == CURLSHE_OK) {
			(_iob[2]).curl_mfprintf("curl_share_cleanup succeed but error expected\n");
			share = ((Object)0);
		} else {
				ModernizedCProgram.curl_mprintf("SHARE_CLEANUP failed, correct\n");
		} 
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_mprintf(/* free share */"SHARE_CLEANUP\n");
		scode = share.curl_share_cleanup();
		if (scode != CURLSHE_OK) {
			(_iob[2]).curl_mfprintf("curl_share_cleanup failed, code errno %d\n", (int)scode);
		} 
		ModernizedCProgram.curl_mprintf("GLOBAL_CLEANUP\n");
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		 formrc = new ();
		curl_httppost formpost = ((Object)0);
		curl_httppost lastptr = ((Object)0);
		/* create a buffer with AAAA...BBBBB...CCCC...etc */int i;
		int size = (int) / 1000;
		for (i = 0; i < size; i++) {
			.memset(ModernizedCProgram.buffer[i * 1000], 65 + i, 1000);
		}
		ModernizedCProgram.buffer[ - 1] = /* zero terminate */0;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		formrc = formpost.curl_formadd(/* Check proper name and data copying. */lastptr, CURLFORM_COPYNAME, "hello", CURLFORM_COPYCONTENTS, ModernizedCProgram.buffer, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(1) = %d\n", (int)formrc);
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			formpost.curl_formfree();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPOST), (formpost))) != /* send a multi-part formpost */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		/* now cleanup the formpost chain */formpost.curl_formfree();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_COPYPOSTFIELDS), (ModernizedCProgram.teststring))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* show verbose for debug */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include header */CURLE_OK) {
			;
		} 
		.strcpy(ModernizedCProgram.teststring, /* Update the original data to detect non-copy. */"FAIL");
		res = /* Now, this is a POST request with binary 0 embedded in POST data. */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 code = new ();
		 curl = ((Object)0);
		int res = 0;
		headerinfo info = new headerinfo(0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADERFUNCTION))), (((header))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADERDATA))), (((info))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		code = curl.curl_easy_perform();
		if (CURLE_OK != code) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed, with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1556.c", 65, (int)code, ModernizedCProgram.curl_easy_strerror(code));
			res = 126;
			;
		} 
		Object generatedLargest = info.getLargest();
		ModernizedCProgram.curl_mprintf("Max: %ld\n", (long)generatedLargest);
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curls = ((Object)0);
		 multi = ((Object)0);
		int still_running;
		int i = 119;
		int res = 0;
		 msg = new ();
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((curls))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			int num;
			res = .curl_multi_wait(multi, ((Object)0), 0, 60 * 1000, num);
			if (res != CURLM_OK) {
				ModernizedCProgram.curl_mprintf("curl_multi_wait() returned %d\n", res);
				res = 126;
				;
			} 
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1500.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		msg = multi.curl_multi_info_read(still_running);
		if (msg/* this should now contain a result code from the easy handle,
		       get it */) {
			i = msg.getData().getResult();
		} 
		curls.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (res) {
			i = res;
		} 
		return /* return the final return code */i;
		 res = new ();
		 curl = new ();
		byte newURL = ((Object)0);
		curl_slist slist = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /*
		    * Begin with curl set to use a single CWD to the URL's directory.
		    */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_SINGLECWD))) != CURLE_OK) {
			;
		} 
		res = curl/*
		    * Change the FTP_FILEMETHOD option to use full paths rather than a CWD
		    * command.  Alter the URL's path a bit, appending a "./".  Use an innocuous
		    * QUOTE command, after which curl will CWD to ftp_conn->entrypath and then
		    * (on the next call to ftp_statemach_act) find a non-zero ftpconn->dirdepth
		    * even though no directories are stored in the ftpconn->dirs array (after a
		    * call to freedirs).
		    */.curl_easy_perform();
		newURL = ModernizedCProgram.curl_maprintf("%s./", URL);
		if (newURL == ((Object)0)) {
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		slist = ((Object)0).curl_slist_append("SYST");
		if (slist == ((Object)0)) {
			.free(newURL);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (newURL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FTP_FILEMETHOD), ((long)CURLFTPMETHOD_NOCWD))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_QUOTE), (slist))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		.free(newURL);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curls = ((Object)0);
		int i = 0;
		int res = 0;
		transfer_status st = new transfer_status();
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		.memset(st, 0, );
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		st.setEasy(/* to allow callbacks access */curls);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_WRITEFUNCTION))), (((write_callback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_WRITEDATA))), (((st))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADERFUNCTION))), (((header_callback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADERDATA))), (((st))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_XFERINFOFUNCTION))), (((please_continue))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_XFERINFODATA))), (((st))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_NOPROGRESS))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1540.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curls.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		if (res) {
			i = res;
		} 
		return /* return the final return code */i;
		 res = new ();
		 curl = new ();
		(Object)/* we don't use this */URL;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MAXREDIRS), (true))) != /* just verify that setting this to -1 is fine */CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		WriteThis pooh = new WriteThis();
		pooh.setReadptr(ModernizedCProgram.data);
		pooh.setSizeleft(.strlen(ModernizedCProgram.data));
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK/* Convert the POST data to ASCII */) {
			;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)generatedSizeleft))) != /* Set the expected POST size */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (pooh))) != /* pointer to pass to our read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		int errors = 0;
		(Object)/* not used */URL/*
		   * The test makes assumptions about the numeric locale (specifically,
		   * RADIXCHAR) so set it to a known working (and portable) one.
		   */;
		.setlocale(4, "C");
		errors += ModernizedCProgram.test_weird_arguments();
		errors += ModernizedCProgram.test_unsigned_short_formatting();
		errors += ModernizedCProgram.test_signed_short_formatting();
		errors += ModernizedCProgram.test_unsigned_int_formatting();
		errors += ModernizedCProgram.test_signed_int_formatting();
		errors += ModernizedCProgram.test_unsigned_long_formatting();
		errors += ModernizedCProgram.test_signed_long_formatting();
		errors += ModernizedCProgram.test_curl_off_t_formatting();
		errors += ModernizedCProgram.test_string_formatting();
		errors += ModernizedCProgram.test_float_formatting();
		if (errors) {
			return 126;
		} else {
				return 0;
		} 
		 curl = new ();
		 res = CURLE_OK;
		double content_length = 0.0;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_NOPROGRESS), (true))) != /* we want to use our own progress function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROGRESSFUNCTION), (progress_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FOLLOWLOCATION), (true))) != /* follow redirects */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		if (!res) {
			FILE moo = new FILE();
			res = curl.curl_easy_getinfo(CURLINFO_CONTENT_LENGTH_DOWNLOAD, content_length);
			moo = .fopen(ModernizedCProgram.libtest_arg2, "wb");
			if (moo) {
				moo.curl_mfprintf("CL: %.0f\n", content_length);
				.fclose(moo);
			} 
		} 
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)/* not used */URL;
		if (ModernizedCProgram.scopeid()) {
			return 6;
		} 
		if (ModernizedCProgram.append()) {
			return 5;
		} 
		if (ModernizedCProgram.set_url()) {
			return 1;
		} 
		if (ModernizedCProgram.set_parts()) {
			return 2;
		} 
		if (ModernizedCProgram.get_url()) {
			return 3;
		} 
		if (ModernizedCProgram.get_parts()) {
			return 4;
		} 
		ModernizedCProgram.curl_mprintf("success\n");
		return 0;
		byte url_after;
		 curlu = .curl_url();
		Curl_easy curl_easy = new Curl_easy();
		 curl = curl_easy.curl_easy_init();
		 curl_code = new ();
		byte[] error_buffer = "";
		.curl_url_set(curlu, CURLUPART_URL, URL, CURLU_DEFAULT_SCHEME);
		curl.curl_easy_setopt(CURLOPT_CURLU, curlu);
		curl.curl_easy_setopt(CURLOPT_ERRORBUFFER, error_buffer);
		curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		curl.curl_easy_setopt(CURLOPT_PORT, /* set a port number that makes this reqeuest fail */-1024);
		curl_code = curl.curl_easy_perform();
		if (!curl_code) {
			(_iob[2]).curl_mfprintf("failure expected, curl_easy_perform returned %ld: <%s>, <%s>\n", (long)curl_code, ModernizedCProgram.curl_easy_strerror(curl_code), error_buffer);
		} 
		.curl_url_get(curlu, CURLUPART_URL, url_after, /* print the used url */0);
		(_iob[2]).curl_mfprintf("curlu now: <%s>\n", url_after);
		ModernizedCProgram.curl_free(url_after);
		curl.curl_easy_setopt(CURLOPT_PORT, /* now reset CURLOP_PORT to go back to originally set port number */-1024);
		curl_code = curl.curl_easy_perform();
		if (curl_code) {
			(_iob[2]).curl_mfprintf("success expected, curl_easy_perform returned %ld: <%s>, <%s>\n", (long)curl_code, ModernizedCProgram.curl_easy_strerror(curl_code), error_buffer);
		} 
		.curl_url_get(curlu, CURLUPART_URL, url_after, /* print url */0);
		(_iob[2]).curl_mfprintf("curlu now: <%s>\n", url_after);
		ModernizedCProgram.curl_free(url_after);
		curl.curl_easy_cleanup();
		.curl_url_cleanup(curlu);
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		int res;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		res = ModernizedCProgram.once(URL, /* old */1);
		if (!res) {
			res = ModernizedCProgram.once(URL, /* new */0);
		} 
		if (!res) {
			res = ModernizedCProgram.cyclic_add();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PORT), (.strtol(ModernizedCProgram.libtest_arg2, ((Object)0), 10)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), ("xxx:yyy"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 res = new ();
		 curl = new ();
		byte ipstr = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.libtest_debug_config.setNohex(1);
		ModernizedCProgram.libtest_debug_config.setTracetime(1);
		if ((res = (curl).curl_easy_setopt((CURLOPT_DEBUGDATA), (ModernizedCProgram.libtest_debug_config))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_DEBUGFUNCTION), (ModernizedCProgram.libtest_debug_cb))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if (ModernizedCProgram.libtest_arg3 && !.strcmp(ModernizedCProgram.libtest_arg3, "activeftp")) {
			if ((res = (curl).curl_easy_setopt((CURLOPT_FTPPORT), ("-"))) != CURLE_OK) {
				;
			} 
		} 
		do {
		} while (0);
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		return /* you end the test code like this: */ModernizedCProgram.unitfail;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FILETIME), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 handle = ((Object)0);
		 res = CURLE_OK;
		chunk_data_t chunk_data = new chunk_data_t(0, 0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		handle = curl_easy.curl_easy_init();
		if (!handle) {
			res = CURLE_OUT_OF_MEMORY;
			;
		} 
		if ((res = (handle).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (handle).curl_easy_setopt((CURLOPT_WILDCARDMATCH), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (handle).curl_easy_setopt((CURLOPT_CHUNK_BGN_FUNCTION), (ModernizedCProgram.chunk_bgn))) != CURLE_OK) {
			;
		} 
		if ((res = (handle).curl_easy_setopt((CURLOPT_CHUNK_END_FUNCTION), (ModernizedCProgram.chunk_end))) != CURLE_OK) {
			;
		} 
		if ((res = (handle).curl_easy_setopt((CURLOPT_CHUNK_DATA), (chunk_data))) != CURLE_OK) {
			;
		} 
		res = handle.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYAUTH), ((long)(CURLAUTH_BASIC | CURLAUTH_DIGEST | CURLAUTH_NTLM)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != /* set in first.c */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYUSERPWD), ("me:password"))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		cb_data data = new cb_data();
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl == ((Object)0)) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		data.reset_data(curl);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK) {
			;
		} 
		Object generatedRemaining_bytes = data.getRemaining_bytes();
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE_LARGE), (()generatedRemaining_bytes))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (data))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (write_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), (data))) != CURLE_OK) {
			;
		} 
		res = ModernizedCProgram.perform_and_check_connections(curl, "First request without CURLOPT_KEEP_SENDING_ON_ERROR", 1);
		if (res != 120) {
			;
		} 
		data.reset_data(curl);
		res = ModernizedCProgram.perform_and_check_connections(curl, "Second request without CURLOPT_KEEP_SENDING_ON_ERROR", 1);
		if (res != 120) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_KEEP_SENDING_ON_ERROR), (true))) != CURLE_OK) {
			;
		} 
		data.reset_data(curl);
		res = ModernizedCProgram.perform_and_check_connections(curl, "First request with CURLOPT_KEEP_SENDING_ON_ERROR", 1);
		if (res != 120) {
			;
		} 
		data.reset_data(curl);
		res = ModernizedCProgram.perform_and_check_connections(curl, "Second request with CURLOPT_KEEP_SENDING_ON_ERROR", 0);
		if (res != 120) {
			;
		} 
		res = 120;
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)arg;
		Curl_easy curl_easy = new Curl_easy();
		return ModernizedCProgram.unitfail;
		(Object)arg;
		Object generatedMagic = empty.getMagic();
		Object generatedConn = empty.getConn();
		Object generatedSet = empty.getSet();
		return ModernizedCProgram.unitfail;
		 curls = ((Object)0);
		int res = 0;
		 field = ((Object)0);
		 mime = ((Object)0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		mime = curls.curl_mime_init();
		field = ModernizedCProgram.curl_mime_addpart(mime);
		ModernizedCProgram.curl_mime_name(field, "name");
		ModernizedCProgram.curl_mime_data(field, "short value", CURL_ZERO_TERMINATED);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_MIMEPOST))), (((mime))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_NOPROGRESS))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib653.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		res = curls.curl_easy_perform();
		if (res) {
			;
		} 
		ModernizedCProgram.curl_mime_data(field, "long value for length change", /* Alter form and resubmit. */CURL_ZERO_TERMINATED);
		res = curls.curl_easy_perform();
		curls.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)/* return the final return code */res;
		int res = 0;
		 curl = ((Object)0);
		 mcurl = ((Object)0);
		int still_running = 1;
		timeval mp_start = new timeval();
		curl_slist rcpt_list = ((Object)0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1507.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((mcurl))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1507.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		rcpt_list = rcpt_list.curl_slist_append("<1507-recipient@example.com>"/* more addresses can be added here
		      rcpt_list = curl_slist_append(rcpt_list, "<others@example.com>");
		   */);
		curl.curl_easy_setopt(CURLOPT_URL, URL);
		curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
		curl.curl_easy_setopt(CURLOPT_READFUNCTION, read_callback);
		curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<1507-realuser@example.com>");
		curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, rcpt_list);
		curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((mcurl))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1507.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		timeval timeval = new timeval();
		mp_start = timeval.tutil_tvnow();
		mcurl.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -1;
			long curl_timeo = -1;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			mcurl.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			ModernizedCProgram.curl_multi_fdset(mcurl, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd/* In a real-world program you OF COURSE check the return code of the
			       function calls.  On success, the value of maxfd is guaranteed to be
			       greater or equal than -1.  We call select(maxfd + 1, ...), specially in
			       case of (maxfd == -1), we call select(0, ...), which is basically equal
			       to sleep. */);
			rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, ModernizedCProgram.timeout);
			if (timeval.tutil_tvnow().tutil_tvdiff(mp_start) > 60 * 1000) {
				(_iob[2]).curl_mfprintf("ABORTING TEST, since it seems that it would have run forever.\n");
				break;
			} 
			switch (rc) {
			case -1/* select error */:
					break;
			case /* timeout */0:
			default:
					mcurl.curl_multi_perform(still_running);
					break;
			}
		}
		ModernizedCProgram.curl_multi_remove_handle(mcurl, curl);
		mcurl.curl_multi_cleanup();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		curl_slist rcpt_list = ((Object)0);
		upload_status upload_ctx = new upload_status(0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		rcpt_list = rcpt_list.curl_slist_append("<recipient@example.com>"/* more addresses can be added here
		     rcpt_list = curl_slist_append(rcpt_list, "<others@example.com>");
		  */);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (upload_ctx))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MAIL_FROM), ("<sender@example.com>"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MAIL_RCPT), (rcpt_list))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curls = ((Object)0);
		 multi = ((Object)0);
		int still_running;
		int i = 0;
		int res = 0;
		 field = ((Object)0);
		 mime = ((Object)0);
		int counter = 1;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		mime = curls.curl_mime_init();
		field = ModernizedCProgram.curl_mime_addpart(mime);
		ModernizedCProgram.curl_mime_name(field, "name");
		ModernizedCProgram.curl_mime_data(field, "value", CURL_ZERO_TERMINATED);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_MIMEPOST))), (((mime))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_USERPWD))), ((("u:s"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_XFERINFOFUNCTION))), (((xferinfo))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_NOPROGRESS))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((curls))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running && counter--) {
			int num;
			res = .curl_multi_wait(multi, ((Object)0), 0, 60 * 1000, num);
			if (res != CURLM_OK) {
				ModernizedCProgram.curl_mprintf("curl_multi_wait() returned %d\n", res);
				res = 126;
				;
			} 
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1553.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		ModernizedCProgram.curl_multi_remove_handle(multi, curls);
		multi.curl_multi_cleanup();
		curls.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (res) {
			i = res;
		} 
		return /* return the final return code */i;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		(Object)URL;
		return 0;
		 res = new ();
		 curl = new ();
		double content_length = 3;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (!res) {
			FILE moo = new FILE();
			res = curl.curl_easy_getinfo(CURLINFO_CONTENT_LENGTH_DOWNLOAD, content_length);
			moo = .fopen(ModernizedCProgram.libtest_arg2, "wb");
			if (moo) {
				moo.curl_mfprintf("CL: %.0f\n", content_length);
				.fclose(moo);
			} 
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 multi = ((Object)0);
		int running;
		int i;
		int num_handles = 0;
		HandleState state = HandleState.ReadyForNewHandle;
		size_t urllen = .strlen(url) + 4 + 1;
		byte full_url = .malloc(urllen);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		if (!full_url) {
			(_iob[2]).curl_mfprintf("Not enough memory for full url\n");
			return 126;
		} 
		for (i = 0; i < 3; ++i) {
			ModernizedCProgram.easy[i] = ((Object)0);
			ModernizedCProgram.sockets[i] = CURL_SOCKET_BAD;
		}
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				ModernizedCProgram.res = (int)ec;
			} 
		} while (0);
		if (ModernizedCProgram.res) {
			.free(full_url);
			return ModernizedCProgram.res;
		} 
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))));
					ModernizedCProgram.res = 123;
				} 
			} while (0);
			if (ModernizedCProgram.res) {
				;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		for (; ; ) {
			timeval interval = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			long timeout = -99;
			int maxfd = -99;
			bool found_new_socket = 0;
			if (HandleState.state == /* Start a new handle if we aren't at the max */HandleState.ReadyForNewHandle) {
				do {
					do {
						if (((((ModernizedCProgram.easy[num_handles]))) = curl_easy.curl_easy_init()) == ((Object)0)) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))));
							ModernizedCProgram.res = 124;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				if (num_handles % 3 == 2) {
					ModernizedCProgram.curl_msnprintf(full_url, urllen, "%s0200", url);
					do {
						do {
							 ec = new ();
							if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_HTTPAUTH))), (((CURLAUTH_NTLM))))) != CURLE_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
								ModernizedCProgram.res = (int)ec;
							} 
						} while (0);
						if (ModernizedCProgram.res) {
							;
						} 
					} while (0);
				} else {
						ModernizedCProgram.curl_msnprintf(full_url, urllen, "%s0100", url);
						do {
							do {
								 ec = new ();
								if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_HTTPAUTH))), (((CURLAUTH_BASIC))))) != CURLE_OK) {
									(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
									ModernizedCProgram.res = (int)ec;
								} 
							} while (0);
							if (ModernizedCProgram.res) {
								;
							} 
						} while (0);
				} 
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_FRESH_CONNECT))), (((true))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_URL))), (((full_url))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_HTTPGET))), (((true))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_USERPWD))), ((("testuser:testpass"))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_WRITEFUNCTION))), (((callback))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_WRITEDATA))), (((ModernizedCProgram.easy + num_handles))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = (((ModernizedCProgram.easy[num_handles]))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				do {
					do {
						 ec = new ();
						if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((ModernizedCProgram.easy[num_handles]))))) != CURLM_OK) {
							(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
							ModernizedCProgram.res = (int)ec;
						} 
					} while (0);
					if (ModernizedCProgram.res) {
						;
					} 
				} while (0);
				num_handles += 1;
				HandleState.state = HandleState.NeedSocketForNewHandle;
			} 
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						ModernizedCProgram.res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)((((running)))));
						ModernizedCProgram.res = 122;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
			(_iob[2]).curl_mfprintf("%s:%d running %d state %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c", 162, running, HandleState.state);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 5 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c")), ((true)));
						ModernizedCProgram.res = 125;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
			if (!running && HandleState.state == HandleState.NoMoreHandles) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						ModernizedCProgram.res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)((((maxfd)))));
						ModernizedCProgram.res = 122;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
			if (HandleState.state == /* At this point, maxfd is guaranteed to be greater or equal than -1. */HandleState.NeedSocketForNewHandle) {
				if (maxfd != -1 && !found_new_socket) {
					(_iob[2]).curl_mfprintf("Warning: socket did not open immediately for new handle (trying again)\n");
					continue;
				} 
				HandleState.state = num_handles < 3 ? HandleState.ReadyForNewHandle : HandleState.NoMoreHandles;
				(_iob[2]).curl_mfprintf("%s:%d new state %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c", 186, HandleState.state);
			} 
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_timeout((((ModernizedCProgram.timeout))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						ModernizedCProgram.res = (int)ec;
					}  else if (((((ModernizedCProgram.timeout)))) < --1024) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() succeeded, but returned invalid timeout value (%ld)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), (long)((((ModernizedCProgram.timeout)))));
						ModernizedCProgram.res = 115;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
			(_iob[2]).curl_mfprintf(/* At this point, timeout is guaranteed to be greater or equal than -1. */"%s:%d num_handles %d timeout %ld running %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c", 194, num_handles, ModernizedCProgram.timeout, running);
			if (ModernizedCProgram.timeout != --1024) {
				int itimeout = (ModernizedCProgram.timeout > (long)2147483647) ? 2147483647 : (int)ModernizedCProgram.timeout;
				interval.setTv_sec(itimeout / 1000);
				interval.setTv_usec((itimeout % 1000) * 1000);
			} else {
					interval.setTv_sec(0);
					interval.setTv_usec(5000/* if there's no timeout and we get here on the last handle, we may
					         already have read the last part of the stream so waiting makes no
					         sense */);
					if (!running && num_handles == 3) {
						break;
					} 
			} 
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c"))), (((true))), ec, .strerror(ec));
						ModernizedCProgram.res = 121;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 5 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c")), ((true)));
						ModernizedCProgram.res = 125;
					} 
				} while (0);
				if (ModernizedCProgram.res) {
					;
				} 
			} while (0);
		}
		multi.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		.free(full_url);
		return ModernizedCProgram.res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		 curl = new ();
		 res = CURLE_OK;
		FILE hd_src = new FILE();
		int hd;
		_stati64 file_info = new _stati64();
		if (!ModernizedCProgram.libtest_arg2) {
			(_iob[2]).curl_mfprintf("Usage: <url> <file-to-upload>\n");
			return 118;
		} 
		hd_src = .fopen(ModernizedCProgram.libtest_arg2, "rb");
		if (((Object)0) == hd_src) {
			(_iob[2]).curl_mfprintf("fopen failed with error: %d %s\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("Error opening file: %s\n", ModernizedCProgram.libtest_arg2);
			return -/* if this happens things are major weird */2;
		} 
		Object generated_file = (hd_src).get_file();
		hd = ._fstati64((generated_file), /* get the file size of the local file */file_info);
		if (hd == -1) {
			(_iob[2]).curl_mfprintf(/* can't open file, bail out */"fstat() failed with error: %d %s\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("ERROR: cannot open file %s\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 126;
		} 
		Object generatedSt_size = file_info.getSt_size();
		if (!generatedSt_size) {
			(_iob[2]).curl_mfprintf("ERROR: file %s has zero size!\n", ModernizedCProgram.libtest_arg2);
			.fclose(hd_src);
			return 126;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			.fclose(hd_src);
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			.fclose(hd_src);
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != /* enable uploading */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* enable verbose */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* specify target */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READDATA), (hd_src))) != /* now specify which file to upload */CURLE_OK) {
			;
		} 
		/* Now run off and do what you've been told! */curl.curl_easy_perform();
		res = /* and now upload the exact same again, but without rewinding so it already
		     is at end of file */curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 curl = ((Object)0);
		 res = CURLE_FAILED_INIT;
		curl_slist hhl = ((Object)0);
		curl_slist phl = ((Object)0);
		curl_slist tmp = ((Object)/* http and proxy header list*/0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		hhl = hhl.curl_slist_append("User-Agent: Http Agent");
		phl = phl.curl_slist_append("User-Agent: Proxy Agent");
		if (!hhl || !phl) {
			;
		} 
		tmp = phl.curl_slist_append("Expect:");
		if (!tmp) {
			;
		} 
		phl = tmp;
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPHEADER), (hhl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYHEADER), (phl))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADEROPT), (CURLHEADER_SEPARATE))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXYTYPE), (CURLPROXY_HTTP))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEFUNCTION), (ModernizedCProgram.fwrite))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPROXYTUNNEL), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_INFILESIZE), ((long).strlen(ModernizedCProgram.data)))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		hhl.curl_slist_free_all();
		phl.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 curls = ((Object)0);
		 multi = ((Object)0);
		int still_running;
		int i = 0;
		int res = 0;
		 msg = new ();
		int counter = 3;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_USERPWD))), ((("u:s"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((curls))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running && counter--) {
			int num;
			res = .curl_multi_wait(multi, ((Object)0), 0, 60 * 1000, num);
			if (res != CURLM_OK) {
				ModernizedCProgram.curl_mprintf("curl_multi_wait() returned %d\n", res);
				res = 126;
				;
			} 
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1552.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		msg = multi.curl_multi_info_read(still_running);
		if (msg/* this should now contain a result code from the easy handle,
		       get it */) {
			i = msg.getData().getResult();
		} 
		curls.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (res) {
			i = res;
		} 
		return /* return the final return code */i;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PROXY), (ModernizedCProgram.libtest_arg2))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_PORT), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), ("xxx:yyy"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_UPLOAD), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 res = new ();
		 curl = new ();
		curl_slist custom_headers = ((Object)0);
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])))) != /* Dump data to stdout for protocol verification */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_OPTIONS))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERAGENT), ("test567"))) != CURLE_OK) {
			;
		} 
		custom_headers = custom_headers.curl_slist_append("Test-Number: 567");
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSPHEADER), (custom_headers))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 c = ((Object)0);
		 m = ((Object)0);
		int res = 0;
		int running;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((c))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_PROXY))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* set in first.c */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_USERPWD))), ((("test:ing"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_PROXYUSERPWD))), ((("test:ing"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_HTTPPROXYTUNNEL))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((c))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib503.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		c.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_REFERER), ("http://example.com/the-moo"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERAGENT), ("the-moo agent next generation"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_COOKIE), ("name=moo"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("retrieve 1 failed\n");
			;
		} 
		curl.curl_easy_reset();
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res) {
			(_iob[2]).curl_mfprintf("retrieve 2 failed\n");
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		 c = ((Object)0);
		 m = ((Object)0);
		int res = 0;
		int running;
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((c))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((c))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			ModernizedCProgram.timeout.setTv_sec(0);
			ModernizedCProgram.timeout.setTv_usec(/* 100 ms */-1024);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib502.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		c.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		int res = 0;
		 curl = ((Object)0);
		int running;
		 m = ((Object)0);
		int current = 0;
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_FAILONERROR))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		(_iob[2]).curl_mfprintf("Start at URL 0\n");
		for (; ; ) {
			timeval interval = new timeval();
			fd_set rd = new fd_set();
			fd_set wr = new fd_set();
			fd_set exc = new fd_set();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				if (!current++) {
					(_iob[2]).curl_mfprintf("Advancing to URL 1\n");
					ModernizedCProgram.curl_multi_remove_handle(m, /* remove the handle we use */curl);
					/* make us re-use the same handle all the time, and try resetting
					           the handle first too */curl.curl_easy_reset();
					do {
						do {
							 ec = new ();
							if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (0);
					do {
						do {
							 ec = new ();
							if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (0);
					do {
						do {
							 ec = new ();
							if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_FAILONERROR))), (((true))))) != CURLE_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (0);
					do {
						do {
							 ec = new ();
							if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curl))))) != CURLM_OK) {
								(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
								res = (int)ec;
							} 
						} while (0);
						if (res) {
							;
						} 
					} while (/* re-add it */0);
				} else {
						break;
				} 
			} 
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib533.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 easy = new ();
		 multi_handle = new ();
		/* keep number of running handles */int still_running;
		/* for picking up messages with the transfer status */ msg = new ();
		/* how many messages are left */int msgs_left;
		int res = CURLE_OK;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1531.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		easy = curl_easy.curl_easy_init();
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_multi_add_handle(multi_handle, /* add the individual transfer */easy);
		easy.curl_easy_setopt(CURLOPT_URL, /* set the options (I left out a few, you'll get the point anyway) */URL);
		easy.curl_easy_setopt(CURLOPT_POSTFIELDSIZE_LARGE, ()ModernizedCProgram.testDataSize);
		easy.curl_easy_setopt(CURLOPT_POSTFIELDS, ModernizedCProgram.testData);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1531.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -1;
			long curl_timeo = -1;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				(_iob[2]).curl_mfprintf("curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case -1/* select error */:
					break;
			case /* timeout */0:
			default:
					multi_handle.curl_multi_perform(still_running);
					break;
			}
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1531.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		} while (still_running);
		/* See how the transfers went */do {
			msg = multi_handle.curl_multi_info_read(msgs_left);
			if (msg && msg.getMsg() == CURLMSG_DONE) {
				ModernizedCProgram.curl_mprintf("HTTP transfer completed with status %d\n", msg.getData().getResult());
				break;
			} 
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1531.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		} while (msg);
		/* Free the CURL handles */easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), ("monster:underbed"))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		res = /* get first page */curl.curl_easy_perform();
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), ("anothermonster:inwardrobe"))) != CURLE_OK) {
			;
		} 
		res = /* get second page */curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		(Object)URL;
		ModernizedCProgram.curl_mprintf("system lacks necessary system function(s)");
		return /* skip test */1/* defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT) */;
		 res = new ();
		 curl = new ();
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_BUFFERSIZE), (true))) != /* the smallest! */CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		int res;
		 curl = new ();
		byte stream_uri = ((Object)0);
		byte rtsp_session_id;
		int request = 1;
		int i;
		FILE idfile = .fopen(ModernizedCProgram.libtest_arg2, "wb");
		if (idfile == ((Object)0)) {
			(_iob[2]).curl_mfprintf("couldn't open the Session ID File\n");
			return 126;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			.fclose(idfile);
			return 126;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			.fclose(idfile);
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_SETUP))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		if (res != (int)CURLE_BAD_FUNCTION_ARGUMENT) {
			(_iob[2]).curl_mfprintf("This should have failed. Cannot setup without a Transport: header");
			res = 126;
			;
		} 
		for (i = 0; i < 3; /* Go through the various Session IDs */i++) {
			stream_uri = ModernizedCProgram.suburl(URL, request++);
			if (!stream_uri) {
				res = 126;
				;
			} 
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
				;
			} 
			.free(stream_uri);
			stream_uri = ((Object)0);
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_SETUP))) != CURLE_OK) {
				;
			} 
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_TRANSPORT), ("Fake/NotReal/JustATest;foo=baz"))) != CURLE_OK) {
				;
			} 
			res = curl.curl_easy_perform();
			if (res) {
				;
			} 
			curl.curl_easy_getinfo(CURLINFO_RTSP_SESSION_ID, rtsp_session_id);
			idfile.curl_mfprintf("Got Session ID: [%s]\n", rtsp_session_id);
			rtsp_session_id = ((Object)0);
			stream_uri = ModernizedCProgram.suburl(URL, request++);
			if (!stream_uri) {
				res = 126;
				;
			} 
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (stream_uri))) != CURLE_OK) {
				;
			} 
			.free(stream_uri);
			stream_uri = ((Object)0);
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), (CURL_RTSPREQ_TEARDOWN))) != CURLE_OK) {
				;
			} 
			res = curl.curl_easy_perform();
			if ((res = (curl).curl_easy_setopt((CURLOPT_RTSP_SESSION_ID), (((Object)0)))) != /* Clear for the next go-round */CURLE_OK) {
				;
			} 
		}
		.free(stream_uri);
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return ModernizedCProgram.unitfail;
		int res = 0;
		 curl = ((Object)0);
		int i;
		byte[] target_url = new byte[256];
		byte[] dnsentry = new byte[256];
		curl_slist slist = ((Object)0);
		curl_slist slist2 = new curl_slist();
		byte port = ModernizedCProgram.libtest_arg3;
		byte address = ModernizedCProgram.libtest_arg2;
		(Object)URL;
		for (i = 0; i < 4; /* Create fake DNS entries for serverX.example.com for all handles */i++) {
			ModernizedCProgram.curl_msnprintf(dnsentry, , "server%d.example.com:%s:%s", i + 1, port, address);
			ModernizedCProgram.curl_mprintf("%s\n", dnsentry);
			slist2 = slist.curl_slist_append(dnsentry);
			if (!slist2) {
				(_iob[2]).curl_mfprintf("curl_slist_append() failed\n");
				;
			} 
			slist = slist2;
		}
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* get an easy handle */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* go verbose */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* include headers */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_RESOLVE))), (((slist))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_MAXCONNECTS))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (i = 0; i < 4; /* get NUM_HANDLES easy handles */i++) {
			ModernizedCProgram.curl_msnprintf(target_url, , "http://server%d.example.com:%s/path/1510%04i", i + 1, port, i + 1);
			target_url[ - 1] = (byte)'\0';
			do {
				do {
					 ec = new ();
					if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((target_url))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			res = curl.curl_easy_perform();
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1510.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		slist.curl_slist_free_all();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 easy = ((Object)0);
		 multi = ((Object)0);
		int res = 0;
		int running;
		int msgs_left;
		 msg = new ();
		FILE upload = ((Object)0);
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		upload = .fopen(ModernizedCProgram.libtest_arg3, "rb");
		if (!upload) {
			(_iob[2]).curl_mfprintf("fopen() failed with error: %d (%s)\n", (._errno()), .strerror((._errno())));
			(_iob[2]).curl_mfprintf("Error opening file: (%s)\n", ModernizedCProgram.libtest_arg3);
			return 117;
		} 
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_global_init(((CURL_GLOBAL_ALL)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			.fclose(upload);
			return res;
		} 
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((easy))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* go verbose */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* specify target */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_UPLOAD))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* enable uploading */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_READDATA))), (((upload))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* data pointer for the file read function */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_FTPPORT))), ((("-"))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* use active mode FTP */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((easy))).curl_easy_setopt((((CURLOPT_ACCEPTTIMEOUT_MS))), (((.strtol(ModernizedCProgram.libtest_arg2, ((Object)0), 10) * 1000))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* server connection timeout */0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((multi))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((multi))), (((easy))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval interval = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			long timeout = -99;
			int maxfd = -99;
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running) {
				break;
			} 
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((multi))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((multi))).curl_multi_timeout((((ModernizedCProgram.timeout))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((ModernizedCProgram.timeout)))) < --1024) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() succeeded, but returned invalid timeout value (%ld)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), (long)((((ModernizedCProgram.timeout)))));
						res = 115;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			if (ModernizedCProgram.timeout != -/* At this point, timeout is guaranteed to be greater or equal than -1. */-1024) {
				int itimeout = (ModernizedCProgram.timeout > (long)2147483647) ? 2147483647 : (int)ModernizedCProgram.timeout;
				interval.setTv_sec(itimeout / 1000);
				interval.setTv_usec((itimeout % 1000) * 1000);
			} else {
					interval.setTv_sec(0);
					interval.setTv_usec(/* 100 ms */-1024);
			} 
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib591.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		msg = multi.curl_multi_info_read(msgs_left);
		if (msg) {
			res = msg.getData().getResult();
		} 
		easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		.fclose(/* close the local file */upload);
		return res;
		byte[] a = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		 res = CURLE_OK;
		byte ptr = ((Object)0);
		int asize;
		(Object)/* we don't use this */URL;
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_global_init() failed\n");
			return 126;
		} 
		ptr = .malloc(558);
		do {
			.free((ptr));
			(ptr) = ((Object)0);
		} while (0);
		asize = (int);
		ptr = ((Object)0).curl_easy_escape((byte)a, asize);
		if (ptr) {
			ModernizedCProgram.curl_free(ptr);
		} 
		ModernizedCProgram.curl_global_cleanup();
		return (int)res;
		long headerSize;
		 code = new ();
		 curl = ((Object)0);
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curl))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_PROXY))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* set in first.c */0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_WRITEFUNCTION))), (((ModernizedCProgram.WriteOutput))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADERFUNCTION))), (((ModernizedCProgram.WriteHeader))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HEADER))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl))).curl_easy_setopt((((CURLOPT_HTTPPROXYTUNNEL))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		code = curl.curl_easy_perform();
		if (CURLE_OK != code) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_perform() failed, with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c", 58, (int)code, ModernizedCProgram.curl_easy_strerror(code));
			res = 126;
			;
		} 
		code = curl.curl_easy_getinfo(CURLINFO_HEADER_SIZE, headerSize);
		if (CURLE_OK != code) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed, with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1509.c", 67, (int)code, ModernizedCProgram.curl_easy_strerror(code));
			res = 126;
			;
		} 
		ModernizedCProgram.curl_mprintf("header length is ........: %ld\n", headerSize);
		ModernizedCProgram.curl_mprintf("header length should be..: %lu\n", ModernizedCProgram.realHeaderSize);
		ModernizedCProgram.curl_global_cleanup();
		return res;
		(Object)arg;
		return /* MSDOS || WIN32 */ModernizedCProgram.unitfail;
		(Object)arg;
		return ModernizedCProgram.unitfail/* nothing to do, just fail */;
		 c = ((Object)0);
		int res = 0;
		 m = ((Object)0);
		fd_set rd = new fd_set();
		fd_set wr = new fd_set();
		fd_set exc = new fd_set();
		int running;
		timeval timeval = new timeval();
		do {
			ModernizedCProgram.tv_test_start = timeval.tutil_tvnow();
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((c))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		if (/* The point here is that there must not be anything running on the given
		     proxy port */ModernizedCProgram.libtest_arg2) {
			do {
				do {
					 ec = new ();
					if ((ec = (((c))).curl_easy_setopt((((CURLOPT_PROXY))), (((ModernizedCProgram.libtest_arg2))))) != CURLE_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
						res = (int)ec;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		} 
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((c))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((m))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((c))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		for (; ; ) {
			timeval interval = new timeval();
			int maxfd = -99;
			interval.setTv_sec(1);
			interval.setTv_usec(0);
			(_iob[2]).curl_mfprintf("curl_multi_perform()\n");
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)((((running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			if (!running/* This is where this code is expected to reach */) {
				int numleft;
				 msg = m.curl_multi_info_read(numleft);
				(_iob[2]).curl_mfprintf("Expected: not running\n");
				if (msg && !numleft) {
					res = /* this is where we should be */120;
				} else {
						res = /* not correct */119;
				} 
				break;
			} 
			(_iob[2]).curl_mfprintf("running == %d\n", running);
			(((fd_set)(rd)).setFd_count(0));
			(((fd_set)(wr)).setFd_count(0));
			(((fd_set)(exc)).setFd_count(0));
			(_iob[2]).curl_mfprintf("curl_multi_fdset()\n");
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((rd))), (((wr))), (((exc))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((rd))), (((wr))), (((exc))), (((interval)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (/* At this point, maxfd is guaranteed to be greater or equal than -1. */0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib504.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		m.curl_multi_cleanup();
		c.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
		 code = new ();
		int rc = 99;
		code = ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		if (code == CURLE_OK) {
			 curl = curl_easy.curl_easy_init();
			if (ModernizedCProgram.curl) {
				 curl2 = new ();
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_HEADER, -1024);
				curl2 = ModernizedCProgram.curl.curl_easy_duphandle();
				if (curl2) {
					code = curl2.curl_easy_setopt(CURLOPT_URL, URL);
					if (code == CURLE_OK) {
						code = curl2.curl_easy_perform();
						if (code == CURLE_OK) {
							rc = 0;
						} else {
								rc = 1;
						} 
					} else {
							rc = 2;
					} 
					curl2.curl_easy_cleanup();
				} else {
						rc = 3;
				} 
				ModernizedCProgram.curl.curl_easy_cleanup();
			} else {
					rc = 4;
			} 
			ModernizedCProgram.curl_global_cleanup();
		} else {
				rc = 5;
		} 
		return rc;
		 curlm = ((Object)0);
		 curl1 = ((Object)0);
		 curl2 = ((Object)0);
		int running_handles = 0;
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_multi curl_multi = new Curl_multi();
		do {
			do {
				if (((((curlm))) = curl_multi.curl_multi_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))));
					res = 123;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curlm))).curl_multi_setopt((((CURLMOPT_MAX_HOST_CONNECTIONS))), (((true))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curl1))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl1))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((curlm))), (((curl1))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				if (((((curl2))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curl2))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((curlm))), (((curl2))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curlm))).curl_multi_perform((((running_handles))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((running_handles)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)((((running_handles)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_remove_handle((((curlm))), (((curl2))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_remove_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		curl2.curl_easy_cleanup();
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_remove_handle((((curlm))), (((curl1))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_remove_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1557.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (/* If curl2 is still in the connect-pending list, this will crash */0);
		curl1.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return res;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* this file is only for systems without getpass_r() */
	/* this file is only for systems without getpass_r() */
	/* keep this as LAST include */
	/* VMS implementation */
	/* MSK, 23-JAN-2004, iosbdef.h wasn't in VAX V7.2 or CC 6.4  */
	/* distribution so I created this.  May revert back later to */
	/* struct _iosb iosb;                                        */
	/* status     */
	/* byte count */
	/* unused     */
	/* we always return success */
	/* __VMS */
	public static Byte getpass_r(Object prompt, Byte buffer, Object buflen) {
		size_t i = new size_t();
		.fputs(prompt, (_iob[2]));
		for (i = 0; i < buflen; i++) {
			buffer[i] = (byte).getch();
			if (buffer[i] == (byte)'\r' || buffer[i] == (byte)'\n') {
				buffer[i] = (byte)'\0';
				break;
			}  else if (buffer[i] == (byte)'\b'/* remove this letter and if this is not the first key, remove the
			           previous one as well */) {
				i = i - (i >= 1 ? 2 : 1);
			} 
		}
		.fputs("\n", (_iob[/* since echo is disabled, print a newline *//* since echo is disabled, print a newline */2]));
		if (i == /* if user didn't hit ENTER, terminate buffer */buflen) {
			buffer[buflen - 1] = (byte)'\0';
		} 
		return /* we always return success */buffer/* WIN32 || __SYMBIAN32__ *//* NetWare implementation */;
	}
	/* remove this letter and if this is not the first key,
	         remove the previous one as well */
	/* __NOVELL_LIBC__ */
	/* NETWARE */
	/* not previously provided */
	/* disable echo by extracting the current 'withecho' mode and remove the
	       ECHO bit and set back the struct */
	/* neither HAVE_TERMIO_H nor HAVE_TERMIOS_H, we can't disable echo! */
	/* not disabled */
	/* disabled */
	/* re-enable echo, assumes we disabled it before (and set the structs we
	     now use to reset the terminal status) */
	/* not enabled */
	/* enabled */
	/* prompt to display */
	/* buffer to store password in */
	/* size of buffer to store password in */
	/* use stdin if the tty couldn't be used */
	/* disable terminal echo */
	/* zero terminate where enter is stored */
	/* got nothing */
	/* if echo actually was disabled, add a newline */
	/* enable echo */
	/* return pointer to buffer */
	/* DONE */
	/* HAVE_GETPASS_R */
	public static void exit_signal_handler(int signum) {
		int old_errno = (._errno());
		if (ModernizedCProgram.got_exit_signal == 0) {
			ModernizedCProgram.got_exit_signal = 1;
			ModernizedCProgram.exit_signal = signum;
		} 
		(Object).signal(signum, ModernizedCProgram.exit_signal_handler);
		(._errno()) = old_errno;
		int old_errno = (._errno());
		if (ModernizedCProgram.got_exit_signal == 0) {
			ModernizedCProgram.got_exit_signal = 1;
			ModernizedCProgram.exit_signal = signum;
		} 
		(Object).signal(signum, ModernizedCProgram.exit_signal_handler);
		(._errno()) = old_errno;
		int old_errno = (._errno());
		if (ModernizedCProgram.got_exit_signal == 0) {
			ModernizedCProgram.got_exit_signal = 1;
			ModernizedCProgram.exit_signal = signum;
		} 
		(Object).signal(signum, ModernizedCProgram.exit_signal_handler);
		(._errno()) = old_errno;
		int old_errno = (._errno());
		if (ModernizedCProgram.got_exit_signal == 0) {
			ModernizedCProgram.got_exit_signal = 1;
			ModernizedCProgram.exit_signal = signum;
		} 
		(Object).signal(signum, ModernizedCProgram.exit_signal_handler);
		(._errno()) = old_errno;
		int old_errno = (._errno());
		if (ModernizedCProgram.got_exit_signal == 0) {
			ModernizedCProgram.got_exit_signal = 1;
			ModernizedCProgram.exit_signal = signum;
		} 
		(Object).signal(signum, ModernizedCProgram.exit_signal_handler);
		(._errno()) = old_errno;
	}
	public static void install_signal_handlers() {
		ModernizedCProgram.old_sigint_handler = .signal(2, /* ignore SIGALRM signal *//* handle SIGINT signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigint_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGINT handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigterm_handler = .signal(15, /* handle SIGTERM signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigterm_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGTERM handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigbreak_handler = .signal(21, /* handle SIGBREAK signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigbreak_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGBREAK handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigint_handler = .signal(2, /* ignore SIGALRM signal *//* handle SIGINT signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigint_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGINT handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigbreak_handler = .signal(21, /* handle SIGBREAK signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigbreak_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGBREAK handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigint_handler = .signal(2, /* ignore SIGPIPE signal *//* handle SIGINT signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigint_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGINT handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigterm_handler = .signal(15, /* handle SIGTERM signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigterm_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGTERM handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigbreak_handler = .signal(21, /* handle SIGBREAK signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigbreak_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGBREAK handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigint_handler = .signal(2, /* ignore SIGALRM signal *//* handle SIGINT signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigint_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGINT handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigterm_handler = .signal(15, /* handle SIGTERM signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigterm_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGTERM handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigbreak_handler = .signal(21, /* handle SIGBREAK signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigbreak_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGBREAK handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigint_handler = .signal(2, /* ignore SIGALRM signal *//* handle SIGINT signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigint_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGINT handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigterm_handler = .signal(15, /* handle SIGTERM signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigterm_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGTERM handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
		ModernizedCProgram.old_sigbreak_handler = .signal(21, /* handle SIGBREAK signal with our exit_signal_handler */ModernizedCProgram.exit_signal_handler);
		if (ModernizedCProgram.old_sigbreak_handler == ((__p_sig_fn_t)-1)) {
			ModernizedCProgram.logmsg("cannot install SIGBREAK handler: %s", .strerror((._errno())));
		} else {
				do {
				} while (0);
		} 
	}
	/* ignore SIGHUP signal */
	/* ignore SIGPIPE signal */
	public static void restore_signal_handlers() {
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigint_handler) {
			(Object).signal(2, ModernizedCProgram.old_sigint_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigterm_handler) {
			(Object).signal(15, ModernizedCProgram.old_sigterm_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigbreak_handler) {
			(Object).signal(21, ModernizedCProgram.old_sigbreak_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigint_handler) {
			(Object).signal(2, ModernizedCProgram.old_sigint_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigbreak_handler) {
			(Object).signal(21, ModernizedCProgram.old_sigbreak_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigint_handler) {
			(Object).signal(2, ModernizedCProgram.old_sigint_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigterm_handler) {
			(Object).signal(15, ModernizedCProgram.old_sigterm_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigbreak_handler) {
			(Object).signal(21, ModernizedCProgram.old_sigbreak_handler/*
			 * init for either read-ahead or write-behind.
			 * zero for write-behind, one for read-head.
			 */);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigint_handler) {
			(Object).signal(2, ModernizedCProgram.old_sigint_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigterm_handler) {
			(Object).signal(15, ModernizedCProgram.old_sigterm_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigbreak_handler) {
			(Object).signal(21, ModernizedCProgram.old_sigbreak_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigint_handler) {
			(Object).signal(2, ModernizedCProgram.old_sigint_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigterm_handler) {
			(Object).signal(15, ModernizedCProgram.old_sigterm_handler);
		} 
		if (((__p_sig_fn_t)-1) != ModernizedCProgram.old_sigbreak_handler) {
			(Object).signal(21, ModernizedCProgram.old_sigbreak_handler);
		} 
	}
	/* store the entire request in a file */
	public static void storerequest(Byte reqbuf, Object totalsize) {
		int res;
		int error = 0;
		size_t written = new size_t();
		size_t writeleft = new size_t();
		FILE dump = new FILE();
		if (reqbuf == ((Object)0)) {
			return ;
		} 
		if (totalsize == 0) {
			return ;
		} 
		do {
			dump = .fopen("log/server.input", "ab");
		} while ((dump == ((Object)0)) && ((error = (._errno())) == 4));
		if (dump == ((Object)0)) {
			ModernizedCProgram.logmsg("Error opening file %s error: %d %s", "log/server.input", error, .strerror(error));
			ModernizedCProgram.logmsg("Failed to write request input to log/server.input");
			return ;
		} 
		writeleft = totalsize;
		do {
			written = .fwrite(reqbuf[totalsize - writeleft], 1, writeleft, dump);
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
			if (written > 0) {
				writeleft -= written;
			} 
		} while ((writeleft > 0) && ((error = (._errno())) == 4));
		if (writeleft == 0) {
			ModernizedCProgram.logmsg("Wrote request (%zu bytes) input to log/server.input", totalsize);
		}  else if (writeleft > 0) {
			ModernizedCProgram.logmsg("Error writing file %s error: %d %s", "log/server.input", error, .strerror(error));
			ModernizedCProgram.logmsg("Wrote only (%zu bytes) of (%zu bytes) request input to %s", totalsize - writeleft, totalsize, "log/server.input");
		} 
		if (res) {
			ModernizedCProgram.logmsg("Error closing file %s error: %d %s", "log/server.input", error, .strerror(error));
		} 
		int res;
		int error = 0;
		size_t written = new size_t();
		size_t writeleft = new size_t();
		FILE dump = new FILE();
		byte dumpfile = ModernizedCProgram.is_proxy ? "log/proxy.input" : "log/server.input";
		if (reqbuf == ((Object)0)) {
			return ;
		} 
		if (totalsize == 0) {
			return ;
		} 
		do {
			dump = .fopen(dumpfile, "ab");
		} while ((dump == ((Object)0)) && ((error = (._errno())) == 4));
		if (dump == ((Object)0)) {
			ModernizedCProgram.logmsg("[2] Error opening file %s error: %d %s", dumpfile, error, .strerror(error));
			ModernizedCProgram.logmsg("Failed to write request input ");
			return ;
		} 
		writeleft = totalsize;
		do {
			written = .fwrite(reqbuf[totalsize - writeleft], 1, writeleft, dump);
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
			if (written > 0) {
				writeleft -= written;
			} 
		} while ((writeleft > 0) && ((error = (._errno())) == 4));
		if (writeleft == 0) {
			ModernizedCProgram.logmsg("Wrote request (%zu bytes) input to %s", totalsize, dumpfile);
		}  else if (writeleft > 0) {
			ModernizedCProgram.logmsg("Error writing file %s error: %d %s", dumpfile, error, .strerror(error));
			ModernizedCProgram.logmsg("Wrote only (%zu bytes) of (%zu bytes) request input to %s", totalsize - writeleft, totalsize, dumpfile);
		} 
		if (res) {
			ModernizedCProgram.logmsg("Error closing file %s error: %d %s", dumpfile, error, .strerror(error));
		} 
	}
	public static int main(int argc, byte argv) {
		srvr_sockaddr_union_t me = new srvr_sockaddr_union_t();
		 sock = CURL_SOCKET_BAD;
		 msgsock = CURL_SOCKET_BAD;
		int wrotepidfile = 0;
		int flag;
		int port = 8999;
		byte pidname = ".rtsp.pid";
		httprequest req = new httprequest();
		int rc;
		int error;
		int arg = 1;
		long pid;
		.memset(req, 0, );
		while (argc > arg) {
			if (!.strcmp("--version", argv[arg])) {
				ModernizedCProgram.curl_mprintf("rtspd IPv4%s\n", "");
				return 0;
			}  else if (!.strcmp("--pidfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					pidname = argv[arg++];
				} 
			}  else if (!.strcmp("--logfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.serverlogfile = argv[arg++];
				} 
			}  else if (!.strcmp("--ipv4", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--ipv6", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--port", argv[arg])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || (ulnum < -1024) || (ulnum > -1024)) {
						(_iob[2]).curl_mfprintf("rtspd: invalid --port argument (%s)\n", argv[arg]);
						return 0;
					} 
					port = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			}  else if (!.strcmp("--srcdir", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.path = argv[arg];
					arg++;
				} 
			} else {
					.puts("Usage: rtspd [option]\n --version\n --logfile [file]\n --pidfile [file]\n --ipv4\n --ipv6\n --port [port]\n --srcdir [path]");
					return 0;
			} 
		}
		ModernizedCProgram.win32_init();
		.atexit(ModernizedCProgram.win32_cleanup);
		ModernizedCProgram.install_signal_handlers();
		pid = (long).getpid();
		sock = .socket(2, 1, 0);
		if (CURL_SOCKET_BAD == sock) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket: (%d) %s", error, .strerror(error));
			;
		} 
		flag = 1;
		if (0 != .setsockopt(sock, -1024, 4, (Object)flag, )) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed with error: (%d) %s", error, .strerror(error));
			;
		} 
		Object generatedSa4 = me.getSa4();
		.memset(generatedSa4, 0, );
		generatedSa4.setSin_family(2);
		generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
		generatedSa4.setSin_port(.htons(port));
		Object generatedSa = me.getSa();
		rc = .bind(sock, generatedSa, );
		if (0 != /* ENABLE_IPV6 */rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error binding socket on port %hu: (%d) %s", port, error, .strerror(error));
			;
		} 
		ModernizedCProgram.logmsg("Running %s version on port %d", ModernizedCProgram.ipv_inuse, (int)port);
		rc = .listen(sock, /* start accepting connections */5);
		if (0 != rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("listen() failed with error: (%d) %s", error, .strerror(error));
			;
		} 
		wrotepidfile = ModernizedCProgram.write_pidfile(pidname);
		if (!wrotepidfile) {
			;
		} 
		 generatedOpen = req.getOpen();
		long generatedTestno = req.getTestno();
		long generatedPartno = req.getPartno();
		for (; ; ) {
			msgsock = .accept(sock, ((Object)0), ((Object)0));
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			if (CURL_SOCKET_BAD == msgsock) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("MAJOR ERROR: accept() failed with error: (%d) %s", error, .strerror(error));
				break;
			} 
			ModernizedCProgram.set_advisor_read_lock("log/serverlogs.lock");
			ModernizedCProgram.serverlogslocked = 1;
			ModernizedCProgram.logmsg("====> Client connect"/*
			     * Disable the Nagle algorithm to make it easier to send out a large
			     * response in many small segments to torture the clients more.
			     */);
			flag = 1;
			if (.setsockopt(msgsock, 6, -1024, (Object)flag, ) == -1) {
				ModernizedCProgram.logmsg("====> TCP_NODELAY failed");
			} 
			req.setPipelining(/* initialization of httprequest struct is done in get_request(), but due
			       to pipelining treatment the pipelining struct field must be initialized
			       previously to FALSE every time a new connection arrives. */0);
			do {
				if (ModernizedCProgram.got_exit_signal) {
					break;
				} 
				if (req/* non-zero means error, break out of loop */.get_request(msgsock)) {
					break;
				} 
				if (ModernizedCProgram.prevbounce) {
					if ((generatedTestno == /* bounce treatment requested */ModernizedCProgram.prevtestno) && (generatedPartno == ModernizedCProgram.prevpartno)) {
						generatedPartno++;
						ModernizedCProgram.logmsg("BOUNCE part number to %ld", generatedPartno);
					} else {
							ModernizedCProgram.prevbounce = 0;
							ModernizedCProgram.prevtestno = -1;
							ModernizedCProgram.prevpartno = -1;
					} 
				} 
				req.send_doc(msgsock);
				if (ModernizedCProgram.got_exit_signal) {
					break;
				} 
				if ((generatedTestno < 0) && (generatedTestno != .DOCNUMBER_CONNECT)) {
					ModernizedCProgram.logmsg("special request received, no persistency");
					break;
				} 
				if (!generatedOpen) {
					ModernizedCProgram.logmsg("instructed to close connection after server-reply");
					break;
				} 
				if (generatedOpen) {
					ModernizedCProgram.logmsg("=> persistent connection request ended, awaits new request");
				} 
			} while (generatedOpen || (generatedTestno == /* if we got a CONNECT, loop and get another request as well! */.DOCNUMBER_CONNECT));
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			ModernizedCProgram.logmsg("====> Client disconnect");
			.closesocket((msgsock));
			msgsock = CURL_SOCKET_BAD;
			if (ModernizedCProgram.serverlogslocked) {
				ModernizedCProgram.serverlogslocked = 0;
				ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
			} 
			if (generatedTestno == .DOCNUMBER_QUIT) {
				break;
			} 
		}
		if (sock != CURL_SOCKET_BAD) {
			.closesocket((sock));
		} 
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("signalled to die");
		} 
		if (wrotepidfile) {
			.unlink(pidname);
		} 
		if (ModernizedCProgram.serverlogslocked) {
			ModernizedCProgram.serverlogslocked = 0;
			ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
		} 
		ModernizedCProgram.restore_signal_handlers();
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("========> %s rtspd (port: %d pid: %ld) exits with signal (%d)", ModernizedCProgram.ipv_inuse, (int)port, pid, ModernizedCProgram.exit_signal/*
			     * To properly set the return status of the process we
			     * must raise the same signal SIGINT or SIGTERM that we
			     * caught and let the old handler take care of it.
			     */);
			.raise(ModernizedCProgram.exit_signal);
		} 
		ModernizedCProgram.logmsg("========> rtspd quits");
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the mailbox folder to select */"imap://imap.example.com/INBOX"/* Set the STORE command with the Deleted flag for message 1. Note that
			     * you can use the STORE command to set other flags such as Seen, Answered,
			     * Flagged, Draft and Recent. */);
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, "STORE 1 +Flags \\Deleted");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} else {
					curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the EXPUNGE command, although you can use the CLOSE command if you
					       * don't want to know the result of the STORE */"EXPUNGE");
					res = /* Perform the second custom request */curl.curl_easy_perform();
					if (res != /* Check for errors */CURLE_OK) {
						.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
					} 
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 share = new ();
		int i;
		Curl_share curl_share = new Curl_share();
		share = curl_share.curl_share_init();
		share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_CONNECT);
		share.curl_share_setopt(CURLSHOPT_LOCKFUNC, my_lock);
		share.curl_share_setopt(CURLSHOPT_UNLOCKFUNC, my_unlock/* Loop the transfer and cleanup the handle properly every lap. This will
		     still reuse connections since the pool is in the shared object! */);
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < 3; i++) {
			 curl = curl_easy.curl_easy_init();
			if (ModernizedCProgram.curl) {
				 res = new ();
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, "https://curl.haxx.se/");
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SHARE, /* use the share object */share);
				ModernizedCProgram.res = /* Perform the request, res will get the return code */ModernizedCProgram.curl.curl_easy_perform();
				if (ModernizedCProgram.res != /* Check for errors */CURLE_OK) {
					.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(ModernizedCProgram.res));
				} 
				/* always cleanup */ModernizedCProgram.curl.curl_easy_cleanup();
			} 
		}
		share.curl_share_cleanup();
		return 0;
		GlobalInfo g = new GlobalInfo();
		(Object)argc;
		(Object)argv;
		.memset(g, 0, );
		g.setEvbase(.event_base_new());
		g.init_fifo();
		Curl_multi curl_multi = new Curl_multi();
		g.setMulti(curl_multi.curl_multi_init());
		event generatedTimer_event = g.getTimer_event();
		event_base generatedEvbase = g.getEvbase();
		.evtimer_assign(generatedTimer_event, generatedEvbase, ModernizedCProgram.timer_cb, g);
		Object generatedMulti = g.getMulti();
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, /* setup the generic multi interface options we want */sock_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETDATA, g);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, multi_timer_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERDATA, g/* we don't call any curl_multi_socket*() function yet as we have no handles
		     added! */);
		.event_base_dispatch(generatedEvbase);
		/* this, of course, won't get called since only way to stop this program is
		     via ctrl-C, but it is here to show how cleanup /would/ be done. */g.clean_fifo();
		.event_del(generatedTimer_event);
		.event_base_free(generatedEvbase);
		generatedMulti.curl_multi_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com/"/*
			     * If you want to connect to a site who isn't using a certificate that is
			     * signed by one of the certs in the CA bundle you have, you can skip the
			     * verification of the server's certificate. This makes the connection
			     * A LOT LESS SECURE.
			     *
			     * If you have a CA cert for the server stored someplace else than in the
			     * default bundle, then the CURLOPT_CAPATH option might come handy for
			     * you.
			     */);
			res = /*
			     * If the site you're connecting to uses a different host name that what
			     * they have mentioned in their server certificate's commonName (or
			     * subjectAltName) fields, libcurl will refuse to connect. You can skip
			     * this check, but this will make the connection less secure.
			     *//* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		myprogress prog = new myprogress();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			prog.setLastruntime(0);
			prog.setCurl(curl);
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com/"/* xferinfo was introduced in 7.32.0, no earlier libcurl versions will
			       compile as they won't have the symbols around.
			
			       If built with a newer libcurl, but running with an older libcurl:
			       curl_easy_setopt() will fail in run-time trying to set the new
			       callback, making the older callback get used.
			
			       New libcurls will prefer the new callback and instead use that one even
			       if both callbacks are set. */);
			curl.curl_easy_setopt(CURLOPT_PROGRESSFUNCTION, /* pass the struct pointer into the xferinfo function, note that this is
			       an alias to CURLOPT_PROGRESSDATA */older_progress);
			curl.curl_easy_setopt(CURLOPT_PROGRESSDATA, /* pass the struct pointer into the progress function */prog);
			curl.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
			res = curl.curl_easy_perform();
			if (res != CURLE_OK) {
				.fprintf((_iob[2]), "%s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com"/* Forcing HTTP/3 will make the connection fail if the server isn't
			       accessible over QUIC + HTTP/3 on the given host and port.
			       Consider using CURLOPT_ALTSVC instead! */);
			curl.curl_easy_setopt(CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_3);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"imap://imap.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the LSUB command. Note the syntax is very similar to that of a LIST
			       command. */"LSUB \"\" *");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist recipients = ((Object)0);
		upload_status upload_ctx = new upload_status();
		upload_ctx.setLines_read(0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl/* This is the URL for your mailserver. In this example we connect to the
		       smtp-submission port as we require an authenticated connection. */) {
			curl.curl_easy_setopt(CURLOPT_URL, "smtp://mail.example.com:587");
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set the username and password */"kurt");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "xipj3plmq");
			curl.curl_easy_setopt(CURLOPT_SASL_AUTHZID, /* Set the authorisation identity (identity to act as) */"ursel");
			curl.curl_easy_setopt(CURLOPT_LOGIN_OPTIONS, /* Force PLAIN authentication */"AUTH=PLAIN"/* Note that this option isn't strictly required, omitting it will result
			     * in libcurl sending the MAIL FROM command with empty sender data. All
			     * autoresponses should have an empty reverse-path, and should be directed
			     * to the address in the reverse-path which triggered them. Otherwise,
			     * they could cause an endless loop. See RFC 5321 Section 4.5.5 for more
			     * details.
			     */);
			curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<ursel@example.org>");
			recipients = recipients.curl_slist_append(/* Add a recipient, in this particular case it corresponds to the
			     * To: addressee in the header. */"<addressee@example.net>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients/* We're using a callback function to specify the payload (the headers and
			     * body of the message). You could just use the CURLOPT_READDATA option to
			     * specify a FILE pointer to read from. */);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
			curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
			res = /* Send the message */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients/* curl won't send the QUIT command until you call cleanup, so you should
			     * be able to re-use this connection for additional messages (setting
			     * CURLOPT_MAIL_FROM and CURLOPT_MAIL_RCPT as required, and calling
			     * curl_easy_perform() again. It may not be a good idea to keep the
			     * connection open for a very long time though (more than a few minutes
			     * may result in the server timing out the connection), and you do want to
			     * clean up in the end.
			     */.curl_slist_free_all();
			curl.curl_easy_cleanup();
		} 
		return (int)res;
		 http_handle = new ();
		 multi_handle = new ();
		int still_running = /* keep number of running handles */0;
		Curl_easy curl_easy = new Curl_easy();
		http_handle = curl_easy.curl_easy_init();
		http_handle.curl_easy_setopt(CURLOPT_URL, /* set the options (I left out a few, you'll get the point anyway) */"https://www.example.com/");
		http_handle.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, my_trace);
		http_handle.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_multi_add_handle(multi_handle, /* add the individual transfers */http_handle);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case 0:
			case -1:
					still_running = /* select error */0;
					.printf("select() returns error, this is badness\n");
					break;
			default:
					multi_handle.curl_multi_perform(/* timeout or readable/writable sockets */still_running);
					break;
			}
		}
		multi_handle.curl_multi_cleanup();
		http_handle.curl_easy_cleanup();
		return 0;
		byte[] buff = new byte[1024];
		if (argc != 2) {
			.printf("Usage: %s EXPECTED_HOSTNAME\n", argv[0]);
			return 1;
		} 
		if (ModernizedCProgram.Curl_gethostname(buff, 1024)) {
			.printf("Curl_gethostname() failed\n");
			return 1;
		} 
		if (.strncmp(buff, argv[1], /* compare the name returned by Curl_gethostname() with the expected one */1024)) {
			.printf("got unexpected host name back, LD_PRELOAD failed\n");
			return 1;
		} 
		return 0;
		 curl = new ();
		 res = new ();
		 form = ((Object)0);
		 field = ((Object)0);
		curl_slist headerlist = ((Object)0);
		byte[] buf = "Expect:";
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			form = /* Create the form */curl.curl_mime_init();
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the file upload field */form);
			ModernizedCProgram.curl_mime_name(field, "sendfile");
			ModernizedCProgram.curl_mime_filedata(field, "postit2.c");
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the filename field */form);
			ModernizedCProgram.curl_mime_name(field, "filename");
			ModernizedCProgram.curl_mime_data(field, "postit2.c", CURL_ZERO_TERMINATED);
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the submit field too, even if this is rarely needed */form);
			ModernizedCProgram.curl_mime_name(field, "submit");
			ModernizedCProgram.curl_mime_data(field, "send", CURL_ZERO_TERMINATED);
			headerlist = headerlist.curl_slist_append(/* initialize custom header list (stating that Expect: 100-continue is not
			       wanted */buf);
			curl.curl_easy_setopt(CURLOPT_URL, /* what URL that receives this POST */"https://example.com/examplepost.cgi");
			if ((argc == 2) && (!.strcmp(argv[1], "noexpectheader"))) {
				curl.curl_easy_setopt(CURLOPT_HTTPHEADER, /* only disable 100-continue header if explicitly requested */headerlist);
			} 
			curl.curl_easy_setopt(CURLOPT_MIMEPOST, form);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
			ModernizedCProgram.curl_mime_free(/* then cleanup the form */form);
			/* free slist */headerlist.curl_slist_free_all();
		} 
		return 0;
		CURL conn = 0;
		CURLcode code = new CURLcode();
		string title = new string();
		// Ensure one argument is given
		if (argc != 2) {
			.fprintf((_iob[2]), "Usage: %s <url>\n", argv[0]);
			.exit(1);
		} 
		curl_global_init CURL_GLOBAL_DEFAULT = new curl_global_init();
		// Initialize CURL connection
		if (!ModernizedCProgram.init(conn, argv[1])) {
			.fprintf((_iob[2]), "Connection initializion failed\n");
			.exit(1);
		} 
		// Retrieve content for the URL// Retrieve content for the URLcode = conn.curl_easy_perform();
		conn.curl_easy_cleanup();
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to get '%s' [%s]\n", argv[1], ModernizedCProgram.errorBuffer);
			.exit(1);
		} 
		// Parse the (assumed) HTML code// Parse the (assumed) HTML codeModernizedCProgram.parseHtml(ModernizedCProgram.buffer, title);
		// Display the extracted title// Display the extracted title.printf("Title: %s\n", .UNRECOGNIZEDFUNCTIONNAME());
		return 0;
		GlobalInfo g = new GlobalInfo();
		 gmain = new ();
		int fd;
		 ch = new ();
		g = .g_malloc0();
		_GlobalInfo _GlobalInfo = new _GlobalInfo();
		fd = _GlobalInfo.init_fifo();
		ch = .g_io_channel_unix_new(fd);
		.g_io_add_watch(ch, G_IO_IN, fifo_cb, g);
		gmain = .g_main_loop_new(((Object)0), FALSE);
		Curl_multi curl_multi = new Curl_multi();
		g.setMulti(curl_multi.curl_multi_init());
		Object generatedMulti = g.getMulti();
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, sock_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETDATA, g);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, update_timeout_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERDATA, g/* we don't call any curl_multi_socket*() function yet as we have no handles
		     added! */);
		.g_main_loop_run(gmain);
		generatedMulti.curl_multi_cleanup();
		return 0;
		 ch = new ();
		 rv = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		ch = curl_easy.curl_easy_init();
		ch.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		ch.curl_easy_setopt(CURLOPT_HEADER, -1024);
		ch.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
		ch.curl_easy_setopt(CURLOPT_NOSIGNAL, -1024);
		ch.curl_easy_setopt(CURLOPT_WRITEFUNCTION, writefunction);
		ch.curl_easy_setopt(CURLOPT_WRITEDATA, (_iob[1]));
		ch.curl_easy_setopt(CURLOPT_HEADERFUNCTION, writefunction);
		ch.curl_easy_setopt(CURLOPT_HEADERDATA, (_iob[2]));
		ch.curl_easy_setopt(CURLOPT_SSLCERTTYPE, "PEM");
		ch.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
		ch.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/"/* Turn off the default CA locations, otherwise libcurl will load CA
		   * certificates from the locations that were detected/specified at
		   * build-time
		   */);
		ch.curl_easy_setopt(CURLOPT_CAINFO, ((Object)0));
		ch.curl_easy_setopt(CURLOPT_CAPATH, ((Object)0/* first try: retrieve page without ca certificates -> should fail
		   * unless libcurl was built --with-ca-fallback enabled at build-time
		   */));
		rv = ch.curl_easy_perform();
		if (rv == CURLE_OK) {
			.printf("*** transfer succeeded ***\n");
		} else {
				.printf("*** transfer failed ***\n"/* use a fresh connection (optional)
				   * this option seriously impacts performance of multiple transfers but
				   * it is necessary order to demonstrate this example. recall that the
				   * ssl ctx callback is only called _before_ an SSL connection is
				   * established, therefore it will not affect existing verified SSL
				   * connections already in the connection cache associated with this
				   * handle. normally you would set the ssl ctx function before making
				   * any transfers, and not use this option.
				   */);
		} 
		ch.curl_easy_setopt(CURLOPT_FRESH_CONNECT, -1024/* second try: retrieve page using cacerts' certificate -> will succeed
		   * load the certificate by installing a function doing the necessary
		   * "modifications" to the SSL CONTEXT just before link init
		   */);
		ch.curl_easy_setopt(CURLOPT_SSL_CTX_FUNCTION, sslctx_function);
		rv = ch.curl_easy_perform();
		if (rv == CURLE_OK) {
			.printf("*** transfer succeeded ***\n");
		} else {
				.printf("*** transfer failed ***\n");
		} 
		ch.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return rv;
		 curl = new ();
		 res = CURLE_OK;
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is mailbox folder to select */"imap://imap.example.com/INBOX"/* Set the SEARCH command specifying what we want to search for. Note that
			     * this can contain a message sequence set and a number of search criteria
			     * keywords including flags such as ANSWERED, DELETED, DRAFT, FLAGGED, NEW,
			     * RECENT and SEEN. For more information about the search criteria please
			     * see RFC-3501 section 6.4.4.   */);
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, "SEARCH NEW");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		Curl_easy curl_easy = new Curl_easy();
		if (argc == 2) {
			 curl = new ();
			byte[] curl_errbuf = new byte[CURL_ERROR_SIZE];
			 tdoc = new ();
			 docbuf = new (0);
			 tidy_errbuf = new (0);
			int err;
			ModernizedCProgram.curl = curl_easy.curl_easy_init();
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, argv[1]);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_ERRORBUFFER, curl_errbuf);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_cb);
			tdoc = .tidyCreate();
			.tidyOptSetBool(tdoc, TidyForceOutput, /* try harder */yes);
			.tidyOptSetInt(tdoc, TidyWrapLen, 4096);
			.tidySetErrorBuffer(tdoc, tidy_errbuf);
			.tidyBufInit(docbuf);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEDATA, docbuf);
			err = ModernizedCProgram.curl.curl_easy_perform();
			if (!err) {
				err = .tidyParseBuffer(tdoc, /* parse the input */docbuf);
				if (err >= 0) {
					err = .tidyCleanAndRepair(/* fix any problems */tdoc);
					if (err >= 0) {
						err = .tidyRunDiagnostics(/* load tidy error buffer */tdoc);
						if (err >= 0) {
							ModernizedCProgram.dumpNode(tdoc, .tidyGetRoot(tdoc), /* walk the tree */0);
							.fprintf((_iob[2]), "%s\n", tidy_errbuf.getBp());
						} 
					} 
				} 
			} else {
					.fprintf((_iob[2]), "%s\n", curl_errbuf);
			} 
			/* clean-up */ModernizedCProgram.curl.curl_easy_cleanup();
			.tidyBufFree(docbuf);
			.tidyBufFree(tidy_errbuf);
			.tidyRelease(tdoc);
			return err;
		} else {
				.printf("usage: %s <url>\n", argv[0]);
		} 
		return 0;
		byte[] zero = new byte[]{(byte)'\0'};
		int chars;
		.setlocale(4, "");
		chars = ModernizedCProgram.curl_msnprintf(zero, 4, "%.1f", 0.0);
		if ((chars == (4 - 1)) && (.strcmp(zero, "0.0") == 0)) {
			return 0;
		} else {
				return 1;
		} 
		 curl = new ();
		 res = new ();
		FtpFile ftpfile = new FtpFile(/* name to store the file as if successful */"curl.tar.gz", ((Object)0));
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl/*
		     * You better replace the URL with one that works!
		     */) {
			curl.curl_easy_setopt(CURLOPT_URL, "ftp://ftp.example.com/curl/curl-7.9.2.tar.gz");
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* Define our callback to get called when there's data to be written */my_fwrite);
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, /* Set a pointer to our struct to pass to the callback */ftpfile);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* Switch on full protocol/debug output */-1024);
			res = curl.curl_easy_perform();
			/* always cleanup */curl.curl_easy_cleanup();
			if (CURLE_OK != res) {
				.fprintf((_iob[2]), "curl told us %d\n", /* we failed */res);
			} 
		} 
		_iobuf generatedStream = ftpfile.getStream();
		if (generatedStream) {
			.fclose(generatedStream);
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		pthread_t[] tid = new pthread_t();
		int i;
		 share = new ();
		initurl[] url = new initurl();
		ModernizedCProgram.curl_global_init(/* Must initialize libcurl before any threads are started */CURL_GLOBAL_ALL);
		Curl_share curl_share = new Curl_share();
		share = curl_share.curl_share_init();
		share.curl_share_setopt(CURLSHOPT_LOCKFUNC, lock_cb);
		share.curl_share_setopt(CURLSHOPT_UNLOCKFUNC, unlock_cb);
		share.curl_share_setopt(CURLSHOPT_SHARE, CURL_LOCK_DATA_CONNECT);
		ModernizedCProgram.init_locks();
		for (i = 0; i < 67; i++) {
			int error;
			url[i].setUrl("http://localhost/4KB");
			url[i].setShare(share);
			url[i].setThreadno(i);
			error = .pthread_create(tid[i], ((Object)0), run_thread, url[i]);
			if (0 != error) {
				.fprintf((_iob[2]), "Couldn't run thread number %d, errno %d\n", i, error);
			} else {
					.fprintf((_iob[2]), "Thread %d, gets %s\n", i, "http://localhost/4KB");
			} 
		}
		for (i = 0; i < 67; /* now wait for all threads to terminate */i++) {
			.pthread_join(tid[i], ((Object)0));
			.fprintf((_iob[2]), "Thread %d terminated\n", i);
		}
		ModernizedCProgram.kill_locks();
		share.curl_share_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		byte[] buf = new byte[1024];
		byte[] logfilename = new byte[256];
		FILE stream = new FILE();
		byte filename;
		int error;
		byte type1_input = ((Object)0);
		byte type3_input = ((Object)0);
		byte type1_output = ((Object)0);
		byte type3_output = ((Object)0);
		size_t size = 0;
		long testnum;
		byte env;
		int arg = 1;
		byte helper_user = "unknown";
		byte helper_proto = "unknown";
		byte helper_domain = "unknown";
		bool use_cached_creds = 0;
		byte msgbuf;
		buf[0] = (byte)'\0';
		while (argc > arg) {
			if (!.strcmp("--use-cached-creds", argv[arg])) {
				use_cached_creds = 1;
				arg++;
			}  else if (!.strcmp("--helper-protocol", argv[arg])) {
				arg++;
				if (argc > arg) {
					helper_proto = argv[arg++];
				} 
			}  else if (!.strcmp("--username", argv[arg])) {
				arg++;
				if (argc > arg) {
					helper_user = argv[arg++];
				} 
			}  else if (!.strcmp("--domain", argv[arg])) {
				arg++;
				if (argc > arg) {
					helper_domain = argv[arg++];
				} 
			} else {
					.puts("Usage: fake_ntlm [option]\n --use-cached-creds\n --helper-protocol [protocol]\n --username [username]\n --domain [domain]");
					.exit(1);
			} 
		}
		env = .getenv("CURL_NTLM_AUTH_TESTNUM");
		if (env) {
			byte endptr;
			long lnum = .strtol(env, endptr, 10);
			if ((endptr != env + .strlen(env)) || (lnum < -1024)) {
				(_iob[2]).curl_mfprintf("Test number not valid in CURL_NTLM_AUTH_TESTNUM");
				.exit(1);
			} 
			testnum = lnum;
		} else {
				(_iob[2]).curl_mfprintf("Test number not specified in CURL_NTLM_AUTH_TESTNUM");
				.exit(1);
		} 
		ModernizedCProgram.curl_msnprintf(logfilename, , "log/fake_ntlm%ld.log", /* logmsg cannot be used until this file name is set */testnum);
		ModernizedCProgram.serverlogfile = logfilename;
		ModernizedCProgram.logmsg("fake_ntlm (user: %s) (proto: %s) (domain: %s) (cached creds: %s)", helper_user, helper_proto, helper_domain, (use_cached_creds) ? "yes" : "no");
		env = .getenv("CURL_NTLM_AUTH_SRCDIR");
		if (env) {
			ModernizedCProgram.path = env;
		} 
		filename = ModernizedCProgram.test2file(testnum);
		stream = .fopen(filename, "rb");
		if (!stream) {
			error = (._errno());
			ModernizedCProgram.logmsg("fopen() failed with error: %d %s", error, .strerror(error));
			ModernizedCProgram.logmsg("Error opening file: %s", filename);
			ModernizedCProgram.logmsg("Couldn't open test file %ld", testnum);
			.exit(1);
		} else {
				error = /* get the ntlm_auth input/output */stream.getpart(type1_input, size, "ntlm_auth_type1", "input");
				.fclose(stream);
				if (error || size == 0) {
					ModernizedCProgram.logmsg("getpart() type 1 input failed with error: %d", error);
					.exit(1);
				} 
		} 
		stream = .fopen(filename, "rb");
		if (!stream) {
			error = (._errno());
			ModernizedCProgram.logmsg("fopen() failed with error: %d %s", error, .strerror(error));
			ModernizedCProgram.logmsg("Error opening file: %s", filename);
			ModernizedCProgram.logmsg("Couldn't open test file %ld", testnum);
			.exit(1);
		} else {
				size = 0;
				error = stream.getpart(type3_input, size, "ntlm_auth_type3", "input");
				.fclose(stream);
				if (error || size == 0) {
					ModernizedCProgram.logmsg("getpart() type 3 input failed with error: %d", error);
					.exit(1);
				} 
		} 
		while (.fgets(buf, , (_iob[0]))) {
			if (.strcmp(buf, type1_input) == 0) {
				stream = .fopen(filename, "rb");
				if (!stream) {
					error = (._errno());
					ModernizedCProgram.logmsg("fopen() failed with error: %d %s", error, .strerror(error));
					ModernizedCProgram.logmsg("Error opening file: %s", filename);
					ModernizedCProgram.logmsg("Couldn't open test file %ld", testnum);
					.exit(1);
				} else {
						size = 0;
						error = stream.getpart(type1_output, size, "ntlm_auth_type1", "output");
						.fclose(stream);
						if (error || size == 0) {
							ModernizedCProgram.logmsg("getpart() type 1 output failed with error: %d", error);
							.exit(1);
						} 
				} 
				ModernizedCProgram.curl_mprintf("%s", type1_output);
				.fflush((_iob[1]));
			}  else if (.strncmp(buf, type3_input, .strlen(type3_input)) == 0) {
				stream = .fopen(filename, "rb");
				if (!stream) {
					error = (._errno());
					ModernizedCProgram.logmsg("fopen() failed with error: %d %s", error, .strerror(error));
					ModernizedCProgram.logmsg("Error opening file: %s", filename);
					ModernizedCProgram.logmsg("Couldn't open test file %ld", testnum);
					.exit(1);
				} else {
						size = 0;
						error = stream.getpart(type3_output, size, "ntlm_auth_type3", "output");
						.fclose(stream);
						if (error || size == 0) {
							ModernizedCProgram.logmsg("getpart() type 3 output failed with error: %d", error);
							.exit(1);
						} 
				} 
				ModernizedCProgram.curl_mprintf("%s", type3_output);
				.fflush((_iob[1]));
			} else {
					ModernizedCProgram.curl_mprintf("Unknown request\n");
					msgbuf = ModernizedCProgram.printable(buf, 0);
					if (msgbuf) {
						ModernizedCProgram.logmsg("invalid input: '%s'\n", msgbuf);
						.free(msgbuf);
					} else {
							ModernizedCProgram.logmsg("OOM formatting invalid input: '%s'\n", buf);
					} 
					.exit(1);
			} 
		}
		ModernizedCProgram.logmsg("Exit");
		return 1;
		 top_window = new ();
		 outside_frame = new ();
		 inside_frame = new ();
		 progress_bar = new ();
		ModernizedCProgram.curl_global_init(/* Must initialize libcurl before any threads are started */CURL_GLOBAL_ALL);
		.g_thread_init(((Object)/* Init thread */0));
		.gdk_threads_init();
		.gdk_threads_enter();
		.gtk_init(argc, argv);
		top_window = .gtk_window_new(/* Base window */GTK_WINDOW_TOPLEVEL);
		outside_frame = .gtk_frame_new(((Object)/* Frame */0));
		.gtk_frame_set_shadow_type(.GTK_FRAME(outside_frame), GTK_SHADOW_OUT);
		.gtk_container_add(.GTK_CONTAINER(top_window), outside_frame);
		inside_frame = .gtk_frame_new(((Object)/* Frame */0));
		.gtk_frame_set_shadow_type(.GTK_FRAME(inside_frame), GTK_SHADOW_IN);
		.gtk_container_set_border_width(.GTK_CONTAINER(inside_frame), 5);
		.gtk_container_add(.GTK_CONTAINER(outside_frame), inside_frame);
		progress_bar = .gtk_progress_bar_new();
		.gtk_progress_bar_pulse(.GTK_PROGRESS_BAR(progress_bar));
		 pulse_ref = .g_timeout_add(300, pulse_bar, /* Make uniform pulsing */progress_bar);
		.g_object_set_data(.G_OBJECT(progress_bar), "pulse_id", .GINT_TO_POINTER(pulse_ref));
		.gtk_container_add(.GTK_CONTAINER(inside_frame), progress_bar);
		.gtk_widget_show_all(top_window);
		.printf("gtk_widget_show_all\n");
		.g_signal_connect(.G_OBJECT(top_window), "delete-event", .G_CALLBACK(cb_delete), ((Object)0));
		if (!.g_thread_create(create_thread, progress_bar, FALSE, ((Object)0)) != 0) {
			.g_warning("can't create the thread");
		} 
		.gtk_main();
		.gdk_threads_leave();
		.printf("gdk_threads_leave\n");
		return 0;
		 curl = new ();
		byte request = /* Minimalistic http request */"GET / HTTP/1.0\r\nHost: example.com\r\n\r\n";
		size_t request_len = .strlen(request/* A general note of caution here: if you're using curl_easy_recv() or
		     curl_easy_send() to implement HTTP or _any_ other protocol libcurl
		     supports "natively", you're doing it wrong and you should stop.
		
		     This example uses HTTP only to show how to use this API, it does not
		     suggest that writing an application doing this is sensible.
		  */);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		return 0;
		 curl = new ();
		 res = new ();
		FtpFile ftpfile = new FtpFile(/* name to store the file as if successful */"yourfile.bin", ((Object)0));
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl/*
		     * You better replace the URL with one that works!
		     */) {
			curl.curl_easy_setopt(CURLOPT_URL, "sftp://user@server/home/user/file.txt");
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* Define our callback to get called when there's data to be written */my_fwrite);
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, /* Set a pointer to our struct to pass to the callback */ftpfile);
			curl.curl_easy_setopt(CURLOPT_SSH_AUTH_TYPES, /* We activate ssh agent. For this to work you need
			       to have ssh-agent running (type set | grep SSH_AGENT to check) or
			       pageant on Windows (there is an icon in systray if so) *//* We activate ssh agent. For this to work you need
			       to have ssh-agent running (type set | grep SSH_AGENT to check) or
			       pageant on Windows (there is an icon in systray if so) */CURLSSH_AUTH_AGENT);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* Switch on full protocol/debug output */-1024);
			res = curl.curl_easy_perform();
			/* always cleanup */curl.curl_easy_cleanup();
			if (CURLE_OK != res) {
				.fprintf((_iob[2]), "curl told us %d\n", /* we failed */res);
			} 
		} 
		_iobuf generatedStream = ftpfile.getStream();
		if (generatedStream) {
			.fclose(generatedStream);
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		stat file_info = new stat();
		 speed_upload = new ();
		 total_time = new ();
		FILE fd = new FILE();
		fd = .fopen("debugit", /* open file to upload */"rb");
		if (!fd) {
			return /* can't continue */1;
		} 
		Object generated_file = (fd).get_file();
		if (.fstat((generated_file), file_info) != /* to get the file size */0) {
			return /* can't continue */1;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedSt_size = file_info.getSt_size();
		.fclose(fd);
		return 0;
		 ver = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		ver = ModernizedCProgram.curl_version_info(CURLVERSION_NOW);
		if (ver.getFeatures() & CURL_VERSION_HTTP2) {
			.printf("HTTP/2 support is present\n");
		} 
		if (ver.getFeatures() & CURL_VERSION_HTTP3) {
			.printf("HTTP/3 support is present\n");
		} 
		if (ver.getFeatures() & CURL_VERSION_ALTSVC) {
			.printf("Alt-svc support is present\n");
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 result = CURLE_OK;
		GlobalConfig global = new GlobalConfig();
		.memset(global, 0, );
		ModernizedCProgram.configure_terminal();
		ModernizedCProgram.main_checkfds();
		do {
		} while (/* Initialize memory tracking */0);
		result = /* Initialize the curl library - do not call any libcurl functions before
		     this point */global.main_init();
		curl_slist curl_slist = new curl_slist();
		Object generatedCurl_slist = item.getCurl_slist();
		if (argc == 2 && !.strcmp(argv[1], /* Undocumented diagnostic option to list the full paths of all loaded
		     modules, regardless of whether or not initialization succeeded. */"--dump-module-paths")) {
			curl_slist item = new curl_slist();
			curl_slist head = curl_slist.GetLoadedModulePaths();
			for (item = head; item; item = generatedCurl_slist) {
				ModernizedCProgram.curl_mprintf("%s\n", generatedCurl_slist);
			}
			head.curl_slist_free_all();
			if (!result) {
				global.main_free();
			} 
		}  else if (!/* WIN32 */result) {
			result = global.operate(argc, /* Start our curl operation */argv);
			/* Perform the main cleanup */global.main_free();
		} 
		ModernizedCProgram.restore_terminal();
		return (int)result/* ndef UNITTESTS */;
		 curl = new ();
		 res = new ();
		MemoryStruct chunk = new MemoryStruct();
		byte postthis = "Field=1&Field=2&Field=3";
		chunk.setMemory(.malloc(/* will be grown as needed by realloc above */1));
		chunk.setSize(/* no data at this point */0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Byte generatedMemory = chunk.getMemory();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://www.example.org/");
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */WriteMemoryCallback);
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, (Object)/* we pass our 'chunk' struct to the callback function */chunk);
			curl.curl_easy_setopt(CURLOPT_USERAGENT, /* some servers don't like requests that are made without a user-agent
			       field, so we provide one */"libcurl-agent/1.0");
			curl.curl_easy_setopt(CURLOPT_POSTFIELDS, postthis);
			curl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long).strlen(/* if we don't provide POSTFIELDSIZE, libcurl will strlen() by
			       itself */postthis));
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res/*
				       * Now, our chunk.memory points to a memory block that is chunk.size
				       * bytes big and contains the remote file.
				       *
				       * Do something nice with it!
				       */));
			} else {
					.printf("%s\n", generatedMemory);
			} 
			/* always cleanup */curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
		} 
		.free(generatedMemory);
		return 0;
		byte part;
		size_t partlen = new size_t();
		if (argc < 3) {
			ModernizedCProgram.curl_mprintf("./testpart main sub\n");
		} else {
				int rc = (_iob[0]).getpart(part, partlen, argv[1], argv[2]);
				size_t i = new size_t();
				if (rc) {
					return rc;
				} 
				for (i = 0; i < partlen; i++) {
					ModernizedCProgram.curl_mprintf("%c", part[i]);
				}
				.free(part);
		} 
		return 0;
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.curl = curl_easy.curl_easy_init();
		if (ModernizedCProgram.curl) {
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/");
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, wrfu);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			(Object)ModernizedCProgram.curl.curl_easy_perform();
			ModernizedCProgram.curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 mcurl = new ();
		int still_running = 1;
		timeval mp_start = new timeval();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			return 1;
		} 
		Curl_multi curl_multi = new Curl_multi();
		mcurl = curl_multi.curl_multi_init();
		if (!mcurl) {
			return 2;
		} 
		curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
		curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
		curl.curl_easy_setopt(CURLOPT_URL, /* This will retrieve message 1 from the user's mailbox */"pop3://pop.example.com/1");
		ModernizedCProgram.curl_multi_add_handle(mcurl, /* Tell the multi stack about our easy handle */curl);
		timeval timeval = new timeval();
		mp_start = timeval.tvnow();
		mcurl.curl_multi_perform(/* We start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			int rc;
			 mc = new ();
			long curl_timeo = -1;
			.FD_ZERO(/* Initialise the file descriptors */fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTimeval(/* Set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTimeval(0);
			mcurl.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTimeval(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTimeval() > 1) {
					ModernizedCProgram.timeout.setTimeval(1);
				} else {
						ModernizedCProgram.timeout.setTimeval((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(mcurl, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			if (timeval.tvnow().tvdiff(mp_start) > 60 * 1000) {
				.fprintf((_iob[2]), "ABORTING: Since it seems that we would have run forever.\n");
				break;
			} 
			switch (rc) {
			case -/* select error */1:
					break;
			case /* timeout */0:
			default:
					mcurl.curl_multi_perform(still_running);
					break;
			}
		}
		ModernizedCProgram.curl_multi_remove_handle(mcurl, /* Always cleanup */curl);
		mcurl.curl_multi_cleanup();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(/* This will fetch message 1 from the user's inbox */CURLOPT_URL, "imap://imap.example.com/INBOX/;UID=1");
			res = /* Perform the fetch */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 easy = new ();
		 multi = new ();
		/* keep number of running handles */int still_running;
		int transfers = /* we start with one */1;
		int i;
		CURLMsg m = new CURLMsg();
		Curl_multi curl_multi = new Curl_multi();
		multi = curl_multi.curl_multi_init();
		Curl_easy curl_easy = new Curl_easy();
		easy = curl_easy.curl_easy_init();
		ModernizedCProgram.setup(/* set options */easy);
		ModernizedCProgram.curl_multi_add_handle(multi, /* add the easy transfer */easy);
		multi.curl_multi_setopt(CURLMOPT_PIPELINING, CURLPIPE_MULTIPLEX);
		multi.curl_multi_setopt(CURLMOPT_PUSHFUNCTION, server_push_callback);
		multi.curl_multi_setopt(CURLMOPT_PUSHDATA, transfers);
		Object generatedCURLMsg = m.getCURLMsg();
		while (transfers) {
			int rc;
			 mcode = multi.curl_multi_perform(still_running);
			if (mcode) {
				break;
			} 
			mcode = .curl_multi_wait(multi, ((Object)0), 0, 1000, rc);
			if (mcode) {
				break;
			} 
			do {
				int msgq = 0;
				;
				m = multi.curl_multi_info_read(msgq);
				if (m && (generatedCURLMsg == CURLMSG_DONE)) {
					 e = generatedCURLMsg;
					transfers--;
					ModernizedCProgram.curl_multi_remove_handle(multi, e);
					e.curl_easy_cleanup();
				} 
			} while (m);
		}
		multi.curl_multi_cleanup();
		for (i = 0; i < ModernizedCProgram.pushindex; /* 'pushindex' is now the number of received transfers */i++) {
			.free(ModernizedCProgram.files[i].getMemory());
		}
		return 0;
		 curl = new ();
		 res = new ();
		curl_httppost formpost = ((Object)0);
		curl_httppost lastptr = ((Object)0);
		curl_slist headerlist = ((Object)0);
		byte[] buf = "Expect:";
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		/* Fill in the file upload field */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "sendfile", CURLFORM_FILE, "postit2.c", CURLFORM_END);
		/* Fill in the filename field */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "filename", CURLFORM_COPYCONTENTS, "postit2.c", CURLFORM_END);
		/* Fill in the submit field too, even if this is rarely needed */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "submit", CURLFORM_COPYCONTENTS, "send", CURLFORM_END);
		curl = curl_easy.curl_easy_init();
		headerlist = headerlist.curl_slist_append(buf);
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* what URL that receives this POST */"https://example.com/examplepost.cgi");
			if ((argc == 2) && (!.strcmp(argv[1], "noexpectheader"))) {
				curl.curl_easy_setopt(CURLOPT_HTTPHEADER, /* only disable 100-continue header if explicitly requested */headerlist);
			} 
			curl.curl_easy_setopt(CURLOPT_HTTPPOST, formpost);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
			/* then cleanup the formpost chain */formpost.curl_formfree();
			/* free slist */headerlist.curl_slist_free_all();
		} 
		return 0;
		 curl = new ();
		 multi_handle = new ();
		int still_running = 0;
		curl_httppost formpost = ((Object)0);
		curl_httppost lastptr = ((Object)0);
		curl_slist headerlist = ((Object)0);
		byte[] buf = "Expect:";
		/* Fill in the file upload field. This makes libcurl load data from
		     the given file name when curl_easy_perform() is called. */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "sendfile", CURLFORM_FILE, "postit2.c", CURLFORM_END);
		/* Fill in the filename field */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "filename", CURLFORM_COPYCONTENTS, "postit2.c", CURLFORM_END);
		/* Fill in the submit field too, even if this is rarely needed */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "submit", CURLFORM_COPYCONTENTS, "send", CURLFORM_END);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		headerlist = headerlist.curl_slist_append(/* initialize custom header list (stating that Expect: 100-continue is not
		     wanted */buf);
		if (curl && multi_handle) {
			curl.curl_easy_setopt(CURLOPT_URL, /* what URL that receives this POST */"https://www.example.com/upload.cgi");
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			curl.curl_easy_setopt(CURLOPT_HTTPHEADER, headerlist);
			curl.curl_easy_setopt(CURLOPT_HTTPPOST, formpost);
			ModernizedCProgram.curl_multi_add_handle(multi_handle, curl);
			multi_handle.curl_multi_perform(still_running);
			while (still_running) {
				timeval timeout = new timeval();
				int rc;
				 mc = new ();
				 fdread = new ();
				 fdwrite = new ();
				 fdexcep = new ();
				int maxfd = -1;
				long curl_timeo = -1;
				.FD_ZERO(fdread);
				.FD_ZERO(fdwrite);
				.FD_ZERO(fdexcep);
				ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
				ModernizedCProgram.timeout.setTv_usec(0);
				multi_handle.curl_multi_timeout(curl_timeo);
				if (curl_timeo >= 0) {
					ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
					if (ModernizedCProgram.timeout.getTv_sec() > 1) {
						ModernizedCProgram.timeout.setTv_sec(1);
					} else {
							ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
					} 
				} 
				mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
				if (mc != CURLM_OK) {
					.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
					break;
				} 
				if (maxfd == -1) {
					.Sleep(100);
					rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
				} else {
						rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
						           If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
				} 
				switch (rc) {
				case 0:
				case -1/* select error */:
						break;
				default:
						.printf(/* timeout or readable/writable sockets */"perform!\n");
						multi_handle.curl_multi_perform(still_running);
						.printf("running: %d!\n", still_running);
						break;
				}
			}
			multi_handle.curl_multi_cleanup();
			/* always cleanup */curl.curl_easy_cleanup();
			/* then cleanup the formpost chain */formpost.curl_formfree();
			/* free slist */headerlist.curl_slist_free_all();
		} 
		return 0;
		transfer[] trans = new transfer();
		 multi_handle = new ();
		int i;
		int still_running = /* keep number of running handles */0;
		int num_transfers;
		if (argc > 1) {
			num_transfers = .atoi(argv[/* if given a number, do that many transfers */1]);
			if ((num_transfers < 1) || (num_transfers > 1000)) {
				num_transfers = /* a suitable low default */3;
			} 
		} else {
				num_transfers = /* suitable default */3;
		} 
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		for (i = 0; i < num_transfers; i++) {
			ModernizedCProgram.setup(trans[i], i);
			ModernizedCProgram.curl_multi_add_handle(multi_handle, trans[i].getEasy());
		}
		multi_handle.curl_multi_setopt(CURLMOPT_PIPELINING, 0);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case 0:
			case -1/* select error */:
					break;
			default:
					multi_handle.curl_multi_perform(/* timeout or readable/writable sockets */still_running);
					break;
			}
		}
		for (i = 0; i < num_transfers; i++) {
			ModernizedCProgram.curl_multi_remove_handle(multi_handle, trans[i].getEasy());
			trans[i].getEasy().curl_easy_cleanup();
		}
		multi_handle.curl_multi_cleanup();
		return 0;
		[] handles = new ();
		 multi_handle = new ();
		int still_running = /* keep number of running handles */0;
		int i;
		/* for picking up messages with the transfer status */ msg = new ();
		/* how many messages are left */int msgs_left;
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < 2; /* Allocate one CURL handle per transfer */i++) {
			handles[i] = curl_easy.curl_easy_init();
		}
		handles[0].curl_easy_setopt(CURLOPT_URL, /* set the options (I left out a few, you'll get the point anyway) */"https://example.com");
		handles[1].curl_easy_setopt(CURLOPT_URL, "ftp://example.com");
		handles[1].curl_easy_setopt(CURLOPT_UPLOAD, -1024);
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		for (i = 0; i < 2; /* add the individual transfers */i++) {
			ModernizedCProgram.curl_multi_add_handle(multi_handle, handles[i]);
		}
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case /* timeout */0:
			case -1/* select error */:
					break;
			default:
					multi_handle.curl_multi_perform(still_running);
					break;
			}
		}
		while ((msg = multi_handle.curl_multi_info_read(/* See how the transfers went */msgs_left))) {
			if (msg.getMsg() == CURLMSG_DONE) {
				int idx;
				for (idx = 0; idx < 2; /* Find out which handle this message is about */idx++) {
					int found = (msg.getEasy_handle() == handles[idx]);
					if (found) {
						break;
					} 
				}
				switch (idx) {
				case 1:
						.printf("FTP transfer completed with status %d\n", msg.getData().getResult());
						break;
				case 0:
						.printf("HTTP transfer completed with status %d\n", msg.getData().getResult());
						break;
				}
			} 
		}
		multi_handle.curl_multi_cleanup();
		for (i = 0; i < 2; /* Free the CURL handles */i++) {
			handles[i].curl_easy_cleanup();
		}
		return 0;
		 curl = new ();
		 res = new ();
		WriteThis upload = new WriteThis();
		upload.setReadptr(ModernizedCProgram.data);
		upload.setSizeleft(.strlen(ModernizedCProgram.data));
		res = ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_DEFAULT);
		if (res != /* Check for errors */CURLE_OK) {
			.fprintf((_iob[2]), "curl_global_init() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			return 1;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedSizeleft = upload.getSizeleft();
		if (curl) {
			curl.curl_easy_setopt(/* First set the URL, the target file */CURLOPT_URL, "ftp://example.com/path/to/upload/file");
			curl.curl_easy_setopt(CURLOPT_USERPWD, /* User and password for the FTP login */"login:secret");
			curl.curl_easy_setopt(CURLOPT_UPLOAD, /* Now specify we want to UPLOAD data */-1024);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
			curl.curl_easy_setopt(CURLOPT_READDATA, /* pointer to pass to our read function */upload);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* get verbose debug output please */-1024);
			curl.curl_easy_setopt(/* Set the expected upload size. */CURLOPT_INFILESIZE_LARGE, ()generatedSizeleft);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"imap://imap.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the NOOP command */"NOOP");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		data config = new data();
		config.setTrace_ascii(/* enable ascii tracing */1);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, my_trace);
			curl.curl_easy_setopt(CURLOPT_DEBUGDATA, config);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* the DEBUGFUNCTION has no effect until we enable VERBOSE */-1024);
			curl.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, /* example.com is redirected, so we tell libcurl to follow redirection */-1024);
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com/");
			res = curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = new ();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com");
			curl.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, /* example.com is redirected, so we tell libcurl to follow redirection */-1024);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = new ();
		curl_slist recipients = ((Object)0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver */"smtp://mail.example.com");
			recipients = recipients.curl_slist_append(/* Note that the CURLOPT_MAIL_RCPT takes a list, not a char array  */"<recipient@example.com>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients);
			res = /* Perform the VRFY */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients/* Curl won't send the QUIT command until you call cleanup, so you should
			     * be able to re-use this connection for additional requests. It may not be
			     * a good idea to keep the connection open for a very long time though
			     * (more than a few minutes may result in the server timing out the
			     * connection) and you do want to clean up in the end.
			     */.curl_slist_free_all();
			curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			byte[] nline = new byte[256];
			curl.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/");
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			curl.curl_easy_setopt(CURLOPT_COOKIEFILE, /* start cookie engine */"");
			res = curl.curl_easy_perform();
			if (res != CURLE_OK) {
				.fprintf((_iob[2]), "Curl perform failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				return 1;
			} 
			ModernizedCProgram.print_cookies(curl);
			.printf("Erasing curl's knowledge of cookies!\n");
			curl.curl_easy_setopt(CURLOPT_COOKIELIST, "ALL");
			ModernizedCProgram.print_cookies(curl);
			.printf("-----------------------------------------------\nSetting a cookie \"PREF\" via cookie interface:\n");
			._snprintf(nline, , /* Netscape format cookie */"%s\t%s\t%s\t%s\t%lu\t%s\t%s", ".example.com", "TRUE", "/", "FALSE", (long).time(((Object)0)) + -1024, "PREF", "hello example, i like you very much!");
			res = curl.curl_easy_setopt(CURLOPT_COOKIELIST, nline);
			if (res != CURLE_OK) {
				.fprintf((_iob[2]), "Curl curl_easy_setopt failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				return 1/* HTTP-header style cookie. If you use the Set-Cookie format and don't
				    specify a domain then the cookie is sent for any domain and will not be
				    modified, likely not what you intended. Starting in 7.43.0 any-domain
				    cookies will not be exported either. For more information refer to the
				    CURLOPT_COOKIELIST documentation.
				    */;
			} 
			._snprintf(nline, , "Set-Cookie: OLD_PREF=3d141414bf4209321; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.example.com");
			res = curl.curl_easy_setopt(CURLOPT_COOKIELIST, nline);
			if (res != CURLE_OK) {
				.fprintf((_iob[2]), "Curl curl_easy_setopt failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				return 1;
			} 
			ModernizedCProgram.print_cookies(curl);
			res = curl.curl_easy_perform();
			if (res != CURLE_OK) {
				.fprintf((_iob[2]), "Curl perform failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				return 1;
			} 
			curl.curl_easy_cleanup();
		} else {
				.fprintf((_iob[2]), "Curl init failed!\n");
				return 1;
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist recipients = ((Object)0);
		upload_status upload_ctx = new upload_status();
		upload_ctx.setLines_read(0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret"/* This is the URL for your mailserver. Note the use of port 587 here,
			     * instead of the normal SMTP port (25). Port 587 is commonly used for
			     * secure mail submission (see RFC4403), but you should use whatever
			     * matches your server configuration. */);
			curl.curl_easy_setopt(CURLOPT_URL, "smtp://mainserver.example.net:587"/* In this example, we'll start with a plain text connection, and upgrade
			     * to Transport Layer Security (TLS) using the STARTTLS command. Be careful
			     * of using CURLUSESSL_TRY here, because if TLS upgrade fails, the transfer
			     * will continue anyway - see the security discussion in the libcurl
			     * tutorial for more details. */);
			curl.curl_easy_setopt(CURLOPT_USE_SSL, (long)CURLUSESSL_ALL/* If your server doesn't have a valid certificate, then you can disable
			     * part of the Transport Layer Security protection by setting the
			     * CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST options to 0 (false).
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
			     * That is, in general, a bad idea. It is still better than sending your
			     * authentication details in plain text though.  Instead, you should get
			     * the issuer certificate (or the host certificate if the certificate is
			     * self-signed) and add it to the set of certificates that are known to
			     * libcurl using CURLOPT_CAINFO and/or CURLOPT_CAPATH. See docs/SSLCERTS
			     * for more information. */);
			curl.curl_easy_setopt(CURLOPT_CAINFO, "/path/to/certificate.pem"/* Note that this option isn't strictly required, omitting it will result
			     * in libcurl sending the MAIL FROM command with empty sender data. All
			     * autoresponses should have an empty reverse-path, and should be directed
			     * to the address in the reverse-path which triggered them. Otherwise,
			     * they could cause an endless loop. See RFC 5321 Section 4.5.5 for more
			     * details.
			     */);
			curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<sender@example.org>"/* Add two recipients, in this particular case they correspond to the
			     * To: and Cc: addressees in the header, but they could be any kind of
			     * recipient. */);
			recipients = recipients.curl_slist_append("<addressee@example.net>");
			recipients = recipients.curl_slist_append("<info@example.org>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients/* We're using a callback function to specify the payload (the headers and
			     * body of the message). You could just use the CURLOPT_READDATA option to
			     * specify a FILE pointer to read from. */);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
			curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024/* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the transfer.
			     */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = /* Send the message */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients.curl_slist_free_all();
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl_handle = new ();
		 res = new ();
		int prtall = 0;
		int prtsep = 0;
		int prttime = 0;
		byte url = "http://speedtest.your.domain/file_1M.bin";
		byte appname = argv[0];
		if (argc > 1) {
			for (; argv; ) {
				if (.strncasecmp(argv, "-", 1) == 0) {
					if (.strncasecmp(argv, "-H", 2) == 0) {
						.fprintf((_iob[2]), "\rUsage: %s [-m=1|2|5|10|20|50|100] [-t] [-x] [url]\n", appname);
						.exit(1);
					}  else if (.strncasecmp(argv, "-V", 2) == 0) {
						.fprintf((_iob[2]), "\r%s %s - %s\n", appname, "1.0", ModernizedCProgram.curl_version());
						.exit(1);
					}  else if (.strncasecmp(argv, "-A", 2) == 0) {
						prtall = 1;
					}  else if (.strncasecmp(argv, "-X", 2) == 0) {
						prtsep = 1;
					}  else if (.strncasecmp(argv, "-T", 2) == 0) {
						prttime = 1;
					}  else if (.strncasecmp(argv, "-M=", 3) == 0) {
						long m = .strtol((argv) + 3, ((Object)0), 10);
						switch (m) {
						case 2:
								url = "http://speedtest.your.domain/file_2M.bin";
								break;
						case 100:
								url = "http://speedtest.your.domain/file_100M.bin";
								break;
						case 1:
								url = "http://speedtest.your.domain/file_1M.bin";
								break;
						case 10:
								url = "http://speedtest.your.domain/file_10M.bin";
								break;
						case 50:
								url = "http://speedtest.your.domain/file_50M.bin";
								break;
						case 20:
								url = "http://speedtest.your.domain/file_20M.bin";
								break;
						case 5:
								url = "http://speedtest.your.domain/file_5M.bin";
								break;
						default:
								.fprintf((_iob[2]), "\r%s: invalid parameter %s\n", appname, argv + 3);
								.exit(1);
						}
					} else {
							.fprintf((_iob[2]), "\r%s: invalid or unknown option %s\n", appname, argv);
							.exit(1);
					} 
				} else {
						url = argv;
				} 
			}
		} 
		if (/* print separator line */prtsep) {
			.printf("-------------------------------------------------\n");
		} 
		if (/* print localtime */prttime) {
			time_t t = .time(((Object)0));
			.printf("Localtime: %s", .ctime(t));
		} 
		ModernizedCProgram.curl_global_init(/* init libcurl */CURL_GLOBAL_ALL);
		curl_handle = curl_easy.curl_easy_init();
		curl_handle.curl_easy_setopt(CURLOPT_URL, /* specify URL to get */url);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */WriteCallback);
		curl_handle.curl_easy_setopt(/* some servers don't like requests that are made without a user-agent
		     field, so we provide one */CURLOPT_USERAGENT, "libcurl-speedchecker/1.0");
		res = /* get it! */curl_handle.curl_easy_perform();
		/* cleanup curl stuff */curl_handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		FILE ftpfile = new FILE();
		FILE respfile = new FILE();
		ftpfile = .fopen("ftp-list", /* local file name to store the file as *//* b is binary, needed on win32 */"wb");
		respfile = .fopen("ftp-responses", /* local file name to store the FTP server's response lines in *//* b is binary, needed on win32 */"wb");
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* Get a file listing from sunet */"ftp://ftp.example.com/");
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, ftpfile/* If you intend to use this on windows with a libcurl DLL, you must use
			       CURLOPT_WRITEFUNCTION as well */);
			curl.curl_easy_setopt(CURLOPT_HEADERFUNCTION, write_response);
			curl.curl_easy_setopt(CURLOPT_HEADERDATA, respfile);
			res = curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		.fclose(/* close the local file */ftpfile);
		.fclose(/* close the response file */respfile);
		return 0;
		int i;
		for (i = 0; ModernizedCProgram.disabled[i]; i++) {
			.printf("%s\n", ModernizedCProgram.disabled[i]);
		}
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			byte p;
			long infilesize;
			upload_status upload_ctx = new upload_status();
			upload_ctx.setLines_read(0);
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret"/* This will create a new message 100. Note that you should perform an
			     * EXAMINE command to obtain the UID of the next message to create and a
			     * SELECT to ensure you are creating the message in the OUTBOX. */);
			curl.curl_easy_setopt(CURLOPT_URL, "imap://imap.example.com/100"/* In this case, we're using a callback function to specify the data. You
			     * could just use the CURLOPT_READDATA option to specify a FILE pointer to
			     * read from. */);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
			curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
			infilesize = 0;
			for (p = ModernizedCProgram.payload_text; p; ++p) {
				infilesize += (long).strlen(p);
			}
			curl.curl_easy_setopt(CURLOPT_INFILESIZE, infilesize);
			res = /* Perform the append */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret"/* This will list the folders within the user's mailbox. If you want to
			     * list the folders within a specific folder, for example the inbox, then
			     * specify the folder as a path in the URL such as /INBOX */);
			curl.curl_easy_setopt(CURLOPT_URL, "imap://imap.example.com");
			res = /* Perform the list */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl_handle = new ();
		 res = new ();
		MemoryStruct chunk = new MemoryStruct();
		chunk.setMemory(.malloc(/* will be grown as needed by the realloc above */1));
		chunk.setSize(/* no data at this point */0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl_handle = curl_easy.curl_easy_init();
		curl_handle.curl_easy_setopt(CURLOPT_URL, /* specify URL to get */"https://www.example.com/");
		curl_handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */WriteMemoryCallback);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEDATA, (Object)/* we pass our 'chunk' struct to the callback function */chunk);
		curl_handle.curl_easy_setopt(CURLOPT_USERAGENT, /* some servers don't like requests that are made without a user-agent
		     field, so we provide one */"libcurl-agent/1.0");
		res = /* get it! */curl_handle.curl_easy_perform();
		Object generatedSize = chunk.getSize();
		if (res != /* check for errors */CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res/*
			     * Now, our chunk.memory points to a memory block that is chunk.size
			     * bytes big and contains the remote file.
			     *
			     * Do something nice with it!
			     */));
		} else {
				.printf("%lu bytes retrieved\n", (long)generatedSize);
		} 
		/* cleanup curl stuff */curl_handle.curl_easy_cleanup();
		Byte generatedMemory = chunk.getMemory();
		.free(generatedMemory);
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 sock = CURL_SOCKET_BAD;
		 msgsock = CURL_SOCKET_BAD;
		int wrotepidfile = 0;
		byte pidname = ".socksd.pid";
		bool juggle_again = new bool();
		int error;
		int arg = 1;
		while (argc > arg) {
			if (!.strcmp("--version", argv[arg])) {
				ModernizedCProgram.curl_mprintf("socksd IPv4%s\n", "");
				return 0;
			}  else if (!.strcmp("--pidfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					pidname = argv[arg++];
				} 
			}  else if (!.strcmp("--config", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.configfile = argv[arg++];
				} 
			}  else if (!.strcmp("--backend", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.backendaddr = argv[arg++];
				} 
			}  else if (!.strcmp("--backendport", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.backendport = (int).atoi(argv[arg++]);
				} 
			}  else if (!.strcmp("--logfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.serverlogfile = argv[arg++];
				} 
			}  else if (!.strcmp("--ipv6", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--ipv4", argv[arg/* for completeness, we support this option as well */])) {
				arg++;
			}  else if (!.strcmp("--port", argv[arg])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || ((ulnum != -1024) && ((ulnum < -1024) || (ulnum > -1024)))) {
						(_iob[2]).curl_mfprintf("socksd: invalid --port argument (%s)\n", argv[arg]);
						return 0;
					} 
					ModernizedCProgram.port = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			} else {
					.puts("Usage: socksd [option]\n --backend [ipv4 addr]\n --backendport [TCP port]\n --config [file]\n --version\n --logfile [file]\n --pidfile [file]\n --ipv4\n --ipv6\n --bindonly\n --port [port]\n");
					return 0;
			} 
		}
		ModernizedCProgram.win32_init();
		.atexit(ModernizedCProgram.win32_cleanup);
		.setmode((((_iob[0])).get_file()), -1024);
		.setmode((((_iob[1])).get_file()), -1024);
		.setmode((((_iob[2])).get_file()), -1024);
		ModernizedCProgram.install_signal_handlers();
		sock = .socket(2, 1, 0);
		if (CURL_SOCKET_BAD == sock) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket: (%d) %s", error, .strerror(error));
			;
		} 
		{ 
			sock = ModernizedCProgram.sockdaemon(sock, /* passive daemon style */ModernizedCProgram.port);
			if (CURL_SOCKET_BAD == sock) {
				;
			} 
			msgsock = /* no stream socket yet */CURL_SOCKET_BAD;
		}
		ModernizedCProgram.logmsg("Running %s version", ModernizedCProgram.ipv_inuse);
		ModernizedCProgram.logmsg("Listening on port %hu", ModernizedCProgram.port);
		wrotepidfile = ModernizedCProgram.write_pidfile(pidname);
		if (!wrotepidfile) {
			;
		} 
		do {
			juggle_again = ModernizedCProgram.incoming(sock);
		} while (juggle_again);
		if (sock != CURL_SOCKET_BAD) {
			.closesocket((sock));
		} 
		if (wrotepidfile) {
			.unlink(pidname);
		} 
		ModernizedCProgram.restore_signal_handlers();
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("============> socksd exits with signal (%d)", ModernizedCProgram.exit_signal/*
			     * To properly set the return status of the process we
			     * must raise the same signal SIGINT or SIGTERM that we
			     * caught and let the old handler take care of it.
			     */);
			.raise(ModernizedCProgram.exit_signal);
		} 
		ModernizedCProgram.logmsg("============> socksd quits");
		return 0;
		 curl = new ();
		 res = new ();
		WriteThis wt = new WriteThis();
		wt.setReadptr(ModernizedCProgram.data);
		wt.setSizeleft(.strlen(ModernizedCProgram.data));
		res = ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_DEFAULT);
		if (res != /* Check for errors */CURLE_OK) {
			.fprintf((_iob[2]), "curl_global_init() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			return 1;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedSizeleft = wt.getSizeleft();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* First set the URL that is about to receive our POST. */"https://example.com/index.cgi");
			curl.curl_easy_setopt(CURLOPT_POST, /* Now specify we want to POST data */-1024);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
			curl.curl_easy_setopt(CURLOPT_READDATA, /* pointer to pass to our read function */wt);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* get verbose debug output please */-1024/*
			      If you use POST to a HTTP 1.1 server, you can send data without knowing
			      the size before starting the POST if you use chunked encoding. You
			      enable this by adding a header like "Transfer-Encoding: chunked" with
			      CURLOPT_HTTPHEADER. With HTTP 1.0 or without chunked transfer, you must
			      specify the size in the request.
			    */);
			curl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long)generatedSizeleft);
			res = /* use curl_slist_free_all() after the *perform() call to free this
			         list again *//* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is source mailbox folder to select */"imap://imap.example.com/INBOX");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the COPY command specifying the message ID and destination folder */"COPY 1 FOLDER"/* Note that to perform a move operation you will need to perform the copy,
			     * then mark the original mail as Deleted and EXPUNGE or CLOSE. Please see
			     * imap-store.c for more information on deleting messages. */);
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		ModernizedCProgram.loop = .uv_default_loop();
		if (argc <= 1) {
			return 0;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL)) {
			.fprintf((_iob[2]), "Could not init curl\n");
			return 1;
		} 
		.uv_timer_init(ModernizedCProgram.loop, ModernizedCProgram.timeout);
		Curl_multi curl_multi = new Curl_multi();
		ModernizedCProgram.curl_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_handle.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, handle_socket);
		ModernizedCProgram.curl_handle.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, start_timeout);
		while (argc-- > 1) {
			ModernizedCProgram.add_download(argv[argc], argc);
		}
		.uv_run(ModernizedCProgram.loop, UV_RUN_DEFAULT);
		ModernizedCProgram.curl_handle.curl_multi_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"imap://imap.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the EXAMINE command specifying the mailbox folder */"EXAMINE OUTBOX");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		if (argc <= 1) {
			return 0;
		} 
		if (ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL)) {
			.fprintf((_iob[2]), "Could not init curl\n");
			return 1;
		} 
		ModernizedCProgram.base = .event_base_new();
		ModernizedCProgram.timeout = .evtimer_new(ModernizedCProgram.base, on_timeout, ((Object)0));
		Curl_multi curl_multi = new Curl_multi();
		ModernizedCProgram.curl_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_handle.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, handle_socket);
		ModernizedCProgram.curl_handle.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, start_timeout);
		while (argc-- > 1) {
			ModernizedCProgram.add_download(argv[argc], argc);
		}
		.event_base_dispatch(ModernizedCProgram.base);
		ModernizedCProgram.curl_handle.curl_multi_cleanup();
		.event_free(ModernizedCProgram.timeout);
		.event_base_free(ModernizedCProgram.base);
		.libevent_global_shutdown();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set the username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_SASL_AUTHZID, /* Set the authorisation identity (identity to act as) */"shared-mailbox");
			curl.curl_easy_setopt(CURLOPT_LOGIN_OPTIONS, /* Force PLAIN authentication */"AUTH=PLAIN");
			curl.curl_easy_setopt(/* This will fetch message 1 from the user's inbox */CURLOPT_URL, "imap://imap.example.com/INBOX/;UID=1");
			res = /* Perform the fetch */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"imap://imap.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the CREATE command specifying the new folder name */"CREATE FOLDER");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 easy = new ();
		 multi_handle = new ();
		/* keep number of running handles */int still_running;
		int transfers = /* we start with one */1;
		CURLMsg m = new CURLMsg();
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		Curl_easy curl_easy = new Curl_easy();
		easy = curl_easy.curl_easy_init();
		if (ModernizedCProgram.setup(/* set options */easy)) {
			.fprintf((_iob[2]), "failed\n");
			return 1;
		} 
		ModernizedCProgram.curl_multi_add_handle(multi_handle, /* add the easy transfer */easy);
		multi_handle.curl_multi_setopt(CURLMOPT_PIPELINING, CURLPIPE_MULTIPLEX);
		multi_handle.curl_multi_setopt(CURLMOPT_PUSHFUNCTION, server_push_callback);
		multi_handle.curl_multi_setopt(CURLMOPT_PUSHDATA, transfers);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		Object generatedCURLMsg = m.getCURLMsg();
		do {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case 0:
			case -1/* select error */:
					break;
			default:
					multi_handle.curl_multi_perform(/* timeout or readable/writable sockets */still_running);
					break;
			}
			do {
				int msgq = 0;
				;
				m = multi_handle.curl_multi_info_read(msgq);
				if (m && (generatedCURLMsg == CURLMSG_DONE)) {
					 e = generatedCURLMsg;
					transfers--;
					ModernizedCProgram.curl_multi_remove_handle(multi_handle, e);
					e.curl_easy_cleanup();
				} 
			} while (m);
		} while (/* as long as we have transfers going */transfers);
		multi_handle.curl_multi_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		FILE headerfile = new FILE();
		byte pPassphrase = ((Object)0);
		byte pCertFile = "testcert.pem";
		byte pCACertFile = "cacert.pem";
		byte pHeaderFile = "dumpit";
		byte pKeyName;
		byte pKeyType;
		byte pEngine;
		pKeyName = /* for nChiper HSM... */"testkey.pem";
		pKeyType = "PEM";
		pEngine = ((Object)0);
		headerfile = .fopen(pHeaderFile, "wb");
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* what call to write: */"HTTPS://your.favourite.ssl.site");
			curl.curl_easy_setopt(CURLOPT_HEADERDATA, headerfile);
			do {
				if (pEngine) {
					if (curl.curl_easy_setopt(CURLOPT_SSLENGINE, pEngine) != /* use crypto engine */CURLE_OK) {
						.fprintf((_iob[2]), /* load the crypto engine */"can't set crypto engine\n");
						break;
					} 
					if (curl.curl_easy_setopt(CURLOPT_SSLENGINE_DEFAULT, -1024) != CURLE_OK/* set the crypto engine as default */) {
						.fprintf((_iob[2]), /* only needed for the first time you load
						             a engine in a curl object... */"can't set crypto engine as default\n");
						break;
					} 
				} 
				curl.curl_easy_setopt(CURLOPT_SSLCERTTYPE, /* cert is stored PEM coded in file... *//* since PEM is default, we needn't set it for PEM */"PEM");
				curl.curl_easy_setopt(CURLOPT_SSLCERT, /* set the cert for client authentication */pCertFile);
				if (/* sorry, for engine we must set the passphrase
				         (if the key has one...) */pPassphrase) {
					curl.curl_easy_setopt(CURLOPT_KEYPASSWD, pPassphrase);
				} 
				curl.curl_easy_setopt(CURLOPT_SSLKEYTYPE, /* if we use a key stored in a crypto engine,
				         we must set the key type to "ENG" */pKeyType);
				curl.curl_easy_setopt(CURLOPT_SSLKEY, /* set the private key (file or ID in engine) */pKeyName);
				curl.curl_easy_setopt(CURLOPT_CAINFO, /* set the file with the certs vaildating the server */pCACertFile);
				curl.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, /* disconnect if we can't validate server's cert */-1024);
				res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
				if (res != /* Check for errors */CURLE_OK) {
					.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
				} 
			} while (/* we are done... */0);
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		byte[] ftpurl = "ftp://ftp.example.com/gnu/binutils/binutils-2.19.1.tar.bz2";
		 curl = new ();
		 res = new ();
		long filetime = -1;
		double filesize = 0.0;
		byte filename = .strrchr(ftpurl, (byte)'/') + 1;
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, ftpurl);
			curl.curl_easy_setopt(CURLOPT_NOBODY, /* No download if the file */-1024);
			curl.curl_easy_setopt(CURLOPT_FILETIME, /* Ask for filetime */-1024);
			curl.curl_easy_setopt(CURLOPT_HEADERFUNCTION, throw_away);
			curl.curl_easy_setopt(CURLOPT_HEADER, -1024/* Switch on full protocol/debug output */);
			res = /* curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L); */curl.curl_easy_perform();
			if (CURLE_OK == res) {
				res = curl.curl_easy_getinfo(CURLINFO_FILETIME, /* https://curl.haxx.se/libcurl/c/curl_easy_getinfo.html */filetime);
				if ((CURLE_OK == res) && (filetime >= 0)) {
					time_t file_time = (time_t)filetime;
					.printf("filetime %s: %s", filename, .ctime(file_time));
				} 
				res = curl.curl_easy_getinfo(CURLINFO_CONTENT_LENGTH_DOWNLOAD, filesize);
				if ((CURLE_OK == res) && (filesize > 0.0)) {
					.printf("filesize %s: %0.0f bytes\n", filename, filesize);
				} 
			} else {
					.fprintf((_iob[2]), "curl told us %d\n", /* we failed */res);
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 mcurl = new ();
		int still_running = 1;
		timeval mp_start = new timeval();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			return 1;
		} 
		Curl_multi curl_multi = new Curl_multi();
		mcurl = curl_multi.curl_multi_init();
		if (!mcurl) {
			return 2;
		} 
		curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
		curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
		curl.curl_easy_setopt(CURLOPT_URL, /* This will fetch message 1 from the user's inbox */"imap://imap.example.com/INBOX/;UID=1");
		ModernizedCProgram.curl_multi_add_handle(mcurl, /* Tell the multi stack about our easy handle */curl);
		timeval timeval = new timeval();
		mp_start = timeval.tvnow();
		mcurl.curl_multi_perform(/* We start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			int rc;
			 mc = new ();
			long curl_timeo = -1;
			.FD_ZERO(/* Initialise the file descriptors */fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTimeval(/* Set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTimeval(0);
			mcurl.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTimeval(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTimeval() > 1) {
					ModernizedCProgram.timeout.setTimeval(1);
				} else {
						ModernizedCProgram.timeout.setTimeval((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(mcurl, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			if (timeval.tvnow().tvdiff(mp_start) > 60 * 1000) {
				.fprintf((_iob[2]), "ABORTING: Since it seems that we would have run forever.\n");
				break;
			} 
			switch (rc) {
			case /* timeout */0:
			case -/* select error */1:
					break;
			default:
					mcurl.curl_multi_perform(still_running);
					break;
			}
		}
		ModernizedCProgram.curl_multi_remove_handle(mcurl, /* Always cleanup */curl);
		mcurl.curl_multi_cleanup();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		/* curl easy handle */ handle = new ();
		callback_data data = new callback_data(/* help data */0);
		int rc = ModernizedCProgram.curl_global_init(/* global initialization */CURL_GLOBAL_ALL);
		if (rc) {
			return rc;
		} 
		Curl_easy curl_easy = new Curl_easy();
		handle = curl_easy.curl_easy_init();
		if (!handle) {
			ModernizedCProgram.curl_global_cleanup();
			return CURLE_OUT_OF_MEMORY;
		} 
		handle.curl_easy_setopt(CURLOPT_WILDCARDMATCH, /* turn on wildcard matching */-1024);
		handle.curl_easy_setopt(CURLOPT_CHUNK_BGN_FUNCTION, /* callback is called before download of concrete file started */ModernizedCProgram.file_is_coming);
		handle.curl_easy_setopt(CURLOPT_CHUNK_END_FUNCTION, /* callback is called after data from the file have been transferred */ModernizedCProgram.file_is_downloaded);
		handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* this callback will write contents into files */ModernizedCProgram.write_it);
		handle.curl_easy_setopt(CURLOPT_CHUNK_DATA, /* put transfer data into callbacks */data);
		handle.curl_easy_setopt(CURLOPT_WRITEDATA, data/* curl_easy_setopt(handle, CURLOPT_VERBOSE, 1L); */);
		if (argc == /* set an URL containing wildcard pattern (only in the last part) */2) {
			handle.curl_easy_setopt(CURLOPT_URL, argv[1]);
		} else {
				handle.curl_easy_setopt(CURLOPT_URL, "ftp://example.com/test/*");
		} 
		rc = /* and start transfer! */handle.curl_easy_perform();
		handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return rc;
		byte name = argc > 1 ? argv[1] : "openssl";
		 result = new ();
		if (!.strcmp("list", name)) {
			 list = new ();
			int i;
			result = ModernizedCProgram.curl_global_sslset(-1, ((Object)0), list);
			((result == CURLSSLSET_UNKNOWN_BACKEND) ? (Object)0 : ._assert("result == CURLSSLSET_UNKNOWN_BACKEND", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\sslbackend.c", 51));
			for (i = 0; list[i]; i++) {
				.printf("SSL backend #%d: '%s' (ID: %d)\n", i, list[i].getName(), list[i].getId());
			}
			return 0;
		}  else if (.isdigit((int)(byte)name)) {
			int id = .atoi(name);
			result = ModernizedCProgram.curl_global_sslset(()id, ((Object)0), ((Object)0));
		} else {
				result = ModernizedCProgram.curl_global_sslset(-1, name, ((Object)0));
		} 
		if (result == CURLSSLSET_UNKNOWN_BACKEND) {
			.fprintf((_iob[2]), "Unknown SSL backend id: %s\n", name);
			return 1;
		} 
		((result == CURLSSLSET_OK) ? (Object)0 : ._assert("result == CURLSSLSET_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\sslbackend.c", 72));
		.printf("Version with SSL backend '%s':\n\n\t%s\n", name, ModernizedCProgram.curl_version());
		return 0;
		 curl = new ();
		conf_t[] conf = new conf_t();
		int RetValue;
		ModernizedCProgram.ShowAllHeader = /* Do not show HTTP Header */0;
		ModernizedCProgram.AutoSyncTime = /* Do not synchronise computer clock */0;
		RetValue = /* Successful Exit */0;
		conf.conf_init();
		if (argc > 1) {
			int OptionIndex = 0;
			while (OptionIndex < argc) {
				if (.strncmp(argv[OptionIndex], "--server=", 9) == 0) {
					.snprintf(conf.getTimeserver(), 256, "%s", argv[OptionIndex][9]);
				} 
				if (.strcmp(argv[OptionIndex], "--showall") == 0) {
					ModernizedCProgram.ShowAllHeader = 1;
				} 
				if (.strcmp(argv[OptionIndex], "--synctime") == 0) {
					ModernizedCProgram.AutoSyncTime = 1;
				} 
				if (.strncmp(argv[OptionIndex], "--proxy-user=", 13) == 0) {
					.snprintf(conf.getProxy_user(), 256, "%s", argv[OptionIndex][13]);
				} 
				if (.strncmp(argv[OptionIndex], "--proxy=", 8) == 0) {
					.snprintf(conf.getHttp_proxy(), 256, "%s", argv[OptionIndex][8]);
				} 
				if ((.strcmp(argv[OptionIndex], "--help") == 0) || (.strcmp(argv[OptionIndex], "/?") == 0)) {
					ModernizedCProgram.showUsage();
					return 0;
				} 
				OptionIndex++;
			}
		} 
		if (conf.getTimeserver() == /* Use default server for time information */0) {
			.snprintf(conf.getTimeserver(), 256, "%s", ModernizedCProgram.DefaultTimeServer[0]);
		} 
		ModernizedCProgram.curl_global_init(/* Init CURL before usage */CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			tm lt = new tm();
			tm gmt = new tm();
			time_t tt = new time_t();
			time_t tt_local = new time_t();
			time_t tt_gmt = new time_t();
			double tzonediffFloat;
			int tzonediffWord;
			byte[] timeBuf = new byte[61];
			byte[] tzoneBuf = new byte[16];
			ModernizedCProgram.SyncTime_CURL_Init(curl, conf.getHttp_proxy(), conf.getProxy_user());
			tt = .time(/* Calculating time diff between GMT and localtime */0);
			lt = .localtime(tt);
			tt_local = .mktime(lt);
			gmt = .gmtime(tt);
			tt_gmt = .mktime(gmt);
			tzonediffFloat = .difftime(tt_local, tt_gmt);
			tzonediffWord = (int)(tzonediffFloat / 3600.0);
			if ((double)(tzonediffWord * 3600) == tzonediffFloat) {
				.snprintf(tzoneBuf, 15, "%+03d'00'", tzonediffWord);
			} else {
					.snprintf(tzoneBuf, 15, "%+03d'30'", tzonediffWord);
			} 
			.GetSystemTime(/* Get current system time and local time */ModernizedCProgram.SYSTime);
			.GetLocalTime(ModernizedCProgram.LOCALTime);
			.snprintf(timeBuf, 60, "%s, %02d %s %04d %02d:%02d:%02d.%03d, ", ModernizedCProgram.DayStr[ModernizedCProgram.LOCALTime.getWDayOfWeek()], ModernizedCProgram.LOCALTime.getWDay(), ModernizedCProgram.MthStr[ModernizedCProgram.LOCALTime.getWMonth() - 1], ModernizedCProgram.LOCALTime.getWYear(), ModernizedCProgram.LOCALTime.getWHour(), ModernizedCProgram.LOCALTime.getWMinute(), ModernizedCProgram.LOCALTime.getWSecond(), ModernizedCProgram.LOCALTime.getWMilliseconds());
			.fprintf((_iob[2]), "Fetch: %s\n\n", conf.getTimeserver());
			.fprintf((_iob[2]), "Before HTTP. Date: %s%s\n\n", timeBuf, tzoneBuf);
			ModernizedCProgram.SyncTime_CURL_Fetch(curl, conf.getTimeserver(), /* HTTP HEAD command to the Webserver */"index.htm", 0);
			.GetLocalTime(ModernizedCProgram.LOCALTime);
			.snprintf(timeBuf, 60, "%s, %02d %s %04d %02d:%02d:%02d.%03d, ", ModernizedCProgram.DayStr[ModernizedCProgram.LOCALTime.getWDayOfWeek()], ModernizedCProgram.LOCALTime.getWDay(), ModernizedCProgram.MthStr[ModernizedCProgram.LOCALTime.getWMonth() - 1], ModernizedCProgram.LOCALTime.getWYear(), ModernizedCProgram.LOCALTime.getWHour(), ModernizedCProgram.LOCALTime.getWMinute(), ModernizedCProgram.LOCALTime.getWSecond(), ModernizedCProgram.LOCALTime.getWMilliseconds());
			.fprintf((_iob[2]), "\nAfter  HTTP. Date: %s%s\n", timeBuf, tzoneBuf);
			if (ModernizedCProgram.AutoSyncTime == 3) {
				if (!.SetSystemTime(/* Synchronising computer clock *//* Set system time */ModernizedCProgram.SYSTime)) {
					.fprintf((_iob[2]), "ERROR: Unable to set system time.\n");
					RetValue = 1;
				} else {
						.GetLocalTime(/* Successfully re-adjusted computer clock */ModernizedCProgram.LOCALTime);
						.snprintf(timeBuf, 60, "%s, %02d %s %04d %02d:%02d:%02d.%03d, ", ModernizedCProgram.DayStr[ModernizedCProgram.LOCALTime.getWDayOfWeek()], ModernizedCProgram.LOCALTime.getWDay(), ModernizedCProgram.MthStr[ModernizedCProgram.LOCALTime.getWMonth() - 1], ModernizedCProgram.LOCALTime.getWYear(), ModernizedCProgram.LOCALTime.getWHour(), ModernizedCProgram.LOCALTime.getWMinute(), ModernizedCProgram.LOCALTime.getWSecond(), ModernizedCProgram.LOCALTime.getWMilliseconds());
						.fprintf((_iob[2]), "\nNew System's Date: %s%s\n", timeBuf, tzoneBuf);
				} 
			} 
			/* Cleanup before exit */conf.conf_init();
			curl.curl_easy_cleanup();
		} 
		return RetValue;
		 curl = new ();
		 res = new ();
		FtpFile ftpfile = new FtpFile(/* name to store the file as if successful */"yourfile.bin", ((Object)0));
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		curl = curl_easy.curl_easy_init();
		if (curl/*
		     * You better replace the URL with one that works! Note that we use an
		     * FTP:// URL with standard explicit FTPS. You can also do FTPS:// URLs if
		     * you want to do the rarer kind of transfers: implicit.
		     */) {
			curl.curl_easy_setopt(CURLOPT_URL, "ftp://user@server/home/user/file.txt");
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* Define our callback to get called when there's data to be written */my_fwrite);
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, /* Set a pointer to our struct to pass to the callback */ftpfile);
			curl.curl_easy_setopt(CURLOPT_USE_SSL, /* We activate SSL and we require it for both control and data */CURLUSESSL_ALL);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* Switch on full protocol/debug output */-1024);
			res = curl.curl_easy_perform();
			/* always cleanup */curl.curl_easy_cleanup();
			if (CURLE_OK != res) {
				.fprintf((_iob[2]), "curl told us %d\n", /* we failed */res);
			} 
		} 
		_iobuf generatedStream = ftpfile.getStream();
		if (generatedStream) {
			.fclose(generatedStream);
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		GlobalInfo g = new GlobalInfo();
		(Object)argc;
		(Object)argv;
		.memset(g, 0, );
		g.setLoop(.ev_default_loop(0));
		g.init_fifo();
		Curl_multi curl_multi = new Curl_multi();
		g.setMulti(curl_multi.curl_multi_init());
		event generatedTimer_event = g.getTimer_event();
		.ev_timer_init(generatedTimer_event, ModernizedCProgram.timer_cb, 0.0, 0.0);
		generatedTimer_event.setEv_timer(g);
		event generatedFifo_event = g.getFifo_event();
		generatedFifo_event.setEv_io(g);
		Object generatedMulti = g.getMulti();
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, sock_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETDATA, g);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, multi_timer_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERDATA, g/* we don't call any curl_multi_socket*() function yet as we have no handles
		     added! */);
		Object generatedLoop = g.getLoop();
		.ev_loop(generatedLoop, 0);
		generatedMulti.curl_multi_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl/* First set the URL that is about to receive our POST. This URL can
		       just as well be a https:// URL if that is what should receive the
		       data. */) {
			curl.curl_easy_setopt(CURLOPT_URL, "http://postit.example.com/moo.cgi");
			curl.curl_easy_setopt(CURLOPT_POSTFIELDS, /* Now specify the POST data */"name=daniel&project=curl");
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set the username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_SASL_AUTHZID, /* Set the authorisation identity (identity to act as) */"shared-mailbox");
			curl.curl_easy_setopt(CURLOPT_LOGIN_OPTIONS, /* Force PLAIN authentication */"AUTH=PLAIN");
			curl.curl_easy_setopt(CURLOPT_URL, /* This will retrieve message 1 from the user's mailbox */"pop3://pop.example.com/1");
			res = /* Perform the retr */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(/* This will fetch message 1 from the user's inbox */CURLOPT_URL, "imap://imap.example.com/INBOX/;UID=1"/* In this example, we'll start with a plain text connection, and upgrade
			     * to Transport Layer Security (TLS) using the STARTTLS command. Be careful
			     * of using CURLUSESSL_TRY here, because if TLS upgrade fails, the transfer
			     * will continue anyway - see the security discussion in the libcurl
			     * tutorial for more details. */);
			curl.curl_easy_setopt(CURLOPT_USE_SSL, (long)CURLUSESSL_ALL/* If your server doesn't have a valid certificate, then you can disable
			     * part of the Transport Layer Security protection by setting the
			     * CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST options to 0 (false).
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
			     *
			     * That is, in general, a bad idea. It is still better than sending your
			     * authentication details in plain text though.  Instead, you should get
			     * the issuer certificate (or the host certificate if the certificate is
			     * self-signed) and add it to the set of certificates that are known to
			     * libcurl using CURLOPT_CAINFO and/or CURLOPT_CAPATH. See docs/SSLCERTS
			     * for more information. */);
			curl.curl_easy_setopt(CURLOPT_CAINFO, "/path/to/certificate.pem"/* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the
			     * transfer */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = /* Perform the fetch */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		Object libptr;
		byte ssl_version;
		byte version;
		if (argc < 1) {
			.puts("report_openssl_version filename");
			.exit(1);
		} 
		libptr = .dlopen(argv[1], 0);
		ssl_version = (byte).dlsym(libptr, "SSLeay_version");
		if ((Object)ssl_version == ((Object)0)) {
			ssl_version = (byte).dlsym(libptr, "ssleay_version");
			if ((Object)ssl_version == ((Object)0)) {
				ssl_version = (byte).dlsym(libptr, "SSLEAY_VERSION");
			} 
		} 
		.dlclose(libptr);
		if ((Object)ssl_version == ((Object)0)) {
			.puts("Unable to lookup version of OpenSSL");
			.exit(1);
		} 
		version = .ssl_version(SSLEAY_VERSION);
		.puts(version);
		if (argc > /* Was a symbol argument given? */1) {
			int status;
			dsc$descriptor_s symbol_dsc = new dsc$descriptor_s();
			dsc$descriptor_s value_dsc = new dsc$descriptor_s();
			long table_type = LIB$K_CLI_LOCAL_SYM;
			symbol_dsc.setDsc$descriptor_s(argv[2]);
			symbol_dsc.setDsc$descriptor_s(.strlen(argv[2]));
			symbol_dsc.setDsc$descriptor_s(DSC$K_DTYPE_T);
			symbol_dsc.setDsc$descriptor_s(DSC$K_CLASS_S);
			value_dsc.setDsc$descriptor_s((byte)/* Cast ok */version);
			value_dsc.setDsc$descriptor_s(.strlen(version));
			value_dsc.setDsc$descriptor_s(DSC$K_DTYPE_T);
			value_dsc.setDsc$descriptor_s(DSC$K_CLASS_S);
			status = .LIB$SET_SYMBOL(symbol_dsc, value_dsc, table_type);
			if (!.$VMS_STATUS_SUCCESS(status)) {
				.exit(status);
			} 
		} 
		.exit(0);
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This will retrieve message 1 from the user's mailbox */"pop3://pop.example.com/1"/* In this example, we'll start with a plain text connection, and upgrade
			     * to Transport Layer Security (TLS) using the STLS command. Be careful of
			     * using CURLUSESSL_TRY here, because if TLS upgrade fails, the transfer
			     * will continue anyway - see the security discussion in the libcurl
			     * tutorial for more details. */);
			curl.curl_easy_setopt(CURLOPT_USE_SSL, (long)CURLUSESSL_ALL/* If your server doesn't have a valid certificate, then you can disable
			     * part of the Transport Layer Security protection by setting the
			     * CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST options to 0 (false).
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			     *   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
			     *
			     * That is, in general, a bad idea. It is still better than sending your
			     * authentication details in plain text though.  Instead, you should get
			     * the issuer certificate (or the host certificate if the certificate is
			     * self-signed) and add it to the set of certificates that are known to
			     * libcurl using CURLOPT_CAINFO and/or CURLOPT_CAPATH. See docs/SSLCERTS
			     * for more information. */);
			curl.curl_easy_setopt(CURLOPT_CAINFO, "/path/to/certificate.pem"/* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the
			     * transfer */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = /* Perform the retr */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl_handle = new ();
		byte pagefilename = "page.out";
		FILE pagefile = new FILE();
		if (argc < 2) {
			.printf("Usage: %s <URL>\n", argv[0]);
			return 1;
		} 
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl_handle = curl_easy.curl_easy_init();
		curl_handle.curl_easy_setopt(CURLOPT_URL, argv[/* set URL to get here */1]);
		curl_handle.curl_easy_setopt(CURLOPT_VERBOSE, /* Switch on full protocol/debug output while testing */-1024);
		curl_handle.curl_easy_setopt(CURLOPT_NOPROGRESS, /* disable progress meter, set to 0L to enable and disable debug output */-1024);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */write_data);
		pagefile = .fopen(pagefilename, /* open the file */"wb");
		if (pagefile) {
			curl_handle.curl_easy_setopt(CURLOPT_WRITEDATA, /* write the page body to this file handle */pagefile);
			/* get it! */curl_handle.curl_easy_perform();
			.fclose(/* close the header file */pagefile);
		} 
		/* cleanup curl stuff */curl_handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(/* This will fetch message 1 from the user's inbox. Note the use of
			    * imaps:// rather than imap:// to request a SSL based connection. */CURLOPT_URL, "imaps://imap.example.com/INBOX/;UID=1"/* If you want to connect to a site who isn't using a certificate that is
			     * signed by one of the certs in the CA bundle you have, you can skip the
			     * verification of the server's certificate. This makes the connection
			     * A LOT LESS SECURE.
			     *
			     * If you have a CA cert for the server stored someplace else than in the
			     * default bundle, then the CURLOPT_CAPATH option might come handy for
			     * you. */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* If the site you're connecting to uses a different host name that what
			     * they have mentioned in their server certificate's commonName (or
			     * subjectAltName) fields, libcurl will refuse to connect. You can skip
			     * this check, but this will make the connection less secure. *//* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the
			     * transfer */-1024);
			res = /* Perform the fetch */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		URL_FILE handle = new URL_FILE();
		FILE outf = new FILE();
		size_t nread = new size_t();
		byte[] buffer = new byte[256];
		byte url;
		if (argc < 2) {
			url = /* default to testurl */"http://192.168.7.3/testfile";
		} else {
				url = argv[/* use passed url */1];
		} 
		outf = .fopen("fgets.test", /* copy from url line by line with fgets */"wb+");
		if (!outf) {
			.perror("couldn't open fgets output file\n");
			return 1;
		} 
		fcurl_data fcurl_data = new fcurl_data();
		handle = fcurl_data.url_fopen(url, "r");
		if (!handle) {
			.printf("couldn't url_fopen() %s\n", url);
			.fclose(outf);
			return 2;
		} 
		while (!handle.url_feof()) {
			handle.url_fgets(buffer, );
			.fwrite(buffer, 1, .strlen(buffer), outf);
		}
		handle.url_fclose();
		.fclose(outf);
		outf = .fopen("fread.test", /* Copy from url with fread */"wb+");
		if (!outf) {
			.perror("couldn't open fread output file\n");
			return 1;
		} 
		handle = fcurl_data.url_fopen("testfile", "r");
		if (!handle) {
			.printf("couldn't url_fopen() testfile\n");
			.fclose(outf);
			return 2;
		} 
		do {
			nread = handle.url_fread(buffer, 1, );
			.fwrite(buffer, 1, nread, outf);
		} while (nread);
		handle.url_fclose();
		.fclose(outf);
		outf = .fopen("rewind.test", /* Test rewind */"wb+");
		if (!outf) {
			.perror("couldn't open fread output file\n");
			return 1;
		} 
		handle = fcurl_data.url_fopen("testfile", "r");
		if (!handle) {
			.printf("couldn't url_fopen() testfile\n");
			.fclose(outf);
			return 2;
		} 
		nread = handle.url_fread(buffer, 1, );
		.fwrite(buffer, 1, nread, outf);
		handle.url_rewind();
		buffer[0] = (byte)'\n';
		.fwrite(buffer, 1, 1, outf);
		nread = handle.url_fread(buffer, 1, );
		.fwrite(buffer, 1, nread, outf);
		handle.url_fclose();
		.fclose(outf);
		return /* all done */0;
		 curl = new ();
		 res = new ();
		byte location;
		long response_code;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com"/* example.com is redirected, figure out the redirection! */);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} else {
					res = curl.curl_easy_getinfo(CURLINFO_RESPONSE_CODE, response_code);
					if ((res == CURLE_OK) && ((response_code / 100) != 3)) {
						.fprintf((_iob[2]), /* a redirect implies a 3xx response code */"Not a redirect.\n");
					} else {
							res = curl.curl_easy_getinfo(CURLINFO_REDIRECT_URL, location);
							if ((res == CURLE_OK) && location/* This is the new absolute URL that you could redirect to, even if
							           * the Location: response header may have been a relative URL. */) {
								.printf("Redirected to: %s\n", location);
							} 
					} 
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		pthread_t[] tid = new pthread_t();
		int i;
		ModernizedCProgram.curl_global_init(/* Must initialize libcurl before any threads are started */CURL_GLOBAL_ALL);
		for (i = 0; i < 4; i++) {
			int error = .pthread_create(tid[i], ((Object)/* default attributes please */0), pull_one_url, (Object)ModernizedCProgram.urls[i]);
			if (0 != error) {
				.fprintf((_iob[2]), "Couldn't run thread number %d, errno %d\n", i, error);
			} else {
					.fprintf((_iob[2]), "Thread %d, gets %s\n", i, ModernizedCProgram.urls[i]);
			} 
		}
		for (i = 0; i < 4; /* now wait for all threads to terminate */i++) {
			.pthread_join(tid[i], ((Object)0));
			.fprintf((_iob[2]), "Thread %d terminated\n", i);
		}
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This will list every message of the given mailbox */"pop3://pop.example.com");
			res = /* Perform the list */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		FILE hd_src = new FILE();
		stat file_info = new stat();
		 fsize = new ();
		curl_slist headerlist = ((Object)0);
		byte[] buf_1 = "RNFR while-uploading.txt";
		byte[] buf_2 = "RNTO renamed-and-fine.txt";
		if (.stat("/tmp/uploadthis.txt", /* get the file size of the local file */file_info)) {
			.printf("Couldn't open '%s': %s\n", "/tmp/uploadthis.txt", .strerror((._errno())));
			return 1;
		} 
		Object generatedSt_size = file_info.getSt_size();
		fsize = ()generatedSt_size;
		hd_src = .fopen("/tmp/uploadthis.txt", /* get a FILE * of the same file */"rb");
		ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			headerlist = headerlist.curl_slist_append(/* build a list of commands to pass to libcurl */buf_1);
			headerlist = headerlist.curl_slist_append(buf_2);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, /* enable uploading */-1024);
			curl.curl_easy_setopt(CURLOPT_URL, /* specify target */"ftp://example.com/while-uploading.txt");
			curl.curl_easy_setopt(CURLOPT_POSTQUOTE, /* pass in that last of FTP commands to run after the transfer */headerlist);
			curl.curl_easy_setopt(CURLOPT_READDATA, /* now specify which file to upload */hd_src/* Set the size of the file to upload (optional).  If you give a *_LARGE
			       option you MUST make sure that the type of the passed-in argument is a
			       curl_off_t. If you use CURLOPT_INFILESIZE (without _LARGE) you must
			       make sure that to pass in a type 'long' argument. */);
			curl.curl_easy_setopt(CURLOPT_INFILESIZE_LARGE, ()fsize);
			res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* clean up the FTP commands list */headerlist.curl_slist_free_all();
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		.fclose(/* close the local file */hd_src);
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = new ();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/");
			res = curl.curl_easy_perform();
			if (CURLE_OK == res) {
				byte ct;
				res = curl.curl_easy_getinfo(CURLINFO_CONTENT_TYPE, /* ask for the content-type */ct);
				if ((CURLE_OK == res) && ct) {
					.printf("We received Content-Type: %s\n", ct);
				} 
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* You can specify the message either in the URL or DELE command */"pop3://pop.example.com/1");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the DELE command */"DELE");
			curl.curl_easy_setopt(CURLOPT_NOBODY, /* Do not perform a transfer as DELE returns no data */-1024);
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK;
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"pop3://pop.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the UIDL command */"UIDL");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		srvr_sockaddr_union_t me = new srvr_sockaddr_union_t();
		tftphdr tp = new tftphdr();
		ssize_t n = 0;
		int arg = 1;
		int port = 8999;
		 sock = CURL_SOCKET_BAD;
		int flag;
		int rc;
		int error;
		long pid;
		testcase test = new testcase();
		int result = 0;
		.memset(test, 0, );
		while (argc > arg) {
			if (!.strcmp("--version", argv[arg])) {
				ModernizedCProgram.curl_mprintf("tftpd IPv4%s\n", "");
				return 0;
			}  else if (!.strcmp("--pidfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.pidname = argv[arg++];
				} 
			}  else if (!.strcmp("--logfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.serverlogfile = argv[arg++];
				} 
			}  else if (!.strcmp("--ipv4", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--ipv6", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--port", argv[arg])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || (ulnum < -1024) || (ulnum > -1024)) {
						(_iob[2]).curl_mfprintf("tftpd: invalid --port argument (%s)\n", argv[arg]);
						return 0;
					} 
					port = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			}  else if (!.strcmp("--srcdir", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.path = argv[arg];
					arg++;
				} 
			} else {
					.puts("Usage: tftpd [option]\n --version\n --logfile [file]\n --pidfile [file]\n --ipv4\n --ipv6\n --port [port]\n --srcdir [path]");
					return 0;
			} 
		}
		ModernizedCProgram.win32_init();
		.atexit(ModernizedCProgram.win32_cleanup);
		ModernizedCProgram.install_signal_handlers();
		pid = (long).getpid();
		sock = .socket(2, 2, 0);
		if (CURL_SOCKET_BAD == sock) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket: (%d) %s", error, .strerror(error));
			result = 1;
			;
		} 
		flag = 1;
		if (0 != .setsockopt(sock, -1024, 4, (Object)flag, )) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed with error: (%d) %s", error, .strerror(error));
			result = 1;
			;
		} 
		Object generatedSa4 = me.getSa4();
		.memset(generatedSa4, 0, );
		generatedSa4.setSin_family(2);
		generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
		generatedSa4.setSin_port(.htons(port));
		Object generatedSa = me.getSa();
		rc = .bind(sock, generatedSa, );
		if (0 != /* ENABLE_IPV6 */rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error binding socket on port %hu: (%d) %s", port, error, .strerror(error));
			result = 1;
			;
		} 
		ModernizedCProgram.wrotepidfile = ModernizedCProgram.write_pidfile(ModernizedCProgram.pidname);
		if (!ModernizedCProgram.wrotepidfile) {
			result = 1;
			;
		} 
		ModernizedCProgram.logmsg("Running %s version on port UDP/%d", ModernizedCProgram.ipv_inuse, (int)port);
		int generatedTh_opcode = tp.getTh_opcode();
		Object generatedBuffer = test.getBuffer();
		Object generatedOfile = test.getOfile();
		for (; ; ) {
			ModernizedCProgram.fromlen = ;
			ModernizedCProgram.fromlen = ;
			n = (ssize_t).recvfrom(sock, ModernizedCProgram.buf.getStorage()[0], , 0, generatedSa, ModernizedCProgram.fromlen);
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			if (n < 0) {
				ModernizedCProgram.logmsg("recvfrom");
				result = 3;
				break;
			} 
			ModernizedCProgram.set_advisor_read_lock("log/serverlogs.lock");
			ModernizedCProgram.serverlogslocked = 1;
			generatedSa4.setSin_family(2);
			ModernizedCProgram.peer = .socket(2, 2, 0);
			if (CURL_SOCKET_BAD == ModernizedCProgram.peer) {
				ModernizedCProgram.logmsg("socket");
				result = 2;
				break;
			} 
			if (.connect(ModernizedCProgram.peer, generatedSa, ) < 0) {
				ModernizedCProgram.logmsg("connect: fail");
				result = 1;
				break;
			} 
			ModernizedCProgram.maxtimeout = 5 * 5;
			tp = ModernizedCProgram.buf.getHdr();
			tp.setTh_opcode(.ntohs(generatedTh_opcode));
			if (generatedTh_opcode == 1 || generatedTh_opcode == 2) {
				.memset(test, 0, );
				if (ModernizedCProgram.do_tftp(test, tp, n) < 0) {
					break;
				} 
				.free(generatedBuffer);
			} 
			.closesocket((ModernizedCProgram.peer));
			ModernizedCProgram.peer = CURL_SOCKET_BAD;
			if (generatedOfile > 0) {
				.close(generatedOfile);
				test.setOfile(0);
			} 
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			if (ModernizedCProgram.serverlogslocked) {
				ModernizedCProgram.serverlogslocked = 0;
				ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
			} 
			ModernizedCProgram.logmsg("end of one transfer");
		}
		if ((ModernizedCProgram.peer != sock) && (ModernizedCProgram.peer != CURL_SOCKET_BAD)) {
			.closesocket((ModernizedCProgram.peer));
		} 
		if (sock != CURL_SOCKET_BAD) {
			.closesocket((sock));
		} 
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("signalled to die");
		} 
		if (ModernizedCProgram.wrotepidfile) {
			.unlink(ModernizedCProgram.pidname);
		} 
		if (ModernizedCProgram.serverlogslocked) {
			ModernizedCProgram.serverlogslocked = 0;
			ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
		} 
		ModernizedCProgram.restore_signal_handlers();
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("========> %s tftpd (port: %d pid: %ld) exits with signal (%d)", ModernizedCProgram.ipv_inuse, (int)port, pid, ModernizedCProgram.exit_signal/*
			     * To properly set the return status of the process we
			     * must raise the same signal SIGINT or SIGTERM that we
			     * caught and let the old handler take care of it.
			     */);
			.raise(ModernizedCProgram.exit_signal);
		} 
		ModernizedCProgram.logmsg("========> tftpd quits");
		return result/*
		 * Handle initial connection protocol.
		 */;
		 curl = new ();
		 multi_handle = new ();
		int still_running = 0;
		 form = ((Object)0);
		 field = ((Object)0);
		curl_slist headerlist = ((Object)0);
		byte[] buf = "Expect:";
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		if (curl && multi_handle) {
			form = /* Create the form */curl.curl_mime_init();
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the file upload field */form);
			ModernizedCProgram.curl_mime_name(field, "sendfile");
			ModernizedCProgram.curl_mime_filedata(field, "multi-post.c");
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the filename field */form);
			ModernizedCProgram.curl_mime_name(field, "filename");
			ModernizedCProgram.curl_mime_data(field, "multi-post.c", CURL_ZERO_TERMINATED);
			field = ModernizedCProgram.curl_mime_addpart(/* Fill in the submit field too, even if this is rarely needed */form);
			ModernizedCProgram.curl_mime_name(field, "submit");
			ModernizedCProgram.curl_mime_data(field, "send", CURL_ZERO_TERMINATED);
			headerlist = headerlist.curl_slist_append(/* initialize custom header list (stating that Expect: 100-continue is not
			       wanted */buf);
			curl.curl_easy_setopt(CURLOPT_URL, /* what URL that receives this POST */"https://www.example.com/upload.cgi");
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			curl.curl_easy_setopt(CURLOPT_HTTPHEADER, headerlist);
			curl.curl_easy_setopt(CURLOPT_MIMEPOST, form);
			ModernizedCProgram.curl_multi_add_handle(multi_handle, curl);
			multi_handle.curl_multi_perform(still_running);
			while (still_running) {
				timeval timeout = new timeval();
				int rc;
				 mc = new ();
				 fdread = new ();
				 fdwrite = new ();
				 fdexcep = new ();
				int maxfd = -1;
				long curl_timeo = -1;
				.FD_ZERO(fdread);
				.FD_ZERO(fdwrite);
				.FD_ZERO(fdexcep);
				ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
				ModernizedCProgram.timeout.setTv_usec(0);
				multi_handle.curl_multi_timeout(curl_timeo);
				if (curl_timeo >= 0) {
					ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
					if (ModernizedCProgram.timeout.getTv_sec() > 1) {
						ModernizedCProgram.timeout.setTv_sec(1);
					} else {
							ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
					} 
				} 
				mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
				if (mc != CURLM_OK) {
					.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
					break;
				} 
				if (maxfd == -1) {
					.Sleep(100);
					rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
				} else {
						rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
						           If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
				} 
				switch (rc) {
				case 0:
				case -1/* select error */:
						break;
				default:
						.printf(/* timeout or readable/writable sockets */"perform!\n");
						multi_handle.curl_multi_perform(still_running);
						.printf("running: %d!\n", still_running);
						break;
				}
			}
			multi_handle.curl_multi_cleanup();
			/* always cleanup */curl.curl_easy_cleanup();
			ModernizedCProgram.curl_mime_free(/* then cleanup the form */form);
			/* free slist */headerlist.curl_slist_free_all();
		} 
		return 0;
		 curl = new ();
		 res = new ();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com");
			curl.curl_easy_setopt(CURLOPT_ALTSVC, /* cache the alternatives in this file */"altsvc.txt");
			curl.curl_easy_setopt(CURLOPT_ALTSVC_CTRL, /* restrict which HTTP versions to use alternatives */(long)CURLALTSVC_H1 | CURLALTSVC_H2 | CURLALTSVC_H3);
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This will retrieve message 1 from the user's mailbox. Note the use of
			     * pop3s:// rather than pop3:// to request a SSL based connection. */"pop3s://pop.example.com/1"/* If you want to connect to a site who isn't using a certificate that is
			     * signed by one of the certs in the CA bundle you have, you can skip the
			     * verification of the server's certificate. This makes the connection
			     * A LOT LESS SECURE.
			     *
			     * If you have a CA cert for the server stored someplace else than in the
			     * default bundle, then the CURLOPT_CAPATH option might come handy for
			     * you. */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, /* If the site you're connecting to uses a different host name that what
			     * they have mentioned in their server certificate's commonName (or
			     * subjectAltName) fields, libcurl will refuse to connect. You can skip
			     * this check, but this will make the connection less secure. *//* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the
			     * transfer */-1024);
			res = /* Perform the retr */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl_slist chunk = ((Object)0);
			chunk = chunk.curl_slist_append(/* Remove a header curl would otherwise add by itself */"Accept:");
			chunk = chunk.curl_slist_append(/* Add a custom header */"Another: yes");
			chunk = chunk.curl_slist_append(/* Modify a header curl otherwise adds differently */"Host: example.com");
			chunk = chunk.curl_slist_append(/* Add a header with "blank" contents to the right of the colon. Note that
			       we're then using a semicolon in the string we pass to curl! */"X-silly-header;");
			curl.curl_easy_setopt(CURLOPT_HTTPHEADER, /* set our custom set of headers */chunk);
			curl.curl_easy_setopt(CURLOPT_URL, "localhost");
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
			/* free the custom headers */chunk.curl_slist_free_all();
		} 
		return 0;
		 curl = new ();
		 res = new ();
		curl_slist recipients = ((Object)0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver */"smtp://mail.example.com");
			recipients = recipients.curl_slist_append(/* Note that the CURLOPT_MAIL_RCPT takes a list, not a char array  */"Friends");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients);
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the EXPN command */"EXPN");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients/* Curl won't send the QUIT command until you call cleanup, so you should
			     * be able to re-use this connection for additional requests. It may not be
			     * a good idea to keep the connection open for a very long time though
			     * (more than a few minutes may result in the server timing out the
			     * connection) and you do want to clean up in the end.
			     */.curl_slist_free_all();
			curl.curl_easy_cleanup();
		} 
		return 0;
		.signal(2, sighandler);
		LIBXML_TEST_VERSION;
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_multi curl_multi = new Curl_multi();
		 multi_handle = curl_multi.curl_multi_init();
		multi_handle.curl_multi_setopt(CURLMOPT_MAX_TOTAL_CONNECTIONS, ModernizedCProgram.max_con);
		multi_handle.curl_multi_setopt(CURLMOPT_MAX_HOST_CONNECTIONS, -1024/* enables http/2 if available */);
		ModernizedCProgram.curl_multi_add_handle(multi_handle, ModernizedCProgram.make_handle(/* sets html start page */ModernizedCProgram.start_page));
		int msgs_left;
		int pending = 0;
		int complete = 0;
		int still_running = 1;
		Object generatedSize = mem.getSize();
		Object generatedBuf = mem.getBuf();
		while (still_running && !ModernizedCProgram.pending_interrupt) {
			int numfds;
			.curl_multi_wait(multi_handle, ((Object)0), 0, 1000, numfds);
			multi_handle.curl_multi_perform(still_running);
			 m = ((Object)/* See how the transfers went */0);
			while ((m = multi_handle.curl_multi_info_read(msgs_left))) {
				if (m.getMsg() == CURLMSG_DONE) {
					 handle = m.getEasy_handle();
					byte url;
					memory mem = new memory();
					handle.curl_easy_getinfo(CURLINFO_PRIVATE, mem);
					handle.curl_easy_getinfo(CURLINFO_EFFECTIVE_URL, url);
					if (m.getData().getResult() == CURLE_OK) {
						long res_status;
						handle.curl_easy_getinfo(CURLINFO_RESPONSE_CODE, res_status);
						if (res_status == 200) {
							byte ctype;
							handle.curl_easy_getinfo(CURLINFO_CONTENT_TYPE, ctype);
							.printf("[%d] HTTP 200 (%s): %s\n", complete, ctype, url);
							if (ModernizedCProgram.is_html(ctype) && generatedSize > 100) {
								if (pending < ModernizedCProgram.max_requests && (complete + pending) < ModernizedCProgram.max_total) {
									pending += mem.follow_links(multi_handle, url);
									still_running = 1;
								} 
							} 
						} else {
								.printf("[%d] HTTP %d: %s\n", complete, (int)res_status, url);
						} 
					} else {
							.printf("[%d] Connection failure: %s\n", complete, url);
					} 
					ModernizedCProgram.curl_multi_remove_handle(multi_handle, handle);
					handle.curl_easy_cleanup();
					.free(generatedBuf);
					.free(mem);
					complete++;
					pending--;
				} 
			}
		}
		multi_handle.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This will retrieve message 1 from the user's mailbox */"pop3://pop.example.com/1");
			res = /* Perform the retr */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			curl.curl_easy_setopt(CURLOPT_HEADER, -1024);
			curl.curl_easy_setopt(CURLOPT_URL, /* get the first document */"https://example.com/");
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			curl.curl_easy_setopt(CURLOPT_URL, /* get another document from the same server using the same
			       connection */"https://example.com/docs/");
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 curl = new ();
		 mcurl = new ();
		int still_running = 1;
		timeval mp_start = new timeval();
		curl_slist recipients = ((Object)0);
		upload_status upload_ctx = new upload_status();
		upload_ctx.setLines_read(0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			return 1;
		} 
		Curl_multi curl_multi = new Curl_multi();
		mcurl = curl_multi.curl_multi_init();
		if (!mcurl) {
			return 2;
		} 
		curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver */"smtp://mail.example.com"/* Note that this option isn't strictly required, omitting it will result in
		   * libcurl sending the MAIL FROM command with empty sender data. All
		   * autoresponses should have an empty reverse-path, and should be directed
		   * to the address in the reverse-path which triggered them. Otherwise, they
		   * could cause an endless loop. See RFC 5321 Section 4.5.5 for more details.
		   */);
		curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<sender@example.com>"/* Add two recipients, in this particular case they correspond to the
		   * To: and Cc: addressees in the header, but they could be any kind of
		   * recipient. */);
		recipients = recipients.curl_slist_append("<recipient@example.com>");
		recipients = recipients.curl_slist_append("<info@example.com>");
		curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients/* We're using a callback function to specify the payload (the headers and
		   * body of the message). You could just use the CURLOPT_READDATA option to
		   * specify a FILE pointer to read from. */);
		curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
		curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
		curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
		ModernizedCProgram.curl_multi_add_handle(mcurl, /* Tell the multi stack about our easy handle */curl);
		timeval timeval = new timeval();
		mp_start = timeval.tvnow();
		mcurl.curl_multi_perform(/* We start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			int rc;
			 mc = new ();
			long curl_timeo = -1;
			.FD_ZERO(/* Initialise the file descriptors */fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTimeval(/* Set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTimeval(0);
			mcurl.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTimeval(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTimeval() > 1) {
					ModernizedCProgram.timeout.setTimeval(1);
				} else {
						ModernizedCProgram.timeout.setTimeval((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(mcurl, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf(stderr, "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			if (timeval.tvnow().tvdiff(mp_start) > 60 * 1000) {
				.fprintf(stderr, "ABORTING: Since it seems that we would have run forever.\n");
				break;
			} 
			switch (rc) {
			case /* timeout */0:
			case -/* select error */1:
					break;
			default:
					mcurl.curl_multi_perform(still_running);
					break;
			}
		}
		/* Free the list of recipients */recipients.curl_slist_free_all();
		ModernizedCProgram.curl_multi_remove_handle(mcurl, /* Always cleanup */curl);
		mcurl.curl_multi_cleanup();
		curl.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		GlobalInfo g = new GlobalInfo();
		itimerspec its = new itimerspec();
		epoll_event ev = new epoll_event();
		epoll_event[] events = new epoll_event();
		(Object)argc;
		(Object)argv;
		ModernizedCProgram.g_should_exit_ = 0;
		.signal(2, SignalHandler);
		.memset(g, 0, );
		g.setEpfd(.epoll_create1(EPOLL_CLOEXEC));
		Object generatedEpfd = g.getEpfd();
		if (generatedEpfd == -1) {
			.perror("epoll_create1 failed");
			.exit(1);
		} 
		g.setTfd(.timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC));
		Object generatedTfd = g.getTfd();
		if (generatedTfd == -1) {
			.perror("timerfd_create failed");
			.exit(1);
		} 
		.memset(its, 0, );
		Object generatedItimerspec = its.getItimerspec();
		generatedItimerspec.setTv_sec(1);
		generatedItimerspec.setTv_sec(1);
		.timerfd_settime(generatedTfd, 0, its, ((Object)0));
		ev.setEpoll_event(EPOLLIN);
		Object generatedEpoll_event = ev.getEpoll_event();
		generatedEpoll_event.setFd(generatedTfd);
		.epoll_ctl(generatedEpfd, EPOLL_CTL_ADD, generatedTfd, ev);
		g.init_fifo();
		Curl_multi curl_multi = new Curl_multi();
		g.setMulti(curl_multi.curl_multi_init());
		Object generatedMulti = g.getMulti();
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, /* setup the generic multi interface options we want */sock_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETDATA, g);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, multi_timer_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERDATA, g/* we don't call any curl_multi_socket*() function yet as we have no handles
		     added! */);
		.fprintf((_iob[1]), "Entering wait loop\n");
		.fflush((_iob[1]));
		Object generatedFifofd = g.getFifofd();
		while (!ModernizedCProgram.g_should_exit_) {
			int idx;
			int err = .epoll_wait(generatedEpfd, events,  / , 10000);
			if (err == -1) {
				if ((._errno()) == 4) {
					.fprintf((_iob[1]), "note: wait interrupted\n");
					continue;
				} else {
						.perror("epoll_wait");
						.exit(1);
				} 
			} 
			for (idx = 0; idx < err; ++idx) {
				if (generatedEpoll_event.getFd() == generatedFifofd) {
					ModernizedCProgram.fifo_cb(g, generatedEpoll_event);
				}  else if (generatedEpoll_event.getFd() == generatedTfd) {
					ModernizedCProgram.timer_cb(g, generatedEpoll_event);
				} else {
						ModernizedCProgram.event_cb(g, generatedEpoll_event.getFd(), generatedEpoll_event);
				} 
			}
		}
		.fprintf((_iob[1]), "Exiting normally.\n");
		.fflush((_iob[1]));
		generatedMulti.curl_multi_cleanup();
		g.clean_fifo();
		return 0;
		 curl = new ();
		 res = new ();
		/*  socket address structure  */sockaddr_in servaddr = new sockaddr_in();
		 sockfd = new ();
		WSADATA wsaData = new WSADATA();
		int initwsa = .WSAStartup(((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(false))) << 8))), wsaData);
		if (initwsa != 0) {
			.printf("WSAStartup failed: %d\n", initwsa);
			return 1;
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedSin_addr = servaddr.getSin_addr();
		if (curl/*
		     * Note that libcurl will internally think that you connect to the host
		     * and port that you specify in the URL option.
		     */) {
			curl.curl_easy_setopt(CURLOPT_URL, "http://99.99.99.99:9999");
			sockfd = .socket(2, 1, /* Create the socket "manually" */0);
			if (sockfd == CURL_SOCKET_BAD) {
				.printf("Error creating listening socket.\n");
				return 3;
			} 
			.memset(servaddr, 0, );
			servaddr.setSin_family(2);
			servaddr.setSin_port(.htons(80));
			generatedSin_addr.getS_un().setS_addr(.inet_addr("127.0.0.1"));
			if (-1024 == generatedSin_addr.getS_un().getS_addr()) {
				.closesocket(sockfd);
				return 2;
			} 
			if (.connect(sockfd, (sockaddr)servaddr, ) == -1) {
				.closesocket(sockfd);
				.printf("client error: connect: %s\n", .strerror((._errno())));
				return 1;
			} 
			curl.curl_easy_setopt(CURLOPT_NOPROGRESS, /* no progress meter please */-1024);
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */write_data);
			curl.curl_easy_setopt(CURLOPT_OPENSOCKETFUNCTION, /* call this function to get a socket */opensocket);
			curl.curl_easy_setopt(CURLOPT_OPENSOCKETDATA, sockfd);
			curl.curl_easy_setopt(CURLOPT_CLOSESOCKETFUNCTION, /* call this function to close sockets */closecb);
			curl.curl_easy_setopt(CURLOPT_CLOSESOCKETDATA, sockfd);
			curl.curl_easy_setopt(CURLOPT_SOCKOPTFUNCTION, /* call this function to set options for the socket */sockopt_callback);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, 1);
			res = curl.curl_easy_perform();
			curl.curl_easy_cleanup();
			.closesocket(sockfd);
			if (res) {
				.printf("libcurl error: %d\n", res);
				return 4;
			} 
		} 
		.WSACleanup();
		return 0;
		 ch = new ();
		 rv = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		ch = curl_easy.curl_easy_init();
		ch.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		ch.curl_easy_setopt(CURLOPT_HEADER, -1024);
		ch.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
		ch.curl_easy_setopt(CURLOPT_NOSIGNAL, -1024);
		ch.curl_easy_setopt(CURLOPT_WRITEFUNCTION, writefunction);
		ch.curl_easy_setopt(CURLOPT_WRITEDATA, (_iob[1]));
		ch.curl_easy_setopt(CURLOPT_HEADERFUNCTION, writefunction);
		ch.curl_easy_setopt(CURLOPT_HEADERDATA, (_iob[2]));
		ch.curl_easy_setopt(CURLOPT_SSLCERTTYPE, "PEM"/* both VERIFYPEER and VERIFYHOST are set to 0 in this case because there is
		     no CA certificate*/);
		ch.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
		ch.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
		ch.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/");
		ch.curl_easy_setopt(CURLOPT_SSLKEYTYPE, "PEM");
		rv = /* first try: retrieve page without user certificate and key -> will fail
		   */ch.curl_easy_perform();
		if (rv == CURLE_OK) {
			.printf("*** transfer succeeded ***\n");
		} else {
				.printf("*** transfer failed ***\n"/* second try: retrieve page using user certificate and key -> will succeed
				   * load the certificate and key by installing a function doing the necessary
				   * "modifications" to the SSL CONTEXT just before link init
				   */);
		} 
		ch.curl_easy_setopt(CURLOPT_SSL_CTX_FUNCTION, sslctx_function);
		rv = ch.curl_easy_perform();
		if (rv == CURLE_OK) {
			.printf("*** transfer succeeded ***\n");
		} else {
				.printf("*** transfer failed ***\n");
		} 
		ch.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return rv;
		 curl_handle = new ();
		byte headerfilename = "head.out";
		FILE headerfile = new FILE();
		byte bodyfilename = "body.out";
		FILE bodyfile = new FILE();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl_handle = curl_easy.curl_easy_init();
		curl_handle.curl_easy_setopt(CURLOPT_URL, /* set URL to get */"https://example.com");
		curl_handle.curl_easy_setopt(CURLOPT_NOPROGRESS, /* no progress meter please */-1024);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* send all data to this function  */write_data);
		headerfile = .fopen(headerfilename, /* open the header file */"wb");
		if (!headerfile) {
			curl_handle.curl_easy_cleanup();
			return -1;
		} 
		bodyfile = .fopen(bodyfilename, /* open the body file */"wb");
		if (!bodyfile) {
			curl_handle.curl_easy_cleanup();
			.fclose(headerfile);
			return -1;
		} 
		curl_handle.curl_easy_setopt(CURLOPT_HEADERDATA, /* we want the headers be written to this file handle */headerfile);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEDATA, /* we want the body be written to this file handle instead of stdout */bodyfile);
		/* get it! */curl_handle.curl_easy_perform();
		.fclose(/* close the header file */headerfile);
		.fclose(/* close the body file */bodyfile);
		/* cleanup curl stuff */curl_handle.curl_easy_cleanup();
		return 0;
		GlobalInfo g = new GlobalInfo();
		(Object)argc;
		(Object)argv;
		.memset(g, 0, );
		Curl_multi curl_multi = new Curl_multi();
		g.setMulti(curl_multi.curl_multi_init());
		Object generatedMulti = g.getMulti();
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETFUNCTION, sock_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_SOCKETDATA, g);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERFUNCTION, multi_timer_cb);
		generatedMulti.curl_multi_setopt(CURLMOPT_TIMERDATA, g);
		/* add a URL */g.new_conn((byte)"www.google.com");
		.UNRECOGNIZEDFUNCTIONNAME();
		generatedMulti.curl_multi_cleanup();
		.fprintf(stdout, "\ndone.\n");
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"pop3://pop.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the TOP command for message 1 to only include the headers */"TOP 1 0");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		byte transport = /* UDP */"RTP/AVP;unicast;client_port=1234-1235"/* TCP */;
		byte range = "0.000-";
		int rc = 0;
		byte base_name = ((Object)0);
		.printf("\nRTSP request %s\n", "V1.0");
		.printf("    Project web site: https://github.com/BackupGGCode/rtsprequest\n");
		.printf("    Requires curl V7.20 or greater\n\n");
		Curl_easy curl_easy = new Curl_easy();
		if ((argc != 2) && (argc != /* check command line */3)) {
			base_name = .strrchr(argv[0], (byte)'/');
			if (base_name == ((Object)0)) {
				base_name = .strrchr(argv[0], (byte)'\\');
			} 
			if (base_name == ((Object)0)) {
				base_name = argv[0];
			} else {
					base_name++;
			} 
			.printf("Usage:   %s url [transport]\n", base_name);
			.printf("         url of video server\n");
			.printf("         transport (optional) specifier for media stream protocol\n");
			.printf("         default transport: %s\n", transport);
			.printf("Example: %s rtsp://192.168.0.2/media/video1\n\n", base_name);
			rc = 1;
		} else {
				byte url = argv[1];
				byte uri = .malloc(.strlen(url) + 32);
				byte sdp_filename = .malloc(.strlen(url) + 32);
				byte control = .malloc(.strlen(url) + 32);
				 res = new ();
				ModernizedCProgram.get_sdp_filename(url, sdp_filename, .strlen(url) + 32);
				if (argc == 3) {
					transport = argv[2];
				} 
				ModernizedCProgram.res = ModernizedCProgram.curl_global_init(/* initialize curl */CURL_GLOBAL_ALL);
				if (ModernizedCProgram.res == CURLE_OK) {
					 data = ModernizedCProgram.curl_version_info(CURLVERSION_NOW);
					 curl = new ();
					.fprintf((_iob[2]), "    curl V%s loaded\n", ModernizedCProgram.data.getVersion());
					ModernizedCProgram.curl = curl_easy.curl_easy_init();
					if (ModernizedCProgram.curl != ((Object)0)) {
						ModernizedCProgram.res = (ModernizedCProgram.curl).curl_easy_setopt((CURLOPT_VERBOSE), (true));
						if (ModernizedCProgram.res != CURLE_OK) {
							.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_VERBOSE", "0L", ModernizedCProgram.res);
						} 
						;
						ModernizedCProgram.res = (ModernizedCProgram.curl).curl_easy_setopt((CURLOPT_NOPROGRESS), (true));
						if (ModernizedCProgram.res != CURLE_OK) {
							.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_NOPROGRESS", "1L", ModernizedCProgram.res);
						} 
						;
						ModernizedCProgram.res = (ModernizedCProgram.curl).curl_easy_setopt((CURLOPT_HEADERDATA), ((_iob[1])));
						if (ModernizedCProgram.res != CURLE_OK) {
							.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_HEADERDATA", "stdout", ModernizedCProgram.res);
						} 
						;
						ModernizedCProgram.res = (ModernizedCProgram.curl).curl_easy_setopt((CURLOPT_URL), (url));
						if (ModernizedCProgram.res != CURLE_OK) {
							.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_URL", "url", ModernizedCProgram.res);
						} 
						;
						.snprintf(uri, .strlen(url) + 32, "%s", /* request server options */url);
						ModernizedCProgram.rtsp_options(ModernizedCProgram.curl, uri);
						ModernizedCProgram.rtsp_describe(ModernizedCProgram.curl, uri, /* request session description and write response to sdp file */sdp_filename);
						ModernizedCProgram.get_media_control_attribute(sdp_filename, /* get media control attribute from sdp file */control);
						.snprintf(uri, .strlen(url) + 32, "%s/%s", url, /* setup media stream */control);
						ModernizedCProgram.rtsp_setup(ModernizedCProgram.curl, uri, transport);
						.snprintf(uri, .strlen(url) + 32, "%s/", /* start playing media stream */url);
						ModernizedCProgram.rtsp_play(ModernizedCProgram.curl, uri, range);
						.printf("Playing video, press any key to stop ...");
						._getch();
						.printf("\n");
						ModernizedCProgram.rtsp_teardown(ModernizedCProgram.curl, /* teardown session */uri);
						/* cleanup */ModernizedCProgram.curl.curl_easy_cleanup();
						ModernizedCProgram.curl = ((Object)0);
					} else {
							.fprintf((_iob[2]), "curl_easy_init() failed\n");
					} 
					ModernizedCProgram.curl_global_cleanup();
				} else {
						.fprintf((_iob[2]), "curl_global_init(%s) failed: %d\n", "CURL_GLOBAL_ALL", ModernizedCProgram.res);
				} 
				.free(control);
				.free(sdp_filename);
				.free(uri);
		} 
		return rc;
		input[] trans = new input();
		 multi_handle = new ();
		int i;
		int still_running = /* keep number of running handles */0;
		byte filename = "index.html";
		int num_transfers;
		if (argc > 1) {
			num_transfers = .atoi(argv[/* if given a number, do that many transfers */1]);
			if (!num_transfers || (num_transfers > 1000)) {
				num_transfers = /* a suitable low default */3;
			} 
			if (argc > 2) {
				filename = argv[/* if given a file name, upload this! */2];
			} 
		} else {
				num_transfers = 3;
		} 
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		for (i = 0; i < num_transfers; i++) {
			ModernizedCProgram.setup(trans[i], i, filename);
			ModernizedCProgram.curl_multi_add_handle(multi_handle, trans[i].getHnd());
		}
		multi_handle.curl_multi_setopt(CURLMOPT_PIPELINING, 0);
		multi_handle.curl_multi_setopt(CURLMOPT_MAX_HOST_CONNECTIONS, /* We do HTTP/2 so let's stick to one connection per host */-1024);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case 0:
			case -1/* select error */:
					break;
			default:
					multi_handle.curl_multi_perform(/* timeout or readable/writable sockets */still_running);
					break;
			}
		}
		multi_handle.curl_multi_cleanup();
		for (i = 0; i < num_transfers; i++) {
			ModernizedCProgram.curl_multi_remove_handle(multi_handle, trans[i].getHnd());
			trans[i].getHnd().curl_easy_cleanup();
		}
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"imap://imap.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the DELETE command specifying the existing folder */"DELETE FOLDER");
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com");
			curl.curl_easy_setopt(/* use platform-specific functions for codeset conversions */CURLOPT_CONV_FROM_NETWORK_FUNCTION, my_conv_from_ascii_to_ebcdic);
			curl.curl_easy_setopt(CURLOPT_CONV_TO_NETWORK_FUNCTION, my_conv_from_ebcdic_to_ascii);
			curl.curl_easy_setopt(CURLOPT_CONV_FROM_UTF8_FUNCTION, my_conv_from_utf8_to_ebcdic);
			curl.curl_easy_perform();
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		 http_handle = new ();
		 http_handle2 = new ();
		 multi_handle = new ();
		int still_running = /* keep number of running handles */0;
		http_handle = curl_easy.curl_easy_init();
		http_handle2 = curl_easy.curl_easy_init();
		http_handle.curl_easy_setopt(CURLOPT_URL, /* set options */"https://www.example.com/");
		http_handle2.curl_easy_setopt(CURLOPT_URL, /* set options */"http://localhost/");
		multi_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_multi_add_handle(multi_handle, /* add the individual transfers */http_handle);
		ModernizedCProgram.curl_multi_add_handle(multi_handle, http_handle2);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			timeval timeout = new timeval();
			int rc;
			 mc = new ();
			 fdread = new ();
			 fdwrite = new ();
			 fdexcep = new ();
			int maxfd = -1;
			long curl_timeo = -1;
			.FD_ZERO(fdread);
			.FD_ZERO(fdwrite);
			.FD_ZERO(fdexcep);
			ModernizedCProgram.timeout.setTv_sec(/* set a suitable timeout to play around with */1);
			ModernizedCProgram.timeout.setTv_usec(0);
			multi_handle.curl_multi_timeout(curl_timeo);
			if (curl_timeo >= 0) {
				ModernizedCProgram.timeout.setTv_sec(curl_timeo / 1000);
				if (ModernizedCProgram.timeout.getTv_sec() > 1) {
					ModernizedCProgram.timeout.setTv_sec(1);
				} else {
						ModernizedCProgram.timeout.setTv_usec((curl_timeo % 1000) * 1000);
				} 
			} 
			mc = ModernizedCProgram.curl_multi_fdset(multi_handle, fdread, fdwrite, fdexcep, /* get file descriptors from the transfers */maxfd);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_fdset() failed, code %d.\n", mc);
				break;
			} 
			if (maxfd == -1) {
				.Sleep(100);
				rc = 0/* Portable sleep for platforms other than Windows. *//* 100ms */;
			} else {
					rc = .select(maxfd + 1, fdread, fdwrite, fdexcep, /* Note that on some platforms 'timeout' may be modified by select().
					         If you need access to the original value save a copy beforehand. */ModernizedCProgram.timeout);
			} 
			switch (rc) {
			case -1/* select error */:
					break;
			case 0:
			default:
					multi_handle.curl_multi_perform(/* timeout or readable/writable sockets */still_running);
					break;
			}
		}
		multi_handle.curl_multi_cleanup();
		http_handle.curl_easy_cleanup();
		http_handle2.curl_easy_cleanup();
		return 0;
		byte[] tag = new byte[1];
		byte[] attr = new byte[4];
		byte[] val = new byte[128];
		 curl = new ();
		 hsp = new ();
		if (argc != 2) {
			.printf("Usage: %s URL\n", argv[0]);
			return EXIT_FAILURE;
		} 
		curl = curl_easy.curl_easy_init();
		hsp = .html_parser_init();
		.html_parser_set_tag_to_lower(hsp, 1);
		.html_parser_set_attr_to_lower(hsp, 1);
		.html_parser_set_tag_buffer(hsp, tag, );
		.html_parser_set_attr_buffer(hsp, attr, );
		.html_parser_set_val_buffer(hsp, val,  - 1);
		curl.curl_easy_setopt(CURLOPT_URL, argv[1]);
		curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_callback);
		curl.curl_easy_setopt(CURLOPT_WRITEDATA, hsp);
		curl.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, -1024);
		curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		.html_parser_cleanup(hsp);
		return EXIT_SUCCESS;
		 curl = new ();
		 res = new ();
		byte postthis = "moo mooo moo moo";
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com");
			curl.curl_easy_setopt(CURLOPT_POSTFIELDS, postthis);
			curl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long).strlen(/* if we don't provide POSTFIELDSIZE, libcurl will strlen() by
			       itself */postthis));
			res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return 0;
		srvr_sockaddr_union_t me = new srvr_sockaddr_union_t();
		 sock = CURL_SOCKET_BAD;
		 msgsock = CURL_SOCKET_BAD;
		int wrotepidfile = 0;
		byte pidname = ".sockfilt.pid";
		bool juggle_again = new bool();
		int rc;
		int error;
		int arg = 1;
		sockmode mode = /* default */sockmode.PASSIVE_LISTEN;
		byte addr = ((Object)0);
		while (argc > arg) {
			if (!.strcmp("--version", argv[arg])) {
				ModernizedCProgram.curl_mprintf("sockfilt IPv4%s\n", "");
				return 0;
			}  else if (!.strcmp("--verbose", argv[arg])) {
				ModernizedCProgram.verbose = 1;
				arg++;
			}  else if (!.strcmp("--pidfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					pidname = argv[arg++];
				} 
			}  else if (!.strcmp("--logfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.serverlogfile = argv[arg++];
				} 
			}  else if (!.strcmp("--ipv6", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--ipv4", argv[arg/* for completeness, we support this option as well */])) {
				arg++;
			}  else if (!.strcmp("--bindonly", argv[arg])) {
				ModernizedCProgram.bind_only = 1;
				arg++;
			}  else if (!.strcmp("--port", argv[arg])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || ((ulnum != -1024) && ((ulnum < -1024) || (ulnum > -1024)))) {
						(_iob[2]).curl_mfprintf("sockfilt: invalid --port argument (%s)\n", argv[arg]);
						return 0;
					} 
					ModernizedCProgram.port = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			}  else if (!.strcmp("--connect", argv[arg/* Asked to actively connect to the specified local port instead of
			         doing a passive server-style listening. */])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || (ulnum < -1024) || (ulnum > -1024)) {
						(_iob[2]).curl_mfprintf("sockfilt: invalid --connect argument (%s)\n", argv[arg]);
						return 0;
					} 
					ModernizedCProgram.connectport = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			}  else if (!.strcmp("--addr", argv[arg])) {
				/* Set an IP address to use with --connect; otherwise use localhost */arg++;
				if (argc > arg) {
					addr = argv[arg];
					arg++;
				} 
			} else {
					.puts("Usage: sockfilt [option]\n --version\n --verbose\n --logfile [file]\n --pidfile [file]\n --ipv4\n --ipv6\n --bindonly\n --port [port]\n --connect [port]\n --addr [address]");
					return 0;
			} 
		}
		ModernizedCProgram.win32_init();
		.atexit(ModernizedCProgram.win32_cleanup);
		.setmode((((_iob[0])).get_file()), -1024);
		.setmode((((_iob[1])).get_file()), -1024);
		.setmode((((_iob[2])).get_file()), -1024);
		ModernizedCProgram.install_signal_handlers();
		sock = .socket(2, 1, 0);
		if (CURL_SOCKET_BAD == sock) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket: (%d) %s", error, .strerror(error));
			ModernizedCProgram.write_stdout("FAIL\n", 5);
			;
		} 
		Object generatedSa4 = me.getSa4();
		Object generatedSa = me.getSa();
		if (ModernizedCProgram.connectport) {
			sockmode.mode = /* Active mode, we should connect to the given port number */sockmode.ACTIVE;
			.memset(generatedSa4, 0, );
			generatedSa4.setSin_family(2);
			generatedSa4.setSin_port(.htons(ModernizedCProgram.connectport));
			generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
			if (!addr) {
				addr = "127.0.0.1";
			} 
			ModernizedCProgram.Curl_inet_pton(2, addr, generatedSa4.getSin_addr());
			rc = .connect(sock, generatedSa, );
			if (/* ENABLE_IPV6 */rc) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("Error connecting to port %hu: (%d) %s", ModernizedCProgram.connectport, error, .strerror(error));
				ModernizedCProgram.write_stdout("FAIL\n", 5);
				;
			} 
			ModernizedCProgram.logmsg("====> Client connect");
			msgsock = /* use this as stream */sock;
		} else {
				sock = ModernizedCProgram.sockdaemon(sock, /* passive daemon style */ModernizedCProgram.port);
				if (CURL_SOCKET_BAD == sock) {
					ModernizedCProgram.write_stdout("FAIL\n", 5);
					;
				} 
				msgsock = /* no stream socket yet */CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Running %s version", ModernizedCProgram.ipv_inuse);
		if (ModernizedCProgram.connectport) {
			ModernizedCProgram.logmsg("Connected to port %hu", ModernizedCProgram.connectport);
		}  else if (ModernizedCProgram.bind_only) {
			ModernizedCProgram.logmsg("Bound without listening on port %hu", ModernizedCProgram.port);
		} else {
				ModernizedCProgram.logmsg("Listening on port %hu", ModernizedCProgram.port);
		} 
		wrotepidfile = ModernizedCProgram.write_pidfile(pidname);
		if (!wrotepidfile) {
			ModernizedCProgram.write_stdout("FAIL\n", 5);
			;
		} 
		do {
			juggle_again = ModernizedCProgram.juggle(msgsock, sock, sockmode.mode);
		} while (juggle_again);
		if (sock != CURL_SOCKET_BAD) {
			.closesocket((sock));
		} 
		if (wrotepidfile) {
			.unlink(pidname);
		} 
		ModernizedCProgram.restore_signal_handlers();
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("============> sockfilt exits with signal (%d)", ModernizedCProgram.exit_signal/*
			     * To properly set the return status of the process we
			     * must raise the same signal SIGINT or SIGTERM that we
			     * caught and let the old handler take care of it.
			     */);
			.raise(ModernizedCProgram.exit_signal);
		} 
		ModernizedCProgram.logmsg("============> sockfilt quits");
		return 0;
		 h = new ();
		 uc = new ();
		byte host;
		byte path;
		h = .curl_url();
		if (!h) {
			return 1;
		} 
		uc = .curl_url_set(h, CURLUPART_URL, "http://example.com/path/index.html", /* parse a full URL */0);
		if (uc) {
			;
		} 
		uc = .curl_url_get(h, CURLUPART_HOST, host, /* extract host name from the parsed URL */0);
		if (!uc) {
			.printf("Host name: %s\n", host);
			ModernizedCProgram.curl_free(host);
		} 
		uc = .curl_url_get(h, CURLUPART_PATH, path, /* extract the path from the parsed URL */0);
		if (!uc) {
			.printf("Path: %s\n", path);
			ModernizedCProgram.curl_free(path);
		} 
		uc = .curl_url_set(h, CURLUPART_URL, "../another/second.html", /* redirect with a relative URL */0);
		if (uc) {
			;
		} 
		uc = .curl_url_get(h, CURLUPART_PATH, path, /* extract the new, updated path */0);
		if (!uc) {
			.printf("Path: %s\n", path);
			ModernizedCProgram.curl_free(path);
		} 
		return 0;
		 curl = new ();
		 res = new ();
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedCurl_certinfo = certinfo.getCurl_certinfo();
		Object generatedCurl_slist = slist.getCurl_slist();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, "https://www.example.com/");
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, wrfu);
			curl.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
			curl.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			curl.curl_easy_setopt(CURLOPT_CERTINFO, -1024);
			res = curl.curl_easy_perform();
			if (!res) {
				curl_certinfo certinfo = new curl_certinfo();
				res = curl.curl_easy_getinfo(CURLINFO_CERTINFO, certinfo);
				if (!res && certinfo) {
					int i;
					.printf("%d certs!\n", generatedCurl_certinfo);
					for (i = 0; i < generatedCurl_certinfo; i++) {
						curl_slist slist = new curl_slist();
						for (slist = generatedCurl_certinfo[i]; slist; slist = generatedCurl_slist) {
							.printf("%s\n", generatedCurl_slist);
						}
					}
				} 
			} 
			curl.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl_handle = new ();
		 res = new ();
		 parser = new ();
		ParserStruct state = new ParserStruct();
		.memset(state, 0, /* Initialize the state structure for parsing. */);
		state.setOk(1);
		parser = .XML_ParserCreateNS(((Object)0), /* Initialize a namespace-aware parser. */(byte)'\0');
		.XML_SetUserData(parser, state);
		.XML_SetElementHandler(parser, startElement, endElement);
		.XML_SetCharacterDataHandler(parser, characterDataHandler);
		ModernizedCProgram.curl_global_init(/* Initialize a libcurl handle. */CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		curl_handle = curl_easy.curl_easy_init();
		curl_handle.curl_easy_setopt(CURLOPT_URL, "https://www.w3schools.com/xml/simple.xml");
		curl_handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, parseStreamCallback);
		curl_handle.curl_easy_setopt(CURLOPT_WRITEDATA, (Object)parser);
		.printf("Depth   Characters   Closing Tag\n");
		res = /* Perform the request and any follow-up parsing. */curl_handle.curl_easy_perform();
		int generatedOk = state.getOk();
		Object generatedTags = state.getTags();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
		}  else if (generatedOk) {
			if (.XML_Parse(parser, ((Object)0), 0, 1) == /* Expat requires one final call to finalize parsing. */0) {
				int error_code = .XML_GetErrorCode(parser);
				.fprintf((_iob[2]), "Finalizing parsing failed with error code %d (%s).\n", error_code, .XML_ErrorString(error_code));
			} else {
					.printf("                     --------------\n");
					.printf("                     %lu tags total\n", generatedTags);
			} 
		} 
		MemoryStruct generatedCharacters = state.getCharacters();
		Byte generatedMemory = generatedCharacters.getMemory();
		.free(generatedMemory);
		.XML_ParserFree(parser);
		curl_handle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"pop3://pop.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the NOOP command */"NOOP");
			curl.curl_easy_setopt(CURLOPT_NOBODY, /* Do not perform a transfer as NOOP returns no data */-1024);
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		pthread_t[] tid = new pthread_t();
		int i;
		(Object)/* we don't use any arguments in this example */argc;
		(Object)argv;
		ModernizedCProgram.curl_global_init(/* Must initialize libcurl before any threads are started */CURL_GLOBAL_ALL);
		ModernizedCProgram.init_locks();
		for (i = 0; i < 4; i++) {
			int error = .pthread_create(tid[i], ((Object)/* default attributes please */0), pull_one_url, (Object)ModernizedCProgram.urls[i]);
			if (0 != error) {
				.fprintf((_iob[2]), "Couldn't run thread number %d, errno %d\n", i, error);
			} else {
					.fprintf((_iob[2]), "Thread %d, gets %s\n", i, ModernizedCProgram.urls[i]);
			} 
		}
		for (i = 0; i < 4; /* now wait for all threads to terminate */i++) {
			.pthread_join(tid[i], ((Object)0));
			.fprintf((_iob[2]), "Thread %d terminated\n", i);
		}
		ModernizedCProgram.kill_locks();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist recipients = ((Object)0);
		upload_status upload_ctx = new upload_status();
		upload_ctx.setLines_read(0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver */"smtp://mail.example.com"/* Note that this option isn't strictly required, omitting it will result
			     * in libcurl sending the MAIL FROM command with empty sender data. All
			     * autoresponses should have an empty reverse-path, and should be directed
			     * to the address in the reverse-path which triggered them. Otherwise,
			     * they could cause an endless loop. See RFC 5321 Section 4.5.5 for more
			     * details.
			     */);
			curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<sender@example.org>"/* Add two recipients, in this particular case they correspond to the
			     * To: and Cc: addressees in the header, but they could be any kind of
			     * recipient. */);
			recipients = recipients.curl_slist_append("<addressee@example.net>");
			recipients = recipients.curl_slist_append("<info@example.org>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients/* We're using a callback function to specify the payload (the headers and
			     * body of the message). You could just use the CURLOPT_READDATA option to
			     * specify a FILE pointer to read from. */);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
			curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
			res = /* Send the message */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients/* curl won't send the QUIT command until you call cleanup, so you should
			     * be able to re-use this connection for additional messages (setting
			     * CURLOPT_MAIL_FROM and CURLOPT_MAIL_RCPT as required, and calling
			     * curl_easy_perform() again. It may not be a good idea to keep the
			     * connection open for a very long time though (more than a few minutes
			     * may result in the server timing out the connection), and you do want to
			     * clean up in the end.
			     */.curl_slist_free_all();
			curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = CURLE_OK/* Each single name resolve string should be written using the format
		     HOST:PORT:ADDRESS where HOST is the name libcurl will try to resolve,
		     PORT is the port number of the service where libcurl wants to connect to
		     the HOST and ADDRESS is the numerical IP address
		   */;
		curl_slist host = ((Object)0).curl_slist_append("example.com:443:127.0.0.1");
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_RESOLVE, host);
			curl.curl_easy_setopt(CURLOPT_URL, "https://example.com");
			res = curl.curl_easy_perform();
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		host.curl_slist_free_all();
		return (int)res;
		 curl = new ();
		 res = new ();
		 urlp = new ();
		 uc = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		urlp = .curl_url();
		uc = .curl_url_set(urlp, CURLUPART_URL, "http://example.com/path/index.html", 0);
		if (uc) {
			.fprintf((_iob[2]), "curl_url_set() failed: %in", uc);
			;
		} 
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_CURLU, /* set urlp to use as working URL */urlp);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			;
		} 
		curl.curl_easy_cleanup();
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		curl_slist recipients = ((Object)0);
		upload_status upload_ctx = new upload_status();
		upload_ctx.setLines_read(0);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver. Note the use of smtps:// rather
			     * than smtp:// to request a SSL based connection. */"smtps://mainserver.example.net"/* If you want to connect to a site who isn't using a certificate that is
			     * signed by one of the certs in the CA bundle you have, you can skip the
			     * verification of the server's certificate. This makes the connection
			     * A LOT LESS SECURE.
			     *
			     * If you have a CA cert for the server stored someplace else than in the
			     * default bundle, then the CURLOPT_CAPATH option might come handy for
			     * you. */);
			curl.curl_easy_setopt(CURLOPT_MAIL_FROM, /* Note that this option isn't strictly required, omitting it will result
			     * in libcurl sending the MAIL FROM command with empty sender data. All
			     * autoresponses should have an empty reverse-path, and should be directed
			     * to the address in the reverse-path which triggered them. Otherwise,
			     * they could cause an endless loop. See RFC 5321 Section 4.5.5 for more
			     * details.
			     */"<sender@example.org>"/* Add two recipients, in this particular case they correspond to the
			     * To: and Cc: addressees in the header, but they could be any kind of
			     * recipient. */);
			recipients = recipients.curl_slist_append("<addressee@example.net>");
			recipients = recipients.curl_slist_append("<info@example.org>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients/* We're using a callback function to specify the payload (the headers and
			     * body of the message). You could just use the CURLOPT_READDATA option to
			     * specify a FILE pointer to read from. */);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, payload_source);
			curl.curl_easy_setopt(CURLOPT_READDATA, upload_ctx);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, -1024/* Since the traffic will be encrypted, it is very useful to turn on debug
			     * information within libcurl to see what is happening during the
			     * transfer */);
			curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			res = /* Send the message */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free the list of recipients */recipients.curl_slist_free_all();
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		byte URL;
		int result;
		.setmode((((_iob[1])).get_file()), -1024);
		do {
		} while (0/*
		   * Setup proper locale from environment. This is needed to enable locale-
		   * specific behaviour by the C library in order to test for undesired side
		   * effects that could cause in libcurl.
		   */);
		.setlocale(0, "");
		if (argc < 2) {
			(_iob[2]).curl_mfprintf("Pass URL as argument please\n");
			return 1;
		} 
		ModernizedCProgram.test_argc = argc;
		ModernizedCProgram.test_argv = argv;
		if (argc > 2) {
			ModernizedCProgram.libtest_arg2 = argv[2];
		} 
		if (argc > 3) {
			ModernizedCProgram.libtest_arg3 = argv[3];
		} 
		URL = argv[/* provide this to the rest */1];
		(_iob[2]).curl_mfprintf("URL: %s\n", URL);
		result = ModernizedCProgram.test(URL);
		return /* prevent valgrind from reporting possibly lost memory (fd cache, ...) */result;
		 http_handle = new ();
		 multi_handle = new ();
		int still_running = /* keep number of running handles */0;
		int repeats = 0;
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		Curl_easy curl_easy = new Curl_easy();
		http_handle = curl_easy.curl_easy_init();
		http_handle.curl_easy_setopt(CURLOPT_URL, /* set the options (I left out a few, you'll get the point anyway) */"https://www.example.com/");
		Curl_multi curl_multi = new Curl_multi();
		multi_handle = curl_multi.curl_multi_init();
		ModernizedCProgram.curl_multi_add_handle(multi_handle, /* add the individual transfers */http_handle);
		multi_handle.curl_multi_perform(/* we start some action by calling perform right away */still_running);
		while (still_running) {
			 mc = new ();
			int numfds;
			mc = .curl_multi_wait(multi_handle, ((Object)0), 0, 1000, /* wait for activity, timeout or "nothing" */numfds);
			if (mc != CURLM_OK) {
				.fprintf((_iob[2]), "curl_multi_wait() failed, code %d.\n", mc);
				break;
			} 
			if (!numfds) {
				/* count number of repeated zero numfds */repeats++;
				if (repeats > 1) {
					.Sleep(/* sleep 100 milliseconds */100);
				} 
			} else {
					repeats = 0;
			} 
			multi_handle.curl_multi_perform(still_running);
		}
		ModernizedCProgram.curl_multi_remove_handle(multi_handle, http_handle);
		http_handle.curl_easy_cleanup();
		multi_handle.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 curlhandle = ((Object)0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curlhandle = curl_easy.curl_easy_init();
		ModernizedCProgram.upload(curlhandle, "ftp://user:pass@example.com/path/file", "C:\\file", 0, 3);
		curlhandle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 in = ((Object)0);
		 out = ((Object)0);
		byte outfile = ((Object)0);
		byte infile = ((Object)0);
		int tabLength = 100;
		byte binaryptr;
		byte mimetype = ((Object)0);
		byte mimetypeaccept = ((Object)0);
		byte contenttype;
		byte pp;
		byte hostporturl = ((Object)0);
		 p12bio = new ();
		byte args = argv + 1;
		byte serverurl;
		sslctxparm p = new sslctxparm();
		byte response;
		 res = new ();
		curl_slist headers = ((Object)0);
		int badarg = 0;
		binaryptr = .malloc(tabLength);
		.memset(p, (byte)'\0', );
		p.setErrorbio(.BIO_new_fp((_iob[2]), BIO_NOCLOSE));
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_DEFAULT);
		.OpenSSL_add_all_ciphers();
		.OpenSSL_add_all_digests();
		.ERR_load_crypto_strings();
		int generatedAccesstype = p.getAccesstype();
		int generatedVerbose = p.getVerbose();
		while (args && args[0] == (byte)'-') {
			if (!.strcmp(args, "-in")) {
				if (args[1]) {
					infile = (++args);
				} else {
						badarg = 1;
				} 
			}  else if (!.strcmp(args, "-out")) {
				if (args[1]) {
					outfile = (++args);
				} else {
						badarg = 1;
				} 
			}  else if (!.strcmp(args, "-p12")) {
				if (args[1]) {
					p.setP12file((++args));
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-envpass") == 0) {
				if (args[1]) {
					p.setPst(.getenv((++args)));
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-connect") == 0) {
				if (args[1]) {
					hostporturl = (++args);
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-mimetype") == 0) {
				if (args[1]) {
					mimetype = (++args);
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-acceptmime") == 0) {
				if (args[1]) {
					mimetypeaccept = (++args);
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-accesstype") == 0) {
				if (args[1]) {
					p.setAccesstype(.OBJ_obj2nid(.OBJ_txt2obj(++args, 0)));
					if (generatedAccesstype == 0) {
						badarg = 1;
					} 
				} else {
						badarg = 1;
				} 
			}  else if (.strcmp(args, "-verbose") == 0) {
				generatedVerbose++;
			} else {
					badarg = 1;
			} 
			args++;
		}
		Byte generatedP12file = p.getP12file();
		if (mimetype == ((Object)0) || mimetypeaccept == ((Object)0) || generatedP12file == ((Object)0)) {
			badarg = 1;
		} 
		Object generatedErrorbio = p.getErrorbio();
		if (badarg) {
			for (pp = ModernizedCProgram.curlx_usage; (pp != ((Object)0)); pp++) {
				.BIO_printf(generatedErrorbio, "%s\n", pp);
			}
			.BIO_printf(generatedErrorbio, "\n");
			;
		} 
		in = .BIO_new(.BIO_s_file());
		if (in == ((Object)0)) {
			.BIO_printf(generatedErrorbio, "Error setting input bio\n");
			;
		}  else if (infile == ((Object)0)) {
			.BIO_set_fp(in, (_iob[0]), BIO_NOCLOSE | BIO_FP_TEXT);
		}  else if (.BIO_read_filename(in, infile) <= 0) {
			.BIO_printf(generatedErrorbio, "Error opening input file %s\n", infile);
			.BIO_free(in);
			;
		} 
		out = .BIO_new(.BIO_s_file());
		if (out == ((Object)0)) {
			.BIO_printf(generatedErrorbio, "Error setting output bio.\n");
			;
		}  else if (outfile == ((Object)0)) {
			.BIO_set_fp(out, (_iob[1]), BIO_NOCLOSE | BIO_FP_TEXT);
		}  else if (.BIO_write_filename(out, outfile) <= 0) {
			.BIO_printf(generatedErrorbio, "Error opening output file %s\n", outfile);
			.BIO_free(out);
			;
		} 
		p.setErrorbio(.BIO_new_fp((_iob[2]), BIO_NOCLOSE));
		Curl_easy curl_easy = new Curl_easy();
		p.setCurl(curl_easy.curl_easy_init());
		Object generatedCurl = p.getCurl();
		if (!generatedCurl) {
			.BIO_printf(generatedErrorbio, "Cannot init curl lib\n");
			;
		} 
		p12bio = .BIO_new_file(generatedP12file, "rb");
		if (!p12bio) {
			.BIO_printf(generatedErrorbio, "Error opening P12 file %s\n", generatedP12file);
			;
		} 
		p.setP12(.d2i_PKCS12_bio(p12bio, ((Object)0)));
		Object generatedP12 = p.getP12();
		if (!generatedP12) {
			.BIO_printf(generatedErrorbio, "Cannot decode P12 structure %s\n", generatedP12file);
			;
		} 
		p.setCa(((Object)0));
		Object generatedPst = p.getPst();
		Object generatedPkey = p.getPkey();
		Object generatedUsercert = p.getUsercert();
		Object generatedCa = p.getCa();
		if (!(.PKCS12_parse(generatedP12, generatedPst, (generatedPkey), (generatedUsercert), (generatedCa)))) {
			.BIO_printf(generatedErrorbio, "Invalid P12 structure in %s\n", generatedP12file);
			;
		} 
		if (.sk_X509_num(generatedCa) <= 0) {
			.BIO_printf(generatedErrorbio, "No trustworthy CA given.%s\n", generatedP12file);
			;
		} 
		if (generatedVerbose > 1) {
			.X509_print_ex(generatedErrorbio, generatedUsercert, 0, 0);
		} 
		if (/* determine URL to go */hostporturl) {
			size_t len = .strlen(hostporturl) + 9;
			serverurl = .malloc(len);
			.snprintf(serverurl, len, "https://%s", hostporturl);
		}  else if (generatedAccesstype != /* see whether we can find an AIA or SIA for a
		                                  given access type */0) {
			serverurl = ModernizedCProgram.my_get_ext(generatedUsercert, generatedAccesstype, NID_info_access);
			if (!serverurl) {
				int j = 0;
				.BIO_printf(generatedErrorbio, "no service URL in user cert cherching in others certificats\n");
				for (ModernizedCProgram.j = 0; ModernizedCProgram.j < .sk_X509_num(generatedCa); ModernizedCProgram.j++) {
					serverurl = ModernizedCProgram.my_get_ext(.sk_X509_value(generatedCa, ModernizedCProgram.j), generatedAccesstype, NID_info_access);
					if (serverurl) {
						break;
					} 
					serverurl = ModernizedCProgram.my_get_ext(.sk_X509_value(generatedCa, ModernizedCProgram.j), generatedAccesstype, NID_sinfo_access);
					if (serverurl) {
						break;
					} 
				}
			} 
		} 
		if (!serverurl) {
			.BIO_printf(generatedErrorbio, "no service URL in certificats, check '-accesstype (AD_DVCS | ad_timestamping)' or use '-connect'\n");
			;
		} 
		if (generatedVerbose) {
			.BIO_printf(generatedErrorbio, "Service URL: <%s>\n", serverurl);
		} 
		generatedCurl.curl_easy_setopt(CURLOPT_URL, serverurl);
		generatedCurl.curl_easy_setopt(CURLOPT_POSTFIELDS, /* Now specify the POST binary data */binaryptr);
		generatedCurl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long)tabLength);
		contenttype = .malloc(15 + .strlen(/* pass our list of custom made headers */mimetype));
		.snprintf(contenttype, 15 + .strlen(mimetype), "Content-type: %s", mimetype);
		headers = headers.curl_slist_append(contenttype);
		generatedCurl.curl_easy_setopt(CURLOPT_HTTPHEADER, headers);
		if (generatedVerbose) {
			.BIO_printf(generatedErrorbio, "Service URL: <%s>\n", serverurl);
		} 
		{ 
			FILE outfp = new FILE();
			.BIO_get_fp(out, outfp);
			generatedCurl.curl_easy_setopt(CURLOPT_WRITEDATA, outfp);
		}
		res = generatedCurl.curl_easy_setopt(CURLOPT_SSL_CTX_FUNCTION, sslctxfun);
		if (res != CURLE_OK) {
			.BIO_printf(generatedErrorbio, "%d %s=%d %d\n", 512, "CURLOPT_SSL_CTX_FUNCTION", CURLOPT_SSL_CTX_FUNCTION, res);
		} 
		generatedCurl.curl_easy_setopt(CURLOPT_SSL_CTX_DATA, p);
		{ 
			byte ptr;
			int lu;
			int i = 0;
			while ((lu = .BIO_read(in, binaryptr[i], tabLength - i)) > 0) {
				i += lu;
				if (i == tabLength) {
					tabLength += 100;
					ptr = .realloc(binaryptr, /* should be more careful */tabLength);
					if (!ptr) {
						.BIO_printf(generatedErrorbio, /* out of memory */"out of memory (realloc returned NULL)\n");
						;
					} 
					binaryptr = ptr;
					ptr = ((Object)0);
				} 
			}
			tabLength = i;
		}
		generatedCurl.curl_easy_setopt(CURLOPT_POSTFIELDS, /* Now specify the POST binary data */binaryptr);
		generatedCurl.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long)tabLength);
		.BIO_printf(generatedErrorbio, "%d %s %d\n", 544, /* Perform the request, res will get the return code */"curl_easy_perform", res = generatedCurl.curl_easy_perform());
		{ 
			generatedCurl.curl_easy_getinfo(CURLINFO_CONTENT_TYPE, response);
			if (mimetypeaccept && generatedVerbose) {
				if (!.strcmp(mimetypeaccept, response)) {
					.BIO_printf(generatedErrorbio, "the response has a correct mimetype : %s\n", response);
				} else {
						.BIO_printf(generatedErrorbio, "the response doesn\'t have an acceptable mime type, it is %s instead of %s\n", response, mimetypeaccept);
				} 
			} 
		}
		generatedCurl.curl_easy_cleanup();
		.BIO_free(in);
		.BIO_free(out);
		return (false);
		.exit(1);
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_USERNAME, /* Set username and password */"user");
			curl.curl_easy_setopt(CURLOPT_PASSWORD, "secret");
			curl.curl_easy_setopt(CURLOPT_URL, /* This is just the server URL */"pop3://pop.example.com");
			curl.curl_easy_setopt(CURLOPT_CUSTOMREQUEST, /* Set the STAT command */"STAT");
			curl.curl_easy_setopt(CURLOPT_NOBODY, /* Do not perform a transfer as the data is in the response */-1024);
			res = /* Perform the custom request */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Always cleanup */curl.curl_easy_cleanup();
		} 
		return (int)res;
		 curl = new ();
		 res = new ();
		int hd;
		stat file_info = new stat();
		byte file;
		byte url;
		if (argc < 3) {
			return 1;
		} 
		file = argv[1];
		url = argv[2];
		hd = .open(file, /* get the file size of the local file */0);
		.fstat(hd, file_info);
		ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_ALL);
		curl = curl_easy.curl_easy_init();
		Object generatedSt_size = file_info.getSt_size();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
			curl.curl_easy_setopt(CURLOPT_READDATA, (Object)/* which file to upload */hd);
			curl.curl_easy_setopt(CURLOPT_IOCTLFUNCTION, /* set the ioctl function */my_ioctl);
			curl.curl_easy_setopt(CURLOPT_IOCTLDATA, (Object)/* pass the file descriptor to the ioctl callback as well */hd);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, /* enable "uploading" (which means PUT when doing HTTP) */-1024);
			curl.curl_easy_setopt(CURLOPT_URL, /* specify target URL, and note that this URL should also include a file
			       name, not only a directory (as you can do with GTP uploads) */url);
			curl.curl_easy_setopt(/* and give the size of the upload, this supports large file sizes
			       on systems that have general support for it */CURLOPT_INFILESIZE_LARGE, ()generatedSt_size);
			curl.curl_easy_setopt(CURLOPT_HTTPAUTH, (long)CURLAUTH_ANY);
			curl.curl_easy_setopt(CURLOPT_USERPWD, /* set user name and password for the authentication */"user:password");
			res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		.close(/* close the local file */hd);
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		 Window = new ();
		 Frame = new ();
		 Frame2 = new ();
		 adj = new ();
		ModernizedCProgram.curl_global_init(/* Must initialize libcurl before any threads are started */CURL_GLOBAL_ALL);
		.g_thread_init(((Object)/* Init thread */0));
		.gtk_init(argc, argv);
		Window = .gtk_window_new(GTK_WINDOW_TOPLEVEL);
		Frame = .gtk_frame_new(((Object)0));
		.gtk_frame_set_shadow_type(.GTK_FRAME(Frame), GTK_SHADOW_OUT);
		.gtk_container_add(.GTK_CONTAINER(Window), Frame);
		Frame2 = .gtk_frame_new(((Object)0));
		.gtk_frame_set_shadow_type(.GTK_FRAME(Frame2), GTK_SHADOW_IN);
		.gtk_container_add(.GTK_CONTAINER(Frame), Frame2);
		.gtk_container_set_border_width(.GTK_CONTAINER(Frame2), 5);
		adj = ().gtk_adjustment_new(0, 0, 100, 0, 0, 0);
		ModernizedCProgram.Bar = .gtk_progress_bar_new_with_adjustment(adj);
		.gtk_container_add(.GTK_CONTAINER(Frame2), ModernizedCProgram.Bar);
		.gtk_widget_show_all(Window);
		if (!.g_thread_create(my_thread, argv[1], FALSE, ((Object)0)) != 0) {
			.g_warning("can't create the thread");
		} 
		.gdk_threads_enter();
		.gtk_main();
		.gdk_threads_leave();
		return 0;
		 curl = new ();
		 res = new ();
		FILE hd_src = new FILE();
		stat file_info = new stat();
		byte file;
		byte url;
		if (argc < 3) {
			return 1;
		} 
		file = argv[1];
		url = argv[2];
		.stat(file, /* get the file size of the local file */file_info/* get a FILE * of the same file, could also be made with
		     fdopen() from the previous descriptor, but hey this is just
		     an example! */);
		hd_src = .fopen(file, "rb");
		ModernizedCProgram.curl_global_init(/* In windows, this will init the winsock stuff */CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		Object generatedSt_size = file_info.getSt_size();
		if (curl) {
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
			curl.curl_easy_setopt(CURLOPT_UPLOAD, /* enable uploading */-1024);
			curl.curl_easy_setopt(CURLOPT_PUT, /* HTTP PUT please */-1024);
			curl.curl_easy_setopt(CURLOPT_URL, /* specify target URL, and note that this URL should include a file
			       name, not only a directory */url);
			curl.curl_easy_setopt(CURLOPT_READDATA, /* now specify which file to upload */hd_src);
			curl.curl_easy_setopt(/* provide the size of the upload, we specicially typecast the value
			       to curl_off_t since we must be sure to use the correct data size */CURLOPT_INFILESIZE_LARGE, ()generatedSt_size);
			res = /* Now run off and do what you've been told! */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		.fclose(/* close the local file */hd_src);
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		byte remote = "sftp://user:pass@example.com/path/filename";
		byte filename = "filename";
		 curlhandle = ((Object)0);
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_easy curl_easy = new Curl_easy();
		curlhandle = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.sftpResumeUpload(curlhandle, remote, filename)) {
			.printf("resumed upload using curl %s failed\n", ModernizedCProgram.curl_version());
		} 
		curlhandle.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
		srvr_sockaddr_union_t me = new srvr_sockaddr_union_t();
		 sock = CURL_SOCKET_BAD;
		int wrotepidfile = 0;
		int flag;
		int port = 8999;
		byte pidname = ".http.pid";
		httprequest req = new httprequest();
		int rc = 0;
		int error;
		int arg = 1;
		long pid;
		byte connecthost = "127.0.0.1";
		byte socket_type = "IPv4";
		byte[] port_str = new byte[11];
		byte location_str = port_str;
		/* a default CONNECT port is basically pointless but still ... */size_t socket_idx = new size_t();
		.memset(req, 0, );
		while (argc > arg) {
			if (!.strcmp("--version", argv[arg])) {
				.puts("sws IPv4");
				return 0;
			}  else if (!.strcmp("--pidfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					pidname = argv[arg++];
				} 
			}  else if (!.strcmp("--logfile", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.serverlogfile = argv[arg++];
				} 
			}  else if (!.strcmp("--gopher", argv[arg])) {
				arg++;
				ModernizedCProgram.use_gopher = 1;
				ModernizedCProgram.end_of_headers = /* gopher style is much simpler */"\r\n";
			}  else if (!.strcmp("--ipv4", argv[arg])) {
				socket_type = "IPv4";
				.socket_domain = 2;
				location_str = port_str;
				arg++;
			}  else if (!.strcmp("--ipv6", argv[arg])) {
				arg++;
			}  else if (!.strcmp("--unix-socket", argv[arg])) {
				arg++;
				if (argc > arg) {
					arg++;
				} 
			}  else if (!.strcmp("--port", argv[arg])) {
				arg++;
				if (argc > arg) {
					byte endptr;
					long ulnum = .strtoul(argv[arg], endptr, 10);
					if ((endptr != argv[arg] + .strlen(argv[arg])) || (ulnum < -1024) || (ulnum > -1024)) {
						(_iob[2]).curl_mfprintf("sws: invalid --port argument (%s)\n", argv[arg]);
						return 0;
					} 
					port = ModernizedCProgram.curlx_ultous(ulnum);
					arg++;
				} 
			}  else if (!.strcmp("--srcdir", argv[arg])) {
				arg++;
				if (argc > arg) {
					ModernizedCProgram.path = argv[arg];
					arg++;
				} 
			}  else if (!.strcmp("--connect", argv[arg/* The connect host IP number that the proxy will connect to no matter
			         what the client asks for, but also use this as a hint that we run as
			         a proxy and do a few different internal choices */])) {
				arg++;
				if (argc > arg) {
					connecthost = argv[arg];
					arg++;
					ModernizedCProgram.is_proxy = 1;
					ModernizedCProgram.logmsg("Run as proxy, CONNECT to host %s", connecthost);
				} 
			} else {
					.puts("Usage: sws [option]\n --version\n --logfile [file]\n --pidfile [file]\n --ipv4\n --ipv6\n --unix-socket [file]\n --port [port]\n --srcdir [path]\n --connect [ip4-addr]\n --gopher");
					return 0;
			} 
		}
		ModernizedCProgram.curl_msnprintf(port_str, , "port %hu", port);
		ModernizedCProgram.win32_init();
		.atexit(ModernizedCProgram.win32_cleanup);
		ModernizedCProgram.install_signal_handlers();
		pid = (long).getpid();
		sock = .socket(.socket_domain, 1, 0);
		ModernizedCProgram.all_sockets[0] = sock;
		ModernizedCProgram.num_sockets = 1;
		if (CURL_SOCKET_BAD == sock) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket: (%d) %s", error, .strerror(error));
			;
		} 
		flag = 1;
		if (0 != .setsockopt(sock, -1024, 4, (Object)flag, )) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed with error: (%d) %s", error, .strerror(error));
			;
		} 
		if (0 != ModernizedCProgram.curlx_nonblock(sock, 1)) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("curlx_nonblock failed with error: (%d) %s", error, .strerror(error));
			;
		} 
		Object generatedSa4 = me.getSa4();
		Object generatedSa = me.getSa();
		switch (.socket_domain) {
		case 2:
				.memset(generatedSa4, 0, );
				generatedSa4.setSin_family(2);
				generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
				generatedSa4.setSin_port(.htons(port));
				rc = .bind(sock, generatedSa, );
				break;
		}
		/* socket server is not alive, now check if it was actually a socket.
		       * Systems which have Unix sockets will also have lstat *//* dead socket, cleanup and retry bind */if (0 != /* stale socket is gone, retry bind *//* USE_UNIX_SOCKETS */rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error binding socket on %s: (%d) %s", location_str, error, .strerror(error));
			;
		} 
		ModernizedCProgram.logmsg("Running %s %s version on %s", ModernizedCProgram.use_gopher ? "GOPHER" : "HTTP", socket_type, location_str);
		rc = .listen(sock, /* start accepting connections */5);
		if (0 != rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("listen() failed with error: (%d) %s", error, .strerror(error));
			;
		} 
		wrotepidfile = ModernizedCProgram.write_pidfile(/*
		  ** As soon as this server writes its pid file the test harness will
		  ** attempt to connect to this server and initiate its verification.
		  */pidname);
		if (!wrotepidfile) {
			;
		} 
		req.init_httprequest();
		Object generatedConnmon = req.getConnmon();
		 generatedOpen = req.getOpen();
		long generatedTestno = req.getTestno();
		for (; ; ) {
			fd_set input = new fd_set();
			fd_set output = new fd_set();
			timeval timeout = new timeval(0, /* 250 ms */-1024);
			 maxfd = (ModernizedCProgram.curl_socket_t) - 1;
			for (socket_idx = ModernizedCProgram.num_sockets - 1; socket_idx >= 1; --/* Clear out closed sockets */socket_idx) {
				if (CURL_SOCKET_BAD == ModernizedCProgram.all_sockets[socket_idx]) {
					byte dst = (byte)(ModernizedCProgram.all_sockets + socket_idx);
					byte src = (byte)(ModernizedCProgram.all_sockets + socket_idx + 1);
					byte end = (byte)(ModernizedCProgram.all_sockets + ModernizedCProgram.num_sockets);
					.memmove(dst, src, end - src);
					ModernizedCProgram.num_sockets -= 1;
				} 
			}
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
			(((fd_set)(ModernizedCProgram.input)).setFd_count(/* Set up for select */0));
			(((fd_set)(output)).setFd_count(0));
			for (socket_idx = 0; socket_idx < ModernizedCProgram.num_sockets; ++socket_idx) {
				do {
					u_int __i = new u_int();
					for (__i = 0; __i < ((fd_set)(ModernizedCProgram.input)).getFd_count(); __i++) {
						if (((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] == (ModernizedCProgram.all_sockets[socket_idx])) {
							break;
						} 
					}
					if (__i == ((fd_set)(ModernizedCProgram.input)).getFd_count()) {
						if (((fd_set)(ModernizedCProgram.input)).getFd_count() < 64) {
							((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] = (ModernizedCProgram.all_sockets[socket_idx]);
							((fd_set)(ModernizedCProgram.input)).getFd_count()++;
						} 
					} 
				} while (/* Listen on all sockets */0);
				if (ModernizedCProgram.all_sockets[socket_idx] > maxfd) {
					maxfd = ModernizedCProgram.all_sockets[socket_idx];
				} 
			}
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
			do {
				rc = .select((int)maxfd + 1, ModernizedCProgram.input, output, ((Object)0), ModernizedCProgram.timeout);
			} while (rc < 0 && (._errno()) == 4 && !ModernizedCProgram.got_exit_signal);
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
			if (rc < 0) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("select() failed with error: (%d) %s", error, .strerror(error));
				;
			} 
			if (rc == 0/* Timed out - try again */) {
				continue;
			} 
			if (.__WSAFDIsSet((SOCKET)(ModernizedCProgram.all_sockets[0]), (fd_set)(/* Check if the listening socket is ready to accept */ModernizedCProgram.input/* Service all queued connections */))) {
				 msgsock = new ();
				do {
					msgsock = ModernizedCProgram.accept_connection(sock);
					ModernizedCProgram.logmsg("accept_connection %d returned %d", sock, msgsock);
					if (CURL_SOCKET_BAD == msgsock) {
						;
					} 
				} while (msgsock > 0);
			} 
			for (socket_idx = 1; socket_idx < ModernizedCProgram.num_sockets; ++/* Service all connections that are ready */socket_idx) {
				if (.__WSAFDIsSet((SOCKET)(ModernizedCProgram.all_sockets[socket_idx]), (fd_set)(ModernizedCProgram.input))) {
					if (ModernizedCProgram.got_exit_signal) {
						;
					} 
					do {
						rc = req.service_connection(ModernizedCProgram.all_sockets[socket_idx], sock, connecthost);
						if (ModernizedCProgram.got_exit_signal) {
							;
						} 
						if (rc < 0) {
							ModernizedCProgram.logmsg("====> Client disconnect %d", generatedConnmon);
							if (generatedConnmon) {
								byte keepopen = "[DISCONNECT]\n";
								ModernizedCProgram.storerequest(keepopen, .strlen(keepopen));
							} 
							if (!generatedOpen) {
								ModernizedCProgram.wait_ms(50);
							} 
							if (ModernizedCProgram.all_sockets[socket_idx] != CURL_SOCKET_BAD) {
								.closesocket((ModernizedCProgram.all_sockets[socket_idx]));
								ModernizedCProgram.all_sockets[socket_idx] = CURL_SOCKET_BAD;
							} 
							ModernizedCProgram.serverlogslocked -= 1;
							if (!ModernizedCProgram.serverlogslocked) {
								ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
							} 
							if (generatedTestno == .DOCNUMBER_QUIT) {
								;
							} 
						} 
						if (rc != /* Reset the request, unless we're still in the middle of reading */0) {
							req.init_httprequest();
						} 
					} while (rc > 0);
				} 
			}
			if (ModernizedCProgram.got_exit_signal) {
				;
			} 
		}
		if (sock != CURL_SOCKET_BAD) {
			.closesocket((sock));
		} 
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("signalled to die");
		} 
		if (wrotepidfile) {
			.unlink(pidname);
		} 
		if (ModernizedCProgram.serverlogslocked) {
			ModernizedCProgram.serverlogslocked = 0;
			ModernizedCProgram.clear_advisor_read_lock("log/serverlogs.lock");
		} 
		ModernizedCProgram.restore_signal_handlers();
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("========> %s sws (%s pid: %ld) exits with signal (%d)", socket_type, location_str, pid, ModernizedCProgram.exit_signal/*
			     * To properly set the return status of the process we
			     * must raise the same signal SIGINT or SIGTERM that we
			     * caught and let the old handler take care of it.
			     */);
			.raise(ModernizedCProgram.exit_signal);
		} 
		ModernizedCProgram.logmsg("========> sws quits");
		return 0;
		 curl = new ();
		 res = CURLE_OK;
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			curl_slist headers = ((Object)0);
			curl_slist recipients = ((Object)0);
			curl_slist slist = ((Object)0);
			 mime = new ();
			 alt = new ();
			 part = new ();
			byte cpp;
			curl.curl_easy_setopt(CURLOPT_URL, /* This is the URL for your mailserver */"smtp://mail.example.com"/* Note that this option isn't strictly required, omitting it will result
			     * in libcurl sending the MAIL FROM command with empty sender data. All
			     * autoresponses should have an empty reverse-path, and should be directed
			     * to the address in the reverse-path which triggered them. Otherwise,
			     * they could cause an endless loop. See RFC 5321 Section 4.5.5 for more
			     * details.
			     */);
			curl.curl_easy_setopt(CURLOPT_MAIL_FROM, "<sender@example.org>"/* Add two recipients, in this particular case they correspond to the
			     * To: and Cc: addressees in the header, but they could be any kind of
			     * recipient. */);
			recipients = recipients.curl_slist_append("<addressee@example.net>");
			recipients = recipients.curl_slist_append("<info@example.org>");
			curl.curl_easy_setopt(CURLOPT_MAIL_RCPT, recipients);
			for (cpp = ModernizedCProgram.headers_text; cpp; /* Build and set the message header list. */cpp++) {
				headers = headers.curl_slist_append(cpp);
			}
			curl.curl_easy_setopt(CURLOPT_HTTPHEADER, headers);
			mime = /* Build the mime message. */curl.curl_mime_init();
			alt = /* The inline part is an alternative proposing the html and the text
			       versions of the e-mail. */curl.curl_mime_init();
			part = ModernizedCProgram.curl_mime_addpart(/* HTML message. */alt);
			ModernizedCProgram.curl_mime_data(part, ModernizedCProgram.inline_html, CURL_ZERO_TERMINATED);
			ModernizedCProgram.curl_mime_type(part, "text/html");
			part = ModernizedCProgram.curl_mime_addpart(/* Text message. */alt);
			ModernizedCProgram.curl_mime_data(part, ModernizedCProgram.inline_text, CURL_ZERO_TERMINATED);
			part = ModernizedCProgram.curl_mime_addpart(/* Create the inline part. */mime);
			ModernizedCProgram.curl_mime_subparts(part, alt);
			ModernizedCProgram.curl_mime_type(part, "multipart/alternative");
			slist = ((Object)0).curl_slist_append("Content-Disposition: inline");
			slist.curl_mime_headers(part, 1);
			part = ModernizedCProgram.curl_mime_addpart(/* Add the current source program as an attachment. */mime);
			ModernizedCProgram.curl_mime_filedata(part, "smtp-mime.c");
			curl.curl_easy_setopt(CURLOPT_MIMEPOST, mime);
			res = /* Send the message */curl.curl_easy_perform();
			if (res != /* Check for errors */CURLE_OK) {
				.fprintf((_iob[2]), "curl_easy_perform() failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			} 
			/* Free lists. */recipients.curl_slist_free_all();
			headers/* curl won't send the QUIT command until you call cleanup, so you should
			     * be able to re-use this connection for additional messages (setting
			     * CURLOPT_MAIL_FROM and CURLOPT_MAIL_RCPT as required, and calling
			     * curl_easy_perform() again. It may not be a good idea to keep the
			     * connection open for a very long time though (more than a few minutes
			     * may result in the server timing out the connection), and you do want to
			     * clean up in the end.
			     */.curl_slist_free_all();
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_mime_free(/* Free multipart message. */mime);
		} 
		return (int)res;
		 cm = new ();
		 msg = new ();
		int transfers = 0;
		int msgs_left = -1;
		int still_alive = 1;
		ModernizedCProgram.curl_global_init(CURL_GLOBAL_ALL);
		Curl_multi curl_multi = new Curl_multi();
		cm = curl_multi.curl_multi_init();
		cm.curl_multi_setopt(CURLMOPT_MAXCONNECTS, (long)/* Limit the amount of simultaneous connections curl should allow: */10);
		for (transfers = 0; transfers < 10; transfers++) {
			ModernizedCProgram.add_transfer(cm, transfers);
		}
		do {
			cm.curl_multi_perform(still_alive);
			while ((msg = cm.curl_multi_info_read(msgs_left))) {
				if (msg.getMsg() == CURLMSG_DONE) {
					byte url;
					 e = msg.getEasy_handle();
					msg.getEasy_handle().curl_easy_getinfo(CURLINFO_PRIVATE, url);
					.fprintf(stderr, "R: %d - %s <%s>\n", msg.getData().getResult(), ModernizedCProgram.curl_easy_strerror(msg.getData().getResult()), url);
					ModernizedCProgram.curl_multi_remove_handle(cm, e);
					e.curl_easy_cleanup();
				} else {
						.fprintf(stderr, "E: CURLMsg (%d)\n", msg.getMsg());
				} 
				if (transfers <  / ) {
					ModernizedCProgram.add_transfer(cm, transfers++);
				} 
			}
			if (still_alive) {
				.curl_multi_wait(cm, ((Object)0), 0, 1000, ((Object)0));
			} 
		} while (still_alive || (transfers <  / ));
		cm.curl_multi_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		return 0;
	}
	public static int parsekeyword(byte pattern, Byte charset) {
		parsekey_state state = .CURLFNM_PKW_INIT;
		byte[] keyword = new byte[]{0};
		int found = 0;
		int i;
		byte p = pattern;
		for (i = 0; !found; i++) {
			byte c = p++;
			if (i >= 10) {
				return 0;
			} 
			switch (state) {
			case .CURLFNM_PKW_DDOT:
					if (c == (byte)']') {
						found = 1;
					} else {
							return 0;
					} 
			case .CURLFNM_PKW_INIT:
					if ((ModernizedCProgram.Curl_islower((int)((byte)c)))) {
						keyword[i] = c;
					}  else if (c == (byte)':') {
						state = .CURLFNM_PKW_DDOT;
					} else {
							return 0;
					} 
					break;
			}
		}
		pattern = /* move caller's pattern pointer */p;
		if (.strcmp(keyword, "digit") == 0) {
			charset[(( * 256) + 2)] = 1;
		}  else if (.strcmp(keyword, "alnum") == 0) {
			charset[(( * 256) + 1)] = 1;
		}  else if (.strcmp(keyword, "alpha") == 0) {
			charset[(( * 256) + 4)] = 1;
		}  else if (.strcmp(keyword, "xdigit") == 0) {
			charset[(( * 256) + 3)] = 1;
		}  else if (.strcmp(keyword, "print") == 0) {
			charset[(( * 256) + 5)] = 1;
		}  else if (.strcmp(keyword, "graph") == 0) {
			charset[(( * 256) + 8)] = 1;
		}  else if (.strcmp(keyword, "space") == 0) {
			charset[(( * 256) + 9)] = 1;
		}  else if (.strcmp(keyword, "blank") == 0) {
			charset[(( * 256) + 6)] = 1;
		}  else if (.strcmp(keyword, "upper") == 0) {
			charset[(( * 256) + 10)] = 1;
		}  else if (.strcmp(keyword, "lower") == 0) {
			charset[(( * 256) + 7)] = 1;
		} else {
				return 0;
		} 
		return 1;
	}
	/* Return the character class. */
	public static  charclass(byte c) {
		if ((ModernizedCProgram.Curl_isupper((int)((byte)c)))) {
			return .CCLASS_UPPER;
		} 
		if ((ModernizedCProgram.Curl_islower((int)((byte)c)))) {
			return .CCLASS_LOWER;
		} 
		if ((ModernizedCProgram.Curl_isdigit((int)((byte)c)))) {
			return .CCLASS_DIGIT;
		} 
		return .CCLASS_OTHER;
	}
	/* Include a character or a range in set. */
	public static void setcharorrange(byte pp, Byte charset) {
		byte p = (pp)++;
		byte c = p++;
		charset[c] = 1;
		if ((ModernizedCProgram.Curl_isalnum((int)((byte)c))) && p++ == (byte)'-') {
			char_class cc = ModernizedCProgram.charclass(c);
			byte endrange = p++;
			if (endrange == (byte)'\\') {
				endrange = p++;
			} 
			if (endrange >= c && ModernizedCProgram.charclass(endrange) == cc) {
				while (c++ != endrange) {
					if (ModernizedCProgram.charclass(c) == /* Chars in class may be not consecutive. */cc) {
						charset[c] = 1;
					} 
				}
				pp = p;
			} 
		} 
	}
	/* returns 1 (true) if pattern is OK, 0 if is bad ("p" is pattern pointer) */
	public static int setcharset(byte p, Byte charset) {
		setcharset_state state = .CURLFNM_SCHS_DEFAULT;
		bool something_found = 0;
		byte c;
		.memset(charset, 0, (( * 256) + 15));
		for (; ; ) {
			c = p;
			if (!c) {
				return 0;
			} 
			switch (state) {
			case .CURLFNM_SCHS_DEFAULT:
					if (c == (byte)']') {
						if (something_found) {
							return 1;
						} 
						something_found = 1;
						state = .CURLFNM_SCHS_RIGHTBR;
						charset[c] = 1;
						(p)++;
					}  else if (c == (byte)'[') {
						byte pp = p + 1;
						if (pp++ == (byte)':' && ModernizedCProgram.parsekeyword(pp, charset)) {
							p = pp;
						} else {
								charset[c] = 1;
								(p)++;
						} 
						something_found = 1;
					}  else if (c == (byte)'^' || c == (byte)'!') {
						if (!something_found) {
							if (charset[( * 256)]) {
								charset[c] = 1;
								something_found = 1;
							} else {
									charset[( * 256)] = /* negate charset */1;
							} 
						} else {
								charset[c] = 1;
						} 
						(p)++;
					}  else if (c == (byte)'\\') {
						c = (++(p));
						if (c) {
							ModernizedCProgram.setcharorrange(p, charset);
						} else {
								charset[(byte)'\\'] = 1;
						} 
						something_found = 1;
					} else {
							ModernizedCProgram.setcharorrange(p, charset);
							something_found = 1;
					} 
					break;
			case .CURLFNM_SCHS_RIGHTBR:
					if (c == (byte)'[') {
						state = .CURLFNM_SCHS_RIGHTBRLEFTBR;
						charset[c] = 1;
						(p)++;
					}  else if (c == (byte)']') {
						return 1;
					}  else if ((ModernizedCProgram.Curl_isprint((int)((byte)c)))) {
						charset[c] = 1;
						(p)++;
						state = .CURLFNM_SCHS_DEFAULT/* used 'goto fail' instead of 'return SETCHARSET_FAIL' to avoid a
						         * nonsense warning 'statement not reached' at end of the fnc when
						         * compiling on Solaris */;
					} else {
							;
					} 
					break;
			case .CURLFNM_SCHS_RIGHTBRLEFTBR:
					if (c == (byte)']') {
						return 1;
					} 
					state = .CURLFNM_SCHS_DEFAULT;
					charset[c] = 1;
					(p)++;
					break;
			}
		}
	}
	public static int loop(Object pattern, Object string, int maxstars) {
		byte p = (byte)pattern;
		byte s = (byte)string;
		byte[] charset = new byte[]{0};
		for (; ; ) {
			byte pp;
			switch (p) {
			case (byte)'*':
					if (!maxstars) {
						return 1/* Regroup consecutive stars and question marks. This can be done because
						         '*?*?*' can be expressed as '??*'. */;
					} 
					for (; ; ) {
						if (++p == (byte)'\0') {
							return 0;
						} 
						if (p == (byte)'?') {
							if (!s++) {
								return 1;
							} 
						}  else if (p != (byte)'*') {
							break;
						} 
					}
					for (maxstars--; s; /* Skip string characters until we find a match with pattern suffix. */s++) {
						if (ModernizedCProgram.loop(p, s, maxstars) == 0) {
							return 0;
						} 
					}
					return 1;
			case (byte)'?':
					if (!s) {
						return 1;
					} 
					s++;
					p++;
					break;
			case (byte)'[':
					pp = p + /* Copy in case of syntax error in set. */1;
					if (ModernizedCProgram.setcharset(pp, charset)) {
						int found = 0;
						if (!s) {
							return 1;
						} 
						if (charset[(int)s]) {
							found = 1;
						}  else if (charset[(( * 256) + 1)]) {
							found = (ModernizedCProgram.Curl_isalnum((int)((byte)s)));
						}  else if (charset[(( * 256) + 4)]) {
							found = (ModernizedCProgram.Curl_isalpha((int)((byte)s)));
						}  else if (charset[(( * 256) + 2)]) {
							found = (ModernizedCProgram.Curl_isdigit((int)((byte)s)));
						}  else if (charset[(( * 256) + 3)]) {
							found = (ModernizedCProgram.Curl_isxdigit((int)((byte)s)));
						}  else if (charset[(( * 256) + 5)]) {
							found = (ModernizedCProgram.Curl_isprint((int)((byte)s)));
						}  else if (charset[(( * 256) + 9)]) {
							found = (ModernizedCProgram.Curl_isspace((int)((byte)s)));
						}  else if (charset[(( * 256) + 10)]) {
							found = (ModernizedCProgram.Curl_isupper((int)((byte)s)));
						}  else if (charset[(( * 256) + 7)]) {
							found = (ModernizedCProgram.Curl_islower((int)((byte)s)));
						}  else if (charset[(( * 256) + 6)]) {
							found = (int)((((byte)s) == (byte)' ') || (((byte)s) == (byte)'\t'));
						}  else if (charset[(( * 256) + 8)]) {
							found = (ModernizedCProgram.Curl_isgraph((int)((byte)s)));
						} 
						if (charset[( * 256)]) {
							found = !found;
						} 
						if (!found) {
							return 1;
						} 
						p = pp + 1;
						s++;
						break;
					} 
					return /* Syntax error in set; mismatch! */1;
			case (byte)'\\':
					if (p[1]) {
						p++;
					} 
					if (s++ != p++) {
						return 1;
					} 
					break;
			case (byte)'\0':
					return s ? 1 : 0;
			default:
					if (p++ != s++) {
						return 1;
					} 
					break;
			}
		}
		 msg = new ();
		long L;
		int Q;
		int U = -1;
		fd_set R = new fd_set();
		fd_set W = new fd_set();
		fd_set E = new fd_set();
		timeval T = new timeval();
		int res = 0;
		res = ModernizedCProgram.init(num, cm, url, userpwd, headers);
		if (res) {
			return res;
		} 
		timeval timeval = new timeval();
		while (U) {
			int M = -99;
			do {
				 ec = new ();
				if ((ec = ((cm)).curl_multi_perform(((U)))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if ((((U))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)(((U))));
					res = 122;
				} 
			} while (0);
			if (res) {
				return res;
			} 
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				return res;
			} 
			if (U) {
				(((fd_set)(R)).setFd_count(0));
				(((fd_set)(W)).setFd_count(0));
				(((fd_set)(E)).setFd_count(0));
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset(((cm)), ((R)), ((W)), ((E)), ((M)))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if ((((M))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)(((M))));
						res = 122;
					} 
				} while (0);
				if (res) {
					return res;
				} 
				do {
					 ec = new ();
					if ((ec = ((cm)).curl_multi_timeout(((L)))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if ((((L))) < --1024) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_timeout() succeeded, but returned invalid timeout value (%ld)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (long)(((L))));
						res = 115;
					} 
				} while (/* At this point, M is guaranteed to be greater or equal than -1. */0);
				if (res) {
					return res;
				} 
				if (L != -/* At this point, L is guaranteed to be greater or equal than -1. */1) {
					int itimeout = (L > (long)2147483647) ? 2147483647 : (int)L;
					T.setTv_sec(itimeout / 1000);
					T.setTv_usec((itimeout % 1000) * 1000);
				} else {
						T.setTv_sec(5);
						T.setTv_usec(0);
				} 
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper(((M + 1)), ((R)), ((W)), ((E)), ((T))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					return res;
				} 
			} 
			while ((msg = cm.curl_multi_info_read(Q)) != ((Object)0)) {
				if (msg.getMsg() == CURLMSG_DONE) {
					int i;
					 e = msg.getEasy_handle();
					(_iob[2]).curl_mfprintf("R: %d - %s\n", (int)msg.getData().getResult(), ModernizedCProgram.curl_easy_strerror(msg.getData().getResult()));
					ModernizedCProgram.curl_multi_remove_handle(cm, e);
					e.curl_easy_cleanup();
					for (i = 0; i < 2; i++) {
						if (ModernizedCProgram.eh[i] == e) {
							ModernizedCProgram.eh[i] = ((Object)0);
							break;
						} 
					}
				} else {
						(_iob[2]).curl_mfprintf("E: CURLMsg (%d)\n", (int)msg.getMsg());
				} 
			}
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		}
		return /* success */0;
	}
	/*
	 * @unittest: 1307
	 */
	public static int Curl_fnmatch(Object ptr, Object pattern, Object string) {
		(Object)/* the argument is specified by the curl_fnmatch_callback
		                prototype, but not used by Curl_fnmatch() */ptr;
		if (!pattern || !string) {
			return 2;
		} 
		return ModernizedCProgram.loop((byte)pattern, (byte)string, 2/*
		 * @unittest: 1307
		 *//* the argument is specified by the curl_fnmatch_callback
		                prototype, but not used by Curl_fnmatch() */);
	}
	/* not reached */
	/* if FTP is disabled */
	public static Object gss_init_sec_context(Object min, Object initiator_cred_handle, Object context_handle, Object target_name, Object mech_type, Object req_flags, Object time_req, Object input_chan_bindings, Object input_token, Object actual_mech_type, Object output_token, Object ret_flags, Object time_rec) {
		int length = 250 * 3 / /* The token will be encoded in base64 */4;
		int used = 0;
		byte token = ((Object)0);
		byte creds = ((Object)0);
		gss_ctx_id_t ctx = ((Object)0);
		(Object)initiator_cred_handle;
		(Object)mech_type;
		(Object)time_req;
		(Object)input_chan_bindings;
		(Object)actual_mech_type;
		if (!min) {
			return (true);
		} 
		min = 0;
		if (!context_handle || !target_name || !output_token) {
			min = min_err_code.GSS_INVALID_ARGS;
			return (true);
		} 
		creds = .getenv("CURL_STUB_GSS_CREDS");
		if (!creds || .strlen(creds) >= 250) {
			min = min_err_code.GSS_INVALID_CREDS;
			return (true);
		} 
		ctx = context_handle;
		if (ctx && .strcmp(ctx.getCreds(), creds)) {
			min = min_err_code.GSS_INVALID_CREDS;
			return (true);
		} 
		output_token.setLength(0);
		output_token.setValue(((Object)0));
		if (input_token && input_token.getLength()) {
			if (!ctx) {
				min = min_err_code.GSS_INVALID_CTX;
				return (true);
			} 
			if (((byte)input_token.getValue())[0] == /* Server response, either D (RA==) or C (Qw==) */(byte)'D') {
				switch (ctx.getSent()) {
				case .KRB5:
				case .NTLM3:
						if (ret_flags) {
							ret_flags = ctx.getFlags();
						} 
						if (time_rec) {
							time_rec = -1024;
						} 
						return 0;
				default:
						min = min_err_code.GSS_SERVER_ERR;
						return (true);
				}
			} 
			if (((byte)input_token.getValue())[0] != (byte)'C') {
				min = /* We only support Done or Continue */min_err_code.GSS_SERVER_ERR;
				return (true);
			} 
			switch (ctx.getSent()) {
			case .KRB5:
					if (ctx.getHave_ntlm()) {
						ctx.setSent(.NTLM1);
						break;
					} else {
							min = min_err_code.GSS_SERVER_ERR;
							return (true);
					} 
			case .NTLM1:
					ctx.setSent(.NTLM3);
					break;
			default:
					min = min_err_code.GSS_SERVER_ERR;
					return (true);
			}
		} else {
				if (ctx) {
					min = min_err_code.GSS_INVALID_CTX;
					return (true);
				} 
				ctx = (gss_ctx_id_t).calloc(, 1);
				if (!ctx) {
					min = min_err_code.GSS_NO_MEMORY;
					return (true);
				} 
				if (.strstr(creds, "KRB5")) {
					ctx.setHave_krb5(1);
				} 
				if (.strstr(creds, "NTLM")) {
					ctx.setHave_ntlm(1);
				} 
				if (ctx.getHave_krb5()) {
					ctx.setSent(.KRB5);
				}  else if (ctx.getHave_ntlm()) {
					ctx.setSent(.NTLM1);
				} else {
						.free(ctx);
						min = min_err_code.GSS_NO_MECH;
						return (true);
				} 
				.strcpy(ctx.getCreds(), creds);
				ctx.setFlags(req_flags);
		} 
		token = .malloc(length);
		if (!token) {
			.free(ctx);
			min = min_err_code.GSS_NO_MEMORY;
			return (true);
		} 
		used = .snprintf(token, length, "%s:%s:%d:", /* Token format: creds:target:type:padding *//* Note: this is using the *real* snprintf() and not the curl provided
		     one */creds, (byte)target_name, ctx.getSent());
		if (used >= length) {
			.free(token);
			.free(ctx);
			min = min_err_code.GSS_NO_MEMORY;
			return (true);
		} 
		.memset(token + used, (byte)'A', length - /* Overwrite null terminator */used);
		context_handle = ctx;
		output_token.setValue(token);
		output_token.setLength(length);
		return (true);
	}
	public static Object gss_delete_sec_context(Object min, Object context_handle, Object output_token) {
		(Object)output_token;
		if (!min) {
			return (true);
		} 
		if (!context_handle) {
			min = min_err_code.GSS_INVALID_CTX;
			return (true);
		} 
		.free(context_handle);
		context_handle = ((Object)0);
		min = 0;
		return 0;
	}
	public static Object gss_release_buffer(Object min, Object buffer) {
		if (min) {
			min = 0;
		} 
		if (buffer && buffer.getLength()) {
			.free(buffer.getValue());
			buffer.setLength(0);
		} 
		return 0;
	}
	public static Object gss_import_name(Object min, Object input_name_buffer, Object input_name_type, Object output_name) {
		byte name = ((Object)0);
		(Object)input_name_type;
		if (!min) {
			return (true);
		} 
		if (!input_name_buffer || !output_name) {
			min = min_err_code.GSS_INVALID_ARGS;
			return (true);
		} 
		name = .strndup(input_name_buffer.getValue(), input_name_buffer.getLength());
		if (!name) {
			min = min_err_code.GSS_NO_MEMORY;
			return (true);
		} 
		output_name = (gss_name_t)name;
		min = 0;
		return 0;
	}
	public static Object gss_release_name(Object min, Object input_name) {
		if (min) {
			min = 0;
		} 
		if (input_name) {
			.free(input_name);
		} 
		return 0;
	}
	public static Object gss_display_status(Object min, Object status_value, int status_type, Object mech_type, Object message_context, Object status_string) {
		byte[] maj_str = "Stub GSS error";
		(Object)mech_type;
		if (min) {
			min = 0;
		} 
		if (message_context) {
			message_context = 0;
		} 
		if (status_string) {
			status_string.setValue(((Object)0));
			status_string.setLength(0);
			if (status_value >= min_err_code.GSS_LAST) {
				return (true);
			} 
			switch (status_type) {
			case 1:
					status_string.setValue(.strdup(maj_str));
					break;
			case 2:
					status_string.setValue(.strdup(ModernizedCProgram.min_err_table[status_value]));
					break;
			default:
					return (true);
			}
			if (status_string.getValue()) {
				status_string.setLength(.strlen(status_string.getValue()));
			} else {
					return (true);
			} 
		} 
		return 0;
	}
	/* Stubs returning error */
	public static Object gss_display_name(Object min, Object input_name, Object output_name_buffer, Object output_name_type) {
		(Object)min;
		(Object)input_name;
		(Object)output_name_buffer;
		(Object)output_name_type;
		return (true);
	}
	public static Object gss_inquire_context(Object min, Object context_handle, Object src_name, Object targ_name, Object lifetime_rec, Object mech_type, Object ctx_flags, Integer locally_initiated, Integer open_context) {
		(Object)min;
		(Object)context_handle;
		(Object)src_name;
		(Object)targ_name;
		(Object)lifetime_rec;
		(Object)mech_type;
		(Object)ctx_flags;
		(Object)locally_initiated;
		(Object)open_context;
		return (true);
	}
	public static Object gss_wrap(Object min, Object context_handle, int conf_req_flag, Object qop_req, Object input_message_buffer, Integer conf_state, Object output_message_buffer) {
		(Object)min;
		(Object)context_handle;
		(Object)conf_req_flag;
		(Object)qop_req;
		(Object)input_message_buffer;
		(Object)conf_state;
		(Object)output_message_buffer;
		return (true);
	}
	public static Object gss_unwrap(Object min, Object context_handle, Object input_message_buffer, Object output_message_buffer, Integer conf_state, Object qop_state) {
		(Object)min;
		(Object)context_handle;
		(Object)input_message_buffer;
		(Object)output_message_buffer;
		(Object)conf_state;
		(Object)qop_state;
		return (true);
	}
	public static Object gss_seal(Object min, Object context_handle, int conf_req_flag, int qop_req, Object input_message_buffer, Integer conf_state, Object output_message_buffer) {
		(Object)min;
		(Object)context_handle;
		(Object)conf_req_flag;
		(Object)qop_req;
		(Object)input_message_buffer;
		(Object)conf_state;
		(Object)output_message_buffer;
		return (true);
	}
	public static Object gss_unseal(Object min, Object context_handle, Object input_message_buffer, Object output_message_buffer, Integer conf_state, Integer qop_state) {
		(Object)min;
		(Object)context_handle;
		(Object)input_message_buffer;
		(Object)output_message_buffer;
		(Object)conf_state;
		(Object)qop_state;
		return (true);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Connection cache shared between easy handles with the share interface
	 * </DESC>
	 */
	public static void my_lock(Object handle, Object data, Object laccess, Object useptr) {
		(Object)handle;
		(Object)data;
		(Object)laccess;
		(Object)useptr;
		.fprintf((_iob[2]), "-> Mutex lock\n");
		byte what;
		userdata user = (userdata)useptr;
		int locknum;
		(Object)handle;
		(Object)laccess;
		switch (data) {
		case CURL_LOCK_DATA_DNS:
				what = "dns";
				locknum = 1;
				break;
		case CURL_LOCK_DATA_COOKIE:
				what = "cookie";
				locknum = 2;
				break;
		case CURL_LOCK_DATA_SHARE:
				what = "share";
				locknum = 0;
				break;
		default:
				(_iob[2]).curl_mfprintf("lock: no such data: %d\n", (int)data);
				return ;
		}
		if (ModernizedCProgram.locks[/* detect locking of locked locks */locknum]) {
			ModernizedCProgram.curl_mprintf("lock: double locked %s\n", what);
			return ;
		} 
		ModernizedCProgram.locks[locknum]++;
		Object generatedText = user.getText();
		int generatedCounter = user.getCounter();
		ModernizedCProgram.curl_mprintf("lock:   %-6s [%s]: %d\n", what, generatedText, generatedCounter);
		generatedCounter++;
		(Object)handle;
		(Object)data;
		(Object)laccess;
		(Object)useptr;
		ModernizedCProgram.curl_mprintf("-> Mutex lock\n");
		byte what;
		userdata user = (userdata)useptr;
		(Object)handle;
		(Object)laccess;
		switch (data) {
		case CURL_LOCK_DATA_SSL_SESSION:
				what = "ssl_session";
				break;
		case CURL_LOCK_DATA_SHARE:
				what = "share";
				break;
		case CURL_LOCK_DATA_COOKIE:
				what = "cookie";
				break;
		case CURL_LOCK_DATA_DNS:
				what = "dns";
				break;
		default:
				(_iob[2]).curl_mfprintf("lock: no such data: %d\n", (int)data);
				return ;
		}
		Object generatedText = user.getText();
		int generatedCounter = user.getCounter();
		ModernizedCProgram.curl_mprintf("lock:   %-6s [%s]: %d\n", what, generatedText, generatedCounter);
		generatedCounter++;
	}
	public static void my_unlock(Object handle, Object data, Object useptr) {
		(Object)handle;
		(Object)data;
		(Object)useptr;
		.fprintf((_iob[2]), "<- Mutex unlock\n");
		byte what;
		userdata user = (userdata)useptr;
		int locknum;
		(Object)handle;
		switch (data) {
		case CURL_LOCK_DATA_COOKIE:
				what = "cookie";
				locknum = 2;
				break;
		case CURL_LOCK_DATA_SHARE:
				what = "share";
				locknum = 0;
				break;
		case CURL_LOCK_DATA_DNS:
				what = "dns";
				locknum = 1;
				break;
		default:
				(_iob[2]).curl_mfprintf("unlock: no such data: %d\n", (int)data);
				return ;
		}
		if (!ModernizedCProgram.locks[/* detect unlocking of unlocked locks */locknum]) {
			ModernizedCProgram.curl_mprintf("unlock: double unlocked %s\n", what);
			return ;
		} 
		ModernizedCProgram.locks[locknum]--;
		Object generatedText = user.getText();
		int generatedCounter = user.getCounter();
		ModernizedCProgram.curl_mprintf("unlock: %-6s [%s]: %d\n", what, generatedText, generatedCounter);
		generatedCounter++;
		(Object)handle;
		(Object)data;
		(Object)useptr;
		ModernizedCProgram.curl_mprintf("<- Mutex unlock\n");
		byte what;
		userdata user = (userdata)useptr;
		(Object)handle;
		switch (data) {
		case CURL_LOCK_DATA_SSL_SESSION:
				what = "ssl_session";
				break;
		case CURL_LOCK_DATA_DNS:
				what = "dns";
				break;
		case CURL_LOCK_DATA_SHARE:
				what = "share";
				break;
		case CURL_LOCK_DATA_COOKIE:
				what = "cookie";
				break;
		default:
				(_iob[2]).curl_mfprintf("unlock: no such data: %d\n", (int)data);
				return ;
		}
		Object generatedText = user.getText();
		int generatedCounter = user.getCounter();
		ModernizedCProgram.curl_mprintf("unlock: %-6s [%s]: %d\n", what, generatedText, generatedCounter);
		generatedCounter++;
	}
	/* Die if we get a bad CURLMcode somewhere */
	public static void mcode_or_die(Object where, Object code) {
		if (CURLM_OK != code) {
			byte s;
			switch (code) {
			case CURLM_BAD_SOCKET:
					s = .__STRING(CURLM_BAD_SOCKET);
					.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s/* ignore this error */);
					return ;
			case CURLM_OUT_OF_MEMORY:
					s = .__STRING(CURLM_OUT_OF_MEMORY);
					break;
			case CURLM_UNKNOWN_OPTION:
					s = .__STRING(CURLM_UNKNOWN_OPTION);
					break;
			case CURLM_INTERNAL_ERROR:
					s = .__STRING(CURLM_INTERNAL_ERROR);
					break;
			case CURLM_LAST:
					s = .__STRING(CURLM_LAST);
					break;
			case CURLM_BAD_HANDLE:
					s = .__STRING(CURLM_BAD_HANDLE);
					break;
			case CURLM_BAD_EASY_HANDLE:
					s = .__STRING(CURLM_BAD_EASY_HANDLE);
					break;
			default:
					s = "CURLM_unknown";
					break;
			}
			.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s);
			.exit(code);
		} 
		if (CURLM_OK != code) {
			byte s;
			switch (code) {
			case CURLM_BAD_SOCKET:
					s = "CURLM_BAD_SOCKET";
					break;
			case CURLM_LAST:
					s = "CURLM_LAST";
					break;
			case CURLM_BAD_EASY_HANDLE:
					s = "CURLM_BAD_EASY_HANDLE";
					break;
			case CURLM_BAD_HANDLE:
					s = "CURLM_BAD_HANDLE";
					break;
			case CURLM_INTERNAL_ERROR:
					s = "CURLM_INTERNAL_ERROR";
					break;
			case CURLM_UNKNOWN_OPTION:
					s = "CURLM_UNKNOWN_OPTION";
					break;
			case CURLM_OUT_OF_MEMORY:
					s = "CURLM_OUT_OF_MEMORY";
					break;
			default:
					s = "CURLM_unknown";
			}
			.g_print("ERROR: %s returns %s\n", where, s);
			.exit(code);
		} 
		if (CURLM_OK != code) {
			byte s;
			switch (code) {
			case CURLM_OUT_OF_MEMORY:
					s = "CURLM_OUT_OF_MEMORY";
					break;
			case CURLM_LAST:
					s = "CURLM_LAST";
					break;
			case CURLM_UNKNOWN_OPTION:
					s = "CURLM_UNKNOWN_OPTION";
					break;
			case CURLM_BAD_HANDLE:
					s = "CURLM_BAD_HANDLE";
					break;
			case CURLM_BAD_EASY_HANDLE:
					s = "CURLM_BAD_EASY_HANDLE";
					break;
			case CURLM_BAD_SOCKET:
					s = "CURLM_BAD_SOCKET";
					.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s/* ignore this error */);
					return ;
			case CURLM_INTERNAL_ERROR:
					s = "CURLM_INTERNAL_ERROR";
					break;
			default:
					s = "CURLM_unknown";
					break;
			}
			.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s);
			.exit(code);
		} 
		if (CURLM_OK != code) {
			byte s;
			switch (code) {
			case CURLM_BAD_SOCKET:
					s = .__STRING(CURLM_BAD_SOCKET);
					.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s/* ignore this error */);
					return ;
			case CURLM_BAD_HANDLE:
					s = .__STRING(CURLM_BAD_HANDLE);
					break;
			case CURLM_INTERNAL_ERROR:
					s = .__STRING(CURLM_INTERNAL_ERROR);
					break;
			case CURLM_LAST:
					s = .__STRING(CURLM_LAST);
					break;
			case CURLM_OUT_OF_MEMORY:
					s = .__STRING(CURLM_OUT_OF_MEMORY);
					break;
			case CURLM_BAD_EASY_HANDLE:
					s = .__STRING(CURLM_BAD_EASY_HANDLE);
					break;
			case CURLM_UNKNOWN_OPTION:
					s = .__STRING(CURLM_UNKNOWN_OPTION);
					break;
			default:
					s = "CURLM_unknown";
					break;
			}
			.fprintf((_iob[1]), "ERROR: %s returns %s\n", where, s);
			.exit(code);
		} 
		if (CURLM_OK != code) {
			byte s;
			switch (code) {
			case CURLM_OUT_OF_MEMORY:
					s = "CURLM_OUT_OF_MEMORY";
					break;
			case CURLM_CALL_MULTI_PERFORM:
					s = "CURLM_CALL_MULTI_PERFORM";
					break;
			case CURLM_LAST:
					s = "CURLM_LAST";
					break;
			case CURLM_BAD_HANDLE:
					s = "CURLM_BAD_HANDLE";
					break;
			case CURLM_BAD_EASY_HANDLE:
					s = "CURLM_BAD_EASY_HANDLE";
					break;
			case CURLM_UNKNOWN_OPTION:
					s = "CURLM_UNKNOWN_OPTION";
					break;
			case CURLM_BAD_SOCKET:
					s = "CURLM_BAD_SOCKET";
					.fprintf(stdout, "\nERROR: %s returns %s", where, s/* ignore this error */);
					return ;
			case CURLM_INTERNAL_ERROR:
					s = "CURLM_INTERNAL_ERROR";
					break;
			default:
					s = "CURLM_unknown";
					break;
			}
			.fprintf(stdout, "\nERROR: %s returns %s", where, s);
			.exit(code);
		} 
	}
	/* Called by libevent when we get action on a multi socket */
	public static void event_cb(int fd, int kind, Object userp) {
		GlobalInfo g = (GlobalInfo)userp;
		 rc = new ();
		int action = ((kind & EV_READ) ? CURL_CSELECT_IN : 0) | ((kind & EV_WRITE) ? CURL_CSELECT_OUT : 0);
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(fd, action, generatedStill_running);
		ModernizedCProgram.mcode_or_die("event_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		event generatedTimer_event = g.getTimer_event();
		if (generatedStill_running <= 0) {
			.fprintf((_iob[1]), "last transfer done, kill timeout\n");
			if (.evtimer_pending(generatedTimer_event, ((Object)0))) {
				.evtimer_del(generatedTimer_event);
			} 
		} 
		GlobalInfo g = (GlobalInfo)ModernizedCProgram.data;
		 rc = new ();
		int fd = .g_io_channel_unix_get_fd(ch);
		int action = ((condition & G_IO_IN) ? CURL_CSELECT_IN : 0) | ((condition & G_IO_OUT) ? CURL_CSELECT_OUT : 0);
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(fd, action, generatedStill_running);
		ModernizedCProgram.mcode_or_die("event_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		event generatedTimer_event = g.getTimer_event();
		if (generatedStill_running) {
			return TRUE;
		} else {
				.g_print("last transfer done, kill timeout\n");
				if (generatedTimer_event) {
					.g_source_remove(generatedTimer_event);
				} 
				return FALSE;
		} 
		 rc = new ();
		itimerspec its = new itimerspec();
		int action = ((revents & EPOLLIN) ? CURL_CSELECT_IN : 0) | ((revents & EPOLLOUT) ? CURL_CSELECT_OUT : 0);
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(fd, action, generatedStill_running);
		ModernizedCProgram.mcode_or_die("event_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		Object generatedTfd = g.getTfd();
		if (generatedStill_running <= 0) {
			.fprintf((_iob[1]), "last transfer done, kill timeout\n");
			.memset(its, 0, );
			.timerfd_settime(generatedTfd, 0, its, ((Object)0));
		} 
		.fprintf(stdout, "\nevent_cb: action=%d", action);
		if (.UNRECOGNIZEDFUNCTIONNAME(s) == .UNRECOGNIZEDFUNCTIONNAME()) {
			.fprintf(stdout, "\nevent_cb: socket already closed");
			return ;
		} 
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		if (fdp == action || fdp == /* make sure the event matches what are wanted */CURL_POLL_INOUT) {
			CURLMcode rc = new CURLMcode();
			if (error) {
				action = CURL_CSELECT_ERR;
			} 
			rc = generatedMulti.curl_multi_socket_action(s, action, generatedStill_running);
			ModernizedCProgram.mcode_or_die("event_cb: curl_multi_socket_action", rc);
			g.check_multi_info();
			if (generatedStill_running <= 0) {
				.fprintf(stdout, "\nlast transfer done, kill timeout");
				.UNRECOGNIZEDFUNCTIONNAME();
			} 
			if (!error && .UNRECOGNIZEDFUNCTIONNAME(s) != .UNRECOGNIZEDFUNCTIONNAME() && (fdp == action || fdp == CURL_POLL_INOUT)) {
				socket tcp_socket = .UNRECOGNIZEDFUNCTIONNAME(s).getSecond();
				if (action == CURL_POLL_IN) {
					.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, action, _1, fdp));
				} 
				if (action == CURL_POLL_OUT) {
					.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, action, _1, fdp));
				} 
			} 
		} 
	}
	/* Called by libevent when our timeout expires */
	public static void timer_cb(int fd, int kind, Object userp) {
		GlobalInfo g = (GlobalInfo)userp;
		 rc = new ();
		(Object)fd;
		(Object)kind;
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, generatedStill_running);
		ModernizedCProgram.mcode_or_die("timer_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		GlobalInfo g = (GlobalInfo)ModernizedCProgram.data;
		 rc = new ();
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, generatedStill_running);
		ModernizedCProgram.mcode_or_die("timer_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		return FALSE;
		 rc = new ();
		uint64_t count = 0;
		ssize_t err = 0;
		Object generatedTfd = g.getTfd();
		err = .read(generatedTfd, count, );
		if (err == -1/* Note that we may call the timer callback even if the timerfd isn't
		     * readable. It's possible that there are multiple events stored in the
		     * epoll buffer (i.e. the timer may have fired multiple times). The
		     * event count is cleared after the first call so future events in the
		     * epoll buffer will fail to read from the timer. */) {
			if ((._errno()) == 11) {
				.fprintf((_iob[1]), "EAGAIN on tfd %d\n", generatedTfd);
				return ;
			} 
		} 
		if (err != ) {
			.fprintf((_iob[2]), "read(tfd) == %ld", err);
			.perror("read(tfd)");
		} 
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		rc = generatedMulti.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, generatedStill_running);
		ModernizedCProgram.mcode_or_die("timer_cb: curl_multi_socket_action", rc);
		g.check_multi_info();
		Object generatedMulti = g.getMulti();
		int generatedStill_running = g.getStill_running();
		if (!error) {
			.fprintf(stdout, "\ntimer_cb: ");
			CURLMcode rc = new CURLMcode();
			rc = generatedMulti.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, generatedStill_running);
			ModernizedCProgram.mcode_or_die("timer_cb: curl_multi_socket_action", rc);
			g.check_multi_info();
		} 
	}
	/* Assign information to a SockInfo structure */
	public static void setsock(_SockInfo f, Object s, Object e, int act, _GlobalInfo g) {
		int kind = ((act & CURL_POLL_IN) ? EV_READ : 0) | ((act & CURL_POLL_OUT) ? EV_WRITE : 0) | EV_PERSIST;
		f.setSockfd(s);
		f.setAction(act);
		f.setEasy(e);
		event generatedEv = f.getEv();
		.event_del(generatedEv);
		event_base generatedEvbase = g.getEvbase();
		Object generatedSockfd = f.getSockfd();
		.event_assign(generatedEv, generatedEvbase, generatedSockfd, kind, event_cb, g);
		.event_add(generatedEv, ((Object)0));
		 kind = ((act & CURL_POLL_IN) ? G_IO_IN : 0) | ((act & CURL_POLL_OUT) ? G_IO_OUT : 0);
		f.setSockfd(s);
		f.setAction(act);
		f.setEasy(e);
		event generatedEv = f.getEv();
		if (generatedEv) {
			.g_source_remove(generatedEv);
		} 
		Object generatedCh = f.getCh();
		f.setEv(.g_io_add_watch(generatedCh, kind, event_cb, g));
		.printf("%s  \n", __PRETTY_FUNCTION__);
		int kind = ((act & CURL_POLL_IN) ? EV_READ : 0) | ((act & CURL_POLL_OUT) ? EV_WRITE : 0);
		f.setSockfd(s);
		f.setAction(act);
		f.setEasy(e);
		Object generatedEvset = f.getEvset();
		Object generatedLoop = g.getLoop();
		event generatedEv = f.getEv();
		if (generatedEvset) {
			.ev_io_stop(generatedLoop, generatedEv);
		} 
		Object generatedSockfd = f.getSockfd();
		.ev_io_init(generatedEv, event_cb, generatedSockfd, kind);
		generatedEv.setEv_io(g);
		f.setEvset(1);
		.ev_io_start(generatedLoop, generatedEv);
		epoll_event ev = new epoll_event();
		int kind = ((act & CURL_POLL_IN) ? EPOLLIN : 0) | ((act & CURL_POLL_OUT) ? EPOLLOUT : 0);
		Object generatedSockfd = f.getSockfd();
		Object generatedEpfd = g.getEpfd();
		if (generatedSockfd) {
			if (.epoll_ctl(generatedEpfd, EPOLL_CTL_DEL, generatedSockfd, ((Object)0))) {
				.fprintf((_iob[2]), "EPOLL_CTL_DEL failed for fd: %d : %s\n", generatedSockfd, .strerror((._errno())));
			} 
		} 
		f.setSockfd(s);
		f.setAction(act);
		f.setEasy(e);
		ev.setEpoll_event(kind);
		Object generatedEpoll_event = ev.getEpoll_event();
		generatedEpoll_event.setFd(s);
		if (.epoll_ctl(generatedEpfd, EPOLL_CTL_ADD, s, ev)) {
			.fprintf((_iob[2]), "EPOLL_CTL_ADD failed for fd: %d : %s\n", s, .strerror((._errno())));
		} 
		.fprintf(stdout, "\nsetsock: socket=%d, act=%d, fdp=%p", s, act, fdp);
		iterator it = .UNRECOGNIZEDFUNCTIONNAME(s);
		if (it == .UNRECOGNIZEDFUNCTIONNAME()) {
			.fprintf(stdout, "\nsocket %d is a c-ares socket, ignoring", s);
			return ;
		} 
		socket tcp_socket = it.getSecond();
		fdp = act;
		if (act == CURL_POLL_IN) {
			.fprintf(stdout, "\nwatching for socket to become readable");
			if (oldact != CURL_POLL_IN && oldact != CURL_POLL_INOUT) {
				.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, CURL_POLL_IN, _1, fdp));
			} 
		}  else if (act == CURL_POLL_OUT) {
			.fprintf(stdout, "\nwatching for socket to become writable");
			if (oldact != CURL_POLL_OUT && oldact != CURL_POLL_INOUT) {
				.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, CURL_POLL_OUT, _1, fdp));
			} 
		}  else if (act == CURL_POLL_INOUT) {
			.fprintf(stdout, "\nwatching for socket to become readable & writable");
			if (oldact != CURL_POLL_IN && oldact != CURL_POLL_INOUT) {
				.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, CURL_POLL_IN, _1, fdp));
			} 
			if (oldact != CURL_POLL_OUT && oldact != CURL_POLL_INOUT) {
				.UNRECOGNIZEDFUNCTIONNAME(.null_buffers(), .bind(event_cb, g, s, CURL_POLL_OUT, _1, fdp));
			} 
		} 
	}
	/* CURLMOPT_SOCKETFUNCTION */
	public static int sock_cb(Object e, Object s, int what, Object cbp, Object sockp) {
		GlobalInfo g = (GlobalInfo)cbp;
		SockInfo fdp = (SockInfo)sockp;
		byte[] whatstr = new byte[]{"none", "IN", "OUT", "INOUT", "REMOVE"};
		.fprintf((_iob[1]), "socket callback: s=%d e=%p what=%s ", s, e, whatstr[what]);
		int generatedAction = fdp.getAction();
		if (what == CURL_POLL_REMOVE) {
			.fprintf((_iob[1]), "\n");
			fdp.remsock();
		} else {
				if (!fdp) {
					.fprintf((_iob[1]), "Adding data: %s\n", whatstr[what]);
					g.addsock(s, e, what);
				} else {
						.fprintf((_iob[1]), "Changing action from %s to %s\n", whatstr[generatedAction], whatstr[what]);
						ModernizedCProgram.setsock(fdp, s, e, what, g);
				} 
		} 
		return 0;
		GlobalInfo g = (GlobalInfo)cbp;
		SockInfo fdp = (SockInfo)sockp;
		byte[] whatstr = new byte[]{"none", "IN", "OUT", "INOUT", "REMOVE"};
		.g_print("socket callback: s=%d e=%p what=%s ", s, e, whatstr[what]);
		int generatedAction = fdp.getAction();
		if (what == CURL_POLL_REMOVE) {
			.g_print("\n");
			fdp.remsock();
		} else {
				if (!fdp) {
					.g_print("Adding data: %s%s\n", (what & CURL_POLL_IN) ? "READ" : "", (what & CURL_POLL_OUT) ? "WRITE" : "");
					g.addsock(s, e, what);
				} else {
						.g_print("Changing action from %d to %d\n", generatedAction, what);
						ModernizedCProgram.setsock(fdp, s, e, what, g);
				} 
		} 
		return 0;
		.printf("%s e %p s %i what %i cbp %p sockp %p\n", __PRETTY_FUNCTION__, e, s, what, cbp, sockp);
		GlobalInfo g = (GlobalInfo)cbp;
		SockInfo fdp = (SockInfo)sockp;
		byte[] whatstr = new byte[]{"none", "IN", "OUT", "INOUT", "REMOVE"};
		.fprintf((_iob[1]), "socket callback: s=%d e=%p what=%s ", s, e, whatstr[what]);
		int generatedAction = fdp.getAction();
		if (what == CURL_POLL_REMOVE) {
			.fprintf((_iob[1]), "\n");
			fdp.remsock(g);
		} else {
				if (!fdp) {
					.fprintf((_iob[1]), "Adding data: %s\n", whatstr[what]);
					g.addsock(s, e, what);
				} else {
						.fprintf((_iob[1]), "Changing action from %s to %s\n", whatstr[generatedAction], whatstr[what]);
						ModernizedCProgram.setsock(fdp, s, e, what, g);
				} 
		} 
		return 0;
		GlobalInfo g = (GlobalInfo)cbp;
		SockInfo fdp = (SockInfo)sockp;
		byte[] whatstr = new byte[]{"none", "IN", "OUT", "INOUT", "REMOVE"};
		.fprintf((_iob[1]), "socket callback: s=%d e=%p what=%s ", s, e, whatstr[what]);
		int generatedAction = fdp.getAction();
		if (what == CURL_POLL_REMOVE) {
			.fprintf((_iob[1]), "\n");
			fdp.remsock(g);
		} else {
				if (!fdp) {
					.fprintf((_iob[1]), "Adding data: %s\n", whatstr[what]);
					g.addsock(s, e, what);
				} else {
						.fprintf((_iob[1]), "Changing action from %s to %s\n", whatstr[generatedAction], whatstr[what]);
						ModernizedCProgram.setsock(fdp, s, e, what, g);
				} 
		} 
		return 0;
		.fprintf(stdout, "\nsock_cb: socket=%d, what=%d, sockp=%p", s, what, sockp);
		GlobalInfo g = (GlobalInfo)cbp;
		int actionp = (int)sockp;
		byte[] whatstr = new byte[]{"none", "IN", "OUT", "INOUT", "REMOVE"};
		.fprintf(stdout, "\nsocket callback: s=%d e=%p what=%s ", s, e, whatstr[what]);
		if (what == CURL_POLL_REMOVE) {
			.fprintf(stdout, "\n");
			actionp.remsock(g);
		} else {
				if (!actionp) {
					.fprintf(stdout, "\nAdding data: %s", whatstr[what]);
					g.addsock(s, e, what);
				} else {
						.fprintf(stdout, "\nChanging action from %s to %s", whatstr[actionp], whatstr[what]);
						ModernizedCProgram.setsock(actionp, s, e, what, actionp, g);
				} 
		} 
		return 0;
	}
	/* CURLOPT_WRITEFUNCTION */
	public static Object write_cb(Object ptr, Object size, Object nmemb, Object data) {
		(Object)ptr;
		(Object)data;
		return size * nmemb;
		size_t realsize = size * nmemb;
		ConnInfo conn = (ConnInfo)data;
		(Object)ptr;
		(Object)conn;
		return realsize;
		 r = new ();
		r = size * nmemb;
		.tidyBufAppend(out, in, r);
		return r;
		size_t realsize = size * nmemb;
		Memory mem = (Memory)userp;
		Byte generatedMemory = mem.getMemory();
		Object generatedSize = mem.getSize();
		byte ptr = .realloc(generatedMemory, generatedSize + realsize + 1);
		if (!ptr) {
			.printf(/* out of memory! */"not enough memory (realloc returned NULL)\n");
			return 0;
		} 
		mem.setMemory(ptr);
		.memcpy((generatedMemory[generatedSize]), contents, realsize);
		generatedSize += realsize;
		generatedMemory[generatedSize] = 0;
		return realsize;
		size_t realsize = size * nmemb;
		ConnInfo conn = (ConnInfo)data;
		(Object)ptr;
		(Object)conn;
		return realsize;
		(Object)/* take care of the data here, ignored in this example */d;
		(Object)p;
		return n * l;
		(Object)ptr;
		(Object)data;
		return size * nmemb;
		size_t written = size * nmemb;
		byte pBuffer = (byte).malloc(written + 1);
		.strncpy(pBuffer, (byte)ptr, written);
		pBuffer[written] = (byte)'\0';
		.fprintf(stdout, "%s", pBuffer);
		.free(pBuffer);
		return written;
		(Object)/* take care of the data here, ignored in this example */data;
		(Object)userp;
		return n * l;
	}
	/* CURLOPT_PROGRESSFUNCTION */
	public static int prog_cb(Object p, double dltotal, double dlnow, double ult, double uln) {
		ConnInfo conn = (ConnInfo)p;
		(Object)ult;
		(Object)uln;
		Byte generatedUrl = conn.getUrl();
		.fprintf((_iob[1]), "Progress: %s (%g/%g)\n", generatedUrl, dlnow, dltotal);
		return 0;
		ConnInfo conn = (ConnInfo)p;
		Byte generatedUrl = conn.getUrl();
		.g_print("Progress: %s (%g/%g)\n", generatedUrl, dlnow, dltotal);
		return 0;
		ConnInfo conn = (ConnInfo)p;
		(Object)ult;
		(Object)uln;
		Byte generatedUrl = conn.getUrl();
		.fprintf((_iob[1]), "Progress: %s (%g/%g)\n", generatedUrl, dlnow, dltotal);
		return 0;
		ConnInfo conn = (ConnInfo)p;
		(Object)ult;
		(Object)uln;
		Byte generatedUrl = conn.getUrl();
		.fprintf((_iob[1]), "Progress: %s (%g/%g)\n", generatedUrl, dlnow, dltotal);
		return 0;
		ConnInfo conn = (ConnInfo)p;
		(Object)ult;
		(Object)uln;
		Byte generatedUrl = conn.getUrl();
		.fprintf(stdout, "\nProgress: %s (%g/%g)", generatedUrl, dlnow, dltotal);
		.fprintf(stdout, "\nProgress: %s (%g)", generatedUrl, ult);
		return 0;
	}
	/* This gets called whenever data is received from the fifo */
	public static void fifo_cb(int fd, int event, Object arg) {
		byte[] s = new byte[1024];
		long rv = 0;
		int n = 0;
		GlobalInfo g = (GlobalInfo)arg;
		(Object)fd;
		(Object)event;
		_iobuf generatedInput = g.getInput();
		int generatedStill_running = g.getStill_running();
		event_base generatedEvbase = g.getEvbase();
		do {
			s[0] = (byte)'\0';
			rv = .fscanf(generatedInput, "%1023s%n", s, n);
			s[n] = (byte)'\0';
			if (n && s[0]) {
				if (!.strcmp(s, "stop")) {
					g.setStopped(1);
					if (generatedStill_running == 0) {
						.event_base_loopbreak(generatedEvbase);
					} 
				} else {
						/* if we read a URL, go get it! */arg.new_conn(s);
				} 
			} else {
					break;
			} 
		} while (rv != (true));
		 len = new ();
		 tp = new ();
		 buf = new ();
		 tmp = new ();
		 all = ((Object)0);
		 rv = new ();
		do {
			 err = ((Object)0);
			rv = .g_io_channel_read_line(ch, buf, len, tp, err);
			if (buf) {
				if (tp) {
					buf[tp] = (byte)'\0';
				} 
				(GlobalInfo)ModernizedCProgram.data.new_conn(buf);
				.g_free(buf);
			} else {
					buf = .g_malloc(1024 + 1);
					while (TRUE) {
						buf[1024] = (byte)'\0';
						.g_io_channel_read_chars(ch, buf, 1024, len, err);
						if (len) {
							buf[len] = (byte)'\0';
							if (all) {
								tmp = all;
								all = .g_strdup_printf("%s%s", tmp, buf);
								.g_free(tmp);
							} else {
									all = .g_strdup(buf);
							} 
						} else {
								break;
						} 
					}
					if (all) {
						(GlobalInfo)ModernizedCProgram.data.new_conn(all);
						.g_free(all);
					} 
					.g_free(buf);
			} 
			if (err) {
				.g_error("fifo_cb: %s", err.getMessage());
				.g_free(err);
				break;
			} 
		} while ((len) && (rv == G_IO_STATUS_NORMAL));
		return TRUE;
		byte[] s = new byte[1024];
		long rv = 0;
		int n = 0;
		_iobuf generatedInput = g.getInput();
		do {
			s[0] = (byte)'\0';
			rv = .fscanf(generatedInput, "%1023s%n", s, n);
			s[n] = (byte)'\0';
			if (n && s[0]) {
				/* if we read a URL, go get it! */g.new_conn(s);
			} else {
					break;
			} 
		} while (rv != (true));
	}
	/* this is how the CURLOPT_XFERINFOFUNCTION callback works */
	public static int xferinfo(Object p, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		myprogress myp = (myprogress)p;
		Object generatedCurl = myp.getCurl();
		 curl = generatedCurl;
		double curtime = 0;
		curl.curl_easy_getinfo(CURLINFO_TOTAL_TIME, curtime/* under certain circumstances it may be desirable for certain functionality
		     to only run every N seconds, in order to do this the transaction time can
		     be used */);
		double generatedLastruntime = myp.getLastruntime();
		if ((curtime - generatedLastruntime) >= 3) {
			myp.setLastruntime(curtime);
			.fprintf((_iob[2]), "TOTAL TIME: %f \r\n", curtime);
		} 
		if (dlnow > 6000) {
			return 1;
		} 
		return 0;
		(Object)p;
		(Object)dlnow;
		(Object)dltotal;
		(Object)ulnow;
		(Object)ultotal;
		(_iob[2]).curl_mfprintf("xferinfo fail!\n");
		return /* fail as fast as we can */1;
	}
	/* for libcurl older than 7.32.0 (CURLOPT_PROGRESSFUNCTION) */
	public static int older_progress(Object p, double dltotal, double dlnow, double ultotal, double ulnow) {
		return ModernizedCProgram.xferinfo(p, ()dltotal, ()dlnow, ()ultotal, ()ulnow);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object unit_setup() {
		return CURLE_OK;
		return /***************************************************************************
		 *                                  _   _ ____  _
		 *  Project                     ___| | | |  _ \| |
		 *                             / __| | | | |_) | |
		 *                            | (__| |_| |  _ <| |___
		 *                             \___|\___/|_| \_\_____|
		 *
		 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
		 *
		 * This software is licensed as described in the file COPYING, which
		 * you should have received as part of this distribution. The terms
		 * are also available at https://curl.haxx.se/docs/copyright.html.
		 *
		 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
		 * copies of the Software, and permit persons to whom the Software is
		 * furnished to do so, under the terms of the COPYING file.
		 *
		 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
		 * KIND, either express or implied.
		 *
		 ***************************************************************************/CURLE_OK;
		return /***************************************************************************
		 *                                  _   _ ____  _
		 *  Project                     ___| | | |  _ \| |
		 *                             / __| | | | |_) | |
		 *                            | (__| |_| |  _ <| |___
		 *                             \___|\___/|_| \_\_____|
		 *
		 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
		 *
		 * This software is licensed as described in the file COPYING, which
		 * you should have received as part of this distribution. The terms
		 * are also available at https://curl.haxx.se/docs/copyright.html.
		 *
		 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
		 * copies of the Software, and permit persons to whom the Software is
		 * furnished to do so, under the terms of the COPYING file.
		 *
		 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
		 * KIND, either express or implied.
		 *
		 ***************************************************************************/CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1609.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		return res;
		return ModernizedCProgram.hash_static.Curl_hash_init(ModernizedCProgram.slots, ModernizedCProgram.Curl_hash_str, ModernizedCProgram.Curl_str_key_compare, mydtor);
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1303.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.data = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.data) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return res;
		return CURLE_OK;
		return /* whatever you want done first */CURLE_OK;
		int rc;
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.data = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.data) {
			return CURLE_OUT_OF_MEMORY;
		} 
		rc = ModernizedCProgram.hp.Curl_mk_dnscache();
		if (rc) {
			ModernizedCProgram.data.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return CURLE_OUT_OF_MEMORY;
		} 
		return CURLE_OK;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1607.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		return res;
		int i;
		for (i = 0; i < 8 - 1; i++) {
			ModernizedCProgram.addrs[i].setAi_next(ModernizedCProgram.addrs[i + 1]);
		}
		return CURLE_OK;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1605.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.easy = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.easy) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return res;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1606.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.easy = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.easy) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return res;
		return CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
		ModernizedCProgram.llist.Curl_llist_init(test_curl_llist_dtor);
		ModernizedCProgram.llist_destination.Curl_llist_init(test_curl_llist_dtor);
		return CURLE_OK;
		ModernizedCProgram.password = .strdup("");
		ModernizedCProgram.login = .strdup("");
		if (!ModernizedCProgram.password || !ModernizedCProgram.login) {
			do {
				.free((ModernizedCProgram.password));
				(ModernizedCProgram.password) = ((Object)0);
			} while (0);
			do {
				.free((ModernizedCProgram.login));
				(ModernizedCProgram.login) = ((Object)0);
			} while (0);
			return CURLE_OUT_OF_MEMORY;
		} 
		return CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1600.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.easy = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.easy) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return res;
		return CURLE_OK;
		return ModernizedCProgram.hash_static.Curl_hash_init(7, ModernizedCProgram.Curl_hash_str, ModernizedCProgram.Curl_str_key_compare, mydtor);
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1302.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.data = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.data) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return res;
		return CURLE_OK;
		int res = CURLE_OK;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1396.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		return res;
		return CURLE_OK;
		return CURLE_OK;
		int res = 0;
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_global_init((((CURL_GLOBAL_ALL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_global_init() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\unit1652.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				return res;
			} 
		} while (0);
		Curl_easy curl_easy = new Curl_easy();
		ModernizedCProgram.data = curl_easy.curl_easy_init();
		if (!ModernizedCProgram.data) {
			return CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.data.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, ModernizedCProgram.debugf_cb);
		ModernizedCProgram.data.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		return CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
		return CURLE_OK;
	}
	public static void unit_stop() {
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.hash_static.Curl_hash_destroy();
		ModernizedCProgram.data.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (ModernizedCProgram.data_node) {
			ModernizedCProgram.data_node.getAddr().Curl_freeaddrinfo();
			.free(ModernizedCProgram.data_node);
		} 
		.free(ModernizedCProgram.data_key);
		ModernizedCProgram.hp.Curl_hash_destroy();
		ModernizedCProgram.data.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		do {
			.free((ModernizedCProgram.password));
			(ModernizedCProgram.password) = ((Object)0);
		} while (0);
		do {
			.free((ModernizedCProgram.login));
			(ModernizedCProgram.login) = ((Object)0);
		} while (0);
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.easy.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.hash_static.Curl_hash_destroy();
		ModernizedCProgram.data.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
		if (ModernizedCProgram.hnd) {
			ModernizedCProgram.hnd.curl_easy_cleanup();
		} 
		ModernizedCProgram.curl_global_cleanup();
		ModernizedCProgram.data.curl_easy_cleanup();
		ModernizedCProgram.curl_global_cleanup();
	}
	public static Object print_httppost_callback(Object arg, Object buf, Object len) {
		.fwrite(buf, len, 1, (_iob[1]));
		((size_t)arg) += len;
		return len;
	}
	public static int readline(byte buffer, Object bufsize) {
		size_t offset = 0;
		byte newptr;
		if (!buffer) {
			buffer = .Curl_cmalloc(128);
			if (!buffer) {
				return -1;
			} 
			bufsize = 128;
		} 
		for (; ; ) {
			size_t length = new size_t();
			int bytestoread = ModernizedCProgram.curlx_uztosi(bufsize - offset);
			if (!.fgets(buffer + offset, bytestoread, stream)) {
				return (offset != 0) ? 0 : 1;
			} 
			length = offset + .strlen(buffer + offset);
			if ((buffer + length - 1) == (byte)'\n') {
				break;
			} 
			offset = length;
			if (length < bufsize - 1) {
				continue;
			} 
			newptr = .Curl_crealloc(buffer, bufsize * 2);
			if (!newptr) {
				return -1;
			} 
			buffer = newptr;
			bufsize *= 2;
		}
		return 0/*
		 * appenddata()
		 *
		 * This appends data from a given source buffer to the end of the used part of
		 * a destination buffer. Arguments relative to the destination buffer are, the
		 * address of a pointer to the destination buffer 'dst_buf', the length of data
		 * in destination buffer excluding potential null string termination 'dst_len',
		 * the allocated size of destination buffer 'dst_alloc'. All three destination
		 * buffer arguments may be modified by this function. Arguments relative to the
		 * source buffer are, a pointer to the source buffer 'src_buf' and indication
		 * whether the source buffer is base64 encoded or not 'src_b64'.
		 *
		 * If the source buffer is indicated to be base64 encoded, this appends the
		 * decoded data, binary or whatever, to the destination. The source buffer
		 * may not hold binary data, only a null terminated string is valid content.
		 *
		 * Destination buffer will be enlarged and relocated as needed.
		 *
		 * Calling function is responsible to provide preallocated destination
		 * buffer and also to deallocate it when no longer needed.
		 *
		 * This function may return:
		 *   GPE_OUT_OF_MEMORY
		 *   GPE_OK
		 */;
	}
	/* dest buffer */
	public static int appenddata(byte dst_buf, Object dst_len, Object dst_alloc, Byte src_buf, int src_b64) {
		size_t need_alloc = /* source buffer *//* != 0 if source is base64 encoded */0;
		size_t src_len = .strlen(src_buf);
		if (!src_len) {
			return 0;
		} 
		need_alloc = src_len + dst_len + 1;
		if (src_b64) {
			if (src_buf[src_len - 1] == (byte)'\r') {
				src_len--;
			} 
			if (src_buf[src_len - 1] == (byte)'\n') {
				src_len--;
			} 
		} 
		if (need_alloc > /* enlarge destination buffer if required */dst_alloc) {
			size_t newsize = need_alloc * 2;
			byte newptr = .Curl_crealloc(dst_buf, newsize);
			if (!newptr) {
				return -1;
			} 
			dst_alloc = newsize;
			dst_buf = newptr;
		} 
		.memcpy(dst_buf + dst_len, src_buf, /* memcpy to support binary blobs */src_len);
		dst_len += src_len;
		(dst_buf + dst_len) = (byte)'\0';
		return 0;
	}
	/* dest buffer data length */
	/* dest buffer allocated size */
	/* dest buffer */
	public static int decodedata(byte buf, Object len) {
		 error = CURLE_OK;
		byte buf64 = ((Object)0);
		size_t src_len = 0;
		if (!len) {
			return 0;
		} 
		error = ModernizedCProgram.Curl_base64_decode(buf, buf64, /* base64 decode the given buffer */src_len);
		if (error) {
			return -1;
		} 
		if (!src_len/*
		    ** currently there is no way to tell apart an OOM condition in
		    ** Curl_base64_decode() from zero length decoded data. For now,
		    ** let's just assume it is an OOM condition, currently we have
		    ** no input for this function that decodes to zero length data.
		    */) {
			.Curl_cfree(buf64);
			return -1;
		} 
		.memcpy(buf, buf64, /* memcpy to support binary blobs */src_len);
		len = src_len;
		(buf + src_len) = (byte)'\0';
		.Curl_cfree(buf64);
		return 0/*
		 * getpart()
		 *
		 * This returns whole contents of specified XML-like section and subsection
		 * from the given file. This is mostly used to retrieve a specific part from
		 * a test definition file for consumption by test suite servers.
		 *
		 * Data is returned in a dynamically allocated buffer, a pointer to this data
		 * and the size of the data is stored at the addresses that caller specifies.
		 *
		 * If the returned data is a string the returned size will be the length of
		 * the string excluding null termination. Otherwise it will just be the size
		 * of the returned binary data.
		 *
		 * Calling function is responsible to free returned buffer.
		 *
		 * This function may return:
		 *   GPE_NO_BUFFER_SPACE
		 *   GPE_OUT_OF_MEMORY
		 *   GPE_OK
		 */;
	}
	/* dest buffer data length */
	public static int getpart(byte outbuf, Object outlen, Object main, Object sub) {
		byte[] couter = new byte[79 + /* current outermost section */1];
		byte[] cmain = new byte[79 + /* current main section */1];
		byte[] csub = new byte[79 + /* current sub section */1];
		byte[] ptag = new byte[79 + /* potential tag */1];
		byte[] patt = new byte[79 + /* potential attributes */1];
		byte buffer = ((Object)0);
		byte ptr;
		byte end;
		Object len;
		size_t bufsize = 0;
		size_t outalloc = 256;
		int in_wanted_part = 0;
		int base64 = 0;
		int error;
		Object state = .STATE_OUTSIDE;
		outlen = 0;
		outbuf = .Curl_cmalloc(outalloc);
		if (!outbuf) {
			return -1;
		} 
		(outbuf) = (byte)'\0';
		couter[0] = cmain[0] = csub[0] = ptag[0] = patt[0] = (byte)'\0';
		Object generatedSig = len.getSig();
		Object generatedUns = len.getUns();
		while ((error = stream.readline(buffer, bufsize)) == 0) {
			ptr = buffer;
			while ((ptr) && (ModernizedCProgram.Curl_isspace((int)((byte)(ptr))))) {
				(ptr)++;
			}
			if ((byte)'<' != ptr) {
				if (in_wanted_part) {
					do {
					} while (0);
					error = ModernizedCProgram.appenddata(outbuf, outlen, outalloc, buffer, base64);
					if (error) {
						break;
					} 
				} 
				continue;
			} 
			ptr++;
			if ((byte)'/' == ptr/*
			      ** closing section tag
			      */) {
				ptr++;
				end = ptr;
				while ((end) && !(ModernizedCProgram.Curl_isspace((int)((byte)(end)))) && ((byte)'>' != (end))) {
					(end)++;
				}
				len.setSig(end - ptr);
				if (generatedSig > 79) {
					error = -2;
					break;
				} 
				.memcpy(ptag, ptr, generatedUns);
				ptag[generatedUns] = (byte)'\0';
				if ((.STATE_INSUB == .state) && !.strcmp(csub, ptag)) {
					.state = /* end of current sub section */.STATE_INMAIN;
					csub[0] = (byte)'\0';
					if (in_wanted_part) {
						in_wanted_part = /* end of wanted part */0;
						if (/* Do we need to base64 decode the data? */base64) {
							error = ModernizedCProgram.decodedata(outbuf, outlen);
							if (error) {
								return error;
							} 
						} 
						break;
					} 
				}  else if ((.STATE_INMAIN == .state) && !.strcmp(cmain, ptag)) {
					.state = /* end of current main section */.STATE_OUTER;
					cmain[0] = (byte)'\0';
					if (in_wanted_part) {
						in_wanted_part = /* end of wanted part */0;
						if (/* Do we need to base64 decode the data? */base64) {
							error = ModernizedCProgram.decodedata(outbuf, outlen);
							if (error) {
								return error;
							} 
						} 
						break;
					} 
				}  else if ((.STATE_OUTER == .state) && !.strcmp(couter, ptag)) {
					.state = /* end of outermost file section */.STATE_OUTSIDE;
					couter[0] = (byte)'\0';
					if (in_wanted_part) {
						in_wanted_part = /* end of wanted part */0;
						break;
					} 
				} 
			}  else if (!in_wanted_part/*
			      ** opening section tag
			      */) {
				end = /* get potential tag */ptr;
				while ((end) && !(ModernizedCProgram.Curl_isspace((int)((byte)(end)))) && ((byte)'>' != (end))) {
					(end)++;
				}
				len.setSig(end - ptr);
				if (generatedSig > 79) {
					error = -2;
					break;
				} 
				.memcpy(ptag, ptr, generatedUns);
				ptag[generatedUns] = (byte)'\0';
				if (((byte)'!' == ptag[0]) || ((byte)'?' == ptag[/* ignore comments, doctypes and xml declarations */0])) {
					do {
					} while (0);
					continue;
				} 
				ptr = /* get all potential attributes */end;
				while ((ptr) && (ModernizedCProgram.Curl_isspace((int)((byte)(ptr))))) {
					(ptr)++;
				}
				end = ptr;
				while (end && ((byte)'>' != end)) {
					end++;
				}
				len.setSig(end - ptr);
				if (generatedSig > 79) {
					error = -2;
					break;
				} 
				.memcpy(patt, ptr, generatedUns);
				patt[generatedUns] = (byte)'\0';
				if (.STATE_OUTSIDE == .state) {
					.strcpy(couter, /* outermost element (<testcase>) */ptag);
					.state = .STATE_OUTER;
					continue;
				}  else if (.STATE_OUTER == .state) {
					.strcpy(cmain, /* start of a main section */ptag);
					.state = .STATE_INMAIN;
					continue;
				}  else if (.STATE_INMAIN == .state) {
					.strcpy(csub, /* start of a sub section */ptag);
					.state = .STATE_INSUB;
					if (!.strcmp(cmain, main) && !.strcmp(csub, sub)) {
						in_wanted_part = /* start of wanted part */1;
						if (.strstr(patt, "base64="/* bit rough test, but "mostly" functional, */)) {
							base64 = /* treat wanted part data as base64 encoded */1;
						} 
					} 
					continue;
				} 
			} 
			if (in_wanted_part) {
				do {
				} while (0);
				error = ModernizedCProgram.appenddata(outbuf, outlen, outalloc, buffer, base64);
				if (error) {
					break;
				} 
			} 
		}
		.Curl_cfree(/* while */buffer);
		if (error != 0) {
			if (error == 1) {
				error = 0;
			} else {
					.Curl_cfree(outbuf);
					outbuf = ((Object)0);
					outlen = 0;
			} 
		} 
		return error;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2014 - 2019, Steve Holme, <steve_holme@hotmail.com>.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include files should be: */
	/*
	 * Curl_auth_build_spn()
	 *
	 * This is used to build a SPN string in the following formats:
	 *
	 * service/host@realm (Not currently used)
	 * service/host       (Not used by GSS-API)
	 * service@realm      (Not used by Windows SSPI)
	 *
	 * Parameters:
	 *
	 * service  [in] - The service type such as http, smtp, pop or imap.
	 * host     [in] - The host name.
	 * realm    [in] - The realm.
	 *
	 * Returns a pointer to the newly allocated SPN.
	 */
	public static Byte Curl_auth_build_spn(Object service, Object host, Object realm) {
		byte spn = ((Object)0);
		if (host && /* Generate our SPN */realm) {
			spn = ModernizedCProgram.curl_maprintf("%s/%s@%s", service, host, realm);
		}  else if (host) {
			spn = ModernizedCProgram.curl_maprintf("%s/%s", service, host);
		}  else if (realm) {
			spn = ModernizedCProgram.curl_maprintf("%s@%s", service, realm);
		} 
		return /* Return our newly allocated SPN */spn;/* Note: We could use DsMakeSPN() or DsClientMakeSpnForTargetServer() rather
		     than doing this ourselves but the first is only available in Windows XP
		     and Windows Server 2003 and the latter is only available in Windows 2000
		     but not Windows95/98/ME or Windows NT4.0 unless the Active Directory
		     Client Extensions are installed. As such it is far simpler for us to
		     formulate the SPN instead. */
	}
	/* Generate our UTF8 based SPN */
	/* Allocate our TCHAR based SPN */
	/* Release the UTF8 variant when operating with Unicode */
	/* Return our newly allocated SPN */
	/* USE_WINDOWS_SSPI */
	/*
	 * Curl_auth_user_contains_domain()
	 *
	 * This is used to test if the specified user contains a Windows domain name as
	 * follows:
	 *
	 * Domain\User (Down-level Logon Name)
	 * Domain/User (curl Down-level format - for compatibility with existing code)
	 * User@Domain (User Principal Name)
	 *
	 * Note: The user name may be empty when using a GSS-API library or Windows
	 * SSPI as the user and domain are either obtained from the credentials cache
	 * when using GSS-API or via the currently logged in user's credentials when
	 * using Windows SSPI.
	 *
	 * Parameters:
	 *
	 * user  [in] - The user name.
	 *
	 * Returns TRUE on success; otherwise FALSE.
	 */
	public static  Curl_auth_user_contains_domain(Object user) {
		bool valid = 0;
		if (user && user) {
			byte p = .strpbrk(user, /* Check we have a domain name or UPN present */"\\/@");
			valid = (p != ((Object)0) && p > user && p < user + .strlen(user) - 1 ? 1 : 0/* User and domain are obtained from the GSS-API credentials cache or the
			       currently logged in user from Windows */);
		} 
		return valid;
	}
	public static int Curl_sasl_decode_mech(Object ptr, Object maxlen, Object len) {
		int i;
		byte c;
		for (i = 0; mechtable[i].getName(); i++) {
			if (maxlen >= mechtable[i].getLen() && !.memcmp(ptr, mechtable[i].getName(), mechtable[i].getLen())) {
				if (len) {
					len = mechtable[i].getLen();
				} 
				if (maxlen == mechtable[i].getLen()) {
					return mechtable[i].getBit();
				} 
				c = ptr[mechtable[i].getLen()];
				if (!(ModernizedCProgram.Curl_isupper((int)((byte)c))) && !(ModernizedCProgram.Curl_isdigit((int)((byte)c))) && c != (byte)'-' && c != (byte)'_') {
					return mechtable[i].getBit();
				} 
			} 
		}
		return 0/*
		 * Curl_sasl_parse_url_auth_option()
		 *
		 * Parse the URL login options.
		 */;
	}
	public static void state(SASL sasl, connectdata conn,  newstate) {
		(Object)/* LAST */conn;
		sasl.setState(newstate/*
		 * Curl_sasl_can_authenticate()
		 *
		 * Check if we have enough auth data and capabilities to authenticate.
		 */);
		 generatedProto = conn.getProto();
		Object generatedSmtpc = generatedProto.getSmtpc();
		smtp_conn smtpc = generatedSmtpc;
		smtpc.setState(/* LAST */newstate/***********************************************************************
		 *
		 * smtp_perform_ehlo()
		 *
		 * Sends the EHLO command to not only initialise communication with the ESMTP
		 * server but to also obtain a list of server side supported capabilities.
		 */);
		 generatedProto = conn.getProto();
		Object generatedImapc = generatedProto.getImapc();
		imap_conn imapc = generatedImapc;
		imapc.setState(/* LAST */newstate/***********************************************************************
		 *
		 * imap_perform_capability()
		 *
		 * Sends the CAPABILITY command in order to obtain a list of server side
		 * supported capabilities.
		 */);
		 generatedProto = conn.getProto();
		Object generatedPop3c = generatedProto.getPop3c();
		pop3_conn pop3c = generatedPop3c;
		pop3c.setState(/* LAST */newstate/***********************************************************************
		 *
		 * pop3_perform_capa()
		 *
		 * Sends the CAPA command in order to obtain a list of server side supported
		 * capabilities.
		 */);
	}
	/* for debug purposes */
	public static  Curl_sasl_can_authenticate(SASL sasl, connectdata conn) {
		ConnectBits generatedBits = conn.getBits();
		Object generatedUser_passwd = generatedBits.getUser_passwd();
		if (generatedUser_passwd) {
			return 1;
		} 
		int generatedAuthmechs = sasl.getAuthmechs();
		int generatedPrefmech = sasl.getPrefmech();
		if (generatedAuthmechs & generatedPrefmech & (1 << /* EXTERNAL can authenticate without a user name and/or password */5)) {
			return 1;
		} 
		return 0/*
		 * Curl_sasl_start()
		 *
		 * Calculate the required login details for SASL authentication.
		 */;
	}
	public static Object Curl_sasl_start(SASL sasl, connectdata conn,  force_ir,  progress) {
		 result = CURLE_OK;
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		int enabledmechs;
		byte mech = ((Object)0);
		byte resp = ((Object)0);
		size_t len = 0;
		saslstate state1 = .SASL_STOP;
		saslstate state2 = .SASL_FINAL;
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		hostname generatedHost = generatedHttp_proxy.getHost();
		Byte generatedName = generatedHost.getName();
		byte hostname = .SSL_IS_PROXY() ? generatedName : generatedName;
		long generatedPort = conn.getPort();
		int generatedRemote_port = conn.getRemote_port();
		long port = .SSL_IS_PROXY() ? generatedPort : generatedRemote_port;
		Object generatedSet = data.getSet();
		Object generatedParams = sasl.getParams();
		byte service = generatedSet.getStr()[dupstring.STRING_SERVICE_NAME] ? generatedSet.getStr()[dupstring.STRING_SERVICE_NAME] : generatedParams.getService();
		sasl.setForce_ir(/* Latch for future use */force_ir);
		sasl.setAuthused(/* No mechanism used yet */0);
		int generatedAuthmechs = sasl.getAuthmechs();
		int generatedPrefmech = sasl.getPrefmech();
		enabledmechs = generatedAuthmechs & generatedPrefmech;
		progress = .SASL_IDLE;
		Byte generatedPasswd = conn.getPasswd();
		Byte generatedUser = conn.getUser();
		ConnectBits generatedBits = conn.getBits();
		Object generatedUser_passwd = generatedBits.getUser_passwd();
		ntlmdata generatedNtlm = conn.getNtlm();
		Byte generatedOauth_bearer = conn.getOauth_bearer();
		Byte generatedSasl_authzid = conn.getSasl_authzid();
		if ((enabledmechs & (1 << 5)) && !generatedPasswd[/* Calculate the supported authentication mechanism, by decreasing order of
		     security, as well as the initial response where appropriate */0]) {
			mech = "EXTERNAL";
			state1 = .SASL_EXTERNAL;
			sasl.setAuthused((1 << 5));
			if (force_ir || generatedSet.getSasl_ir()) {
				result = data.Curl_auth_create_external_message(generatedUser, resp, len);
			} 
		}  else if (generatedUser_passwd) {
			if ((enabledmechs & (1 << 3)) && ModernizedCProgram.Curl_auth_is_digest_supported()) {
				mech = "DIGEST-MD5";
				state1 = .SASL_DIGESTMD5;
				sasl.setAuthused((1 << 3));
			}  else if (enabledmechs & (1 << 2)) {
				mech = "CRAM-MD5";
				state1 = .SASL_CRAMMD5;
				sasl.setAuthused((1 << 2));
			}  else if ((enabledmechs & (1 << 6)) && ModernizedCProgram.Curl_auth_is_ntlm_supported()) {
				mech = "NTLM";
				state1 = .SASL_NTLM;
				state2 = .SASL_NTLM_TYPE2MSG;
				sasl.setAuthused((1 << 6));
				if (force_ir || generatedSet.getSasl_ir()) {
					result = ModernizedCProgram.Curl_auth_create_ntlm_type1_message(data, generatedUser, generatedPasswd, service, hostname, generatedNtlm, resp, len);
				} 
			}  else if ((enabledmechs & (1 << 8)) && generatedOauth_bearer) {
				mech = "OAUTHBEARER";
				state1 = .SASL_OAUTH2;
				state2 = .SASL_OAUTH2_RESP;
				sasl.setAuthused((1 << 8));
				if (force_ir || generatedSet.getSasl_ir()) {
					result = data.Curl_auth_create_oauth_bearer_message(generatedUser, hostname, port, generatedOauth_bearer, resp, len);
				} 
			}  else if ((enabledmechs & (1 << 7)) && generatedOauth_bearer) {
				mech = "XOAUTH2";
				state1 = .SASL_OAUTH2;
				sasl.setAuthused((1 << 7));
				if (force_ir || generatedSet.getSasl_ir()) {
					result = data.Curl_auth_create_xoauth_bearer_message(generatedUser, generatedOauth_bearer, resp, len);
				} 
			}  else if (enabledmechs & (1 << 1)) {
				mech = "PLAIN";
				state1 = .SASL_PLAIN;
				sasl.setAuthused((1 << 1));
				if (force_ir || generatedSet.getSasl_ir()) {
					result = data.Curl_auth_create_plain_message(generatedSasl_authzid, generatedUser, generatedPasswd, resp, len);
				} 
			}  else if (enabledmechs & (1 << 0)) {
				mech = "LOGIN";
				state1 = .SASL_LOGIN;
				state2 = .SASL_LOGIN_PASSWD;
				sasl.setAuthused((1 << 0));
				if (force_ir || generatedSet.getSasl_ir()) {
					result = data.Curl_auth_create_login_message(generatedUser, resp, len);
				} 
			} 
		} 
		if (!result && mech) {
			if (resp && generatedParams.getMaxirlen() && .strlen(mech) + len > generatedParams.getMaxirlen()) {
				.Curl_cfree(resp);
				resp = ((Object)0);
			} 
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, mech, resp);
			if (!result) {
				progress = .SASL_INPROGRESS;
				ModernizedCProgram.state(sasl, conn, resp ? state2 : state1);
			} 
		} 
		.Curl_cfree(resp);
		return result/*
		 * Curl_sasl_continue()
		 *
		 * Continue the authentication.
		 */;
	}
	public static Object Curl_sasl_continue(SASL sasl, connectdata conn, int code,  progress) {
		 result = CURLE_OK;
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		saslstate newstate = .SASL_FINAL;
		byte resp = ((Object)0);
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		hostname generatedHost = generatedHttp_proxy.getHost();
		Byte generatedName = generatedHost.getName();
		byte hostname = .SSL_IS_PROXY() ? generatedName : generatedName;
		long generatedPort = conn.getPort();
		int generatedRemote_port = conn.getRemote_port();
		long port = .SSL_IS_PROXY() ? generatedPort : generatedRemote_port;
		byte chlg = ((Object)0);
		size_t chlglen = 0;
		Object generatedSet = data.getSet();
		Object generatedParams = sasl.getParams();
		byte service = generatedSet.getStr()[dupstring.STRING_SERVICE_NAME] ? generatedSet.getStr()[dupstring.STRING_SERVICE_NAME] : generatedParams.getService();
		byte serverdata;
		size_t len = 0;
		progress = .SASL_INPROGRESS;
		 generatedState = sasl.getState();
		if (generatedState == .SASL_FINAL) {
			if (code != generatedParams.getFinalcode()) {
				result = CURLE_LOGIN_DENIED;
			} 
			progress = .SASL_DONE;
			ModernizedCProgram.state(sasl, conn, .SASL_STOP);
			return result;
		} 
		if (generatedState != .SASL_CANCEL && generatedState != .SASL_OAUTH2_RESP && code != generatedParams.getContcode()) {
			progress = .SASL_DONE;
			ModernizedCProgram.state(sasl, conn, .SASL_STOP);
			return CURLE_LOGIN_DENIED;
		} 
		Byte generatedSasl_authzid = conn.getSasl_authzid();
		Byte generatedUser = conn.getUser();
		Byte generatedPasswd = conn.getPasswd();
		ntlmdata generatedNtlm = conn.getNtlm();
		int generatedAuthused = sasl.getAuthused();
		Byte generatedOauth_bearer = conn.getOauth_bearer();
		int generatedAuthmechs = sasl.getAuthmechs();
		Object generatedForce_ir = sasl.getForce_ir();
		switch (generatedState) {
		case .SASL_OAUTH2_RESP:
				if (code == generatedParams.getFinalcode()) {
					progress = /* Final response was received so we are done */.SASL_DONE;
					ModernizedCProgram.state(sasl, conn, .SASL_STOP);
					return result;
				}  else if (code == generatedParams.getContcode()) {
					resp = .Curl_cstrdup("AQ==");
					if (!resp) {
						result = CURLE_OUT_OF_MEMORY;
					} 
					break;
				} else {
						progress = .SASL_DONE;
						ModernizedCProgram.state(sasl, conn, .SASL_STOP);
						return CURLE_LOGIN_DENIED;
				} 
		case .SASL_DIGESTMD5:
				.UNRECOGNIZEDFUNCTIONNAME(generatedState.getBuffer(), serverdata);
				result = data.Curl_auth_create_digest_md5_message(serverdata, generatedUser, generatedPasswd, service, resp, len);
				newstate = .SASL_DIGESTMD5_RESP;
				break;
		case .SASL_DIGESTMD5_RESP:
				resp = .Curl_cstrdup("");
				if (!resp) {
					result = CURLE_OUT_OF_MEMORY;
				} 
				break;
		case .SASL_NTLM_TYPE2MSG:
				.UNRECOGNIZEDFUNCTIONNAME(generatedState.getBuffer(), /* Decode the type-2 message */serverdata);
				result = ModernizedCProgram.Curl_auth_decode_ntlm_type2_message(data, serverdata, generatedNtlm);
				if (!result) {
					result = ModernizedCProgram.Curl_auth_create_ntlm_type3_message(data, generatedUser, generatedPasswd, generatedNtlm, resp, len);
				} 
				break;
		case .SASL_LOGIN_PASSWD:
				result = data.Curl_auth_create_login_message(generatedPasswd, resp, len);
				break;
		case .SASL_STOP:
				progress = .SASL_DONE;
				return result;
		case .SASL_NTLM:
				result = ModernizedCProgram.Curl_auth_create_ntlm_type1_message(/* Create the type-1 message */data, generatedUser, generatedPasswd, service, hostname, generatedNtlm, resp, len);
				newstate = .SASL_NTLM_TYPE2MSG;
				break;
		case .SASL_EXTERNAL:
				result = data.Curl_auth_create_external_message(generatedUser, resp, len);
				break;
		case .SASL_LOGIN:
				result = data.Curl_auth_create_login_message(generatedUser, resp, len);
				newstate = .SASL_LOGIN_PASSWD;
				break;
		case .SASL_CANCEL:
				generatedAuthmechs ^=  generatedAuthused;
				result = ModernizedCProgram.Curl_sasl_start(sasl, conn, generatedForce_ir, /* Start an alternative SASL authentication */progress);
				newstate = generatedState;
				break;
		case /* Decode the security challenge and create the response message */.SASL_OAUTH2:
				if (generatedAuthused == (1 << /* Create the authorisation message */8)) {
					result = data.Curl_auth_create_oauth_bearer_message(generatedUser, hostname, port, generatedOauth_bearer, resp, len);
					newstate = /* Failures maybe sent by the server as continuations for OAUTHBEARER */.SASL_OAUTH2_RESP;
				} else {
						result = data.Curl_auth_create_xoauth_bearer_message(generatedUser, generatedOauth_bearer, resp, len);
				} 
				break;
		case .SASL_PLAIN:
				result = data.Curl_auth_create_plain_message(generatedSasl_authzid, generatedUser, generatedPasswd, resp, len);
				break;
		case .SASL_CRAMMD5:
				.UNRECOGNIZEDFUNCTIONNAME(generatedState.getBuffer(), serverdata);
				result = ModernizedCProgram.Curl_auth_decode_cram_md5_message(serverdata, chlg, chlglen);
				if (!result) {
					result = data.Curl_auth_create_cram_md5_message(chlg, generatedUser, generatedPasswd, resp, len);
				} 
				.Curl_cfree(chlg);
				break;
		default:
				data.Curl_failf("Unsupported SASL authentication mechanism");
				result = /* Should not happen */CURLE_UNSUPPORTED_PROTOCOL;
				break;
		}
		switch (result) {
		case CURLE_BAD_CONTENT_ENCODING:
				result = .UNRECOGNIZEDFUNCTIONNAME(conn, /* Cancel dialog */"*");
				newstate = .SASL_CANCEL;
				break;
		case CURLE_OK:
				if (resp) {
					result = .UNRECOGNIZEDFUNCTIONNAME(conn, resp);
				} 
				break;
		default:
				newstate = /* Stop on error */.SASL_STOP;
				progress = .SASL_DONE;
				break;
		}
		.Curl_cfree(resp);
		ModernizedCProgram.state(sasl, conn, newstate);
		return result/* protocols are enabled that use SASL */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Check for bugs #1303 and #1327: libcurl should never remove DNS entries
	 * created via CURLOPT_RESOLVE, neither after DNS_CACHE_TIMEOUT elapses
	 * (test1515) nor a dead connection is detected (test1616).
	 */
	public static int debug_callback(Object curl, Object info, Byte msg, Object len, Object ptr) {
		(Object)curl;
		(Object)ptr;
		if (info == CURLINFO_TEXT) {
			(_iob[2]).curl_mfprintf("debug: %.*s", (int)len, msg);
		} 
		return 0;
	}
	public static int do_one_request(Object m, Byte URL, Byte resolve) {
		 curls = new ();
		curl_slist resolve_list = ((Object)0);
		int still_running;
		int res = 0;
		 msg = new ();
		int msgs_left;
		resolve_list = resolve_list.curl_slist_append(resolve);
		Curl_easy curl_easy = new Curl_easy();
		do {
			do {
				if (((((curls))) = curl_easy.curl_easy_init()) == ((Object)0)) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))));
					res = 124;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_URL))), (((URL))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_RESOLVE))), (((resolve_list))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_DEBUGFUNCTION))), (((debug_callback))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_VERBOSE))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((curls))).curl_easy_setopt((((CURLOPT_DNS_CACHE_TIMEOUT))), (((true))))) != CURLE_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = ModernizedCProgram.curl_multi_add_handle((((m))), (((curls))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		do {
			do {
				 ec = new ();
				if ((ec = (((m))).curl_multi_perform((((still_running))))) != CURLM_OK) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
					res = (int)ec;
				}  else if (((((still_running)))) < 0) {
					(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)((((still_running)))));
					res = 122;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		timeval timeval = new timeval();
		do {
			do {
				if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
					(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c")), ((true)));
					res = 125;
				} 
			} while (0);
			if (res) {
				;
			} 
		} while (0);
		while (still_running) {
			timeval timeout = new timeval();
			fd_set fdread = new fd_set();
			fd_set fdwrite = new fd_set();
			fd_set fdexcep = new fd_set();
			int maxfd = -99;
			(((fd_set)(fdread)).setFd_count(0));
			(((fd_set)(fdwrite)).setFd_count(0));
			(((fd_set)(fdexcep)).setFd_count(0));
			ModernizedCProgram.timeout.setTv_sec(1);
			ModernizedCProgram.timeout.setTv_usec(0);
			do {
				do {
					 ec = new ();
					if ((ec = ModernizedCProgram.curl_multi_fdset((((m))), (((fdread))), (((fdwrite))), (((fdexcep))), (((maxfd))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((maxfd)))) < -1) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_fdset() succeeded, but returned invalid max_fd value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)((((maxfd)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					int ec;
					if (ModernizedCProgram.select_wrapper((((maxfd + 1))), (((fdread))), (((fdwrite))), (((fdexcep))), (((ModernizedCProgram.timeout)))) == -1) {
						ec = ((int).WSAGetLastError());
						(_iob[2]).curl_mfprintf("%s:%d select() failed, with errno %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), ec, .strerror(ec));
						res = 121;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					 ec = new ();
					if ((ec = (((m))).curl_multi_perform((((still_running))))) != CURLM_OK) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() failed, with code %d (%s)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
						res = (int)ec;
					}  else if (((((still_running)))) < 0) {
						(_iob[2]).curl_mfprintf("%s:%d curl_multi_perform() succeeded, but returned invalid running_handles value (%d)\n", ((("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c"))), (((true))), (int)((((still_running)))));
						res = 122;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
			do {
				do {
					if (timeval.tutil_tvnow().tutil_tvdiff(ModernizedCProgram.tv_test_start) > 60 * 1000) {
						(_iob[2]).curl_mfprintf("%s:%d ABORTING TEST, since it seems that it would have run forever.\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1515.c")), ((true)));
						res = 125;
					} 
				} while (0);
				if (res) {
					;
				} 
			} while (0);
		}
		do {
			msg = m.curl_multi_info_read(msgs_left);
			if (msg && msg.getMsg() == CURLMSG_DONE && msg.getEasy_handle() == curls) {
				res = msg.getData().getResult();
				break;
			} 
		} while (msg);
		curls.curl_easy_cleanup();
		resolve_list.curl_slist_free_all();
		return res;
	}
	public static Object write_callback(Object contents, Object size, Object nmemb, Object userp) {
		size_t realsize = size * nmemb;
		(Object)contents;
		(Object)userp;
		return realsize;
		int amount = ModernizedCProgram.curlx_uztosi(size * nmemb);
		ModernizedCProgram.curl_mprintf("%.*s", amount, (byte)ptr);
		(Object)stream;
		return size * nmemb;
		byte newbuff;
		size_t rembuff = new size_t();
		URL_FILE url = (URL_FILE)userp;
		size *= nitems;
		Object generatedBuffer_len = url.getBuffer_len();
		Object generatedBuffer_pos = url.getBuffer_pos();
		rembuff = generatedBuffer_len - generatedBuffer_pos;
		Byte generatedBuffer = url.getBuffer();
		if (size > rembuff) {
			newbuff = .realloc(generatedBuffer, generatedBuffer_len + (size - /* not enough space in buffer */rembuff));
			if (newbuff == ((Object)0)) {
				.fprintf((_iob[2]), "callback buffer grow failed\n");
				size = rembuff;
			} else {
					generatedBuffer_len += size - /* realloc succeeded increase buffer size*/rembuff;
					url.setBuffer(newbuff);
			} 
		} 
		.memcpy(generatedBuffer[generatedBuffer_pos], ModernizedCProgram.buffer, size);
		generatedBuffer_pos += size;
		return size;
		transfer_status st = (transfer_status)userp;
		size_t len = size * nmemb;
		int generatedCounter = st.getCounter();
		generatedCounter++;
		if (generatedCounter > 1/* the first call puts us on pause, so subsequent calls are after
		       unpause */) {
			.fwrite(ptr, size, nmemb, (_iob[1]));
			return len;
		} 
		ModernizedCProgram.curl_mprintf("Got %d bytes but pausing!\n", (int)len);
		st.setHalted(1);
		return CURL_WRITEFUNC_PAUSE;
		size_t realsize = size * nmemb;
		size_t p = new size_t();
		for (p = 0; p < realsize; p++) {
			.html_parser_char_parse(hsp, ((byte)ModernizedCProgram.buffer)[p]);
			if (.html_parser_cmp_tag(hsp, "a", 1)) {
				if (.html_parser_cmp_attr(hsp, "href", 4)) {
					if (.html_parser_is_in(hsp, HTML_VALUE_ENDED)) {
						.html_parser_val(hsp)[.html_parser_val_length(hsp)] = (byte)'\0';
						.printf("%s\n", .html_parser_val(hsp));
					} 
				} 
			} 
		}
		return realsize;
		cb_data data = (cb_data)userdata;
		size_t totalsize = nmemb * size;
		(Object)/* unused parameter */ptr;
		data.setResponse_received(/* all response headers have been received */1);
		int generatedPaused = data.getPaused();
		Object generatedEasy_handle = data.getEasy_handle();
		if (generatedPaused) {
			data.setPaused(/* continue to send request body data */0);
			generatedEasy_handle.curl_easy_pause(CURLPAUSE_CONT);
		} 
		return totalsize;
	}
	public static int parse_url_file(Object filename) {
		FILE f = new FILE();
		int filetime;
		byte[] buf = new byte[200];
		ModernizedCProgram.num_handles = 0;
		ModernizedCProgram.blacklist_num_sites = 0;
		ModernizedCProgram.blacklist_num_servers = 0;
		f = .fopen(filename, "rb");
		if (!f) {
			return 0;
		} 
		Object generated_flag = (f).get_flag();
		while (!(generated_flag & -1024)) {
			if (.fscanf(f, "%d %199s\n", filetime, buf)) {
				ModernizedCProgram.urltime[ModernizedCProgram.num_handles] = filetime;
				ModernizedCProgram.urlstring[ModernizedCProgram.num_handles] = .strdup(buf);
				ModernizedCProgram.num_handles++;
				continue;
			} 
			if (.fscanf(f, "blacklist_site %199s\n", buf)) {
				ModernizedCProgram.site_blacklist[ModernizedCProgram.blacklist_num_sites] = .strdup(buf);
				ModernizedCProgram.blacklist_num_sites++;
				continue;
			} 
			break;
		}
		.fclose(f);
		ModernizedCProgram.site_blacklist[ModernizedCProgram.blacklist_num_sites] = ((Object)0);
		ModernizedCProgram.server_blacklist[ModernizedCProgram.blacklist_num_servers] = ((Object)0);
		return ModernizedCProgram.num_handles;
	}
	public static void free_urls() {
		int i;
		for (i = 0; i < ModernizedCProgram.num_handles; i++) {
			do {
				.free((ModernizedCProgram.urlstring[i]));
				(ModernizedCProgram.urlstring[i]) = ((Object)0);
			} while (0);
		}
		for (i = 0; i < ModernizedCProgram.blacklist_num_servers; i++) {
			do {
				.free((ModernizedCProgram.server_blacklist[i]));
				(ModernizedCProgram.server_blacklist[i]) = ((Object)0);
			} while (0);
		}
		for (i = 0; i < ModernizedCProgram.blacklist_num_sites; i++) {
			do {
				.free((ModernizedCProgram.site_blacklist[i]));
				(ModernizedCProgram.site_blacklist[i]) = ((Object)0);
			} while (0);
		}
	}
	public static int create_handles() {
		int i;
		Curl_easy curl_easy = new Curl_easy();
		for (i = 0; i < ModernizedCProgram.num_handles; i++) {
			ModernizedCProgram.handles[i] = curl_easy.curl_easy_init();
		}
		return 0;
	}
	public static void setup_handle(Byte base_url, Object m, int handlenum) {
		byte[] urlbuf = new byte[256];
		ModernizedCProgram.curl_msnprintf(urlbuf, , "%s%s", base_url, ModernizedCProgram.urlstring[handlenum]);
		ModernizedCProgram.handles[handlenum].curl_easy_setopt(CURLOPT_URL, urlbuf);
		ModernizedCProgram.handles[handlenum].curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		ModernizedCProgram.handles[handlenum].curl_easy_setopt(CURLOPT_FAILONERROR, -1024);
		ModernizedCProgram.handles[handlenum].curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_callback);
		ModernizedCProgram.handles[handlenum].curl_easy_setopt(CURLOPT_WRITEDATA, ((Object)0));
		ModernizedCProgram.curl_multi_add_handle(m, ModernizedCProgram.handles[handlenum]);
	}
	public static void remove_handles() {
		int i;
		for (i = 0; i < ModernizedCProgram.num_handles; i++) {
			if (ModernizedCProgram.handles[i]) {
				ModernizedCProgram.handles[i].curl_easy_cleanup();
			} 
		}
	}
	public static int curlSocketCallback(Object easy, Object s, int action, Object userp, Object socketp) {
		ReadWriteSockets sockets = userp;
		(Object)/* unused */easy;
		(Object)/* unused */socketp;
		Sockets generatedRead = sockets.getRead();
		if (action == CURL_POLL_IN || action == CURL_POLL_INOUT) {
			generatedRead.addFd(s, "read");
		} 
		Sockets generatedWrite = sockets.getWrite();
		if (action == CURL_POLL_OUT || action == CURL_POLL_INOUT) {
			generatedWrite.addFd(s, "write");
		} 
		if (action == CURL_POLL_REMOVE) {
			generatedRead.removeFd(s, 1);
			generatedWrite.removeFd(s, 0);
		} 
		return 0/**
		 * Callback invoked by curl to set a timeout.
		 */;
	}
	public static int curlTimerCallback(Object multi, long timeout_ms, Object userp) {
		timeval timeout = userp;
		(Object)/* unused */multi;
		timeval timeval = new timeval();
		long generatedTv_usec = timeout.getTv_usec();
		if (timeout_ms != -1) {
			timeout = timeval.tutil_tvnow();
			generatedTv_usec += timeout_ms * 1000;
		} else {
				timeout.setTv_sec(-1);
		} 
		return 0/**
		 * Check for curl completion.
		 */;
	}
	public static int checkForCompletion(Object curl, int success) {
		int numMessages;
		 message = new ();
		int result = 0;
		success = 0;
		while ((message = curl.curl_multi_info_read(numMessages)) != ((Object)0)) {
			if (message.getMsg() == CURLMSG_DONE) {
				result = 1;
				if (message.getData().getResult() == CURLE_OK) {
					success = 1;
				} else {
						success = 0;
				} 
			} else {
					(_iob[2]).curl_mfprintf("Got an unexpected message from curl: %i\n", (int)message.getMsg());
					result = 1;
					success = 0;
			} 
		}
		return result;
	}
	public static void updateFdSet(Sockets sockets, fd_set fdset, Object maxFd) {
		int i;
		int generatedCount = sockets.getCount();
		Object generatedSockets = sockets.getSockets();
		for (i = 0; i < generatedCount; ++i) {
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fdset)).getFd_count(); __i++) {
					if (((fd_set)(fdset)).getFd_array()[__i] == (generatedSockets[i])) {
						break;
					} 
				}
				if (__i == ((fd_set)(fdset)).getFd_count()) {
					if (((fd_set)(fdset)).getFd_count() < 64) {
						((fd_set)(fdset)).getFd_array()[__i] = (generatedSockets[i]);
						((fd_set)(fdset)).getFd_count()++;
					} 
				} 
			} while (0);
			if (maxFd < generatedSockets[i] + 1) {
				maxFd = generatedSockets[i] + 1;
			} 
		}
	}
	public static void notifyCurl(Object curl, Object s, int evBitmask, Object info) {
		int numhandles = 0;
		 result = curl.curl_multi_socket_action(s, evBitmask, numhandles);
		if (result != CURLM_OK) {
			(_iob[2]).curl_mfprintf("Curl error on %s: %i (%s)\n", info, result, ModernizedCProgram.curl_multi_strerror(result));
		} 
	}
	/**
	 * Invoke curl when a file descriptor is set.
	 */
	public static void checkFdSet(Object curl, Sockets sockets, fd_set fdset, int evBitmask, Object name) {
		int i;
		int generatedCount = sockets.getCount();
		Object generatedSockets = sockets.getSockets();
		for (i = 0; i < generatedCount; ++i) {
			if (.__WSAFDIsSet((SOCKET)(generatedSockets[i]), (fd_set)(fdset))) {
				ModernizedCProgram.notifyCurl(curl, generatedSockets[i], evBitmask, name);
			} 
		}
	}
	public static Object payload_source(Object ptr, Object size, Object nmemb, Object userp) {
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
	}
	public static void free_callback(Object userp) {
		WriteThis pooh = (WriteThis)userp;
		int generatedFreecount = pooh.getFreecount();
		generatedFreecount++;
	}
	public static Object read_callback(byte ptr, Object size, Object nmemb, Object userp) {
		WriteThis pooh = (WriteThis)userp;
		byte generatedReadptr = pooh.getReadptr();
		int eof = !generatedReadptr;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		eof = generatedSizeleft <= 0;
		if (!eof) {
			generatedSizeleft--;
		} 
		if (!eof) {
			ptr = generatedReadptr;
			generatedReadptr++;
			return /* we return 1 byte at a time! */1;
		} 
		return /* no more data left to deliver */0;
		WriteThis pooh = (WriteThis)userp;
		byte data;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedCounter = pooh.getCounter();
		data = ModernizedCProgram.post[generatedCounter];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedCounter++;
			return len;
		} 
		return /* no more data left to deliver */0;
		size_t amount = nmemb * /* Total bytes curl wants */size;
		if (ModernizedCProgram.consumed == .strlen(ModernizedCProgram.data)) {
			return 0;
		} 
		if (amount > .strlen(ModernizedCProgram.data) - ModernizedCProgram.consumed) {
			amount = .strlen(ModernizedCProgram.data);
		} 
		ModernizedCProgram.consumed += amount;
		(Object)stream;
		.memcpy(ptr, ModernizedCProgram.data, amount);
		return amount;
		(Object)ptr;
		(Object)size;
		(Object)nmemb;
		(Object)userp;
		return CURL_READFUNC_ABORT;
		WriteThis upload = (WriteThis)userp;
		size_t max = size * nmemb;
		if (max < 1) {
			return 0;
		} 
		Object generatedSizeleft = upload.getSizeleft();
		byte generatedReadptr = upload.getReadptr();
		if (generatedSizeleft) {
			size_t copylen = max;
			if (copylen > generatedSizeleft) {
				copylen = generatedSizeleft;
			} 
			.memcpy(ptr, generatedReadptr, copylen);
			generatedReadptr += copylen;
			generatedSizeleft -= copylen;
			return copylen;
		} 
		return /* no more data left to deliver */0;
		WriteThis pooh = (WriteThis)userp;
		size_t tocopy = size * nmemb;
		ModernizedCProgram.wait_ms(/* Wait one second before return POST data          *
		   * so libcurl will wait before sending request body */1000);
		Object generatedSizeleft = pooh.getSizeleft();
		if (tocopy < 1 || !generatedSizeleft) {
			return 0;
		} 
		if (generatedSizeleft < tocopy) {
			tocopy = generatedSizeleft;
		} 
		byte generatedReadptr = pooh.getReadptr();
		.memcpy(ptr, generatedReadptr, /* copy requested data */tocopy);
		generatedReadptr += /* advance pointer */tocopy;
		generatedSizeleft -= /* less data left */tocopy;
		return tocopy;
		WriteThis wt = (WriteThis)userp;
		size_t buffer_size = size * nmemb;
		Object generatedSizeleft = wt.getSizeleft();
		byte generatedReadptr = wt.getReadptr();
		if (generatedSizeleft) {
			size_t copy_this_much = generatedSizeleft;
			if (copy_this_much > buffer_size) {
				copy_this_much = buffer_size;
			} 
			.memcpy(dest, generatedReadptr, copy_this_much);
			generatedReadptr += copy_this_much;
			generatedSizeleft -= copy_this_much;
			return /* we copied this many bytes */copy_this_much;
		} 
		return /* no more data left to deliver */0;
		WriteThis pooh = (WriteThis)userp;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		byte generatedReadptr = pooh.getReadptr();
		if (generatedSizeleft) {
			(byte)ptr = generatedReadptr[/* copy one single byte */0];
			generatedReadptr++;
			generatedSizeleft--;
			return /* we return 1 byte at a time! */1;
		} 
		return /* no more data left to deliver */0;
		WriteThis pooh = (WriteThis)userp;
		byte data;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedCounter = pooh.getCounter();
		data = ModernizedCProgram.post[generatedCounter];
		if (data) {
			size_t len = .strlen(data);
			if (size * nmemb < len) {
				(_iob[2]).curl_mfprintf("read buffer is too small to run test\n");
				return 0;
			} 
			.memcpy(ptr, data, len);
			generatedCounter++;
			return len;
		} 
		return /* no more data left to deliver */0;
		size_t amount = nmemb * /* Total bytes curl wants */size;
		if (amount < .strlen(ModernizedCProgram.data)) {
			return .strlen(ModernizedCProgram.data);
		} 
		(Object)stream;
		.memcpy(ptr, ModernizedCProgram.data, .strlen(ModernizedCProgram.data));
		return .strlen(ModernizedCProgram.data);
		size_t amount = nmemb * /* Total bytes curl wants */size;
		size_t available =  - /* What we have to
		                                                           give */ModernizedCProgram.current_offset;
		size_t given = amount < available ? amount : /* What is given */available;
		(Object)stream;
		.memcpy(ptr, ModernizedCProgram.databuf + ModernizedCProgram.current_offset, given);
		ModernizedCProgram.current_offset += given;
		return given;
		WriteThis pooh = (WriteThis)userp;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		byte generatedReadptr = pooh.getReadptr();
		if (generatedSizeleft) {
			(byte)ptr = generatedReadptr[/* copy one single byte */0];
			generatedReadptr++;
			generatedSizeleft--;
			return /* we return 1 byte at a time! */1;
		} 
		return /* no more data left to deliver */0;
		size_t amount = nmemb * /* Total bytes curl wants */size;
		if (amount < .strlen(ModernizedCProgram.data)) {
			return .strlen(ModernizedCProgram.data);
		} 
		(Object)stream;
		.memcpy(ptr, ModernizedCProgram.data, .strlen(ModernizedCProgram.data));
		return .strlen(ModernizedCProgram.data);
		 nread = new ();
		/* in real-world cases, this would probably get this data differently
		     as this fread() stuff is exactly what the library already would do
		     by default internally */
		size_t retcode = .fread(ptr, size, nmemb, stream);
		nread = ()retcode;
		return retcode;
		WriteThis pooh = (WriteThis)userp;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		byte generatedReadptr = pooh.getReadptr();
		if (generatedSizeleft) {
			(byte)ptr = generatedReadptr[/* copy one single byte */0];
			generatedReadptr++;
			generatedSizeleft--;
			return /* we return 1 byte at a time! */1;
		} 
		return /* no more data left to deliver */0;
		WriteThis pooh = (WriteThis)userp;
		byte generatedReadptr = pooh.getReadptr();
		int eof = !generatedReadptr;
		if (size * nmemb < 1) {
			return 0;
		} 
		Object generatedSizeleft = pooh.getSizeleft();
		eof = generatedSizeleft <= 0;
		if (!eof) {
			generatedSizeleft--;
		} 
		if (!eof) {
			ptr = generatedReadptr;
			generatedReadptr++;
			return /* we return 1 byte at a time! */1;
		} 
		return /* no more data left to deliver */0;
		input i = userp;
		_iobuf generatedIn = i.getIn();
		size_t retcode = .fread(ptr, size, nmemb, generatedIn);
		Object generatedBytes_read = i.getBytes_read();
		generatedBytes_read += retcode;
		return retcode;
		cb_data data = (cb_data)userdata;
		int generatedResponse_received = data.getResponse_received();
		Object generatedRemaining_bytes = data.getRemaining_bytes();
		if (generatedResponse_received) {
			size_t totalsize = nitems * size;
			size_t bytes_to_send = generatedRemaining_bytes;
			if (bytes_to_send > totalsize) {
				bytes_to_send = totalsize;
			} 
			.memset(ptr, (byte)'a', bytes_to_send);
			generatedRemaining_bytes -= bytes_to_send;
			return bytes_to_send;
		} else {
				data.setPaused(1);
				return CURL_READFUNC_PAUSE;
		} 
		(Object)ptr;
		(Object)size;
		(Object)nmemb;
		(Object)userp;
		return CURL_READFUNC_ABORT;
		upload_status upload_ctx = (upload_status)userp;
		byte data;
		if ((size == 0) || (nmemb == 0) || ((size * nmemb) < 1)) {
			return 0;
		} 
		int generatedLines_read = upload_ctx.getLines_read();
		data = ModernizedCProgram.payload_text[generatedLines_read];
		if (data) {
			size_t len = .strlen(data);
			.memcpy(ptr, data, len);
			generatedLines_read++;
			return len;
		} 
		return 0;
		size_t amount = nmemb * /* Total bytes curl wants */size;
		if (amount < .strlen(ModernizedCProgram.data)) {
			return .strlen(ModernizedCProgram.data);
		} 
		(Object)stream;
		.memcpy(ptr, ModernizedCProgram.data, .strlen(ModernizedCProgram.data));
		return .strlen(ModernizedCProgram.data);
		ssize_t retcode = new ssize_t();
		 nread = new ();
		int fdp = (int)stream;
		int fd = fdp;
		retcode = .read(fd, ptr, (int)(size * nmemb));
		nread = ()retcode;
		return retcode;
		size_t retcode = new size_t();
		 nread = new ();
		/* in real-world cases, this would probably get this data differently
		     as this fread() stuff is exactly what the library already would do
		     by default internally */
		retcode = .fread(ptr, size, nmemb, stream);
		nread = ()retcode;
		return retcode;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * multi interface and debug callback
	 * </DESC>
	 */
	/* somewhat unix-specific */
	/* curl stuff */
	public static void dump(Object text, Byte ptr, Object size, Object nohex) {
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		.fprintf(stream, "%s, %10.10lu bytes (0x%8.8lx)\n", text, (long)size, (long)size);
		for (i = 0; i < size; i += width) {
			.fprintf(stream, "%4.4lx: ", (long)i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						.fprintf(stream, "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				.fprintf(stream, "%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		.fprintf((_iob[2]), "%d %s, %lu bytes (0x%lx)\n", num, text, (long)size, (long)size);
		for (i = 0; i < size; i += width) {
			.fprintf((_iob[2]), "%4.4lx: ", (long)i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						.fprintf((_iob[2]), "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", (_iob[2]));
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				.fprintf((_iob[2]), "%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', (_iob[/* newline */2]));
		}
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		.fprintf(stream, "%s, %10.10lu bytes (0x%8.8lx)\n", text, (long)size, (long)size);
		for (i = 0; i < size; i += width) {
			.fprintf(stream, "%4.4lx: ", (long)i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						.fprintf(stream, "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				.fprintf(stream, "%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (tracetype == .TRACE_ASCII) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		stream.curl_mfprintf("%s%s, %zu bytes (0x%zx)\n", timebuf, text, size, size);
		for (i = 0; i < size; i += width) {
			stream.curl_mfprintf("%04zx: ", i);
			if (tracetype == .TRACE_BIN) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						stream.curl_mfprintf("%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if ((tracetype == /* check for 0D0A; if found, skip past and start a new line of output */.TRACE_ASCII) && (i + c + 1 < size) && (ptr[i + c] == -1024) && (ptr[i + c + 1] == -1024)) {
					i += (c + 2 - width);
					break;
				} 
				(Object)/* convert to host encoding and print this character */infotype;
				stream.curl_mfprintf("%c", ((ptr[i + c] >= -1024) && (ptr[i + c] < -1024)) ? ptr[i + c] : (byte)'.'/* CURL_DOES_CONVERSIONS */);
				if ((tracetype == /* check again for 0D0A, to avoid an extra \n if it's at width */.TRACE_ASCII) && (i + c + 2 < size) && (ptr[i + c + 1] == -1024) && (ptr[i + c + 2] == -1024)) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		.fprintf((_iob[2]), "%s, %lu bytes (0x%lx)\n", text, (long)size, (long)size);
		for (i = 0; i < size; i += width) {
			.fprintf((_iob[2]), "%4.4lx: ", (long)i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						.fprintf((_iob[2]), "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", (_iob[2]));
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				.fprintf((_iob[2]), "%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', (_iob[/* newline */2]));
		}
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		stream.curl_mfprintf("%s, %zu bytes (0x%zx)\n", text, size, size);
		for (i = 0; i < size; i += width) {
			stream.curl_mfprintf("%04zx: ", i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						stream.curl_mfprintf("%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				stream.curl_mfprintf("%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		.fprintf((_iob[2]), "%d %s, %lu bytes (0x%lx)\n", num, text, (long)size, (long)size);
		for (i = 0; i < size; i += width) {
			.fprintf((_iob[2]), "%4.4lx: ", (long)i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						.fprintf((_iob[2]), "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", (_iob[2]));
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (nohex && (i + c + 1 < size) && ptr[i + c] == /* check for 0D0A; if found, skip past and start a new line of output */-1024 && ptr[i + c + 1] == -1024) {
					i += (c + 2 - width);
					break;
				} 
				.fprintf((_iob[2]), "%c", (ptr[i + c] >= -1024) && (ptr[i + c] < -1024) ? ptr[i + c] : (byte)'.');
				if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == /* check again for 0D0A, to avoid an extra \n if it's at width */-1024 && ptr[i + c + 2] == -1024) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', (_iob[/* newline */2]));
		}
	}
	public static int my_trace(Object handle, Object type, Byte data, Object size, Object userp) {
		byte text;
		(Object)userp;
		(Object)/* prevent compiler warning */handle;
		switch (type) {
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_TEXT:
				.fprintf((_iob[2]), "== Info: %s", data/* FALLTHROUGH */);
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		(_iob[2]).dump(text, data, size, 1);
		return 0/*
		 * Simply download a HTTP file.
		 */;
		byte text;
		transfer t = (transfer)userp;
		int generatedNum = t.getNum();
		int num = generatedNum;
		(Object)/* prevent compiler warning */handle;
		switch (type) {
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_TEXT:
				.fprintf((_iob[2]), "== %u Info: %s", num, data/* FALLTHROUGH */);
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		num.dump(text, (byte)data, size, 1);
		return 0;
		data config = (data)userp;
		byte text;
		(Object)/* prevent compiler warning */handle;
		switch (type) {
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_TEXT:
				.fprintf((_iob[2]), "== Info: %s", data/* FALLTHROUGH */);
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		default:
				return 0;
		}
		byte generatedTrace_ascii = config.getTrace_ascii();
		(_iob[2]).dump(text, (byte)data, size, generatedTrace_ascii);
		return 0;
		byte text;
		(Object)/* prevent compiler warning */handle;
		(Object)userp;
		switch (type) {
		case CURLINFO_TEXT:
				.fprintf((_iob[2]), "== Info: %s", data/* FALLTHROUGH */);
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		(byte)data.dump(text, size, 1);
		return 0;
		data config = (data)userp;
		byte text;
		(Object)/* prevent compiler warning */handle;
		switch (type) {
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_TEXT:
				(_iob[2]).curl_mfprintf("== Info: %s", (byte)data/* FALLTHROUGH */);
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		byte generatedTrace_ascii = config.getTrace_ascii();
		(_iob[2]).dump(text, (byte)data, size, generatedTrace_ascii);
		return 0;
		byte[] timebuf = new byte[60];
		byte text;
		input i = (input)userp;
		int generatedNum = i.getNum();
		int num = generatedNum;
		time_t epoch_offset = new time_t();
		int known_offset;
		timeval tv = new timeval();
		time_t secs = new time_t();
		tm now = new tm();
		(Object)/* prevent compiler warning */handle;
		.gettimeofday(tv, ((Object)0));
		long generatedTv_sec = tv.getTv_sec();
		if (!known_offset) {
			epoch_offset = .time(((Object)0)) - generatedTv_sec;
			known_offset = 1;
		} 
		secs = epoch_offset + generatedTv_sec;
		now = .localtime(/* not thread safe but we don't care */secs);
		Object generatedTm_hour = now.getTm_hour();
		Object generatedTm_min = now.getTm_min();
		Object generatedTm_sec = now.getTm_sec();
		long generatedTv_usec = tv.getTv_usec();
		.snprintf(timebuf, , "%02d:%02d:%02d.%06ld", generatedTm_hour, generatedTm_min, generatedTm_sec, (long)generatedTv_usec);
		switch (type) {
		case CURLINFO_TEXT:
				.fprintf((_iob[2]), "%s [%d] Info: %s", timebuf, num, data/* FALLTHROUGH */);
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		num.dump(text, (byte)data, size, 1);
		return 0;
	}
	/* Curl_win32_init() performs win32 global initialization */
	public static Object Curl_win32_init(long flags) {
		Object generatedWVersion = wsaData.getWVersion();
		if (flags & CURL_GLOBAL_WIN32) {
			WORD wVersionRequested = new WORD();
			WSADATA wsaData = new WSADATA();
			int res;
			wVersionRequested = ((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(true))) << 8)));
			ModernizedCProgram.res = .WSAStartup(wVersionRequested, wsaData);
			if (ModernizedCProgram.res != 0/* Tell the user that we couldn't find a usable */) {
				return /* winsock.dll.     */CURLE_FAILED_INIT/* Confirm that the Windows Sockets DLL supports what we need.*//* Note that if the DLL supports versions greater */;
			} 
			if (((BYTE)(generatedWVersion)) != ((BYTE)(/* than wVersionRequested, it will still return *//* wVersionRequested in wVersion. wHighVersion contains the *//* highest supported version. */wVersionRequested)) || ((BYTE)(((WORD)(generatedWVersion) >> 8) & -1024)) != ((BYTE)(((WORD)(wVersionRequested) >> 8) & -1024/* Tell the user that we couldn't find a usable */))) {
				.WSACleanup();
				return CURLE_FAILED_INIT/* The Windows Sockets DLL is acceptable. Proceed. *//* CURL_GLOBAL_WIN32 */;
			} 
		} 
		ModernizedCProgram.s_hIpHlpApiDll = ModernizedCProgram.Curl_load_library("iphlpapi.dll");
		if (ModernizedCProgram.s_hIpHlpApiDll/* Get the address of the if_nametoindex function */) {
			IF_NAMETOINDEX_FN pIfNameToIndex = (IF_NAMETOINDEX_FN)(Object)((.GetProcAddress(ModernizedCProgram.s_hIpHlpApiDll, "if_nametoindex")));
			if (pIfNameToIndex) {
				ModernizedCProgram.Curl_if_nametoindex = pIfNameToIndex;
			} 
		} 
		if (ModernizedCProgram.Curl_verify_windows_version(6, 0, .PLATFORM_WINNT, .VERSION_GREATER_THAN_EQUAL)) {
			ModernizedCProgram.Curl_isVistaOrGreater = 1;
			.QueryPerformanceFrequency(ModernizedCProgram.Curl_freq);
		} else {
				ModernizedCProgram.Curl_isVistaOrGreater = 0;
		} 
		return CURLE_OK;
	}
	/* CURL_GLOBAL_WIN32 controls the *optional* part of the initialization which
	     is just for Winsock at the moment. Any required win32 initialization
	     should take place after this block. */
	/* Curl_win32_cleanup() is the opposite of Curl_win32_init() */
	public static void Curl_win32_cleanup(long init_flags) {
		if (ModernizedCProgram.s_hIpHlpApiDll) {
			.FreeLibrary(ModernizedCProgram.s_hIpHlpApiDll);
			ModernizedCProgram.s_hIpHlpApiDll = ((Object)0);
			ModernizedCProgram.Curl_if_nametoindex = ((Object)0);
		} 
		if (init_flags & CURL_GLOBAL_WIN32) {
			.WSACleanup();
		} 
		/* We use our own typedef here since some headers might lack these */
	}
	/* See function definitions in winbase.h */
	/*
	 * Curl_verify_windows_version()
	 *
	 * This is used to verify if we are running on a specific windows version.
	 *
	 * Parameters:
	 *
	 * majorVersion [in] - The major version number.
	 * minorVersion [in] - The minor version number.
	 * platform     [in] - The optional platform identifier.
	 * condition    [in] - The test condition used to specifier whether we are
	 *                     checking a version less then, equal to or greater than
	 *                     what is specified in the major and minor version
	 *                     numbers.
	 *
	 * Returns TRUE if matched; otherwise FALSE.
	 */
	public static  Curl_verify_windows_version(Object majorVersion, Object minorVersion, Object platform, Object condition) {
		bool matched = 0/* We have no way to determine the Windows version from Windows apps,
		     so let's assume we're running on the target Windows version. */;
		/* we're always running on PLATFORM_WINNT */OSVERSIONINFO osver = new OSVERSIONINFO();
		.memset(osver, 0, );
		osver.setDwOSVersionInfoSize();
		if (.GetVersionExA(/* Find out Windows version */osver)) {
			switch (/* Verify the Operating System version number */condition) {
			case .VERSION_EQUAL:
					if (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() == minorVersion) {
						matched = 1;
					} 
					break;
			case .VERSION_GREATER_THAN_EQUAL:
					if (osver.getDwMajorVersion() > majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() >= minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_LESS_THAN_EQUAL:
					if (osver.getDwMajorVersion() < majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() <= minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_LESS_THAN:
					if (osver.getDwMajorVersion() < majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() < minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_GREATER_THAN:
					if (osver.getDwMajorVersion() > majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() > minorVersion)) {
						matched = 1;
					} 
					break;
			}
			if (/* Verify the platform identifier (if necessary) */matched) {
				switch (platform) {
				case .PLATFORM_WINDOWS:
						if (osver.getDwPlatformId() != 1) {
							matched = 0;
						} 
						break;
				case .PLATFORM_WINNT:
						if (osver.getDwPlatformId() != 2) {
							matched = 0;
						} 
				default:
						break;
				}
			} 
		} 
		return matched/*
		 * Curl_load_library()
		 *
		 * This is used to dynamically load DLLs using the most secure method available
		 * for the version of Windows that we are running on.
		 *
		 * Parameters:
		 *
		 * filename  [in] - The filename or full path of the DLL to load. If only the
		 *                  filename is passed then the DLL will be loaded from the
		 *                  Windows system directory.
		 *
		 * Returns the handle of the module on success; otherwise NULL.
		 */;
	}
	public static Object Curl_load_library(Object filename) {
		HMODULE hModule = ((Object)0);
		LOADLIBRARYEX_FN pLoadLibraryEx = ((Object)0);
		HMODULE hKernel32 = .GetModuleHandleA(/* Get a handle to kernel32 so we can access it's functions at runtime */"kernel32");
		if (!hKernel32) {
			return ((Object)0);
		} 
		/* Attempt to find LoadLibraryEx() which is only available on Windows 2000
		     and above */pLoadLibraryEx = (LOADLIBRARYEX_FN)(Object)((.GetProcAddress(hKernel32, "LoadLibraryExA"/* Detect if there's already a path in the filename and load the library if
		     there is. Note: Both back slashes and forward slashes have been supported
		     since the earlier days of DOS at an API level although they are not
		     supported by command prompt */)));
		if (.strpbrk(filename, "\\/")) {
			hModule = /** !checksrc! disable BANNEDFUNC 1 **/pLoadLibraryEx ? .pLoadLibraryEx(filename, ((Object)0), 8) : .LoadLibraryA(filename/* Detect if KB2533623 is installed, as LOAD_LIBARY_SEARCH_SYSTEM32 is only
			     supported on Windows Vista, Windows Server 2008, Windows 7 and Windows
			     Server 2008 R2 with this patch or natively on Windows 8 and above */);
		}  else if (pLoadLibraryEx && .GetProcAddress(hKernel32, "AddDllDirectory")) {
			hModule = .pLoadLibraryEx(filename, ((Object)0), /* Load the DLL from the Windows system directory */-1024);
		} else {
				UINT systemdirlen = .GetSystemDirectoryA(((Object)0), /* Attempt to get the Windows system path */0);
				if (systemdirlen/* Allocate space for the full DLL path (Room for the null terminator
				         is included in systemdirlen) */) {
					size_t filenamelen = .strlen(filename);
					TCHAR path = .Curl_cmalloc( * (systemdirlen + 1 + filenamelen));
					if (ModernizedCProgram.path && .GetSystemDirectoryA(ModernizedCProgram.path, systemdirlen)) {
						.strcpy(ModernizedCProgram.path + .strlen(ModernizedCProgram.path), /* Calculate the full DLL path */"\\");
						.strcpy(ModernizedCProgram.path + .strlen(ModernizedCProgram.path), filename);
						hModule = /* Load the DLL from the Windows system directory *//** !checksrc! disable BANNEDFUNC 1 **/pLoadLibraryEx ? .pLoadLibraryEx(ModernizedCProgram.path, ((Object)0), 8) : .LoadLibraryA(ModernizedCProgram.path);
					} 
					.Curl_cfree(ModernizedCProgram.path);
				} 
		} 
		return hModule/* the Universal Windows Platform (UWP) can't do this *//* WIN32 */;
	}
	public static void parse_cert_parameter(Object cert_parameter, byte certname, byte passphrase) {
		size_t param_length = .strlen(cert_parameter);
		size_t span = new size_t();
		byte param_place = ((Object)0);
		byte certname_place = ((Object)0);
		certname = ((Object)0);
		passphrase = ((Object)0);
		if (param_length == /* most trivial assumption: cert_parameter is empty */0) {
			return ;
		} 
		if (ModernizedCProgram.curl_strnequal(cert_parameter, "pkcs11:", 7) || !.strpbrk(cert_parameter, ":\\")) {
			certname = .strdup(cert_parameter);
			return ;
		} 
		certname_place = .malloc(param_length + /* deal with escaped chars; find unescaped colon if it exists */1);
		if (!certname_place) {
			return ;
		} 
		certname = certname_place;
		param_place = cert_parameter;
		while (param_place) {
			span = .strcspn(param_place, ":\\");
			.strncpy(certname_place, param_place, span);
			param_place += span;
			certname_place += span/* we just ate all the non-special chars. now we're on either a special
			     * char or the end of the string. */;
			switch (param_place) {
			case (byte)'\0':
					break;
			case (byte)':'/* Since we live in a world of weirdness and confusion, the win32
			         dudes can use : when using drive letters and thus c:\file:password
			         needs to work. In order not to break compatibility, we still use : as
			         separator, but we try to detect when it is used for a file name! On
			         windows. */:
					if (param_place && (param_place == cert_parameter[1]) && (cert_parameter[2] == (byte)'\\' || cert_parameter[2] == (byte)'/') && ((ModernizedCProgram.Curl_isalpha((int)((byte)cert_parameter[0/* colon in the second column, followed by a backslash, and the
					           first character is an alphabetic letter:
					
					           this is a drive letter colon */]))))) {
						certname_place++ = (byte)':';
						param_place++;
						break;
					} 
					/* escaped colons and Windows drive letter colons were handled
					       * above; if we're still here, this is a separating colon */param_place++;
					if (.strlen(param_place) > 0) {
						passphrase = .strdup(param_place);
					} 
					;
			case (byte)'\\':
					param_place++;
					switch (param_place) {
					case (byte)'\0':
							certname_place++ = (byte)'\\';
							break;
					case (byte)'\\':
							certname_place++ = (byte)'\\';
							param_place++;
							break;
					case (byte)':':
							certname_place++ = (byte)':';
							param_place++;
							break;
					default:
							certname_place++ = (byte)'\\';
							certname_place++ = param_place;
							param_place++;
							break;
					}
					break;
			}
		}
	}
	public static void GetFileAndPassword(Byte nextarg, byte file, byte password) {
		byte certname;
		byte passphrase;
		ModernizedCProgram.parse_cert_parameter(nextarg, certname, passphrase);
		do {
			.free((file));
			(file) = ((Object)0);
		} while (0);
		file = certname;
		if (passphrase) {
			do {
				.free((password));
				(password) = ((Object)0);
			} while (0);
			password = passphrase;
		} 
		ModernizedCProgram.cleanarg(nextarg/* Get a size parameter for '--limit-rate' or '--max-filesize'.
		 * We support a 'G', 'M' or 'K' suffix too.
		  */);
	}
	/* f or -long-flag */
	public static  getparameter(Object flag, byte nextarg,  usedarg, GlobalConfig global, OperationConfig config) {
		byte letter;
		byte subletter = /* subletters can only occur on long options */(byte)'\0';
		int rc;
		byte parse = ((Object)0);
		int j;
		time_t now = new time_t();
		int hit = -1;
		bool longopt = 0;
		bool singleopt = /* when true means '-o foo' used '-ofoo' */0;
		ParameterError err = new ParameterError();
		bool toggle = /* how to switch boolean options, on or off. Controlled
		                         by using --OPTION or --no-OPTION */1;
		usedarg = /* default is that we don't use the arg */0;
		if (((byte)'-' != flag[0]) || ((byte)'-' == flag[1])) {
			byte word = ((byte)'-' == flag[0]) ? flag + 2 : /* this should be a long name */flag;
			size_t fnam = .strlen(word);
			int numhits = 0;
			bool noflagged = 0;
			if (!.strncmp(word, "no-", 3)) {
				word += /* disable this option but ignore the "no-" part when looking for it */3;
				toggle = 0;
				noflagged = 1;
			} 
			for (j = 0; j <  / ; j++) {
				if (ModernizedCProgram.curl_strnequal(ModernizedCProgram.aliases[j].getLname(), word, fnam)) {
					longopt = 1;
					numhits++;
					if (ModernizedCProgram.curl_strequal(ModernizedCProgram.aliases[j].getLname(), word)) {
						parse = ModernizedCProgram.aliases[j].getLetter();
						hit = j;
						numhits = /* a single unique hit */1;
						break;
					} 
					parse = ModernizedCProgram.aliases[j].getLetter();
					hit = j;
				} 
			}
			if (numhits > 1) {
				return /* this is at least the second match! */.PARAM_OPTION_AMBIGUOUS;
			} 
			if (hit < 0) {
				return .PARAM_OPTION_UNKNOWN;
			} 
			if (noflagged && (ModernizedCProgram.aliases[hit].getDesc() != .ARG_BOOL)) {
				return /* --no- prefixed an option that isn't boolean! */.PARAM_NO_NOT_BOOLEAN;
			} 
		} else {
				/* prefixed with one dash, pass it */flag++;
				hit = -1;
				parse = flag;
		} 
		Byte generatedDns_ipv4_addr = config.getDns_ipv4_addr();
		Byte generatedDns_ipv6_addr = config.getDns_ipv6_addr();
		Byte generatedRandom_file = config.getRandom_file();
		Byte generatedEgd_file = config.getEgd_file();
		Byte generatedOauth_bearer = config.getOauth_bearer();
		long generatedAuthtype = config.getAuthtype();
		double generatedConnecttimeout = config.getConnecttimeout();
		Byte generatedDoh_url = config.getDoh_url();
		Byte generatedCipher_list = config.getCipher_list();
		Byte generatedDns_interface = config.getDns_interface();
		Byte generatedDns_servers = config.getDns_servers();
		Byte generatedTrace_dump = global.getTrace_dump();
		 generatedTracetype = global.getTracetype();
		long generatedMaxredirs = config.getMaxredirs();
		 generatedErrors_fopened = global.getErrors_fopened();
		_iobuf generatedErrors = global.getErrors();
		Byte generatedIface = config.getIface();
		Byte generatedKrblevel = config.getKrblevel();
		getout generatedUrl_get = config.getUrl_get();
		getout generatedUrl_list = config.getUrl_list();
		int generatedFlags = generatedUrl_get.getFlags();
		getout generatedNext = generatedUrl_get.getNext();
		getout getout = new getout();
		Byte generatedUrl = url.getUrl();
		Byte generatedFtpport = config.getFtpport();
		Byte generatedProxy = config.getProxy();
		long generatedReq_retry = config.getReq_retry();
		long generatedRetry_delay = config.getRetry_delay();
		long generatedRetry_maxtime = config.getRetry_maxtime();
		Byte generatedFtp_account = config.getFtp_account();
		long generatedLocalport = config.getLocalport();
		long generatedLocalportrange = config.getLocalportrange();
		Byte generatedFtp_alternative_to_user = config.getFtp_alternative_to_user();
		int generatedFtp_ssl_ccc_mode = config.getFtp_ssl_ccc_mode();
		Byte generatedLibcurl = global.getLibcurl();
		long generatedAlivetime = config.getAlivetime();
		Byte generatedNoproxy = config.getNoproxy();
		long generatedTftp_blksize = config.getTftp_blksize();
		Byte generatedMail_from = config.getMail_from();
		curl_slist generatedMail_rcpt = config.getMail_rcpt();
		long generatedProto = config.getProto();
		long generatedProto_redir = config.getProto_redir();
		curl_slist generatedResolve = config.getResolve();
		Byte generatedMail_auth = config.getMail_auth();
		Byte generatedSasl_authzid = config.getSasl_authzid();
		Byte generatedUnix_socket_path = config.getUnix_socket_path();
		Byte generatedProxy_service_name = config.getProxy_service_name();
		Byte generatedService_name = config.getService_name();
		Byte generatedProto_default = config.getProto_default();
		double generatedExpect100timeout = config.getExpect100timeout();
		curl_slist generatedConnect_to = config.getConnect_to();
		long generatedSsl_version_max = config.getSsl_version_max();
		long generatedHappy_eyeballs_timeout_ms = config.getHappy_eyeballs_timeout_ms();
		Byte generatedCipher13_list = config.getCipher13_list();
		Byte generatedProxy_cipher13_list = config.getProxy_cipher13_list();
		Byte generatedUseragent = config.getUseragent();
		Byte generatedAltsvc = config.getAltsvc();
		Byte generatedCookie = config.getCookie();
		Byte generatedCookiefile = config.getCookiefile();
		Byte generatedCookiejar = config.getCookiejar();
		Object generatedResume_from = config.getResume_from();
		Byte generatedPostfields = config.getPostfields();
		Object generatedPostfieldsize = config.getPostfieldsize();
		Byte generatedHeaderfile = config.getHeaderfile();
		Byte generatedReferer = config.getReferer();
		Byte generatedCert = config.getCert();
		Byte generatedKey_passwd = config.getKey_passwd();
		Byte generatedCacert = config.getCacert();
		Byte generatedCert_type = config.getCert_type();
		Byte generatedKey = config.getKey();
		Byte generatedKey_type = config.getKey_type();
		Byte generatedEngine = config.getEngine();
		Byte generatedCapath = config.getCapath();
		Byte generatedPubkey = config.getPubkey();
		Byte generatedHostpubmd5 = config.getHostpubmd5();
		Byte generatedCrlfile = config.getCrlfile();
		Byte generatedTls_username = config.getTls_username();
		Byte generatedTls_password = config.getTls_password();
		Byte generatedTls_authtype = config.getTls_authtype();
		Byte generatedPinnedpubkey = config.getPinnedpubkey();
		Byte generatedProxy_pinnedpubkey = config.getProxy_pinnedpubkey();
		Byte generatedProxy_tls_username = config.getProxy_tls_username();
		Byte generatedProxy_tls_password = config.getProxy_tls_password();
		Byte generatedProxy_tls_authtype = config.getProxy_tls_authtype();
		Byte generatedProxy_cert = config.getProxy_cert();
		Byte generatedProxy_key_passwd = config.getProxy_key_passwd();
		Byte generatedProxy_cert_type = config.getProxy_cert_type();
		Byte generatedProxy_key = config.getProxy_key();
		Byte generatedProxy_key_type = config.getProxy_key_type();
		Byte generatedProxy_cipher_list = config.getProxy_cipher_list();
		Byte generatedProxy_crlfile = config.getProxy_crlfile();
		Byte generatedLogin_options = config.getLogin_options();
		Byte generatedProxy_cacert = config.getProxy_cacert();
		Byte generatedProxy_capath = config.getProxy_capath();
		long generatedSocks5_auth = config.getSocks5_auth();
		tool_mime generatedMimeroot = config.getMimeroot();
		tool_mime generatedMimecurrent = config.getMimecurrent();
		 generatedHttpreq = config.getHttpreq();
		Byte generatedRequest_target = config.getRequest_target();
		curl_slist generatedProxyheaders = config.getProxyheaders();
		curl_slist generatedHeaders = config.getHeaders();
		 generatedNo_body = config.getNo_body();
		 generatedShow_headers = config.getShow_headers();
		double generatedTimeout = config.getTimeout();
		Byte generatedNetrc_file = config.getNetrc_file();
		getout generatedUrl_out = config.getUrl_out();
		byte generatedOutfile = url.getOutfile();
		curl_slist generatedPostquote = config.getPostquote();
		curl_slist generatedPrequote = config.getPrequote();
		curl_slist generatedQuote = config.getQuote();
		return .PARAM_OK;
	}
	/* NULL if unset */
	/* set to TRUE if the arg
	                                                 has been used */
	/* required anyway if one of upper preprocessor definitions enabled */
	/* proceed with current user credentials */
	/* #if defined(USE_WINDOWS_SSPI) */
	public static int ldap_win_bind(connectdata conn, ldap server, Object user, Object passwd) {
		int rc = -1024;
		PTCHAR inuser = ((Object)0);
		PTCHAR inpass = ((Object)0);
		Curl_easy generatedData = conn.getData();
		Object generatedSet = generatedData.getSet();
		if (user && passwd && (generatedSet.getHttpauth() & CURLAUTH_BASIC)) {
			inuser = ((byte)user);
			inpass = ((byte)passwd);
			rc = .ldap_simple_bind_sA(server, inuser, inpass);
			do {
				(inuser) = ((Object)0);
			} while (0);
			do {
				(inpass) = ((Object)0);
			} while (0);
		} 
		return rc/* #if defined(USE_WIN32_LDAP) */;
	}
	/*
	 * Return scope-value for a scope-string.
	 */
	/*
	 * Return scope-value for a scope-string.
	 */
	public static int str2scope(Object p) {
		if (ModernizedCProgram.Curl_strcasecompare(p, "one")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "onetree")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "base")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "sub")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "subtree")) {
			return -1024;
		} 
		return (true/*
		 * Split 'str' into strings separated by commas.
		 * Note: out[] points into 'str'.
		 */);
	}
	public static  split_str(Byte str, byte out, Object count) {
		byte res;
		byte lasts;
		byte s;
		size_t i = new size_t();
		size_t items = 1;
		s = .strchr(str, (byte)',');
		while (s) {
			items++;
			s = .strchr(++s, (byte)',');
		}
		res = .Curl_ccalloc(items, );
		if (!res) {
			return 0;
		} 
		for (; s && i < items; ) {
			res[i] = s;
		}
		out = res;
		count = items;
		return 1/*
		 * Break apart the pieces of an LDAP URL.
		 * Syntax:
		 *   ldap://<hostname>:<port>/<base_dn>?<attributes>?<scope>?<filter>?<ext>
		 *
		 * <hostname> already known from 'conn->host.name'.
		 * <port>     already known from 'conn->remote_port'.
		 * extract the rest from 'conn->data->state.path+1'. All fields are optional.
		 * e.g.
		 *   ldap://<hostname>:<port>/?<attributes>?<scope>?<filter>
		 * yields ludp->lud_dn = "".
		 *
		 * Defined in RFC4516 section 2.
		 */;
	}
	public static int _ldap_url_parse2(Object conn) {
		int rc = -1024;
		byte p;
		byte path;
		byte q = ((Object)0);
		byte query = ((Object)0);
		size_t i = new size_t();
		if (!conn.getData() || !conn.getData().getState().getUp().getPath() || conn.getData().getState().getUp().getPath()[0] != (byte)'/' || !ModernizedCProgram.Curl_strncasecompare("LDAP", conn.getData().getState().getUp().getScheme(), 4)) {
			return -1024;
		} 
		this.setLud_scope(-1024);
		this.setLud_port(conn.getRemote_port());
		this.setLud_host(conn.getHost().getName());
		p = path = .Curl_cstrdup(conn.getData().getState().getUp().getPath() + /* Duplicate the path */1);
		if (!path) {
			return -1024;
		} 
		if (conn.getData().getState().getUp().getQuery()) {
			q = query = .Curl_cstrdup(conn.getData().getState().getUp().getQuery());
			if (!query) {
				.Curl_cfree(path);
				return -1024;
			} 
		} 
		Object generatedLud_dn = this.getLud_dn();
		if (/* Parse the DN (Distinguished Name) */p) {
			byte dn = p;
			byte unescaped;
			 result = new ();
			do {
			} while (0);
			ModernizedCProgram.result = conn.getData().Curl_urldecode(dn, 0, unescaped, ((Object)0), /* Unescape the DN */0);
			if (ModernizedCProgram.result) {
				rc = -1024;
				;
			} 
			this.setLud_dn((/* Convert the unescaped string to a tchar */unescaped));
			do {
				(unescaped) = ((Object)0);
			} while (/* Free the unescaped string as we are done with it */0);
			if (!generatedLud_dn) {
				rc = -1024;
				;
			} 
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the attributes. skip "??" */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		Object generatedLud_attrs = this.getLud_attrs();
		Object generatedLud_attrs_dups = this.getLud_attrs_dups();
		if (p) {
			byte attributes;
			size_t count = 0;
			if (!ModernizedCProgram.split_str(p, attributes, /* Split the string into an array of attributes */count)) {
				rc = -1024;
				;
			} 
			this.setLud_attrs(.Curl_ccalloc(count + 1, /* Allocate our array (+1 for the NULL entry) */));
			if (!generatedLud_attrs) {
				.Curl_cfree(attributes);
				rc = -1024;
				;
			} 
			for (i = 0; i < count; i++) {
				byte unescaped;
				 result = new ();
				do {
				} while (0);
				ModernizedCProgram.result = conn.getData().Curl_urldecode(attributes[i], 0, unescaped, ((Object)/* Unescape the attribute */0), 0);
				if (ModernizedCProgram.result) {
					.Curl_cfree(attributes);
					rc = -1024;
					;
				} 
				generatedLud_attrs[i] = (/* Convert the unescaped string to a tchar */unescaped);
				do {
					(unescaped) = ((Object)0);
				} while (/* Free the unescaped string as we are done with it */0);
				if (!generatedLud_attrs[i]) {
					.Curl_cfree(attributes);
					rc = -1024;
					;
				} 
				generatedLud_attrs_dups++;
			}
			.Curl_cfree(attributes);
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the scope. skip "??" */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		Object generatedLud_scope = this.getLud_scope();
		if (p) {
			this.setLud_scope(ModernizedCProgram.str2scope(p));
			if (generatedLud_scope == -1) {
				rc = -1024;
				;
			} 
			do {
			} while (0);
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the filter */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		Object generatedLud_filter = this.getLud_filter();
		if (p) {
			byte filter = p;
			byte unescaped;
			 result = new ();
			do {
			} while (0);
			ModernizedCProgram.result = conn.getData().Curl_urldecode(filter, 0, unescaped, ((Object)0), /* Unescape the filter */0);
			if (ModernizedCProgram.result) {
				rc = -1024;
				;
			} 
			this.setLud_filter((/* Convert the unescaped string to a tchar */unescaped));
			do {
				(unescaped) = ((Object)0);
			} while (/* Free the unescaped string as we are done with it */0);
			if (!generatedLud_filter) {
				rc = -1024;
				;
			} 
		} 
		p = q;
		if (p && !p) {
			rc = -1024;
			;
		} 
		.Curl_cfree(query);
		return rc;
	}
	public static int _ldap_url_parse(Object conn) {
		CURL_LDAPURLDesc ludp = .Curl_ccalloc(1, );
		int rc;
		ludpp = ((Object)0);
		if (!ludp) {
			return -1024;
		} 
		rc = ludp._ldap_url_parse2(conn);
		if (rc != -1024) {
			ludp._ldap_free_urldesc();
			ludp = ((Object)0);
		} 
		ludpp = ludp;
		return (rc);
	}
	public static void _ldap_free_urldesc() {
		if (!ludp) {
			return ;
		} 
		Object generatedLud_dn = this.getLud_dn();
		.Curl_cfree(generatedLud_dn);
		Object generatedLud_filter = this.getLud_filter();
		.Curl_cfree(generatedLud_filter);
		Object generatedLud_attrs = this.getLud_attrs();
		Object generatedLud_attrs_dups = this.getLud_attrs_dups();
		if (generatedLud_attrs) {
			size_t i = new size_t();
			for (i = 0; i < generatedLud_attrs_dups; i++) {
				.Curl_cfree(generatedLud_attrs[i]);
			}
			.Curl_cfree(generatedLud_attrs);
		} 
		.Curl_cfree(ludp/* !HAVE_LDAP_URL_PARSE *//* !CURL_DISABLE_LDAP && !USE_OPENLDAP */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* header from libc, not from libattr */
	/* keep this as LAST include */
	/* mapping table of curl metadata to extended attribute names */
	/* name of the xattr */
	/* mappings proposed by
	   * https://freedesktop.org/wiki/CommonExtendedAttributes/
	   */
	/* last element, abort loop here */
	/* returns TRUE if a new URL is returned, that then needs to be freed */
	/* @unittest: 1621 */
	/* store metadata from the curl request alongside the downloaded
	 * file using extended attributes
	 */
	/* loop through all xattr-curlinfo pairs and abort on a set error */
	/* FreeBSD's extattr_set_fd returns the length of the extended
	             attribute */
	public static int fwrite_xattr(Object curl, int fd) {
		(Object)curl;
		(Object)fd;
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static int new_fnmatch(Object ptr, Object pattern, Object string) {
		(Object)ptr;
		(Object)pattern;
		(Object)string;
		return CURL_FNMATCHFUNC_MATCH;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static void fileinfo_dtor(Object user, Object element) {
		(Object)user;
		element.Curl_fileinfo_cleanup();
	}
	/* Escape string to C string syntax.  Return NULL if out of memory.
	 * Is this correct for those wacky EBCDIC guys? */
	public static Byte c_escape(Object str, Object len) {
		byte s;
		byte c;
		byte escaped;
		byte e;
		if (len == CURL_ZERO_TERMINATED) {
			len = .strlen(str);
		} 
		if (len > (~(size_t)0) / /* Check for possible overflow. */4) {
			return ((Object)0);
		} 
		escaped = .malloc(4 * len + /* Allocate space based on worst-case */1);
		if (!escaped) {
			return ((Object)0);
		} 
		e = escaped;
		for (s = str; (c = s) != (byte)'\0'; s++) {
			if (c == (byte)'\n') {
				.strcpy(e, "\\n");
				e += 2;
			}  else if (c == (byte)'\r') {
				.strcpy(e, "\\r");
				e += 2;
			}  else if (c == (byte)'\t') {
				.strcpy(e, "\\t");
				e += 2;
			}  else if (c == (byte)'\\') {
				.strcpy(e, "\\\\");
				e += 2;
			}  else if (c == (byte)'"') {
				.strcpy(e, "\\\"");
				e += 2;
			}  else if (!.isprint(c)) {
				ModernizedCProgram.curl_msnprintf(e, 5, "\\%03o", (int)c);
				e += 4;
			} else {
					e++ = c;
			} 
		}
		e = (byte)'\0';
		return escaped;
	}
	/* Generate code for a struct curl_slist. */
	public static Object libcurl_generate_slist(Object slist, int slistno) {
		 ret = CURLE_OK;
		byte escaped = ((Object)0);
		slistno = ++/* May need several slist variables, so invent name */ModernizedCProgram.easysrc_slist_count;
		do {
			ret = ModernizedCProgram.easysrc_decl.easysrc_addf("struct curl_slist *slist%d;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_data.easysrc_addf("slist%d = NULL;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_clean.easysrc_addf("curl_slist_free_all(slist%d);", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_clean.easysrc_addf("slist%d = NULL;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		for (; slist; slist = slist.getNext()) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(slist.getData(), CURL_ZERO_TERMINATED);
			if (!escaped) {
				return CURLE_OUT_OF_MEMORY;
			} 
			do {
				ret = ModernizedCProgram.easysrc_data.easysrc_addf("slist%d = curl_slist_append(slist%d, \"%s\");", slistno, slistno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		}
		return ret;
	}
	/* Wrapper to generate source code for a mime part. */
	public static Object libcurl_generate_mime_part(Object curl, GlobalConfig config, tool_mime part, int mimeno) {
		 ret = CURLE_OK;
		int submimeno = 0;
		byte escaped = ((Object)0);
		byte data = ((Object)0);
		Object generatedFilename = part.getFilename();
		byte filename = generatedFilename;
		tool_mime generatedPrev = part.getPrev();
		if (generatedPrev) {
			ret = ModernizedCProgram.libcurl_generate_mime_part(curl, config, generatedPrev, mimeno);
			if (ret) {
				return ret;
			} 
		} 
		do {
			ret = ModernizedCProgram.easysrc_code.easysrc_addf("part%d = curl_mime_addpart(mime%d);", mimeno, mimeno);
			if (ret) {
				;
			} 
		} while (/* Create the part. */0);
		Object generatedData = part.getData();
		 generatedKind = part.getKind();
		switch (generatedKind) {
		case .TOOLMIME_FILE:
		case .TOOLMIME_DATA/* Data will be set in ASCII, thus issue a comment with clear text. *//* Our data is always textual: convert it to ASCII. */:
				data = generatedData;
				if (!ret) {
					do {
						.free((escaped));
						(escaped) = ((Object)0);
					} while (0);
					escaped = ModernizedCProgram.c_escape(data, CURL_ZERO_TERMINATED);
					do {
						if (!escaped) {
							ret = CURLE_OUT_OF_MEMORY;
							;
						} 
					} while (0);
					do {
						ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_data(part%d, \"%s\", CURL_ZERO_TERMINATED);", mimeno, escaped);
						if (ret) {
							;
						} 
					} while (0);
				} 
				break;
		case .TOOLMIME_FILEDATA:
				escaped = ModernizedCProgram.c_escape(generatedData, CURL_ZERO_TERMINATED);
				do {
					if (!escaped) {
						ret = CURLE_OUT_OF_MEMORY;
						;
					} 
				} while (0);
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_filedata(part%d, \"%s\");", mimeno, escaped);
					if (ret) {
						;
					} 
				} while (0);
				if (generatedKind == .TOOLMIME_FILEDATA && !filename) {
					do {
						ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_filename(part%d, NULL);", mimeno);
						if (ret) {
							;
						} 
					} while (0);
				} 
				break;
		case .TOOLMIME_PARTS:
				ret = ModernizedCProgram.libcurl_generate_mime(curl, config, part, submimeno);
				if (!ret) {
					do {
						ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_subparts(part%d, mime%d);", mimeno, submimeno);
						if (ret) {
							;
						} 
					} while (0);
					do {
						ret = ModernizedCProgram.easysrc_code.easysrc_addf("mime%d = NULL;", submimeno);
						if (ret) {
							;
						} 
					} while (/* Avoid freeing in CLEAN. */0);
				} 
				break;
		case /* FALLTHROUGH */.TOOLMIME_STDINDATA:
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_data_cb(part%d, -1, (curl_read_callback) fread, \\", mimeno);
					if (ret) {
						;
					} 
				} while (/* Can only be reading stdin in the current context. */0);
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_add("                  (curl_seek_callback) fseek, NULL, stdin);");
					if (ret) {
						;
					} 
				} while (0);
				break;
		case .TOOLMIME_STDIN:
				if (!filename) {
					filename = "-";
				} 
		default:
				break;
		}
		Object generatedEncoder = part.getEncoder();
		if (!ret && generatedEncoder) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(generatedEncoder, CURL_ZERO_TERMINATED);
			do {
				if (!escaped) {
					ret = CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_encoder(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		if (!ret && filename) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(filename, CURL_ZERO_TERMINATED);
			do {
				if (!escaped) {
					ret = CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_filename(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		Object generatedName = part.getName();
		if (!ret && generatedName) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(generatedName, CURL_ZERO_TERMINATED);
			do {
				if (!escaped) {
					ret = CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_name(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		Object generatedType = part.getType();
		if (!ret && generatedType) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(generatedType, CURL_ZERO_TERMINATED);
			do {
				if (!escaped) {
					ret = CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_type(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		curl_slist generatedHeaders = part.getHeaders();
		if (!ret && generatedHeaders) {
			int slistno;
			ret = ModernizedCProgram.libcurl_generate_slist(generatedHeaders, slistno);
			if (!ret) {
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_mime_headers(part%d, slist%d, 1);", mimeno, slistno);
					if (ret) {
						;
					} 
				} while (0);
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_addf("slist%d = NULL;", slistno);
					if (ret) {
						;
					} 
				} while (/* Prevent CLEANing. */0);
			} 
		} 
		return ret;
	}
	/* Wrapper to generate source code for a mime structure. */
	public static Object libcurl_generate_mime(Object curl, GlobalConfig config, tool_mime toolmime, int mimeno) {
		 ret = CURLE_OK;
		mimeno = ++/* May need several mime variables, so invent name. */ModernizedCProgram.easysrc_mime_count;
		do {
			ret = ModernizedCProgram.easysrc_decl.easysrc_addf("curl_mime *mime%d;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_data.easysrc_addf("mime%d = NULL;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_code.easysrc_addf("mime%d = curl_mime_init(hnd);", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_clean.easysrc_addf("curl_mime_free(mime%d);", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_clean.easysrc_addf("mime%d = NULL;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		tool_mime generatedSubparts = toolmime.getSubparts();
		if (generatedSubparts) {
			do {
				ret = ModernizedCProgram.easysrc_decl.easysrc_addf("curl_mimepart *part%d;", mimeno);
				if (ret) {
					;
				} 
			} while (0);
			ret = ModernizedCProgram.libcurl_generate_mime_part(curl, config, generatedSubparts, mimeno);
		} 
	}
	/* setopt wrapper for curl_slist options */
	public static Object tool_setopt_slist(Object curl, GlobalConfig config, Object name, Object tag, curl_slist list) {
		 ret = CURLE_OK;
		ret = curl.curl_easy_setopt(tag, list);
		Byte generatedLibcurl = config.getLibcurl();
		if (generatedLibcurl && list && !ret) {
			int i;
			ret = ModernizedCProgram.libcurl_generate_slist(list, i);
			if (!ret) {
				do {
					ret = ModernizedCProgram.easysrc_code.easysrc_addf("curl_easy_setopt(hnd, %s, slist%d);", name, i);
					if (ret) {
						;
					} 
				} while (0);
			} 
		} 
	}
	/* CURL_DISABLE_LIBCURL_OPTION */
	/*
	 * tool_setopt_skip() allows the curl tool code to avoid setopt options that
	 * are explicitly disabled in the build.
	 */
	public static  tool_setopt_skip(Object tag) {
		(Object)tag;
		return 0;
	}
	public static void smtp_get_message(Byte buffer, byte outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 4) {
			len -= /* Find the start of the message */4;
			for (message = buffer + 4; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change SMTP state!
		 */;
	}
	/*
	 * SMTP protocol handler.
	 */
	public static Object Context() {
	}
	//
	//  libcurl write callback function
	//
	public static int writer(Byte data, Object size, Object nmemb) {
		if (writerData == 0) {
			return 0;
		} 
		.UNRECOGNIZEDFUNCTIONNAME(data, size * nmemb);
		return size * nmemb;//
	}
	//  libcurl connection initialization
	//
	public static boolean init(Object conn, Byte url) {
		CURLcode code = new CURLcode();
		Curl_easy curl_easy = new Curl_easy();
		conn = curl_easy.curl_easy_init();
		if (conn == 0) {
			.fprintf((_iob[2]), "Failed to create CURL connection\n");
			.exit(1);
		} 
		code = conn.curl_easy_setopt(CURLOPT_ERRORBUFFER, ModernizedCProgram.errorBuffer);
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to set error buffer [%d]\n", code);
			return false;
		} 
		code = conn.curl_easy_setopt(CURLOPT_URL, url);
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to set URL [%s]\n", ModernizedCProgram.errorBuffer);
			return false;
		} 
		code = conn.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, -1024);
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to set redirect option [%s]\n", ModernizedCProgram.errorBuffer);
			return false;
		} 
		code = conn.curl_easy_setopt(CURLOPT_WRITEFUNCTION, writer);
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to set writer [%s]\n", ModernizedCProgram.errorBuffer);
			return false;
		} 
		code = conn.curl_easy_setopt(CURLOPT_WRITEDATA, ModernizedCProgram.buffer);
		if (code != CURLE_OK) {
			.fprintf((_iob[2]), "Failed to set write data [%s]\n", ModernizedCProgram.errorBuffer);
			return false;
		} 
		return true;//
		int res = 0;
		Curl_easy curl_easy = new Curl_easy();
		do {
			if ((((ModernizedCProgram.eh[num])) = curl_easy.curl_easy_init()) == ((Object)0)) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_init() failed\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)));
				res = 124;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_URL)), ((url)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_PROXY)), ((ModernizedCProgram.libtest_arg2)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_PROXYUSERPWD)), ((userpwd)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_PROXYAUTH)), (((long)CURLAUTH_ANY)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_VERBOSE)), ((true)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_HEADER)), ((true)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ((ModernizedCProgram.eh[num])).curl_easy_setopt(((CURLOPT_HTTPHEADER)), ((headers)))) != CURLE_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_easy_setopt() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_easy_strerror(ec));
				res = (int)ec;
			} 
		} while (/* custom Host: */0);
		if (res) {
			;
		} 
		do {
			 ec = new ();
			if ((ec = ModernizedCProgram.curl_multi_add_handle(((cm)), ((ModernizedCProgram.eh[num])))) != CURLM_OK) {
				(_iob[2]).curl_mfprintf("%s:%d curl_multi_add_handle() failed, with code %d (%s)\n", (("E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib540.c")), ((true)), (int)ec, ModernizedCProgram.curl_multi_strerror(ec));
				res = (int)ec;
			} 
		} while (0);
		if (res) {
			;
		} 
		return /* success */0;
		ModernizedCProgram.eh[num] = ((Object)0);
		return /* failure */res;
	}
	//  libxml start element callback function
	//
	public static void StartElement(Object voidContext, Object name, Object attributes) {
		Context context = (Context)voidContext;
		if ((!.strcasecmp(((byte)name), ("TITLE")))) {
			context.setTitle("");
			context.setAddTitle(true);
		} 
		(Object)attributes//;//
	}
	//  libxml end element callback function
	//
	public static void EndElement(Object voidContext, Object name) {
		Context context = (Context)voidContext;
		if ((!.strcasecmp(((byte)name), ("TITLE")))) {
			context.setAddTitle(false);
		} 
	}
	//  libxml PCDATA callback function
	//
	public static void Characters(Object voidContext, Object chars, int length) {
		Context context = (Context)voidContext;
		context.handleCharacters(chars, length)//;//
	}
	//  libxml CDATA callback function
	//
	public static void cdata(Object voidContext, Object chars, int length) {
		Context context = (Context)voidContext;
		context.handleCharacters(chars, length)////  libxml SAX callback structure//;////  libxml SAX callback structure//
	}
	//
	//  Parse given (assumed to be) HTML text and return the title
	//
	public static void parseHtml(Object html, Object title) {
		htmlParserCtxtPtr ctxt = new htmlParserCtxtPtr();
		Context context = new Context();
		ctxt = .htmlCreatePushParserCtxt(ModernizedCProgram.saxHandler, context, "", 0, "", XML_CHAR_ENCODING_NONE);
		.htmlParseChunk(ctxt, .UNRECOGNIZEDFUNCTIONNAME(), .UNRECOGNIZEDFUNCTIONNAME(), 0);
		.htmlParseChunk(ctxt, "", 0, 1);
		.htmlFreeParserCtxt(ctxt);
		basic_string generatedTitle = context.getTitle();
		title = generatedTitle;
	}
	public static Object writedata(Byte data, Object size, Object nmemb, Object userdata) {
		(Object)data;
		(Object)userdata;
		if (size && nmemb) {
			ModernizedCProgram.hasbody = 1;
		} 
		return size * nmemb;
	}
	public static int onetest(Object curl, Object url, Object p) {
		 res = new ();
		int replyselector;
		byte[] urlbuf = new byte[256];
		replyselector = (p.getFlags() & (1 << 3)) ? 1 : 0;
		if (p.getFlags() & (1 << 1)) {
			replyselector += 2;
		} 
		ModernizedCProgram.curl_msnprintf(urlbuf, , "%s%04u", url, replyselector);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (urlbuf))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RESUME_FROM), ((p.getFlags() & (1 << 0)) ? 3 : 0))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_RANGE), (!(p.getFlags() & (1 << 0)) ? "3-1000000" : (byte)((Object)0)))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_FAILONERROR), ((p.getFlags() & (1 << 2)) ? 1 : 0))) != CURLE_OK) {
			;
		} 
		ModernizedCProgram.hasbody = 0;
		res = curl.curl_easy_perform();
		if (res != p.getResult()) {
			(_iob[2]).curl_mfprintf("bad error code (%d): resume=%s, fail=%s, http416=%s, content-range=%s, expected=%d\n", res, (p.getFlags() & (1 << 0)) ? "yes" : "no", (p.getFlags() & (1 << 2)) ? "yes" : "no", (p.getFlags() & (1 << 1)) ? "yes" : "no", (p.getFlags() & (1 << 3)) ? "yes" : "no", p.getResult());
			return 1;
		} 
		if (ModernizedCProgram.hasbody && (p.getFlags() & (1 << 4))) {
			(_iob[2]).curl_mfprintf("body should be ignored and is not: resume=%s, fail=%s, http416=%s, content-range=%s\n", (p.getFlags() & (1 << 0)) ? "yes" : "no", (p.getFlags() & (1 << 2)) ? "yes" : "no", (p.getFlags() & (1 << 1)) ? "yes" : "no", (p.getFlags() & (1 << 3)) ? "yes" : "no");
			return 1;
		} 
		return 0;
	}
	public static Object rtp_write(Object ptr, Object size, Object nmemb, Object stream) {
		byte data = (byte)ptr;
		int channel = ((int)((byte)((data)[1])));
		int message_size;
		int coded_size = ((((int)((byte)((data)[2]))) << 8) | ((int)((byte)((data)[3]))));
		size_t failure = (size && nmemb) ? 0 : 1;
		int i;
		(Object)stream;
		message_size = ModernizedCProgram.curlx_uztosi(size * nmemb) - 4;
		ModernizedCProgram.curl_mprintf("RTP: message size %d, channel %d\n", message_size, channel);
		if (message_size != coded_size) {
			ModernizedCProgram.curl_mprintf("RTP embedded size (%d) does not match the write size (%d).\n", coded_size, message_size);
			return failure;
		} 
		data += 4;
		for (i = 0; i < message_size; i += 12) {
			if (message_size - i > 12) {
				if (.memcmp(ModernizedCProgram.RTP_DATA, data + i, 12) != 0) {
					ModernizedCProgram.curl_mprintf("RTP PAYLOAD CORRUPTED [%s]\n", data + i);
					return failure;
				} 
			} else {
					if (.memcmp(ModernizedCProgram.RTP_DATA, data + i, message_size - i) != 0) {
						ModernizedCProgram.curl_mprintf("RTP PAYLOAD END CORRUPTED (%d), [%s]\n", message_size - i, data + i);
						return failure;
					} 
			} 
		}
		ModernizedCProgram.rtp_packet_count++;
		(_iob[2]).curl_mfprintf("packet count is %d\n", ModernizedCProgram.rtp_packet_count);
		return size * nmemb;
	}
	/* build request url */
	public static Byte suburl(Object base, int i) {
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i);
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i/*
		 * Test the Client->Server ANNOUNCE functionality (PUT style)
		 */);
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i);
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i/*
		 * Test GET_PARAMETER: PUT, HEARTBEAT, and POST
		 */);
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i);
		return ModernizedCProgram.curl_maprintf("%s%.4d", base, i/*
		 * Test Session ID capture
		 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Verify that some API functions are locked from being called inside callback
	 */
	public static int progressCallback(Object arg, double dltotal, double dlnow, double ultotal, double ulnow) {
		 res = 0;
		byte[] buffer = new byte[256];
		size_t n = 0;
		(Object)arg;
		(Object)dltotal;
		(Object)dlnow;
		(Object)ultotal;
		(Object)ulnow;
		res = ModernizedCProgram.curl.curl_easy_recv(buffer, 256, n);
		ModernizedCProgram.curl_mprintf("curl_easy_recv returned %d\n", res);
		res = ModernizedCProgram.curl.curl_easy_send(buffer, n, n);
		ModernizedCProgram.curl_mprintf("curl_easy_send returned %d\n", res);
		return 1;
	}
	/* Update the event timer after curl_multi library calls */
	public static int update_timeout_cb(Object multi, long timeout_ms, Object userp) {
		timeval timeout = new timeval();
		GlobalInfo g = (GlobalInfo)userp;
		timeout.setTimeval(timeout_ms / 1000);
		timeout.setTimeval((timeout_ms % 1000) * 1000);
		Object generatedTimeval = timeout.getTimeval();
		.g_print("*** update_timeout_cb %ld => %ld:%ld ***\n", timeout_ms, generatedTimeval, generatedTimeval);
		if (timeout_ms >= 0) {
			g.setTimer_event(.g_timeout_add(timeout_ms, ModernizedCProgram.timer_cb, g));
		} 
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/***************************************************************************
	 *
	 * Curl_memdup(source, length)
	 *
	 * Copies the 'source' data to a newly allocated buffer (that is
	 * returned). Copies 'length' bytes.
	 *
	 * Returns the new pointer or NULL on failure.
	 *
	 ***************************************************************************/
	public static Object Curl_memdup(Object src, Object length) {
		Object buffer = .Curl_cmalloc(length);
		if (!buffer) {
			return ((Object)/* fail */0);
		} 
		.memcpy(buffer, src, length);
		return buffer/***************************************************************************
		 *
		 * Curl_saferealloc(ptr, size)
		 *
		 * Does a normal realloc(), but will free the data pointer if the realloc
		 * fails. If 'size' is non-zero, it will free the data and return a failure.
		 *
		 * This convenience function is provided and used to help us avoid a common
		 * mistake pattern when we could pass in a zero, catch the NULL return and end
		 * up free'ing the memory twice.
		 *
		 * Returns the new pointer or NULL on failure.
		 *
		 ***************************************************************************/;
	}
	public static Object Curl_saferealloc(Object ptr, Object size) {
		Object datap = .Curl_crealloc(ptr, size);
		if (size && !datap) {
			.Curl_cfree(/* only free 'ptr' if size was non-zero */ptr);
		} 
		return datap;
	}
	public static  output_expected(Object url, Object uploadfile) {
		if (!uploadfile) {
			return /* download */1;
		} 
		if (ModernizedCProgram.curl_strnequal("http://", url, .strlen("http://")) || ModernizedCProgram.curl_strnequal("https://", url, .strlen("https://"))) {
			return /* HTTP(S) upload */1;
		} 
		return /* non-HTTP upload, probably no output should be expected */0;
	}
	public static  stdin_upload(Object uploadfile) {
		return (!.strcmp(uploadfile, "-") || !.strcmp(uploadfile, ".")) ? 1 : 0/*
		 * Adds the file name to the URL if it doesn't already have one.
		 * url will be freed before return if the returned pointer is different
		 */;
	}
	public static Byte add_file_name_to_url(Byte url, Object filename) {
		byte ptr = .strstr(url, /* If no file name part is given in the URL, we add this file name */"://");
		Curl_easy curl_easy = new Curl_easy();
		 curl = curl_easy.curl_easy_init();
		if (!curl) {
			return ((Object)/* error! */0);
		} 
		if (ptr) {
			ptr += 3;
		} else {
				ptr = url;
		} 
		ptr = .strrchr(ptr, (byte)'/');
		if (!ptr || !.strlen(++ptr/* The URL has no file name part, add the local file name. In order
		       to be able to do so, we have to create a new URL in another
		       buffer.*/)) {
			byte filep = .strrchr(filename, /* We only want the part of the local path that is on the right
			       side of the rightmost slash and backslash. */(byte)'/');
			byte file2 = .strrchr(filep ? filep : filename, (byte)'\\');
			byte encfile;
			if (file2) {
				filep = file2 + 1;
			}  else if (filep) {
				filep++;
			} else {
					filep = filename;
			} 
			encfile = curl.curl_easy_escape(filep, /* URL encode the file name *//* use strlen */0);
			if (encfile) {
				byte urlbuffer;
				if (ptr) {
					urlbuffer = ModernizedCProgram.curl_maprintf("%s%s", url, /* there is a trailing slash on the URL */encfile);
				} else {
						urlbuffer = ModernizedCProgram.curl_maprintf("%s/%s", url, /* there is no trailing slash on the URL */encfile);
				} 
				ModernizedCProgram.curl_free(encfile);
				do {
					.free((url));
					(url) = ((Object)0);
				} while (0);
				if (!urlbuffer) {
					return ((Object)0);
				} 
				url = /* use our new URL instead! */urlbuffer;
			} else {
					do {
						.free((url));
						(url) = ((Object)0);
					} while (0);
			} 
		} 
		curl.curl_easy_cleanup();
		return url/* Extracts the name portion of the URL.
		 * Returns a pointer to a heap-allocated string or NULL if
		 * no name part, at location indicated by first argument.
		 */;
	}
	public static Object get_url_file_name(byte filename, Object url) {
		byte pc;
		byte pc2;
		filename = ((Object)0);
		pc = .strstr(url, /* Find and get the remote file name */"://");
		if (pc) {
			pc += 3;
		} else {
				pc = url;
		} 
		pc2 = .strrchr(pc, (byte)'\\');
		pc = .strrchr(pc, (byte)'/');
		if (pc2 && (!pc || pc < pc2)) {
			pc = pc2;
		} 
		if (pc) {
			/* duplicate the string beyond the slash */pc++;
		} else {
				pc = /* no slash => empty string */"";
		} 
		filename = .strdup(pc);
		if (!filename) {
			return CURLE_OUT_OF_MEMORY;
		} 
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, filename, 0);
			do {
				.free((filename));
				(filename) = ((Object)0);
			} while (0);
			if (sc) {
				return CURLE_URL_MALFORMAT;
			} 
			filename = sanitized/* MSDOS || WIN32 *//* in case we built debug enabled, we allow an environment variable
			   * named CURL_TESTDIR to prefix the given file name to put it into a
			   * specific directory
			   */;
		}
		/* suitably large */return /* clone the buffer */CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * CA cert in memory with OpenSSL to get a HTTPS page.
	 * </DESC>
	 */
	public static Object writefunction(Object ptr, Object size, Object nmemb, Object stream) {
		.fwrite(ptr, size, nmemb, (FILE)stream);
		return (nmemb * size);
		.fwrite(ptr, size, nmemb, stream);
		return (nmemb * size);
	}
	public static Object sslctx_function(Object curl, Object sslctx, Object parm) {
		 rv = CURLE_ABORTED_BY_CALLBACK;
		/** This example uses two (fake) certificates **/byte[] mypem = "-----BEGIN CERTIFICATE-----\nMIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UE\nAwwJQUNDVlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQsw\nCQYDVQQGEwJFUzAeFw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQ\nBgNVBAMMCUFDQ1ZSQUlaMTEQMA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUND\nVjELMAkGA1UEBhMCRVMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCb\nqau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPfmt4ftVTdFXxpNRFvu8gMjmoY\nHtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM3802/J+Nq2DoLSRYWo\nG2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkXhBilyNpA\n0KIV9VMJcRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eH\nk6fGioozl2A3ED6XPm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/47\nJyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/+QEnWCzI7UiRfD+m\nAM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA9j9ajepD\nvV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms\ntn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH\n7ehVRE2I9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5h\nI6zppSSMEYCUWqKiuUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szA\nh1xA2syVP1XgNce4hL60Xc16gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xF\nd3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2H\npPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbRD0tVNEYqi4Y7\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFtTCCA52gAwIBAgIIYY3HhjsBggUwDQYJKoZIhvcNAQEFBQAwRDEWMBQGA1UE\nAwwNQUNFRElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00x\nCzAJBgNVBAYTAkVTMB4XDTA4MDQxODE2MjQyMloXDTI4MDQxMzE2MjQyMlowRDEW\nMBQGA1UEAwwNQUNFRElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZF\nRElDT00xCzAJBgNVBAYTAkVTMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKC\nAgEA/5KV4WgGdrQsyFhIyv2AVClVYyT/kGWbEHV7w2rbYgIB8hiGtXxaOLHkWLn7\n09gtn70yN78sFW2+tfQh0hOR2QetAQXW8713zl9CgQr5auODAKgrLlUTY4HKRxx7\nXBZXehuDYAQ6PmXDzQHe3qTWDLqO3tkE7hdWIpuPY/1NFgu3e3eM+SW10W2ZEi5P\ngvoFNTPhNahXwOf9jU8/kzJPeGYDdwdY6ZXIfj7QeQCM8htRM5u8lOk6e25SLTKe\nI6RF+7YuE7CLGLHdztUdp0J/Vb77W7tH1PwkzQSulgUV1qzOMPPKC8W64iLgpq0i\n5ALudBF/TP94HTXa5gI06xgSYXcGCRZj6hitoocf8seACQl1ThCojz2GuHURwCRi\nipZ7SkXp7FnFvmuD5uHorLUwHv4FB4D54SMNUI8FmP8sX+g7tq3PgbUhh8oIKiMn\nMCArz+2UW6yyetLHKKGKC5tNSixthT8Jcjxn4tncB7rrZXtaAWPWkFtPF2Y9fwsZ\no5NjEFIqnxQWWOLcpfShFosOkYuByptZ+thrkQdlVV9SH686+5DdaaVbnG0OLLb6\nzqylfDJKZ0DcMDQj3dcEI2bw/FWAp/tmGYI1Z2JwOV5vx+qQQEQIHriy1tvuWacN\nGHk0vFQYXlPKNFHtRQrmjseCNj6nOGOpMCwXEGCSn1WHElkQwg9naRHMTh5+Spqt\nr0CodaxWkHS4oJyleW/c6RrIaQXpuvoDs3zk4E7Czp3otkYNbn5XOmeUwssfnHdK\nZ05phkOTOPu220+DkdRgfks+KzgHVZhepA==\n-----END CERTIFICATE-----\n";
		 cbio = .BIO_new_mem_buf(mypem, );
		 cts = .SSL_CTX_get_cert_store(()sslctx);
		int i;
		.STACK_OF(X509_INFO) * inf;
		(Object)curl;
		(Object)parm;
		if (!cts || !cbio) {
			return rv;
		} 
		inf = .PEM_X509_INFO_read_bio(cbio, ((Object)0), ((Object)0), ((Object)0));
		if (!inf) {
			.BIO_free(cbio);
			return rv;
		} 
		for (i = 0; i < .sk_X509_INFO_num(inf); i++) {
			 itmp = .sk_X509_INFO_value(inf, i);
			if (itmp.getX509()) {
				.X509_STORE_add_cert(cts, itmp.getX509());
			} 
			if (itmp.getCrl()) {
				.X509_STORE_add_crl(cts, itmp.getCrl());
			} 
		}
		.sk_X509_INFO_pop_free(inf, X509_INFO_free);
		.BIO_free(cbio);
		rv = CURLE_OK;
		return rv;
		 cert = ((Object)0);
		 bio = ((Object)0);
		 kbio = ((Object)0);
		 rsa = ((Object)0);
		int ret;
		/* www.cacert.org */byte mypem = "-----BEGIN CERTIFICATE-----\nMIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290\nIENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB\nIENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA\nY2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO\nBgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi\nMCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ\nARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC\nCgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ\n8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6\nzWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y\nfk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7\nw2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc\nG8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k\nepKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q\nlaegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ\nQUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU\nfslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826\nYreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w\nggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY\ngBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe\nMBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0\nIFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy\ndC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw\nczovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0\ndHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl\naHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC\nAQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg\nb3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB\nACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc\nnWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg\n18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c\ngr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl\nJzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY\nsONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T\nSCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF\nCpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum\nGCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk\nzk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW\nomTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD\n-----END CERTIFICATE-----\n";
		/*replace the XXX with the actual RSA key*/byte mykey = "-----BEGIN RSA PRIVATE KEY-----\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n-----END RSA PRIVATE KEY-----\n";
		(Object)/* avoid warnings */curl;
		(Object)/* avoid warnings */parm;
		bio = .BIO_new_mem_buf((byte)mypem, -/* get a BIO */1);
		if (bio == ((Object)0)) {
			.printf("BIO_new_mem_buf failed\n");
		} 
		cert = .PEM_read_bio_X509(bio, ((Object)0), 0, ((Object)/* use it to read the PEM formatted certificate from memory into an X509
		   * structure that SSL can use
		   */0));
		if (cert == ((Object)0)) {
			.printf("PEM_read_bio_X509 failed...\n");
		} 
		ret = .SSL_CTX_use_certificate(()sslctx, /*tell SSL to use the X509 certificate*/cert);
		if (ret != 1) {
			.printf("Use certificate failed\n");
		} 
		kbio = .BIO_new_mem_buf((byte)mykey, -/*create a bio for the RSA key*/1);
		if (kbio == ((Object)0)) {
			.printf("BIO_new_mem_buf failed\n");
		} 
		rsa = .PEM_read_bio_RSAPrivateKey(kbio, ((Object)0), 0, ((Object)/*read the key bio into an RSA object*/0));
		if (rsa == ((Object)0)) {
			.printf("Failed to create key bio\n");
		} 
		ret = .SSL_CTX_use_RSAPrivateKey(()sslctx, /*tell SSL to use the RSA key from memory*/rsa);
		if (ret != 1) {
			.printf("Use Key failed\n");
		} 
		if (/* free resources that have been allocated by openssl functions */bio) {
			.BIO_free(bio);
		} 
		if (kbio) {
			.BIO_free(kbio);
		} 
		if (rsa) {
			.RSA_free(rsa);
		} 
		if (cert) {
			.X509_free(cert);
		} 
		return /* all set to go */CURLE_OK;
	}
	public static Object tool_write_cb(Byte buffer, Object sz, Object nmemb, Object userdata) {
		size_t rc = new size_t();
		per_transfer per = userdata;
		OutStruct generatedOuts = per.getOuts();
		OutStruct outs = generatedOuts;
		OperationConfig generatedConfig = outs.getConfig();
		OperationConfig config = generatedConfig;
		size_t bytes = sz * nmemb;
		Object generatedOperationConfig = config.getOperationConfig();
		bool is_tty = generatedOperationConfig.getIsatty();
		CONSOLE_SCREEN_BUFFER_INFO console_info = new CONSOLE_SCREEN_BUFFER_INFO();
		intptr_t fhnd = new intptr_t();
		/*
		   * Once that libcurl has called back tool_write_cb() the returned value
		   * is checked against the amount that was intended to be written, if
		   * it does not match then it fails with CURLE_WRITE_ERROR. So at this
		   * point returning a value different from sz*nmemb indicates failure.
		   */
		size_t failure = bytes ? 0 : 1;
		/* Some internal congruency checks on received OutStruct */
		_iobuf generatedStream = outs.getStream();
		/* regular file *//* standard stream */if (!generatedStream && !outs.tool_create_output_file()) {
			return failure;
		} 
		Object generatedBytes = outs.getBytes();
		if (is_tty && (generatedBytes < 2000) && !generatedOperationConfig) {
			if (.memchr(buffer, 0, /* binary output to terminal? */bytes)) {
				generatedOperationConfig.warnf("Binary output can mess up your terminal. Use \"--output -\" to tell curl to output it to your terminal anyway, or consider \"--output <FILE>\" to save to a file.\n");
				config.setOperationConfig(.ERR_BINARY_TERMINAL);
				return failure;
			} 
		} 
		Object generated_file = (generatedStream).get_file();
		fhnd = ._get_osfhandle((generated_file));
		if (.isatty((generated_file)) && .GetConsoleScreenBufferInfo((HANDLE)fhnd, console_info)) {
			DWORD in_len = (DWORD)(sz * nmemb);
			wchar_t wc_buf = new wchar_t();
			DWORD wc_len = new DWORD();
			wc_len = .MultiByteToWideChar(65001, 0, buffer, in_len, ((Object)0), /* calculate buffer size for wide characters */0);
			wc_buf = (wchar_t).malloc(wc_len * );
			if (!wc_buf) {
				return failure;
			} 
			wc_len = .MultiByteToWideChar(65001, 0, buffer, in_len, wc_buf, /* calculate buffer size for multi-byte characters */wc_len);
			if (!wc_len) {
				.free(wc_buf);
				return failure;
			} 
			if (!.WriteConsoleW((HANDLE)fhnd, wc_buf, wc_len, wc_len, ((Object)0))) {
				.free(wc_buf);
				return failure;
			} 
			.free(wc_buf);
			rc = bytes;
		} else {
				rc = .fwrite(buffer, sz, nmemb, generatedStream);
		} 
		if (bytes == rc) {
			generatedBytes += /* we added this amount of data to the output */bytes;
		} 
		Object generatedCurl = per.getCurl();
		if (generatedOperationConfig) {
			config.setOperationConfig(0);
			generatedCurl.curl_easy_pause(CURLPAUSE_CONT);
		} 
		if (generatedOperationConfig) {
			int res = .fflush(generatedStream);
			if (ModernizedCProgram.res) {
				return failure;
			} 
		} 
		return rc;
	}
	/* MSVC extension, dllimport identity */
	/**
	 * curl_global_init() globally initializes curl given a bitwise set of the
	 * different features of what to initialize.
	 */
	public static Object global_init(long flags,  memoryfuncs) {
		if (ModernizedCProgram.initialized++) {
			return CURLE_OK;
		} 
		if (memoryfuncs) {
			ModernizedCProgram.Curl_cmalloc = (curl_malloc_callback)/* Setup the default memory functions here (again) */malloc;
			ModernizedCProgram.Curl_cfree = (curl_free_callback)free;
			ModernizedCProgram.Curl_crealloc = (curl_realloc_callback)realloc;
			ModernizedCProgram.Curl_cstrdup = (curl_strdup_callback)strdup;
			ModernizedCProgram.Curl_ccalloc = (curl_calloc_callback)calloc;
		} 
		if (!.Curl_ssl_init()) {
			do {
			} while (0);
			return CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.Curl_win32_init(flags)) {
			do {
			} while (0);
			return CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.Curl_resolver_global_init()) {
			do {
			} while (0);
			return CURLE_FAILED_INIT;
		} 
		(Object)0;
		if (flags & CURL_GLOBAL_ACK_EINTR) {
			ModernizedCProgram.Curl_ack_eintr = 1;
		} 
		ModernizedCProgram.init_flags = flags;
		ModernizedCProgram.Curl_version_init();
		return CURLE_OK/**
		 * curl_global_init() globally initializes curl given a bitwise set of the
		 * different features of what to initialize.
		 */;
	}
	public static Object curl_global_init(long flags) {
		return ModernizedCProgram.global_init(flags, 1/*
		 * curl_global_init_mem() globally initializes curl and also registers the
		 * user provided callback routines.
		 */);
	}
	public static Object curl_global_init_mem(long flags, Object m, Object f, Object r, Object s, Object c) {
		if (!m || !f || !r || !s || !/* Invalid input, return immediately */c) {
			return CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.initialized/* Already initialized, don't do it again, but bump the variable anyway to
		       work like curl_global_init() and require the same amount of cleanup
		       calls. */) {
			ModernizedCProgram.initialized++;
			return CURLE_OK;
		} 
		ModernizedCProgram.Curl_cmalloc = /* set memory functions before global_init() in case it wants memory
		     functions */m;
		ModernizedCProgram.Curl_cfree = f;
		ModernizedCProgram.Curl_cstrdup = s;
		ModernizedCProgram.Curl_crealloc = r;
		ModernizedCProgram.Curl_ccalloc = c;
		return ModernizedCProgram.global_init(flags, /* Call the actual init function, but without setting */0/**
		 * curl_global_cleanup() globally cleanups curl, uses the value of
		 * "init_flags" to determine what needs to be cleaned up and what doesn't.
		 */);
	}
	public static void curl_global_cleanup() {
		if (!ModernizedCProgram.initialized) {
			return ;
		} 
		if (--ModernizedCProgram.initialized) {
			return ;
		} 
		.Curl_ssl_cleanup();
		ModernizedCProgram.Curl_resolver_global_cleanup();
		ModernizedCProgram.Curl_win32_cleanup(ModernizedCProgram.init_flags);
		do {
		} while (0);
		;
		ModernizedCProgram.init_flags = 0/*
		 * curl_easy_init() is the external interface to alloc, setup and init an
		 * easy handle that is returned. If anything goes wrong, NULL is returned.
		 */;
	}
	public static Object easy_connection(Curl_easy data, Object sfd, connectdata connp) {
		if (data == ((Object)0)) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		Object generatedSet = data.getSet();
		if (!generatedSet.getConnect_only()) {
			data.Curl_failf("CONNECT_ONLY is required!");
			return CURLE_UNSUPPORTED_PROTOCOL;
		} 
		sfd = ModernizedCProgram.Curl_getconnectinfo(data, connp);
		if (sfd == CURL_SOCKET_BAD) {
			data.Curl_failf("Failed to get recent socket");
			return CURLE_UNSUPPORTED_PROTOCOL;
		} 
		return CURLE_OK/*
		 * Receives data from the connected socket. Use after successful
		 * curl_easy_perform() with CURLOPT_CONNECT_ONLY option.
		 * Returns CURLE_OK on success, error code on error.
		 */;
	}
	/* Traverse the document tree */
	public static void dumpNode(Object doc, Object tnod, int indent) {
		 child = new ();
		for (child = .tidyGetChild(tnod); child; child = .tidyGetNext(child)) {
			 name = .tidyNodeGetName(child);
			if (ModernizedCProgram.name/* if it has a name, then it's an HTML tag ... */) {
				 attr = new ();
				.printf("%*.*s%s ", indent, indent, "<", ModernizedCProgram.name);
				for (attr = .tidyAttrFirst(child); attr; attr = .tidyAttrNext(/* walk the attribute list */attr)) {
					.printf(.tidyAttrName(attr));
					.tidyAttrValue(attr) ? .printf("=\"%s\" ", .tidyAttrValue(attr)) : .printf(" ");
				}
				.printf(">\n");
			} else {
					 buf = new ();
					.tidyBufInit(ModernizedCProgram.buf);
					.tidyNodeGetText(doc, child, ModernizedCProgram.buf);
					.printf("%*.*s\n", indent, indent, ModernizedCProgram.buf.getBp() ? (byte)ModernizedCProgram.buf.getBp() : "");
					.tidyBufFree(ModernizedCProgram.buf);
			} 
			ModernizedCProgram.dumpNode(doc, child, indent + /* recursive */4);
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	public static void hash_element_dtor(Object user, Object element) {
		curl_hash h = (curl_hash)user;
		curl_hash_element e = (curl_hash_element)element;
		Object generatedPtr = e.getPtr();
		if (generatedPtr) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedPtr);
			e.setPtr(((Object)0));
		} 
		e.setKey_len(0);
		.Curl_cfree(e/* Initializes a hash structure.
		 * Return 1 on error, 0 is fine.
		 *
		 * @unittest: 1602
		 * @unittest: 1603
		 */);
	}
	public static Object Curl_hash_str(Object key, Object key_length, Object slots_num) {
		byte key_str = (byte)key;
		byte end = key_str + key_length;
		size_t h = 5381;
		while (key_str < end) {
			h += h << 5;
			h ^=  key_str++;
		}
		return (h % slots_num);
	}
	public static Object Curl_str_key_compare(Object k1, Object key1_len, Object k2, Object key2_len) {
		if ((key1_len == key2_len) && !.memcmp(k1, k2, key1_len)) {
			return 1;
		} 
		return 0;
	}
	public static void Curl_hash_start_iterate(curl_hash hash, curl_hash_iterator iter) {
		iter.setHash(hash);
		iter.setSlot_index(0);
		iter.setCurrent_element(((Object)0));
	}
	public static Object readcallback(Object ptr, Object size, Object nmemb, Object clientp) {
		int counter = (int)clientp;
		if (counter) {
			(_iob[2]).curl_mfprintf(/* only do this once and then require a clearing of this */"READ ALREADY DONE!\n");
			return 0;
		} 
		(/* bump */counter)++;
		if (size * nmemb > .strlen(ModernizedCProgram.uploadthis)) {
			(_iob[2]).curl_mfprintf("READ!\n");
			.strcpy(ptr, ModernizedCProgram.uploadthis);
			return .strlen(ModernizedCProgram.uploadthis);
		} 
		(_iob[2]).curl_mfprintf("READ NOT FINE!\n");
		return 0;
		int counter = (int)clientp;
		if (counter) {
			(_iob[2]).curl_mfprintf(/* only do this once and then require a clearing of this */"READ ALREADY DONE!\n");
			return 0;
		} 
		(/* bump */counter)++;
		if (size * nmemb > .strlen("this is the blurb we want to upload\n")) {
			(_iob[2]).curl_mfprintf("READ!\n");
			.strcpy(ptr, "this is the blurb we want to upload\n");
			return .strlen("this is the blurb we want to upload\n");
		} 
		(_iob[2]).curl_mfprintf("READ NOT FINE!\n");
		return 0;
	}
	public static Object ioctlcallback(Object handle, int cmd, Object clientp) {
		int counter = (int)clientp;
		(Object)/* unused */handle;
		if (cmd == CURLIOCMD_RESTARTREAD) {
			(_iob[2]).curl_mfprintf("REWIND!\n");
			counter = /* clear counter to make the read callback restart */0;
		} 
		return CURLIOE_OK;
		int counter = (int)clientp;
		(Object)/* unused */handle;
		if (cmd == CURLIOCMD_RESTARTREAD) {
			(_iob[2]).curl_mfprintf("REWIND!\n");
			counter = /* clear counter to make the read callback restart */0;
		} 
		return CURLIOE_OK;
	}
	public static void MD5_Init() {
		Object generatedHCryptProv = this.getHCryptProv();
		Object generatedHHash = this.getHHash();
		if (.CryptAcquireContextA(generatedHCryptProv, ((Object)0), ((Object)0), 1, -1024)) {
			.CryptCreateHash(generatedHCryptProv, (32768 | 0 | 3), 0, 0, generatedHHash);
		} 
	}
	public static void MD5_Update(Object input, int inputLen) {
		Object generatedHHash = this.getHHash();
		.CryptHashData(generatedHHash, (byte)input, inputLen, 0);
	}
	public static void MD5_Final(Byte digest) {
		long length = 0;
		Object generatedHHash = this.getHHash();
		.CryptGetHashParam(generatedHHash, 2, ((Object)0), length, 0);
		if (length == 16) {
			.CryptGetHashParam(generatedHHash, 2, digest, length, 0);
		} 
		if (generatedHHash) {
			.CryptDestroyHash(generatedHHash);
		} 
		Object generatedHCryptProv = this.getHCryptProv();
		if (generatedHCryptProv) {
			.CryptReleaseContext(generatedHCryptProv, 0/* When no other crypto library is available we use this code segment *//*
			 * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
			 * MD5 Message-Digest Algorithm (RFC 1321).
			 *
			 * Homepage:
			 https://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
			 *
			 * Author:
			 * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
			 *
			 * This software was written by Alexander Peslyak in 2001.  No copyright is
			 * claimed, and the software is hereby placed in the public domain.
			 * In case this attempt to disclaim copyright and place the software in the
			 * public domain is deemed null and void, then the software is
			 * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the
			 * general public under the following terms:
			 *
			 * Redistribution and use in source and binary forms, with or without
			 * modification, are permitted.
			 *
			 * There's ABSOLUTELY NO WARRANTY, express or implied.
			 *
			 * (This is a heavily cut-down "BSD license".)
			 *
			 * This differs from Colin Plumb's older public domain implementation in that
			 * no exactly 32-bit integer data type is required (any 32-bit or wider
			 * unsigned integer data type will do), there's no compile-time endianness
			 * configuration, and the function prototypes match OpenSSL's.  No code from
			 * Colin Plumb's implementation has been reused; this comment merely compares
			 * the properties of the two independent implementations.
			 *
			 * The primary goals of this implementation are portability and ease of use.
			 * It is meant to be fast, but not as fast as possible.  Some known
			 * optimizations are not included to reduce source code size and avoid
			 * compile-time configuration.
			 */);
		} 
	}
	/*
	 * @unittest: 1601
	 */
	/* 16 bytes */
	public static void Curl_md5it(Byte outbuffer, Object input) {
		MD5_CTX ctx = new MD5_CTX();
		ctx.MD5_Init();
		ctx.MD5_Update(input, ModernizedCProgram.curlx_uztoui(.strlen((byte)input)));
		ctx.MD5_Final(outbuffer);
	}
	public static  Curl_MD5_init(Object md5params) {
		MD5_context ctxt = new MD5_context();
		ctxt = .Curl_cmalloc();
		if (!ctxt) {
			return ctxt;
		} 
		ctxt.setMd5_hashctx(.Curl_cmalloc(md5params.getMd5_ctxtsize()));
		Object generatedMd5_hashctx = ctxt.getMd5_hashctx();
		if (!generatedMd5_hashctx) {
			.Curl_cfree(ctxt);
			return ((Object)0);
		} 
		ctxt.setMd5_hash(md5params);
		.UNRECOGNIZEDFUNCTIONNAME(generatedMd5_hashctx);
		return ctxt;
	}
	public static Object Curl_MD5_update(Object data, int len) {
		Object generatedMd5_hashctx = this.getMd5_hashctx();
		.UNRECOGNIZEDFUNCTIONNAME(generatedMd5_hashctx, data, len);
		return CURLE_OK;
	}
	public static Object Curl_MD5_final(Byte result) {
		Object generatedMd5_hashctx = this.getMd5_hashctx();
		.UNRECOGNIZEDFUNCTIONNAME(result, generatedMd5_hashctx);
		.Curl_cfree(generatedMd5_hashctx);
		.Curl_cfree(context);
		return CURLE_OK/* CURL_DISABLE_CRYPTO_AUTH */;
	}
	public static Object my_fwrite(Object buffer, Object size, Object nmemb, Object stream) {
		FtpFile out = (FtpFile)stream;
		_iobuf generatedStream = out.getStream();
		Object generatedFilename = out.getFilename();
		if (!generatedStream) {
			out.setStream(.fopen(generatedFilename, /* open file for writing */"wb"));
			if (!generatedStream) {
				return -/* failure, can't open file to write */1;
			} 
		} 
		return .fwrite(buffer, size, nmemb, generatedStream);
		FtpFile out = (FtpFile)stream;
		_iobuf generatedStream = out.getStream();
		Object generatedFilename = out.getFilename();
		if (!generatedStream) {
			out.setStream(.fopen(generatedFilename, /* open file for writing */"wb"));
			if (!generatedStream) {
				return -/* failure, can't open file to write */1;
			} 
		} 
		return .fwrite(buffer, size, nmemb, generatedStream);
		FtpFile out = (FtpFile)stream;
		_iobuf generatedStream = out.getStream();
		Object generatedFilename = out.getFilename();
		if (!generatedStream) {
			out.setStream(.fopen(generatedFilename, /* open file for writing */"wb"));
			if (!generatedStream) {
				return -/* failure, can't open file to write */1;
			} 
		} 
		return .fwrite(buffer, size, nmemb, generatedStream);
	}
	public static int resolver_alloc_cb_fail(Object resolver_state, Object reserved, Object userdata) {
		(Object)resolver_state;
		(Object)reserved;
		ModernizedCProgram.cb_count++;
		if (.strcmp(userdata, ModernizedCProgram.TEST_DATA_STRING)) {
			(_iob[2]).curl_mfprintf("Invalid test data received");
			.exit(1);
		} 
		return 1;
	}
	public static int resolver_alloc_cb_pass(Object resolver_state, Object reserved, Object userdata) {
		(Object)resolver_state;
		(Object)reserved;
		ModernizedCProgram.cb_count++;
		if (.strcmp(userdata, ModernizedCProgram.TEST_DATA_STRING)) {
			(_iob[2]).curl_mfprintf("Invalid test data received");
			.exit(1);
		} 
		return 0;
	}
	/* Set mime part name, taking care of non nul-terminated name string. */
	public static Object setname(Object part, Object name, Object len) {
		byte zname;
		 res = new ();
		if (!name || !len) {
			return ModernizedCProgram.curl_mime_name(part, name);
		} 
		zname = .Curl_cmalloc(len + 1);
		if (!zname) {
			return CURLE_OUT_OF_MEMORY;
		} 
		.memcpy(zname, name, len);
		zname[len] = (byte)'\0';
		res = ModernizedCProgram.curl_mime_name(part, zname);
		.Curl_cfree(zname);
		return res/*
		 * Curl_getformdata() converts a linked list of "meta data" into a mime
		 * structure. The input list is in 'post', while the output is stored in
		 * mime part at '*finalform'.
		 *
		 * This function will not do a failf() for the potential memory failures but
		 * should for all other errors it spots. Just note that this function MAY get
		 * a NULL pointer in the 'data' argument.
		 */;
	}
	public static Object Curl_getformdata(Curl_easy data, Object finalform, curl_httppost post, Object fread_func) {
		 result = CURLE_OK;
		 form = ((Object)0);
		 part = new ();
		curl_httppost file = new curl_httppost();
		ModernizedCProgram.Curl_mime_cleanpart(/* default form is empty */finalform);
		if (!post) {
			return /* no input => no output! */result;
		} 
		form = data.curl_mime_init();
		if (!form) {
			result = CURLE_OUT_OF_MEMORY;
		} 
		if (!result) {
			result = ModernizedCProgram.curl_mime_subparts(finalform, form);
		} 
		Object generatedCurl_httppost = post.getCurl_httppost();
		for (; !result && post; post = generatedCurl_httppost) {
			 multipart = /* If we have more than a file here, create a mime subpart and fill it. */form;
			if (generatedCurl_httppost) {
				part = ModernizedCProgram.curl_mime_addpart(form);
				if (!part) {
					result = CURLE_OUT_OF_MEMORY;
				} 
				if (!result) {
					result = ModernizedCProgram.setname(part, generatedCurl_httppost, generatedCurl_httppost);
				} 
				if (!result) {
					multipart = data.curl_mime_init();
					if (!multipart) {
						result = CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!result) {
					result = ModernizedCProgram.curl_mime_subparts(part, multipart);
				} 
			} 
			for (file = post; !result && file; file = generatedCurl_httppost) {
				part = ModernizedCProgram.curl_mime_addpart(/* Create the part. */multipart);
				if (!part) {
					result = CURLE_OUT_OF_MEMORY;
				} 
				if (!/* Set the headers. */result) {
					result = generatedCurl_httppost.curl_mime_headers(part, 0);
				} 
				if (!result && generatedCurl_httppost) {
					result = ModernizedCProgram.curl_mime_type(part, generatedCurl_httppost);
				} 
				if (!result && !generatedCurl_httppost) {
					result = ModernizedCProgram.setname(part, generatedCurl_httppost, generatedCurl_httppost);
				} 
				if (!/* Process contents. */result) {
					 clen = generatedCurl_httppost;
					if (generatedCurl_httppost & CURL_HTTPPOST_LARGE) {
						clen = generatedCurl_httppost;
					} 
					if (!clen) {
						clen = -1;
					} 
					if (generatedCurl_httppost & (CURL_HTTPPOST_FILENAME | CURL_HTTPPOST_READFILE)) {
						if (!.strcmp(generatedCurl_httppost, "-"/* There are a few cases where the code below won't work; in
						               particular, freopen(stdin) by the caller is not guaranteed
						               to result as expected. This feature has been kept for backward
						               compatibility: use of "-" pseudo file name should be avoided. */)) {
							result = ModernizedCProgram.curl_mime_data_cb(part, (ModernizedCProgram.curl_off_t) - 1, ()ModernizedCProgram.fread, ()(Object)(fseek), ((Object)0), (Object)(_iob[0]));
						} else {
								result = ModernizedCProgram.curl_mime_filedata(part, generatedCurl_httppost);
						} 
						if (!result && (generatedCurl_httppost & CURL_HTTPPOST_READFILE)) {
							result = ModernizedCProgram.curl_mime_filename(part, ((Object)0));
						} 
					}  else if (generatedCurl_httppost & CURL_HTTPPOST_BUFFER) {
						result = ModernizedCProgram.curl_mime_data(part, generatedCurl_httppost, generatedCurl_httppost ? generatedCurl_httppost : -1);
					}  else if (generatedCurl_httppost & CURL_HTTPPOST_CALLBACK/* the contents should be read with the callback and the size is set
					             with the contentslength */) {
						result = ModernizedCProgram.curl_mime_data_cb(part, clen, fread_func, ((Object)0), ((Object)0), generatedCurl_httppost);
					} else {
							result = ModernizedCProgram.curl_mime_data(part, generatedCurl_httppost, (ssize_t)clen/* Convert textual contents now. */);
					} 
				} 
				if (!result && generatedCurl_httppost) {
					if (generatedCurl_httppost || (generatedCurl_httppost & (CURL_HTTPPOST_FILENAME | CURL_HTTPPOST_BUFFER | CURL_HTTPPOST_CALLBACK))) {
						result = ModernizedCProgram.curl_mime_filename(part, generatedCurl_httppost);
					} 
				} 
			}
		}
		if (result) {
			ModernizedCProgram.Curl_mime_cleanpart(finalform);
		} 
		return result/* if disabled */;
	}
	/* 32 unsigned chars */
	public static void Curl_sha256it(Byte outbuffer, Object input) {
		SHA256_CTX ctx = new SHA256_CTX();
		ctx.SHA256_Init();
		ctx.SHA256_Update(input, ModernizedCProgram.curlx_uztoui(.strlen((byte)input)));
		ctx/* CURL_DISABLE_CRYPTO_AUTH */.SHA256_Final(outbuffer);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NTLM details:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 * https://www.innovation.ch/java/ntlm.html
	 */
	/* SSL backend-specific #if branches in this file must be kept in the order
	   documented in curl_ntlm_core. */
	/* for Curl_nss_force_init() */
	/* The last #include files should be: */
	/* "NTLMSSP" signature is always in ASCII regardless of the platform */
	/*
	 * ntlm_decode_type2_target()
	 *
	 * This is used to decode the "target info" in the NTLM type-2 message
	 * received.
	 *
	 * Parameters:
	 *
	 * data      [in]     - The session handle.
	 * buffer    [in]     - The decoded type-2 message.
	 * size      [in]     - The input buffer size, at least 32 bytes.
	 * ntlm      [in/out] - The NTLM data struct being used and modified.
	 *
	 * Returns CURLE_OK on success.
	 */
	public static Object ntlm_decode_type2_target(Curl_easy data, Byte buffer, Object size, ntlmdata ntlm) {
		int target_info_len = 0;
		int target_info_offset = 0;
		Object generatedTarget_info = ntlm.getTarget_info();
		if (size >= 48) {
			target_info_len = ModernizedCProgram.Curl_read16_le(buffer[40]);
			target_info_offset = ModernizedCProgram.Curl_read32_le(buffer[44]);
			if (target_info_len > 0) {
				if ((target_info_offset >= size) || ((target_info_offset + target_info_len) > size) || (target_info_offset < 48)) {
					data.Curl_infof("NTLM handshake failure (bad type-2 message). Target Info Offset Len is set incorrect by the peer\n");
					return CURLE_BAD_CONTENT_ENCODING;
				} 
				ntlm.setTarget_info(.Curl_cmalloc(target_info_len));
				if (!generatedTarget_info) {
					return CURLE_OUT_OF_MEMORY;
				} 
				.memcpy(generatedTarget_info, buffer[target_info_offset], target_info_len);
			} 
		} 
		ntlm.setTarget_info_len(target_info_len);
		return CURLE_OK/*
		  NTLM message structure notes:
		
		  A 'short' is a 'network short', a little-endian 16-bit unsigned value.
		
		  A 'long' is a 'network long', a little-endian, 32-bit unsigned value.
		
		  A 'security buffer' represents a triplet used to point to a buffer,
		  consisting of two shorts and one long:
		
		    1. A 'short' containing the length of the buffer content in bytes.
		    2. A 'short' containing the allocated space for the buffer in bytes.
		    3. A 'long' containing the offset to the start of the buffer in bytes,
		       from the beginning of the NTLM message.
		*/;
	}
	/*
	 * Curl_auth_is_ntlm_supported()
	 *
	 * This is used to evaluate if NTLM is supported.
	 *
	 * Parameters: None
	 *
	 * Returns TRUE as NTLM as handled by libcurl.
	 */
	public static  Curl_auth_is_ntlm_supported() {
		return 1/*
		 * Curl_auth_decode_ntlm_type2_message()
		 *
		 * This is used to decode an already encoded NTLM type-2 message. The message
		 * is first decoded from a base64 string into a raw NTLM message and checked
		 * for validity before the appropriate data for creating a type-3 message is
		 * written to the given NTLM data structure.
		 *
		 * Parameters:
		 *
		 * data     [in]     - The session handle.
		 * type2msg [in]     - The base64 encoded type-2 message.
		 * ntlm     [in/out] - The NTLM data struct being used and modified.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static Object Curl_auth_decode_ntlm_type2_message(Curl_easy data, Object type2msg, ntlmdata ntlm) {
		byte[] type2_marker = new byte[]{-1024, -1024, -1024, -1024/* NTLM type-2 message structure:
		
		          Index  Description            Content
		            0    NTLMSSP Signature      Null-terminated ASCII "NTLMSSP"
		                                        (0x4e544c4d53535000)
		            8    NTLM Message Type      long (0x02000000)
		           12    Target Name            security buffer
		           20    Flags                  long
		           24    Challenge              8 bytes
		          (32)   Context                8 bytes (two consecutive longs) (*)
		          (40)   Target Information     security buffer (*)
		          (48)   OS Version Structure   8 bytes (*)
		  32 (48) (56)   Start of data block    (*)
		                                        (*) -> Optional
		  */};
		 result = CURLE_OK;
		byte type2 = ((Object)0);
		size_t type2_len = 0/* Make sure the crypto backend is initialized */;
		if (.strlen(type2msg) && type2msg != /* Decode the base-64 encoded type-2 message */(byte)'=') {
			result = ModernizedCProgram.Curl_base64_decode(type2msg, type2, type2_len);
			if (result) {
				return result;
			} 
		} 
		if (!/* Ensure we have a valid type-2 message */type2) {
			data.Curl_infof("NTLM handshake failure (empty type-2 message)\n");
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		ntlm.setFlags(0);
		if ((type2_len < 32) || (.memcmp(type2, "\x4e\x54\x4c\x4d\x53\x53\x50", 8) != 0) || (.memcmp(type2 + 8, type2_marker, ) != 0)) {
			.Curl_cfree(/* This was not a good enough type-2 message */type2);
			data.Curl_infof("NTLM handshake failure (bad type-2 message)\n");
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		ntlm.setFlags(ModernizedCProgram.Curl_read32_le(type2[20]));
		Object generatedNonce = ntlm.getNonce();
		.memcpy(generatedNonce, type2[24], 8);
		int generatedFlags = ntlm.getFlags();
		if (generatedFlags & NTLMFLAG_NEGOTIATE_TARGET_INFO) {
			result = ModernizedCProgram.ntlm_decode_type2_target(data, type2, type2_len, ntlm);
			if (result) {
				.Curl_cfree(type2);
				data.Curl_infof("NTLM handshake failure (bad type-2 message)\n");
				return result;
			} 
		} 
		do {
		} while (0);
		.Curl_cfree(type2);
		return result;
	}
	/* copy the source to the destination and fill in zeroes in every
	   other destination byte! */
	public static void unicodecpy(Byte dest, Object src, Object length) {
		size_t i = new size_t();
		for (i = 0; i < length; i++) {
			dest[2 * i] = (byte)src[i];
			dest[2 * i + 1] = (byte)'\0'/*
			 * Curl_auth_create_ntlm_type1_message()
			 *
			 * This is used to generate an already encoded NTLM type-1 message ready for
			 * sending to the recipient using the appropriate compile time crypto API.
			 *
			 * Parameters:
			 *
			 * data    [in]     - The session handle.
			 * userp   [in]     - The user name in the format User or Domain\User.
			 * passwdp [in]     - The user's password.
			 * service [in]     - The service type such as http, smtp, pop or imap.
			 * host    [in]     - The host name.
			 * ntlm    [in/out] - The NTLM data struct being used and modified.
			 * outptr  [in/out] - The address where a pointer to newly allocated memory
			 *                    holding the result will be stored upon completion.
			 * outlen  [out]    - The length of the output message.
			 *
			 * Returns CURLE_OK on success.
			 */;
		}
	}
	public static Object Curl_auth_create_ntlm_type1_message(Curl_easy data, Object userp, Object passwdp, Object service, Object hostname, ntlmdata ntlm, Byte outptr, Object outlen) {
		size_t size = new size_t();
		byte[] ntlmbuf = new byte[NTLM_BUFSIZE];
		byte host = /* empty */"";
		byte domain = /* empty */"";
		size_t hostlen = 0;
		size_t domlen = 0;
		size_t hostoff = 0;
		size_t domoff = hostoff + /* This is 0: remember that host and
		                                         domain are empty */hostlen;
		(Object)userp;
		(Object)passwdp;
		;
		ModernizedCProgram.curl_msnprintf((byte)ntlmbuf, NTLM_BUFSIZE, "\x4e\x54\x4c\x4d\x53\x53\x50%c\x01%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%s%s"/* 32-bit type = 1 *//* 32-bit NTLM flag field *//* domain length *//* domain allocated space *//* domain name offset *//* 2 zeroes */, /* host length *//* host allocated space *//* host name offset *//* 2 zeroes *//* host name *//* domain string *//* trailing zero */0, 0, 0, /* part of type-1 long */0, ((int)((NTLMFLAG_NEGOTIATE_OEM | NTLMFLAG_REQUEST_TARGET | NTLMFLAG_NEGOTIATE_NTLM_KEY | 0 | NTLMFLAG_NEGOTIATE_ALWAYS_SIGN) & -1024)), ((int)(((NTLMFLAG_NEGOTIATE_OEM | NTLMFLAG_REQUEST_TARGET | NTLMFLAG_NEGOTIATE_NTLM_KEY | 0 | NTLMFLAG_NEGOTIATE_ALWAYS_SIGN) >> 8) & -1024)), ((int)(((NTLMFLAG_NEGOTIATE_OEM | NTLMFLAG_REQUEST_TARGET | NTLMFLAG_NEGOTIATE_NTLM_KEY | 0 | NTLMFLAG_NEGOTIATE_ALWAYS_SIGN) >> 16) & -1024)), ((int)(((NTLMFLAG_NEGOTIATE_OEM | NTLMFLAG_REQUEST_TARGET | NTLMFLAG_NEGOTIATE_NTLM_KEY | 0 | NTLMFLAG_NEGOTIATE_ALWAYS_SIGN) >> 24) & -1024)), ((int)((domlen) & -1024)), ((int)(((domlen) >> 8) & -1024)), ((int)((domlen) & -1024)), ((int)(((domlen) >> 8) & -1024)), ((int)((domoff) & -1024)), ((int)(((domoff) >> 8) & -1024)), 0, 0, ((int)((hostlen) & -1024)), ((int)(((hostlen) >> 8) & -1024)), ((int)((hostlen) & -1024)), ((int)(((hostlen) >> 8) & -1024)), ((int)((hostoff) & -1024)), ((int)(((hostoff) >> 8) & -1024)), 0, 0, /* this is empty */host, /* this is empty */domain);
		size = 32 + hostlen + /* Initial packet length */domlen;
		do {
		} while (0);
		return data.Curl_base64_encode((byte)ntlmbuf, size, outptr, /* Return with binary blob encoded into base64 */outlen/*
		 * Curl_auth_create_ntlm_type3_message()
		 *
		 * This is used to generate an already encoded NTLM type-3 message ready for
		 * sending to the recipient using the appropriate compile time crypto API.
		 *
		 * Parameters:
		 *
		 * data    [in]     - The session handle.
		 * userp   [in]     - The user name in the format User or Domain\User.
		 * passwdp [in]     - The user's password.
		 * ntlm    [in/out] - The NTLM data struct being used and modified.
		 * outptr  [in/out] - The address where a pointer to newly allocated memory
		 *                    holding the result will be stored upon completion.
		 * outlen  [out]    - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */);
	}
	public static Object Curl_auth_create_ntlm_type3_message(Curl_easy data, Object userp, Object passwdp, ntlmdata ntlm, Byte outptr, Object outlen) {
		 result = CURLE_OK;
		size_t size = new size_t();
		byte[] ntlmbuf = new byte[NTLM_BUFSIZE];
		int lmrespoff;
		byte[] lmresp = new byte[/* fixed-size */24];
		int ntrespoff;
		int ntresplen = 24;
		byte[] ntresp = new byte[/* fixed-size */24];
		byte ptr_ntresp = ntresp[0];
		byte ntlmv2resp = ((Object)0);
		int generatedFlags = ntlm.getFlags();
		bool unicode = (generatedFlags & NTLMFLAG_NEGOTIATE_UNICODE) ? 1 : 0;
		byte[] host = "";
		byte user;
		byte domain = "";
		size_t hostoff = 0;
		size_t useroff = 0;
		size_t domoff = 0;
		size_t hostlen = 0;
		size_t userlen = 0;
		size_t domlen = 0;
		user = .strchr(userp, (byte)'\\');
		if (!user) {
			user = .strchr(userp, (byte)'/');
		} 
		if (user) {
			domain = userp;
			domlen = (user - domain);
			user++;
		} else {
				user = userp;
		} 
		userlen = .strlen(user);
		if (ModernizedCProgram.Curl_gethostname(host, )) {
			data.Curl_infof("gethostname() failed, continuing without!\n");
			hostlen = 0;
		} else {
				hostlen = .strlen(host);
		} 
		Object generatedNonce = ntlm.getNonce();
		if (generatedFlags & NTLMFLAG_NEGOTIATE_NTLM2_KEY/* Need to create 8 bytes random data *//* 8 bytes random data as challenge in lmresp */) {
			byte[] ntbuffer = new byte[-1024];
			byte[] entropy = new byte[8];
			byte[] ntlmv2hash = new byte[-1024];
			result = ModernizedCProgram.Curl_rand(data, entropy, 8);
			if (result) {
				return result;
			} 
			result = data.Curl_ntlm_core_mk_nt_hash(passwdp, ntbuffer);
			if (result) {
				return result;
			} 
			result = ModernizedCProgram.Curl_ntlm_core_mk_ntlmv2_hash(user, userlen, domain, domlen, ntbuffer, ntlmv2hash);
			if (result) {
				return result;
			} 
			result = ModernizedCProgram.Curl_ntlm_core_mk_lmv2_resp(ntlmv2hash, /* LMv2 response */entropy, generatedNonce[0], lmresp);
			if (result) {
				return result;
			} 
			result = ntlm.Curl_ntlm_core_mk_ntlmv2_resp(ntlmv2hash, /* NTLMv2 response */entropy, ntlmv2resp, ntresplen);
			if (result) {
				return result;
			} 
			ptr_ntresp = ntlmv2resp/* We don't support NTLM2 if we don't have USE_NTRESPONSES */;
		} else {
				byte[] ntbuffer = new byte[/* End of NTLM2 Session code *//* NTLM v2 session security is a misnomer because it is not NTLM v2.
				       It is NTLM v1 using the extended session security that is also
				       in NTLM v2 */-1024];
				byte[] lmbuffer = new byte[-1024];
				result = data.Curl_ntlm_core_mk_nt_hash(passwdp, ntbuffer);
				if (result) {
					return result;
				} 
				ModernizedCProgram.Curl_ntlm_core_lm_resp(ntbuffer, generatedNonce[0], ntresp);
				result = data.Curl_ntlm_core_mk_lm_hash(passwdp, lmbuffer);
				if (result) {
					return result;
				} 
				ModernizedCProgram.Curl_ntlm_core_lm_resp(lmbuffer, generatedNonce[0], lmresp/* A safer but less compatible alternative is:
				     *   Curl_ntlm_core_lm_resp(ntbuffer, &ntlm->nonce[0], lmresp);
				     * See https://davenport.sourceforge.io/ntlm.html#ntlmVersion2 */);
		} 
		/* Pad with zeros *//* Fill tmp with challenge(nonce?) + entropy *//* We shall only use the first 8 bytes of md5sum, but the des code in
		         Curl_ntlm_core_lm_resp only encrypt the first 8 bytes */if (unicode) {
			domlen = domlen * 2;
			userlen = userlen * 2;
			hostlen = hostlen * 2;
		} 
		lmrespoff = /* size of the message header */64;
		ntrespoff = lmrespoff + -1024;
		domoff = ntrespoff + ntresplen;
		useroff = domoff + domlen;
		hostoff = useroff + userlen;
		size = ModernizedCProgram.curl_msnprintf((byte)ntlmbuf, /* Create the big type-3 message binary blob */NTLM_BUFSIZE, "\x4e\x54\x4c\x4d\x53\x53\x50%c\x03%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c"/* 32-bit type = 3 *//* LanManager length *//* LanManager allocated space *//* LanManager offset *//* 2 zeroes *//* NT-response length *//* NT-response allocated space *//* NT-response offset *//* 2 zeroes *//* domain length *//* domain allocated space *//* domain name offset *//* 2 zeroes *//* user length *//* user allocated space *//* user offset */, /* 2 zeroes *//* host length *//* host allocated space *//* host offset *//* 2 zeroes *//* session key length (unknown purpose) *//* session key allocated space (unknown purpose) *//* session key offset (unknown purpose) *//* 2 zeroes *//* flags *//* domain string *//* user string *//* host string *//* LanManager response *//* NT response *//* zero termination */0, 0, 0, /* type-3 long, the 24 upper bits */0, ((int)((true) & -1024)), ((int)(((true) >> 8) & /* LanManager response length, twice */-1024)), ((int)((true) & -1024)), ((int)(((true) >> 8) & -1024)), ((int)((lmrespoff) & -1024)), ((int)(((lmrespoff) >> 8) & -1024)), -1024, -1024, ((int)((ntresplen) & -1024)), ((int)(((ntresplen) >> 8) & /* NT-response length, twice */-1024)), ((int)((ntresplen) & -1024)), ((int)(((ntresplen) >> 8) & -1024)), ((int)((ntrespoff) & -1024)), ((int)(((ntrespoff) >> 8) & -1024)), -1024, -1024, ((int)((domlen) & -1024)), ((int)(((domlen) >> 8) & -1024)), ((int)((domlen) & -1024)), ((int)(((domlen) >> 8) & -1024)), ((int)((domoff) & -1024)), ((int)(((domoff) >> 8) & -1024)), -1024, -1024, ((int)((userlen) & -1024)), ((int)(((userlen) >> 8) & -1024)), ((int)((userlen) & -1024)), ((int)(((userlen) >> 8) & -1024)), ((int)((useroff) & -1024)), ((int)(((useroff) >> 8) & -1024)), -1024, -1024, ((int)((hostlen) & -1024)), ((int)(((hostlen) >> 8) & -1024)), ((int)((hostlen) & -1024)), ((int)(((hostlen) >> 8) & -1024)), ((int)((hostoff) & -1024)), ((int)(((hostoff) >> 8) & -1024)), -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, ((int)((generatedFlags) & -1024)), ((int)(((generatedFlags) >> 8) & -1024)), ((int)(((generatedFlags) >> 16) & -1024)), ((int)(((generatedFlags) >> 24) & -1024)));
		do {
		} while (0);
		do {
		} while (0);
		if (size < (NTLM_BUFSIZE - /* We append the binary hashes */-1024)) {
			.memcpy(ntlmbuf[size], lmresp, -1024);
			size += -1024;
		} 
		do {
		} while (0);
		if (ntresplen + size > ) {
			data.Curl_failf("incoming NTLM message too big");
			return CURLE_OUT_OF_MEMORY;
		} 
		do {
		} while (0);
		.memcpy(ntlmbuf[size], ptr_ntresp, ntresplen);
		size += ntresplen;
		do {
		} while (0);
		.Curl_cfree(/* Free the dynamic buffer allocated for NTLMv2 */ntlmv2resp);
		do {
		} while (0);
		if (size + userlen + domlen + hostlen >= /* Make sure that the domain, user and host strings fit in the
		     buffer before we copy them there. */NTLM_BUFSIZE) {
			data.Curl_failf("user + domain + host name too big");
			return CURLE_OUT_OF_MEMORY;
		} 
		do {
		} while (0);
		if (unicode) {
			ModernizedCProgram.unicodecpy(ntlmbuf[size], domain, domlen / 2);
		} else {
				.memcpy(ntlmbuf[size], domain, domlen);
		} 
		size += domlen;
		do {
		} while (0);
		if (unicode) {
			ModernizedCProgram.unicodecpy(ntlmbuf[size], user, userlen / 2);
		} else {
				.memcpy(ntlmbuf[size], user, userlen);
		} 
		size += userlen;
		do {
		} while (0);
		if (unicode) {
			ModernizedCProgram.unicodecpy(ntlmbuf[size], host, hostlen / 2);
		} else {
				.memcpy(ntlmbuf[size], host, hostlen);
		} 
		size += hostlen;
		result = ();
		if (result) {
			return CURLE_CONV_FAILED;
		} 
		result = data.Curl_base64_encode((byte)ntlmbuf, size, outptr, /* Return with binary blob encoded into base64 */outlen);
		ntlm.Curl_auth_cleanup_ntlm();
		return result/*
		 * Curl_auth_cleanup_ntlm()
		 *
		 * This is used to clean up the NTLM specific data.
		 *
		 * Parameters:
		 *
		 * ntlm    [in/out] - The NTLM data struct being cleaned up.
		 *
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Multi-threaded transfers sharing a single connection pool
	 * </DESC>
	 *
	 * This example fires up NUM_THREADS threads and in each single thread, it
	 * downloads the same fixed URL a URL_ITERATIONS number of times. The received
	 * data is just thrown away. It sets up a single shared object that holds the
	 * connection cache and all easy handles in all threads share that same cache.
	 *
	 * This example uses pthreads for threads and mutexes, but should be easy to
	 * modify to use different thread/mutex system should you want to.
	 *
	 */
	/*
	  URL to fetch. If you select HTTPS, you need to use a TLS backend with mutex
	  locks taken care of (OpenSSL 1.1.x, NSS, etc) or add SSL mutex callbacks!
	*/
	/* number of threads to fire up in parallel */
	/* how many times each URL is transferred per thread */
	public static Object write_db(Object ptr, Object size, Object nmemb, Object data) {
		(Object)/* not interested in the downloaded bytes, return the size *//* unused */ptr;
		(Object)/* unused */data;
		return (size_t)(size * nmemb);
	}
	public static void lock_cb(Object handle, Object data, Object access, Object userptr) {
		(Object)/* unused */access;
		(Object)/* unused */userptr;
		(Object)/* unused */handle;
		(Object)/* unused */data;
		.pthread_mutex_lock(ModernizedCProgram.connlock);
	}
	public static void unlock_cb(Object handle, Object data, Object userptr) {
		(Object)/* unused */userptr;
		(Object)/* unused */handle;
		(Object)/* unused */data;
		.pthread_mutex_unlock(ModernizedCProgram.connlock);
	}
	public static void init_locks() {
		.pthread_mutex_init(ModernizedCProgram.connlock, ((Object)0));
		int i;
		ModernizedCProgram.lockarray = (pthread_mutex_t).OPENSSL_malloc(.CRYPTO_num_locks() * );
		for (i = 0; i < .CRYPTO_num_locks(); i++) {
			.pthread_mutex_init((ModernizedCProgram.lockarray[i]), ((Object)0));
		}
		.CRYPTO_set_id_callback((long)thread_id);
		.CRYPTO_set_locking_callback((Object)lock_callback);
	}
	public static void kill_locks() {
		.pthread_mutex_destroy(ModernizedCProgram.connlock);
		int i;
		.CRYPTO_set_locking_callback(((Object)0));
		for (i = 0; i < .CRYPTO_num_locks(); i++) {
			.pthread_mutex_destroy((ModernizedCProgram.lockarray[i]));
		}
		.OPENSSL_free(ModernizedCProgram.lockarray);
	}
	public static Object run_thread(Object ptr) {
		initurl u = (initurl)ptr;
		int i;
		Curl_easy curl_easy = new Curl_easy();
		Object generatedUrl = u.getUrl();
		Object generatedShare = u.getShare();
		int generatedThreadno = u.getThreadno();
		for (i = 0; i < 11235; i++) {
			 curl = curl_easy.curl_easy_init();
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, generatedUrl);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SHARE, generatedShare);
			ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_db);
			/* ignores error */ModernizedCProgram.curl.curl_easy_perform();
			ModernizedCProgram.curl.curl_easy_cleanup();
			.fprintf((_iob[2]), "Thread %d transfer %d\n", generatedThreadno, i);
		}
		return ((Object)0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object opensocket(Object clientp, Object purpose, Object address) {
		(Object)purpose;
		(Object)address;
		(Object)clientp;
		(_iob[2]).curl_mfprintf("opensocket() returns CURL_SOCKET_BAD\n");
		return CURL_SOCKET_BAD;
		 sockfd = new ();
		(Object)purpose;
		(Object)address;
		sockfd = ()clientp/* the actual externally set socket is passed in via the OPENSOCKETDATA
		     option */;
		return sockfd;
		.fprintf(stdout, "\nopensocket :");
		curl_socket_t sockfd = CURL_SOCKET_BAD;
		int generatedFamily = address.getFamily();
		if (purpose == CURLSOCKTYPE_IPCXN && generatedFamily == /* restrict to IPv4 */AF_INET/* create a tcp socket object */) {
			socket tcp_socket = ;
			error_code ec = new error_code();
			.UNRECOGNIZEDFUNCTIONNAME(.v4(), ec);
			if (ec) {
				cout << endl << "Couldn't open socket [" << ec << /* An error occurred */"][" << .UNRECOGNIZEDFUNCTIONNAME() << "]";
				.fprintf(stdout, "\nERROR: Returning CURL_SOCKET_BAD to signal error");
			} else {
					sockfd = .UNRECOGNIZEDFUNCTIONNAME();
					.fprintf(stdout, "\nOpened socket %d", sockfd);
					.UNRECOGNIZEDFUNCTIONNAME(.pair(sockfd, tcp_socket));
			} 
		} 
		return sockfd;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2010, Mandy Wu, <mandy.wu@intel.com>
	 * Copyright (C) 2011 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * This is a fake ntlm_auth, which is used for testing NTLM single-sign-on.
	 * When DEBUGBUILD is defined, libcurl invoke this tool instead of real winbind
	 * daemon helper /usr/bin/ntlm_auth. This tool will accept commands and
	 * responses with a pre-written string saved in test case test2005.
	 */
	/* from the private lib dir */
	/* include memdebug.h last */
	/*
	 * Returns an allocated buffer with printable representation of input
	 * buffer contents or returns NULL on out of memory condition.
	 */
	public static Byte printable(Byte inbuf, Object inlength) {
		byte outbuf;
		byte newbuf;
		size_t newsize = new size_t();
		size_t outsize = new size_t();
		size_t outincr = 0;
		size_t i = new size_t();
		size_t o = 0;
		if (!inlength) {
			inlength = .strlen(inbuf);
		} 
		if (inlength) {
			outincr = ((inlength / 2) < (6 + 1)) ? 6 + 1 : inlength / 2;
			outsize = inlength + outincr;
		} else {
				outsize = 9 + 1;
		} 
		outbuf = .malloc(outsize);
		if (!outbuf) {
			return ((Object)0);
		} 
		if (!inlength) {
			ModernizedCProgram.curl_msnprintf(outbuf[0], outsize, "%s", "[NOTHING]");
			return outbuf;
		} 
		for (i = 0; i < inlength; i++) {
			if (o > outsize - (6 + 1)) {
				newsize = outsize + outincr;
				newbuf = .realloc(outbuf, newsize);
				if (!newbuf) {
					.free(outbuf);
					return ((Object)0);
				} 
				outbuf = newbuf;
				outsize = newsize;
			} 
			if ((inbuf[i] > -1024) && (inbuf[i] < -1024)) {
				outbuf[o] = inbuf[i];
				o++;
			} else {
					ModernizedCProgram.curl_msnprintf(outbuf[o], outsize - o, "[0x%02X]", inbuf[i]);
					o += 6;
			} 
		}
		outbuf[o] = (byte)'\0';
		return outbuf;
	}
	public static Object write_file(Object ptr, Object size, Object nmemb) {
		return .fwrite(ptr, size, nmemb, /* printf("write_file\n"); */stream);
	}
	/* https://weather.com/weather/today/l/46214?cc=*&dayf=5&unit=i */
	public static Object pull_one_url(Object NaN) {
		.pthread_mutex_lock(/* Stop threads from entering unless j is incremented */ModernizedCProgram.lock);
		Curl_easy curl_easy = new Curl_easy();
		while (ModernizedCProgram.j < ModernizedCProgram.num_urls) {
			 curl = new ();
			 http = new ();
			.printf("j = %d\n", ModernizedCProgram.j);
			http = .g_strdup_printf("xoap.weather.com/weather/local/%s?cc=*&dayf=5&unit=i\n", ModernizedCProgram.urls[ModernizedCProgram.j]);
			.printf("http %s", http);
			ModernizedCProgram.curl = curl_easy.curl_easy_init();
			if (ModernizedCProgram.curl) {
				FILE outfile = .fopen(ModernizedCProgram.urls[ModernizedCProgram.j], "wb");
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_URL, /* Set the URL and transfer type */http);
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEDATA, /* Write to the file */outfile);
				ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_file);
				/* critical line */ModernizedCProgram.j++;
				.pthread_mutex_unlock(ModernizedCProgram.lock);
				ModernizedCProgram.curl.curl_easy_perform();
				.fclose(outfile);
				.printf("fclose\n");
				ModernizedCProgram.curl.curl_easy_cleanup();
			} 
			.g_free(http);
			.sleep(/* Adds more latency, testing the mutex.*/1);
		}
		return ((Object)/* end while */0);
		 curl = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		curl.curl_easy_setopt(CURLOPT_URL, url);
		/* ignores error */curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		return ((Object)0/*
		   int pthread_create(pthread_t *new_thread_ID,
		   const pthread_attr_t *attr,
		   void * (*start_func)(void *), void *arg);
		*/);
		 curl = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		curl.curl_easy_setopt(CURLOPT_URL, url/* this example doesn't verify the server's certificate, which means we
		     might be downloading stuff from an impostor */);
		curl.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
		curl.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
		/* ignores error */curl.curl_easy_perform();
		curl.curl_easy_cleanup();
		return ((Object)0);
	}
	public static Object pulse_bar(Object data) {
		.gdk_threads_enter();
		.gtk_progress_bar_pulse(.GTK_PROGRESS_BAR(data));
		.gdk_threads_leave();
		return TRUE;
	}
	public static Object create_thread(Object progress_bar) {
		pthread_t[] tid = new pthread_t();
		int i;
		for (i = 0; i < 4 && i < ModernizedCProgram.num_urls; /* Make sure I don't create more threads than urls. */i++) {
			int error = .pthread_create(tid[i], ((Object)/* default attributes please */0), pull_one_url, ((Object)0));
			if (0 != error) {
				.fprintf((_iob[2]), "Couldn't run thread number %d, errno %d\n", i, error);
			} else {
					.fprintf((_iob[2]), "Thread %d, gets %s\n", i, ModernizedCProgram.urls[i]);
			} 
		}
		for (i = 0; i < 4 && i < ModernizedCProgram.num_urls; /* Wait for all threads to terminate. */i++) {
			.pthread_join(tid[i], ((Object)0));
			.fprintf((_iob[2]), "Thread %d terminated\n", i);
		}
		.g_source_remove(.GPOINTER_TO_INT(.g_object_get_data(.G_OBJECT(/* This stops the pulsing if you have it turned on in the progress bar
		     section */progress_bar), "pulse_id")));
		.gtk_widget_destroy(/* This destroys the progress bar */progress_bar/* [Un]Comment this out to kill the program rather than pushing close. */);
		return ((Object)/* gtk_main_quit(); */0);
	}
	public static Object cb_delete(Object window, Object data) {
		.gtk_main_quit();
		return FALSE;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * An example of curl_easy_send() and curl_easy_recv() usage.
	 * </DESC>
	 */
	/* Auxiliary function that waits on the socket. */
	public static int wait_on_socket(Object sockfd, int for_recv, long timeout_ms) {
		timeval tv = new timeval();
		 infd = new ();
		 outfd = new ();
		 errfd = new ();
		int res;
		tv.setTimeval(timeout_ms / 1000);
		tv.setTimeval((timeout_ms % 1000) * 1000);
		.FD_ZERO(infd);
		.FD_ZERO(outfd);
		.FD_ZERO(errfd);
		.FD_SET(sockfd, /* always check for error */errfd);
		if (for_recv) {
			.FD_SET(sockfd, infd);
		} else {
				.FD_SET(sockfd, outfd);
		} 
		res = .select((int)sockfd + 1, infd, outfd, errfd, /* select() returns the number of signalled sockets or -1 */tv);
		return res;
	}
	public static void Curl_llist_insert_next(curl_llist list, curl_llist_element e, Object p, curl_llist_element ne) {
		ne.setPtr((Object)p);
		Object generatedSize = list.getSize();
		curl_llist_element generatedHead = list.getHead();
		curl_llist_element generatedNext = e.getNext();
		if (generatedSize == 0) {
			list.setHead(ne);
			generatedHead.setPrev(((Object)0));
			generatedHead.setNext(((Object)0));
			list.setTail(ne);
		} else {
				ne.setNext(e ? generatedNext : generatedHead);
				ne.setPrev(e);
				if (!e) {
					generatedHead.setPrev(ne);
					list.setHead(ne);
				}  else if (generatedNext) {
					generatedNext.setPrev(ne);
				} else {
						list.setTail(ne);
				} 
				if (e) {
					e.setNext(ne);
				} 
		} 
		++generatedSize;
	}
	public static void Curl_llist_remove(curl_llist list, curl_llist_element e, Object user) {
		Object ptr;
		Object generatedSize = list.getSize();
		if (e == ((Object)0) || generatedSize == 0) {
			return ;
		} 
		curl_llist_element generatedHead = list.getHead();
		curl_llist_element generatedNext = e.getNext();
		curl_llist_element generatedPrev = e.getPrev();
		if (e == generatedHead) {
			list.setHead(generatedNext);
			if (generatedHead == ((Object)0)) {
				list.setTail(((Object)0));
			} else {
					generatedNext.setPrev(((Object)0));
			} 
		} else {
				if (!generatedPrev) {
					list.setHead(generatedNext);
				} else {
						generatedPrev.setNext(generatedNext);
				} 
				if (!generatedNext) {
					list.setTail(generatedPrev);
				} else {
						generatedNext.setPrev(generatedPrev);
				} 
		} 
		Object generatedPtr = e.getPtr();
		ptr = generatedPtr;
		e.setPtr(((Object)0));
		e.setPrev(((Object)0));
		e.setNext(((Object)0));
		--generatedSize;
		Object generatedDtor = list.getDtor();
		if (generatedDtor) {
			.UNRECOGNIZEDFUNCTIONNAME(user, ptr);
		} 
	}
	public static void Curl_llist_move(curl_llist list, curl_llist_element e, curl_llist to_list, curl_llist_element to_e) {
		Object generatedSize = list.getSize();
		if (e == ((Object)0) || generatedSize == /* Remove element from list */0) {
			return ;
		} 
		curl_llist_element generatedHead = list.getHead();
		curl_llist_element generatedNext = e.getNext();
		curl_llist_element generatedPrev = e.getPrev();
		if (e == generatedHead) {
			list.setHead(generatedNext);
			if (generatedHead == ((Object)0)) {
				list.setTail(((Object)0));
			} else {
					generatedNext.setPrev(((Object)0));
			} 
		} else {
				generatedPrev.setNext(generatedNext);
				if (!generatedNext) {
					list.setTail(generatedPrev);
				} else {
						generatedNext.setPrev(generatedPrev);
				} 
		} 
		--generatedSize;
		if (generatedSize == /* Add element to to_list after to_e */0) {
			to_list.setHead(e);
			generatedHead.setPrev(((Object)0));
			generatedHead.setNext(((Object)0));
			to_list.setTail(e);
		} else {
				e.setNext(generatedNext);
				e.setPrev(to_e);
				if (generatedNext) {
					generatedNext.setPrev(e);
				} else {
						to_list.setTail(e);
				} 
				to_e.setNext(e);
		} 
		++generatedSize;
	}
	public static Object Curl_disconnect(Curl_easy data, connectdata conn,  dead_connection) {
		if (!conn) {
			return /* this is closed and fine already */CURLE_OK;
		} 
		if (!data) {
			do {
			} while (0);
			return CURLE_OK/*
			   * If this connection isn't marked to force-close, leave it open if there
			   * are other users of it
			   */;
		} 
		curl_llist generatedEasyq = (conn).getEasyq();
		Object generatedSize = generatedEasyq.getSize();
		if ((generatedSize) && !dead_connection) {
			do {
			} while (0);
			return CURLE_OK;
		} 
		Curl_dns_entry generatedDns_entry = conn.getDns_entry();
		if (generatedDns_entry != ((Object)0)) {
			ModernizedCProgram.Curl_resolv_unlock(data, generatedDns_entry);
			conn.setDns_entry(((Object)0));
		} 
		/* kill old DNS cache entries */data.Curl_hostcache_prune();
		/* Cleanup NTLM connection-related data */conn/* Cleanup NEGOTIATE connection-related data */.Curl_http_auth_cleanup_ntlm();
		conn.setData(/* the protocol specific disconnect handler and conn_shutdown need a transfer
		     for the connection! */data);
		ConnectBits generatedBits = conn.getBits();
		Object generatedConnect_only = generatedBits.getConnect_only();
		if (generatedConnect_only) {
			dead_connection = /* treat the connection as dead in CONNECT_ONLY situations */1;
		} 
		Object generatedHandler = conn.getHandler();
		if (generatedHandler.getDisconnect()) {
			.UNRECOGNIZEDFUNCTIONNAME(conn, /* This is set if protocol-specific cleanups should be made */dead_connection);
		} 
		conn.conn_shutdown();
		conn.conn_free();
		return CURLE_OK/*
		 * This function should return TRUE if the socket is to be assumed to
		 * be dead. Most commonly this happens when the server has closed the
		 * connection due to inactivity.
		 */;
	}
	public static  SocketIsDead(Object sock) {
		int sval;
		bool ret_val = 1;
		sval = ModernizedCProgram.Curl_socket_check(sock, CURL_SOCKET_BAD, CURL_SOCKET_BAD, (time_t)0);
		if (sval == 0) {
			ret_val = /* timeout */0;
		} 
		return ret_val/*
		 * IsMultiplexingPossible()
		 *
		 * Return a bitmask with the available multiplexing options for the given
		 * requested connection.
		 */;
	}
	public static int IsMultiplexingPossible(Object handle, Object conn) {
		int avail = 0;
		if ((conn.getHandler().getProtocol() & (CURLPROTO_HTTP | /* If a HTTP protocol and multiplexing is enabled */CURLPROTO_HTTPS)) && (!conn.getBits().getProtoconnstart() || !conn.getBits().getClose())) {
			if (ModernizedCProgram.Curl_multiplex_wanted(handle.getMulti()) && (handle.getSet().getHttpversion() >= CURL_HTTP_VERSION_2)) {
				avail |=  /* allows HTTP/2 */CURLPIPE_MULTIPLEX;
			} 
		} 
		return avail;
	}
	public static  proxy_info_matches(Object data, Object needle) {
		if ((data.getProxytype() == needle.getProxytype()) && (data.getPort() == needle.getPort()) && ModernizedCProgram.Curl_safe_strcasecompare(data.getHost().getName(), needle.getHost().getName())) {
			return 1;
		} 
		return 0/* disabled, won't get called */;
	}
	/* A connection has to have been idle for a shorter time than 'maxage_conn' to
	   be subject for reuse. The success rate is just too low after this. */
	public static  conn_maxage(Curl_easy data, connectdata conn, curltime now) {
		Curl_easy generatedData = conn.getData();
		curltime generatedLastused = conn.getLastused();
		Object generatedSet = data.getSet();
		if (!generatedData) {
			timediff_t idletime = now.Curl_timediff(generatedLastused);
			idletime /= /* integer seconds is fine */1000;
			if (idletime > generatedSet.getMaxage_conn()) {
				data.Curl_infof("Too old connection (%ld seconds), disconnect it\n", idletime);
				return 1;
			} 
		} 
		return 0/*
		 * This function checks if the given connection is dead and extracts it from
		 * the connection cache if so.
		 *
		 * When this is called as a Curl_conncache_foreach() callback, the connection
		 * cache lock is held!
		 *
		 * Returns TRUE if the connection was dead and extracted.
		 */;
	}
	public static  extract_if_dead(connectdata conn, Curl_easy data) {
		curl_llist generatedEasyq = (conn).getEasyq();
		Object generatedSize = generatedEasyq.getSize();
		Curl_easy generatedData = conn.getData();
		curltime curltime = new curltime();
		Object generatedHandler = conn.getHandler();
		Object generatedSock = conn.getSock();
		long generatedConnection_id = conn.getConnection_id();
		if (!(generatedSize) && !generatedData) {
			bool dead = new bool();
			curltime now = curltime.Curl_now();
			if (ModernizedCProgram.conn_maxage(data, conn, now)) {
				dead = 1;
			}  else if (generatedHandler.getConnection_check()) {
				int state;
				Curl_easy olddata = generatedData;
				conn.setData(/* use this transfer for now */data);
				state = .UNRECOGNIZEDFUNCTIONNAME(conn, (1 << 0));
				conn.setData(olddata);
				dead = (state & (1 << 0));
			} else {
					dead = ModernizedCProgram.SocketIsDead(generatedSock[/* Use the general method for determining the death of a connection */0]);
			} 
			if (dead) {
				data.Curl_infof("Connection %ld seems to be dead!\n", generatedConnection_id);
				ModernizedCProgram.Curl_conncache_remove_conn(data, conn, 0);
				return 1;
			} 
		} 
		return 0;
	}
	public static  ConnectionExists(Curl_easy data, connectdata needle, connectdata usethis,  force_reuse,  waitpipe) {
		connectdata check = new connectdata();
		connectdata chosen = 0;
		bool foundPendingCandidate = 0;
		bool canmultiplex = ModernizedCProgram.IsMultiplexingPossible(data, needle);
		connectbundle bundle = new connectbundle();
		byte hostbundle;
		Object generatedState = data.getState();
		Object generatedHandler = needle.getHandler();
		bool wantNTLMhttp = ((generatedState.getAuthhost().getWant() & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) && (generatedHandler.getProtocol() & (CURLPROTO_HTTP | CURLPROTO_HTTPS)));
		ConnectBits generatedBits = needle.getBits();
		Object generatedProxy_user_passwd = generatedBits.getProxy_user_passwd();
		bool wantProxyNTLMhttp = (generatedProxy_user_passwd && ((generatedState.getAuthproxy().getWant() & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) && (generatedHandler.getProtocol() & (CURLPROTO_HTTP | CURLPROTO_HTTPS))));
		force_reuse = 0;
		waitpipe = 0;
		connectbundle connectbundle = new connectbundle();
		bundle = connectbundle.Curl_conncache_find_bundle(needle, generatedState.getConn_cache(), hostbundle);
		int generatedMultiuse = bundle.getMultiuse();
		Object generatedSet = data.getSet();
		Object generatedMulti = data.getMulti();
		curl_llist generatedConn_list = bundle.getConn_list();
		curl_llist_element generatedHead = generatedConn_list.getHead();
		Object generatedPtr = curr.getPtr();
		curl_llist_element generatedNext = curr.getNext();
		Object generatedConnect_only = generatedBits.getConnect_only();
		curl_llist generatedEasyq = (check).getEasyq();
		Object generatedSize = generatedEasyq.getSize();
		Object generatedProtoconnstart = generatedBits.getProtoconnstart();
		Object generatedClose = generatedBits.getClose();
		Object generatedIp_addr_str = check.getIp_addr_str();
		long generatedConnection_id = check.getConnection_id();
		Object generatedSock = check.getSock();
		Object generatedTls_upgraded = check.getTls_upgraded();
		Object generatedHttpproxy = generatedBits.getHttpproxy();
		Object generatedSocksproxy = generatedBits.getSocksproxy();
		proxy_info generatedSocks_proxy = needle.getSocks_proxy();
		Object generatedConn_to_host = generatedBits.getConn_to_host();
		Object generatedConn_to_port = generatedBits.getConn_to_port();
		proxy_info generatedHttp_proxy = needle.getHttp_proxy();
		Object generatedTunnel_proxy = generatedBits.getTunnel_proxy();
		Object generatedProxytype = generatedHttp_proxy.getProxytype();
		ssl_primary_config generatedProxy_ssl_config = needle.getProxy_ssl_config();
		ssl_primary_config generatedSsl_config = needle.getSsl_config();
		Curl_easy generatedData = check.getData();
		Byte generatedLocaldev = needle.getLocaldev();
		int generatedLocalport = needle.getLocalport();
		int generatedLocalportrange = check.getLocalportrange();
		Byte generatedUser = needle.getUser();
		Byte generatedPasswd = needle.getPasswd();
		hostname generatedHost = needle.getHost();
		Byte generatedName = generatedHost.getName();
		int generatedRemote_port = needle.getRemote_port();
		 generatedHttp_ntlm_state = check.getHttp_ntlm_state();
		 generatedProxy_ntlm_state = check.getProxy_ntlm_state();
		if (bundle/* Max pipe length is zero (unlimited) for multiplexed connections */) {
			curl_llist_element curr = new curl_llist_element();
			data.Curl_infof("Found bundle for host %s: %p [%s]\n", hostbundle, (Object)bundle, (generatedMultiuse == 2 ? "can multiplex" : "serially"));
			if (/* We can't multiplex if we don't know anything about the server */canmultiplex) {
				if (generatedMultiuse == 0) {
					if (generatedSet.getPipewait()) {
						data.Curl_infof("Server doesn't support multiplex yet, wait\n");
						waitpipe = 1;
						data.Curl_conncache_unlock();
						return /* no re-use */0;
					} 
					data.Curl_infof("Server doesn't support multiplex (yet)\n");
					canmultiplex = 0;
				} 
				if ((generatedMultiuse == 2) && !ModernizedCProgram.Curl_multiplex_wanted(generatedMulti)) {
					data.Curl_infof("Could multiplex, but not asked to!\n");
					canmultiplex = 0;
				} 
				if (generatedMultiuse == -1) {
					data.Curl_infof("Can not multiplex, even if we wanted to!\n");
					canmultiplex = 0;
				} 
			} 
			curr = generatedHead;
			while (curr) {
				bool match = 0;
				size_t multiplexed = new size_t();
				check = generatedPtr;
				curr = generatedNext;
				if (generatedConnect_only) {
					continue;
				} 
				multiplexed = (generatedSize) && (generatedMultiuse == 2);
				if (canmultiplex) {
					if (generatedProtoconnstart && generatedClose) {
						continue;
					} 
				} else {
						if (multiplexed/* can only happen within multi handles, and means that another easy
						             handle is using this connection */) {
							continue;
						} 
						if (1/* ip_addr_str[0] is NUL only if the resolving of the name hasn't
						             completed yet and until then we don't re-use this connection */) {
							if (!generatedIp_addr_str[0]) {
								data.Curl_infof("Connection #%ld is still name resolving, can't reuse\n", generatedConnection_id);
								continue;
							} 
						} 
						if ((generatedSock[0] == CURL_SOCKET_BAD) || generatedClose) {
							if (!generatedClose) {
								foundPendingCandidate = 1/* Don't pick a connection that hasn't connected yet or that is going
								             to get closed. */;
							} 
							data.Curl_infof("Connection #%ld isn't open enough, can't reuse\n", generatedConnection_id);
							continue;
						} 
				} 
				if ((generatedHandler.getFlags() & (1 << 0)) != (generatedHandler.getFlags() & (1 << 0))) {
					if (ModernizedCProgram.get_protocol_family(generatedHandler.getProtocol()) != generatedHandler.getProtocol() || !generatedTls_upgraded) {
						continue;
					} 
				} 
				if (generatedHttpproxy != generatedHttpproxy || generatedSocksproxy != generatedSocksproxy) {
					continue;
				} 
				if (generatedSocksproxy && !ModernizedCProgram.proxy_info_matches(generatedSocks_proxy, generatedSocks_proxy)) {
					continue;
				} 
				if (generatedConn_to_host != generatedConn_to_host) {
					continue;
				} 
				if (generatedConn_to_port != generatedConn_to_port) {
					continue;
				} 
				if (generatedHttpproxy) {
					if (!ModernizedCProgram.proxy_info_matches(generatedHttp_proxy, generatedHttp_proxy)) {
						continue;
					} 
					if (generatedTunnel_proxy != generatedTunnel_proxy) {
						continue;
					} 
					if (generatedProxytype == CURLPROXY_HTTPS) {
						if (generatedHandler.getFlags() & (1 << /* use https proxy */0)) {
							if (!generatedProxy_ssl_config.Curl_ssl_config_matches(generatedProxy_ssl_config)) {
								continue;
							} 
							if (generatedState != .ssl_connection_complete) {
								continue;
							} 
						} else {
								if (!generatedSsl_config.Curl_ssl_config_matches(generatedSsl_config)) {
									continue;
								} 
								if (generatedState != .ssl_connection_complete) {
									continue;
								} 
						} 
					} 
				} 
				if (!canmultiplex && generatedData) {
					continue;
				} 
				if ((generatedSize) && generatedData && (generatedMulti != generatedMulti)) {
					continue;
				} 
				if (generatedLocaldev || generatedLocalport) {
					if ((generatedLocalport != generatedLocalport) || (generatedLocalportrange != generatedLocalportrange) || (generatedLocaldev && (!generatedLocaldev || .strcmp(generatedLocaldev, generatedLocaldev)))) {
						continue;
					} 
				} 
				if (!(generatedHandler.getFlags() & (1 << 7/* This protocol requires credentials per connection,
				           so verify that we're using the same name and password as well */))) {
					if (.strcmp(generatedUser, generatedUser) || .strcmp(generatedPasswd, generatedPasswd)) {
						continue;
					} 
				} 
				if (!generatedHttpproxy || (generatedHandler.getFlags() & (1 << 0)) || generatedTunnel_proxy) {
					if ((ModernizedCProgram.Curl_strcasecompare(generatedHandler.getScheme(), generatedHandler.getScheme()) || (ModernizedCProgram.get_protocol_family(generatedHandler.getProtocol()) == generatedHandler.getProtocol() && generatedTls_upgraded)) && (!generatedConn_to_host || ModernizedCProgram.Curl_strcasecompare(generatedConn_to_host.getName(), generatedConn_to_host.getName())) && (!generatedConn_to_port || generatedConn_to_port == generatedConn_to_port) && ModernizedCProgram.Curl_strcasecompare(generatedName, generatedName) && generatedRemote_port == generatedRemote_port) {
						if (generatedHandler.getFlags() & (1 << 0/* This is a SSL connection so verify that we're using the same
						               SSL options as well */)) {
							if (!generatedSsl_config.Curl_ssl_config_matches(generatedSsl_config)) {
								do {
								} while (0);
								continue;
							} 
							if (generatedState != .ssl_connection_complete) {
								foundPendingCandidate = 1;
								do {
								} while (0);
								continue;
							} 
						} 
						match = 1;
					} 
				} else {
						match = /* The requested connection is using the same HTTP proxy in normal
						           mode (no tunneling) */1;
				} 
				if (match/* If we are looking for an HTTP+NTLM connection, check if this is
				           already authenticating with the right credentials. If not, keep
				           looking so that we can reuse NTLM connections if
				           possible. (Especially we must not reuse the same connection if
				           partway through a handshake!) */) {
					if (wantNTLMhttp) {
						if (.strcmp(generatedUser, generatedUser) || .strcmp(generatedPasswd, generatedPasswd)) {
							if (generatedHttp_ntlm_state == /* we prefer a credential match, but this is at least a connection
							               that can be reused and "upgraded" to NTLM */.NTLMSTATE_NONE) {
								chosen = check;
							} 
							continue;
						} 
					}  else if (generatedHttp_ntlm_state != .NTLMSTATE_NONE/* Connection is using NTLM auth but we don't want NTLM */) {
						continue;
					} 
					if (/* Same for Proxy NTLM authentication */wantProxyNTLMhttp/* Both check->http_proxy.user and check->http_proxy.passwd can be
					           * NULL */) {
						if (!generatedUser || !generatedPasswd) {
							continue;
						} 
						if (.strcmp(generatedUser, generatedUser) || .strcmp(generatedPasswd, generatedPasswd)) {
							continue;
						} 
					}  else if (generatedProxy_ntlm_state != .NTLMSTATE_NONE/* Proxy connection is using NTLM auth but we don't want NTLM */) {
						continue;
					} 
					if (wantNTLMhttp || wantProxyNTLMhttp) {
						chosen = /* Credentials are already checked, we can use this connection */check;
						if ((wantNTLMhttp && (generatedHttp_ntlm_state != .NTLMSTATE_NONE)) || (wantProxyNTLMhttp && (generatedProxy_ntlm_state != .NTLMSTATE_NONE))) {
							force_reuse = /* We must use this connection, no other */1;
							break;
						} 
						continue;
					} 
					if (canmultiplex/* We can multiplex if we want to. Let's continue looking for
					             the optimal connection to use. */) {
						if (!multiplexed) {
							chosen = /* We have the optimal connection. Let's stop looking. */check;
							break;
						} 
						chosen = /* When not multiplexed, we have a match here! */check;
						data.Curl_infof("Multiplexed connection found!\n");
						break;
					} else {
							chosen = /* We have found a connection. Let's stop searching. */check;
							break;
					} 
				} 
			}
		} 
		if (chosen) {
			chosen.setData(/* mark it as used before releasing the lock *//* own it! */data);
			data.Curl_conncache_unlock();
			usethis = chosen;
			return /* yes, we found one to use! */1;
		} 
		data.Curl_conncache_unlock();
		if (foundPendingCandidate && generatedSet.getPipewait()) {
			data.Curl_infof("Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\n");
			waitpipe = 1;
		} 
		return /* no matching connecting exists */0/*
		 * verboseconnect() displays verbose information after a connect
		 */;
	}
	/*
	 * Helpers for IDNA conversions.
	 */
	public static  is_ASCII_name(Object hostname) {
		byte ch = (byte)hostname;
		while (ch) {
			if (ch++ & -1024) {
				return 0;
			} 
		}
		return 1/*
		 * Strip single trailing dot in the hostname,
		 * primarily for SNI and http host header.
		 */;
	}
	public static Object idnconvert_hostname(connectdata conn, hostname host) {
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		(Object)data;
		(Object)conn;
		Byte generatedName = host.getName();
		host.setDispname(generatedName);
		if (!ModernizedCProgram.is_ASCII_name(generatedName)/* change the name pointer to point to the encoded hostname */) {
			data.Curl_infof(/* change the name pointer to point to the encoded hostname */"IDN support not present, can't parse Unicode domains\n");
		} 
		return CURLE_OK/*
		 * Frees data allocated by idnconvert_hostname()
		 */;
	}
	public static Object Curl_builtin_scheme(Object scheme) {
		Curl_handler pp = new Curl_handler();
		Curl_handler p = new Curl_handler();
		/* Scan protocol handler table and match against 'scheme'. The handler may
		     be changed later when the protocol specific setup function is called. */
		for (pp = ModernizedCProgram.protocols; (p = pp) != ((Object)0); pp++) {
			if (ModernizedCProgram.Curl_strcasecompare(p.getScheme(), scheme)) {
				return /* Protocol found in table. Check if allowed */p;
			} 
		}
		return ((Object)/* not found */0);
	}
	public static Object findprotocol(Curl_easy data, connectdata conn, Object protostr) {
		Curl_handler p = ModernizedCProgram.Curl_builtin_scheme(protostr);
		Object generatedSet = data.getSet();
		Object generatedState = data.getState();
		if (/* Protocol found in table. Check if allowed */p && (generatedSet.getAllowed_protocols() & p.getProtocol())) {
			if (generatedState.getThis_is_a_follow() && !(generatedSet.getRedir_protocols() & p.getProtocol())) {
				;
			} else {
					conn.setHandler(conn.setGiven(/* Perform setup complement if some. */p));
					return /* 'port' and 'remote_port' are set in setup_connection_internals() */CURLE_OK;
			} 
		} 
		data.Curl_failf(/* The protocol was not found in the table, but we don't have to assign it
		     to anything since it is already assigned to a dummy-struct in the
		     create_conn() function when the connectdata struct is allocated. */"Protocol \"%s\" not supported or disabled in libcurl", protostr);
		return CURLE_UNSUPPORTED_PROTOCOL;
	}
	public static Object Curl_uc_to_curlcode(Object uc) {
		switch (uc) {
		case CURLUE_OUT_OF_MEMORY:
				return CURLE_OUT_OF_MEMORY;
		case CURLUE_USER_NOT_ALLOWED:
				return CURLE_LOGIN_DENIED/*
				 * If the URL was set with an IPv6 numerical address with a zone id part, set
				 * the scope_id based on that!
				 */;
		case CURLUE_UNSUPPORTED_SCHEME:
				return CURLE_UNSUPPORTED_PROTOCOL;
		default:
				return CURLE_URL_MALFORMAT;
		}
	}
	/*
	 * Parse URL and fill in the relevant members of the connection struct.
	 */
	public static Object parseurlandfillconn(Curl_easy data, connectdata conn) {
		 result = new ();
		 uh = new ();
		 uc = new ();
		byte hostname;
		/* cleanup previous leftovers first */data.up_free();
		Object generatedSet = data.getSet();
		Object generatedState = data.getState();
		if (generatedSet.getUh()) {
			uh = generatedState.setUh(.curl_url_dup(generatedSet.getUh()));
		} else {
				uh = generatedState.setUh(.curl_url());
		} 
		if (!uh) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Object generatedChange = data.getChange();
		if (generatedSet.getStr()[dupstring.STRING_DEFAULT_PROTOCOL] && !.Curl_is_absolute_url(generatedChange.getUrl(), ((Object)0), 40)) {
			byte url;
			if (generatedChange.getUrl_alloc()) {
				.Curl_cfree(generatedChange.getUrl());
			} 
			url = ModernizedCProgram.curl_maprintf("%s://%s", generatedSet.getStr()[dupstring.STRING_DEFAULT_PROTOCOL], generatedChange.getUrl());
			if (!url) {
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedChange.setUrl(url);
			generatedChange.setUrl_alloc(1);
		} 
		if (!generatedSet.getUh()) {
			byte newurl;
			uc = .curl_url_set(uh, CURLUPART_URL, generatedChange.getUrl(), CURLU_GUESS_SCHEME | CURLU_NON_SUPPORT_SCHEME | (generatedSet.getDisallow_username_in_url() ? CURLU_DISALLOW_USER : 0) | (generatedSet.getPath_as_is() ? CURLU_PATH_AS_IS : 0));
			if (uc) {
				do {
				} while (0);
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
			uc = .curl_url_get(uh, CURLUPART_URL, newurl, /* after it was parsed, get the generated normalized version */0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
			if (generatedChange.getUrl_alloc()) {
				.Curl_cfree(generatedChange.getUrl());
			} 
			generatedChange.setUrl(newurl);
			generatedChange.setUrl_alloc(1);
		} 
		uc = .curl_url_get(uh, CURLUPART_SCHEME, generatedState.getUp().getScheme(), 0);
		if (uc) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		result = ModernizedCProgram.findprotocol(data, conn, generatedState.getUp().getScheme());
		if (result) {
			return result;
		} 
		uc = .curl_url_get(uh, CURLUPART_USER, generatedState.getUp().getUser(), CURLU_URLDECODE);
		Byte generatedUser = conn.getUser();
		ConnectBits generatedBits = conn.getBits();
		if (!uc) {
			conn.setUser(.Curl_cstrdup(generatedState.getUp().getUser()));
			if (!generatedUser) {
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedBits.setUser_passwd(1);
		}  else if (uc != CURLUE_NO_USER) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = .curl_url_get(uh, CURLUPART_PASSWORD, generatedState.getUp().getPassword(), CURLU_URLDECODE);
		Byte generatedPasswd = conn.getPasswd();
		if (!uc) {
			conn.setPasswd(.Curl_cstrdup(generatedState.getUp().getPassword()));
			if (!generatedPasswd) {
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedBits.setUser_passwd(1);
		}  else if (uc != CURLUE_NO_PASSWORD) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = .curl_url_get(uh, CURLUPART_OPTIONS, generatedState.getUp().getOptions(), CURLU_URLDECODE);
		Byte generatedOptions = conn.getOptions();
		if (!uc) {
			conn.setOptions(.Curl_cstrdup(generatedState.getUp().getOptions()));
			if (!generatedOptions) {
				return CURLE_OUT_OF_MEMORY;
			} 
		}  else if (uc != CURLUE_NO_OPTIONS) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = .curl_url_get(uh, CURLUPART_HOST, generatedState.getUp().getHostname(), 0);
		if (uc) {
			if (!ModernizedCProgram.Curl_strcasecompare("file", generatedState.getUp().getScheme())) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		uc = .curl_url_get(uh, CURLUPART_PATH, generatedState.getUp().getPath(), 0);
		if (uc) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = .curl_url_get(uh, CURLUPART_PORT, generatedState.getUp().getPort(), CURLU_DEFAULT_PORT);
		if (uc) {
			if (!ModernizedCProgram.Curl_strcasecompare("file", generatedState.getUp().getScheme())) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} else {
				long port = .strtoul(generatedState.getUp().getPort(), ((Object)0), 10);
				conn.setPort(conn.setRemote_port(ModernizedCProgram.curlx_ultous(ModernizedCProgram.port)));
		} 
		(Object).curl_url_get(uh, CURLUPART_QUERY, generatedState.getUp().getQuery(), 0);
		hostname = generatedState.getUp().getHostname();
		if (hostname && hostname[0] == (byte)'['/* This looks like an IPv6 address literal. See if there is an address
		       scope. */) {
			size_t hlen = new size_t();
			generatedBits.setIpv6_ip(1);
			/* cut off the brackets! */hostname++;
			hlen = .strlen(hostname);
			hostname[hlen - 1] = 0;
			conn.zonefrom_url(uh);
		} 
		hostname generatedHost = conn.getHost();
		generatedHost.setRawalloc(.Curl_cstrdup(hostname ? hostname : /* make sure the connect struct gets its own copy of the host name */""));
		Byte generatedRawalloc = generatedHost.getRawalloc();
		if (!generatedRawalloc) {
			return CURLE_OUT_OF_MEMORY;
		} 
		generatedHost.setName(generatedRawalloc);
		if (generatedSet.getScope_id()) {
			conn.setScope_id(generatedSet.getScope_id());
		} 
		return CURLE_OK/*
		 * If we're doing a resumed transfer, we need to setup our stuff
		 * properly.
		 */;
	}
	/****************************************************************
	* Checks if the host is in the noproxy list. returns true if it matches
	* and therefore the proxy should NOT be used.
	****************************************************************/
	/****************************************************************
	* Checks if the host is in the noproxy list. returns true if it matches
	* and therefore the proxy should NOT be used.
	****************************************************************/
	public static  check_noproxy(Object name, Object no_proxy) {
		if (no_proxy && no_proxy[0]) {
			size_t tok_start = new size_t();
			size_t tok_end = new size_t();
			byte separator = ", ";
			size_t no_proxy_len = new size_t();
			size_t namelen = new size_t();
			byte endptr;
			if (ModernizedCProgram.Curl_strcasecompare("*", no_proxy)) {
				return 1;
			} 
			no_proxy_len = .strlen(/* NO_PROXY was specified and it wasn't just an asterisk */no_proxy);
			if (name[0] == (byte)'[') {
				endptr = .strchr(name, /* IPv6 numerical address */(byte)']');
				if (!endptr) {
					return 0;
				} 
				name++;
				namelen = endptr - name;
			} else {
					namelen = .strlen(name);
			} 
			for (tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {
				while (tok_start < no_proxy_len && .strchr(separator, no_proxy[tok_start]) != ((Object)0)) {
					++/* Look for the beginning of the token. */tok_start;
				}
				if (tok_start == no_proxy_len) {
					break;
				} 
				for (tok_end = tok_start; tok_end < no_proxy_len && .strchr(separator, no_proxy[tok_end]) == ((Object)0); ++tok_end/* Look for the end of the token. */) {
					;
				}
				if (no_proxy[tok_start] == (byte)'.') {
					++tok_start;
				} 
				if ((tok_end - tok_start) <= namelen) {
					byte checkn = name + namelen - (tok_end - /* Match the last part of the name to the domain we are checking. */tok_start);
					if (ModernizedCProgram.Curl_strncasecompare(no_proxy + tok_start, checkn, tok_end - tok_start)) {
						if ((tok_end - tok_start) == namelen || (checkn - 1) == (byte)'.'/* We either have an exact match, or the previous character is a .
						             * so it is within the same domain, so no proxy for this host.
						             */) {
							return 1/* if((tok_end - tok_start) <= namelen) */;
						} 
					} 
				} 
			}
		} 
		return /* for(tok_start = 0; tok_start < no_proxy_len;
		         tok_start = tok_end + 1) *//* NO_PROXY was specified and it wasn't just an asterisk */0/****************************************************************
		* Detect what (if any) proxy to use. Remember that this selects a host
		* name and is not limited to HTTP proxies only.
		* The returned pointer must be freed by the caller (unless NULL)
		****************************************************************//****************************************************************
		* Detect what (if any) proxy to use. Remember that this selects a host
		* name and is not limited to HTTP proxies only.
		* The returned pointer must be freed by the caller (unless NULL)
		****************************************************************/;
	}
	/* no_proxy=domain1.dom,host.domain2.dom
	   *   (a comma-separated list of hosts which should
	   *   not be proxied, or an asterisk to override
	   *   all proxy variables)
	   */
	public static Object parse_proxy(Curl_easy data, connectdata conn, Byte proxy, Object proxytype) {
		byte portptr = ((Object)0);
		long port = -1;
		byte proxyuser = ((Object)0);
		byte proxypasswd = ((Object)0);
		byte host;
		bool sockstype = new bool();
		 uc = new ();
		proxy_info proxyinfo = new proxy_info();
		 uhp = .curl_url();
		 result = CURLE_OK;
		byte scheme = ((Object)0);
		uc = .curl_url_set(uhp, CURLUPART_URL, /* When parsing the proxy, allowing non-supported schemes since we have
		     these made up ones for proxies. Guess scheme for URLs without it. */proxy, CURLU_NON_SUPPORT_SCHEME | CURLU_GUESS_SCHEME);
		if (!uc) {
			uc = .curl_url_get(uhp, CURLUPART_SCHEME, scheme, /* parsed okay as a URL */0);
			if (uc) {
				result = CURLE_OUT_OF_MEMORY;
				;
			} 
			if (ModernizedCProgram.Curl_strcasecompare("https", scheme)) {
				proxytype = CURLPROXY_HTTPS;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks5h", scheme)) {
				proxytype = CURLPROXY_SOCKS5_HOSTNAME;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks5", scheme)) {
				proxytype = CURLPROXY_SOCKS5;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks4a", scheme)) {
				proxytype = CURLPROXY_SOCKS4A;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks4", scheme) || ModernizedCProgram.Curl_strcasecompare("socks", scheme)) {
				proxytype = CURLPROXY_SOCKS4;
			}  else if (ModernizedCProgram.Curl_strcasecompare("http", scheme)) {
				;
			} else {
					data.Curl_failf("Unsupported proxy scheme for \'%s\'", /* Any other xxx:// reject! */proxy);
					result = CURLE_COULDNT_CONNECT;
					;
			} 
		} else {
				data.Curl_failf("Unsupported proxy syntax in \'%s\'", proxy);
				result = CURLE_COULDNT_RESOLVE_PROXY;
				;
		} 
		if (proxytype == CURLPROXY_HTTPS) {
			data.Curl_failf("Unsupported proxy \'%s\', libcurl is built without the HTTPS-proxy support.", proxy);
			result = CURLE_NOT_BUILT_IN;
			;
		} 
		sockstype = proxytype == CURLPROXY_SOCKS5_HOSTNAME || proxytype == CURLPROXY_SOCKS5 || proxytype == CURLPROXY_SOCKS4A || proxytype == CURLPROXY_SOCKS4;
		proxy_info generatedSocks_proxy = conn.getSocks_proxy();
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		proxyinfo = sockstype ? generatedSocks_proxy : generatedHttp_proxy;
		proxyinfo.setProxytype(proxytype);
		.curl_url_get(uhp, CURLUPART_USER, proxyuser, /* Is there a username and password given in this proxy url? */CURLU_URLDECODE);
		.curl_url_get(uhp, CURLUPART_PASSWORD, proxypasswd, CURLU_URLDECODE);
		Byte generatedUser = proxyinfo.getUser();
		Byte generatedPasswd = proxyinfo.getPasswd();
		ConnectBits generatedBits = conn.getBits();
		if (proxyuser || proxypasswd) {
			do {
				.Curl_cfree((generatedUser));
				(generatedUser) = ((Object)0);
			} while (0);
			proxyinfo.setUser(proxyuser);
			do {
				.Curl_cfree((generatedPasswd));
				(generatedPasswd) = ((Object)0);
			} while (0);
			if (!proxypasswd) {
				proxypasswd = .Curl_cstrdup("");
				if (!proxypasswd) {
					result = CURLE_OUT_OF_MEMORY;
					;
				} 
			} 
			proxyinfo.setPasswd(proxypasswd);
			generatedBits.setProxy_user_passwd(/* enable it */1);
		} 
		.curl_url_get(uhp, CURLUPART_PORT, portptr, 0);
		Object generatedSet = data.getSet();
		if (portptr) {
			port = .strtol(portptr, ((Object)0), 10);
			.Curl_cfree(portptr);
		} else {
				if (generatedSet.getProxyport()) {
					port = generatedSet.getProxyport();
				} else {
						if (proxytype == CURLPROXY_HTTPS) {
							port = 443;
						} else {
								port = 1080;
						} 
				} 
		} 
		long generatedPort = conn.getPort();
		hostname generatedHost = generatedSocks_proxy.getHost();
		Byte generatedRawalloc = generatedHost.getRawalloc();
		if (port >= 0) {
			proxyinfo.setPort(port);
			if (generatedPort < 0 || sockstype || !generatedRawalloc) {
				conn.setPort(port);
			} 
		} 
		uc = .curl_url_get(uhp, CURLUPART_HOST, host, /* now, clone the proxy host name */CURLU_URLDECODE);
		if (uc) {
			result = CURLE_OUT_OF_MEMORY;
			;
		} 
		do {
			.Curl_cfree((generatedRawalloc));
			(generatedRawalloc) = ((Object)0);
		} while (0);
		generatedHost.setRawalloc(host);
		if (host[0] == (byte)'[') {
			size_t len = .strlen(/* this is a numerical IPv6, strip off the brackets */host);
			host[len - 1] = /* clear the trailing bracket */0;
			host++;
			conn.zonefrom_url(uhp);
		} 
		generatedHost.setName(host);
		.curl_url_cleanup(uhp);
		return result/*
		 * Extract the user and password from the authentication string
		 */;
	}
	public static Object parse_proxy_auth(Curl_easy data, connectdata conn) {
		byte[] proxyuser = "";
		byte[] proxypasswd = "";
		 result = new ();
		Object generatedSet = data.getSet();
		if (generatedSet.getStr()[dupstring.STRING_PROXYUSERNAME] != ((Object)0)) {
			.strncpy(proxyuser, generatedSet.getStr()[dupstring.STRING_PROXYUSERNAME], 256);
			proxyuser[256 - 1] = /*To be on safe side*/(byte)'\0';
		} 
		if (generatedSet.getStr()[dupstring.STRING_PROXYPASSWORD] != ((Object)0)) {
			.strncpy(proxypasswd, generatedSet.getStr()[dupstring.STRING_PROXYPASSWORD], 256);
			proxypasswd[256 - 1] = /*To be on safe side*/(byte)'\0';
		} 
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		Byte generatedUser = generatedHttp_proxy.getUser();
		result = data.Curl_urldecode(proxyuser, 0, generatedUser, ((Object)0), 0);
		Byte generatedPasswd = generatedHttp_proxy.getPasswd();
		if (!result) {
			result = data.Curl_urldecode(proxypasswd, 0, generatedPasswd, ((Object)0), 0);
		} 
		return result;
	}
	public static Object Curl_parse_login_details(Object login, Object len, byte userp, byte passwdp, byte optionsp) {
		 result = CURLE_OK;
		byte ubuf = ((Object)0);
		byte pbuf = ((Object)0);
		byte obuf = ((Object)0);
		byte psep = ((Object)0);
		byte osep = ((Object)0);
		size_t ulen = new size_t();
		size_t plen = new size_t();
		size_t olen = new size_t();
		if (/* Attempt to find the password separator */passwdp) {
			psep = .strchr(login, (byte)':');
			if (psep >= login + /* Within the constraint of the login string */len) {
				psep = ((Object)0);
			} 
		} 
		if (/* Attempt to find the options separator */optionsp) {
			osep = .strchr(login, (byte)';');
			if (osep >= login + /* Within the constraint of the login string */len) {
				osep = ((Object)0);
			} 
		} 
		ulen = (/* Calculate the portion lengths */psep ? (size_t)(osep && psep > osep ? osep - login : psep - login) : (osep ? (size_t)(osep - login) : len));
		plen = (psep ? (osep && osep > psep ? (size_t)(osep - psep) : (size_t)(login + len - psep)) - 1 : 0);
		olen = (osep ? (psep && psep > osep ? (size_t)(psep - osep) : (size_t)(login + len - osep)) - 1 : 0);
		if (userp && /* Allocate the user portion buffer */ulen) {
			ubuf = .Curl_cmalloc(ulen + 1);
			if (!ubuf) {
				result = CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result && passwdp && /* Allocate the password portion buffer */plen) {
			pbuf = .Curl_cmalloc(plen + 1);
			if (!pbuf) {
				.Curl_cfree(ubuf);
				result = CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result && optionsp && /* Allocate the options portion buffer */olen) {
			obuf = .Curl_cmalloc(olen + 1);
			if (!obuf) {
				.Curl_cfree(pbuf);
				.Curl_cfree(ubuf);
				result = CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result) {
			if (/* Store the user portion if necessary */ubuf) {
				.memcpy(ubuf, login, ulen);
				ubuf[ulen] = (byte)'\0';
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				userp = ubuf;
			} 
			if (/* Store the password portion if necessary */pbuf) {
				.memcpy(pbuf, psep + 1, plen);
				pbuf[plen] = (byte)'\0';
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwdp = pbuf;
			} 
			if (/* Store the options portion if necessary */obuf) {
				.memcpy(obuf, osep + 1, olen);
				obuf[olen] = (byte)'\0';
				do {
					.Curl_cfree((optionsp));
					(optionsp) = ((Object)0);
				} while (0);
				optionsp = obuf;
			} 
		} 
		return result/*************************************************************
		 * Figure out the remote port number and fix it in the URL
		 *
		 * No matter if we use a proxy or not, we have to figure out the remote
		 * port number of various reasons.
		 *
		 * The port number embedded in the URL is replaced, if necessary.
		 *************************************************************/;
	}
	public static Object parse_remote_port(Curl_easy data, connectdata conn) {
		Object generatedSet = data.getSet();
		Object generatedState = data.getState();
		int generatedRemote_port = conn.getRemote_port();
		if (generatedSet.getUse_port() && generatedState.getAllow_port()) {
			byte[] portbuf = new byte[/* if set, we use this instead of the port possibly given in the URL */16];
			 uc = new ();
			conn.setRemote_port((int)generatedSet.getUse_port());
			ModernizedCProgram.curl_msnprintf(portbuf, , "%d", generatedRemote_port);
			uc = .curl_url_set(generatedState.getUh(), CURLUPART_PORT, portbuf, 0);
			if (uc) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		return CURLE_OK/*
		 * Override the login details from the URL with that in the CURLOPT_USERPWD
		 * option or a .netrc file, if applicable.
		 */;
	}
	public static Object override_login(Curl_easy data, connectdata conn, byte userp, byte passwdp, byte optionsp) {
		bool user_changed = 0;
		bool passwd_changed = 0;
		 uc = new ();
		Object generatedSet = data.getSet();
		ConnectBits generatedBits = conn.getBits();
		Object generatedUser_passwd = generatedBits.getUser_passwd();
		if (generatedSet.getUse_netrc() == CURL_NETRC_REQUIRED && generatedUser_passwd) {
			if (/* ignore user+password in the URL */userp) {
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				user_changed = 1;
			} 
			if (passwdp) {
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwd_changed = 1;
			} 
			generatedBits.setUser_passwd(/* disable user+password */0);
		} 
		if (generatedSet.getStr()[dupstring.STRING_USERNAME]) {
			.Curl_cfree(userp);
			userp = .Curl_cstrdup(generatedSet.getStr()[dupstring.STRING_USERNAME]);
			if (!userp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedBits.setUser_passwd(/* enable user+password */1);
			user_changed = 1;
		} 
		if (generatedSet.getStr()[dupstring.STRING_PASSWORD]) {
			.Curl_cfree(passwdp);
			passwdp = .Curl_cstrdup(generatedSet.getStr()[dupstring.STRING_PASSWORD]);
			if (!passwdp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedBits.setUser_passwd(/* enable user+password */1);
			passwd_changed = 1;
		} 
		if (generatedSet.getStr()[dupstring.STRING_OPTIONS]) {
			.Curl_cfree(optionsp);
			optionsp = .Curl_cstrdup(generatedSet.getStr()[dupstring.STRING_OPTIONS]);
			if (!optionsp) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		generatedBits.setNetrc(0);
		hostname generatedHost = conn.getHost();
		Byte generatedName = generatedHost.getName();
		if (generatedSet.getUse_netrc() != CURL_NETRC_IGNORED && (!userp || !userp || !passwdp || !passwdp)) {
			bool netrc_user_changed = 0;
			bool netrc_passwd_changed = 0;
			int ret;
			ret = ModernizedCProgram.Curl_parsenetrc(generatedName, userp, passwdp, netrc_user_changed, netrc_passwd_changed, generatedSet.getStr()[dupstring.STRING_NETRC_FILE]);
			if (ret > 0) {
				data.Curl_infof("Couldn't find host %s in the .netrc file; using defaults\n", generatedName);
			}  else if (ret < 0) {
				return CURLE_OUT_OF_MEMORY;
			} else {
					generatedBits.setNetrc(/* set bits.netrc TRUE to remember that we got the name from a .netrc
					         file, so that it is safe to use even if we followed a Location: to a
					         different host or similar. */1);
					generatedBits.setUser_passwd(/* enable user+password */1);
					if (netrc_user_changed) {
						user_changed = 1;
					} 
					if (netrc_passwd_changed) {
						passwd_changed = 1;
					} 
			} 
		} 
		Object generatedState = data.getState();
		if (/* for updated strings, we update them in the URL */user_changed) {
			uc = .curl_url_set(generatedState.getUh(), CURLUPART_USER, userp, 0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
		} 
		if (passwd_changed) {
			uc = .curl_url_set(generatedState.getUh(), CURLUPART_PASSWORD, passwdp, 0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
		} 
		return CURLE_OK/*
		 * Set the login details so they're available in the connection
		 */;
	}
	public static Object parse_connect_to_string(Curl_easy data, connectdata conn, Object conn_to_host, byte host_result, int port_result) {
		 result = CURLE_OK;
		byte ptr = conn_to_host;
		int host_match = 0;
		int port_match = 0;
		host_result = ((Object)0);
		port_result = -1;
		ConnectBits generatedBits = conn.getBits();
		Object generatedIpv6_ip = generatedBits.getIpv6_ip();
		hostname generatedHost = conn.getHost();
		Byte generatedName = generatedHost.getName();
		if (ptr == (byte)':') {
			host_match = /* an empty hostname always matches */1;
			ptr++;
		} else {
				size_t hostname_to_match_len = new size_t();
				byte hostname_to_match = ModernizedCProgram.curl_maprintf("%s%s%s", generatedIpv6_ip ? "[" : "", generatedName, generatedIpv6_ip ? "]" : "");
				if (!hostname_to_match) {
					return CURLE_OUT_OF_MEMORY;
				} 
				hostname_to_match_len = .strlen(hostname_to_match);
				host_match = ModernizedCProgram.Curl_strncasecompare(ptr, hostname_to_match, hostname_to_match_len);
				.Curl_cfree(hostname_to_match);
				ptr += hostname_to_match_len;
				host_match = host_match && ptr == (byte)':';
				ptr++;
		} 
		int generatedRemote_port = conn.getRemote_port();
		if (host_match) {
			if (ptr == (byte)':') {
				port_match = /* an empty port always matches */1;
				ptr++;
			} else {
					byte ptr_next = .strchr(ptr, /* check whether the URL's port matches */(byte)':');
					if (ptr_next) {
						byte endp = ((Object)0);
						long port_to_match = .strtol(ptr, endp, 10);
						if ((endp == ptr_next) && (port_to_match == generatedRemote_port)) {
							port_match = 1;
							ptr = ptr_next + 1;
						} 
					} 
			} 
		} 
		if (host_match && port_match) {
			result = data.parse_connect_to_host_port(ptr, host_result, /* parse the hostname and port to connect to */port_result);
		} 
		return result/*
		 * Processes all strings in the "connect to" slist, and uses the "connect
		 * to host" and "connect to port" of the first string that matches.
		 */;
	}
	public static Object parse_connect_to_slist(Curl_easy data, connectdata conn, curl_slist conn_to_host) {
		 result = CURLE_OK;
		byte host = ((Object)0);
		int port = -1;
		Object generatedCurl_slist = conn_to_host.getCurl_slist();
		hostname generatedConn_to_host = conn.getConn_to_host();
		ConnectBits generatedBits = conn.getBits();
		while (conn_to_host && !host && port == -1) {
			result = ModernizedCProgram.parse_connect_to_string(data, conn, generatedCurl_slist, host, port);
			if (result) {
				return result;
			} 
			if (host && host) {
				generatedConn_to_host.setRawalloc(host);
				generatedConn_to_host.setName(host);
				generatedBits.setConn_to_host(1);
				data.Curl_infof("Connecting to hostname: %s\n", host);
			} else {
					generatedBits.setConn_to_host(/* no "connect to host" */0);
					do {
						.Curl_cfree((host));
						(host) = ((Object)0);
					} while (0);
			} 
			if (port >= 0) {
				conn.setConn_to_port(port);
				generatedBits.setConn_to_port(1);
				data.Curl_infof("Connecting to port: %d\n", port);
			} else {
					generatedBits.setConn_to_port(/* no "connect to port" */0);
					port = -1;
			} 
			conn_to_host = generatedCurl_slist;
		}
		/* with h2 support, check that first *//* from *//* to *//* from *//* to *//* protocol version switch */return /* shouldn't be possible */result/*************************************************************
		 * Resolve the address of the server or proxy
		 *************************************************************/;
	}
	public static Object resolve_server(Curl_easy data, connectdata conn,  async) {
		 result = CURLE_OK;
		timediff_t timeout_ms = ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1);
		do {
		} while (0);
		do {
		} while (0/*************************************************************
		   * Resolve the name of the server or proxy
		   *************************************************************/);
		ConnectBits generatedBits = conn.getBits();
		Object generatedReuse = generatedBits.getReuse();
		Object generatedProxy = generatedBits.getProxy();
		Object generatedConn_to_host = generatedBits.getConn_to_host();
		hostname generatedHost = conn.getHost();
		Object generatedConn_to_port = generatedBits.getConn_to_port();
		int generatedRemote_port = conn.getRemote_port();
		Byte generatedName = connhost.getName();
		Byte generatedHostname_resolve = conn.getHostname_resolve();
		long generatedPort = conn.getPort();
		Object generatedDispname = connhost.getDispname();
		Object generatedSocksproxy = generatedBits.getSocksproxy();
		if (generatedReuse) {
			async = 0;
		} else {
				int rc;
				Curl_dns_entry hostaddr = new Curl_dns_entry();
				if (!generatedProxy) {
					hostname connhost = new hostname();
					if (generatedConn_to_host) {
						connhost = generatedConn_to_host;
					} else {
							connhost = generatedHost;
					} 
					if (generatedConn_to_port) {
						conn.setPort(generatedConn_to_port);
					} else {
							conn.setPort(generatedRemote_port);
					} 
					conn.setHostname_resolve(.Curl_cstrdup(generatedName));
					if (!generatedHostname_resolve) {
						return CURLE_OUT_OF_MEMORY;
					} 
					rc = ModernizedCProgram.Curl_resolv_timeout(conn, generatedHostname_resolve, (int)generatedPort, hostaddr, timeout_ms);
					if (rc == 1) {
						async = 1;
					}  else if (rc == -2) {
						result = CURLE_OPERATION_TIMEDOUT;
					}  else if (!hostaddr) {
						data.Curl_failf("Couldn't resolve host '%s'", generatedDispname);
						result = CURLE_COULDNT_RESOLVE_HOST/* don't return yet, we need to clean up the timeout first */;
					} 
				} else {
						hostname host = generatedSocksproxy ? generatedHost : generatedHost;
						conn.setHostname_resolve(.Curl_cstrdup(generatedName));
						if (!generatedHostname_resolve) {
							return CURLE_OUT_OF_MEMORY;
						} 
						rc = ModernizedCProgram.Curl_resolv_timeout(conn, generatedHostname_resolve, (int)generatedPort, hostaddr, timeout_ms);
						if (rc == 1) {
							async = 1;
						}  else if (rc == -2) {
							result = CURLE_OPERATION_TIMEDOUT;
						}  else if (!hostaddr) {
							data.Curl_failf("Couldn't resolve proxy '%s'", generatedDispname);
							result = CURLE_COULDNT_RESOLVE_PROXY/* don't return yet, we need to clean up the timeout first */;
						} 
				} 
				do {
				} while (0);
				conn.setDns_entry(hostaddr);
		} 
		return result/*
		 * Cleanup the connection just allocated before we can move along and use the
		 * previously existing one.  All relevant data is copied over and old_conn is
		 * ready for freeing once this function returns.
		 */;
	}
	public static Object create_conn(Curl_easy data, connectdata in_connect,  async) {
		 result = CURLE_OK;
		connectdata conn = new connectdata();
		connectdata conn_temp = ((Object)0);
		bool reuse = new bool();
		bool connections_available = 1;
		bool force_reuse = 0;
		bool waitpipe = 0;
		Object generatedMulti = data.getMulti();
		size_t max_host_connections = generatedMulti.Curl_multi_max_host_connections();
		size_t max_total_connections = generatedMulti.Curl_multi_max_total_connections();
		async = 0;
		in_connect = ((Object)0/*************************************************************
		   * Check input data
		   *************************************************************/);
		Object generatedChange = data.getChange();
		if (!generatedChange.getUrl()) {
			result = CURLE_URL_MALFORMAT;
			;
		} 
		connectdata connectdata = new connectdata();
		conn = connectdata.allocate_conn(data);
		if (!conn) {
			result = CURLE_OUT_OF_MEMORY;
			;
		} 
		in_connect = /* We must set the return variable as soon as possible, so that our
		     parent can cleanup any possible allocs we may have done before
		     any failure */conn;
		result = ModernizedCProgram.parseurlandfillconn(data, conn);
		if (result) {
			;
		} 
		Object generatedSet = data.getSet();
		Byte generatedOauth_bearer = conn.getOauth_bearer();
		if (generatedSet.getStr()[dupstring.STRING_BEARER]) {
			conn.setOauth_bearer(.Curl_cstrdup(generatedSet.getStr()[dupstring.STRING_BEARER]));
			if (!generatedOauth_bearer) {
				result = CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		Byte generatedSasl_authzid = conn.getSasl_authzid();
		if (generatedSet.getStr()[dupstring.STRING_SASL_AUTHZID]) {
			conn.setSasl_authzid(.Curl_cstrdup(generatedSet.getStr()[dupstring.STRING_SASL_AUTHZID]));
			if (!generatedSasl_authzid) {
				result = CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		result = /* After the unix socket init but before the proxy vars are used, parse and
		     initialize the proxy vars */conn.create_conn_helper_init_proxy();
		if (result) {
			;
		} 
		Object generatedGiven = conn.getGiven();
		ConnectBits generatedBits = conn.getBits();
		Object generatedHttpproxy = generatedBits.getHttpproxy();
		if ((generatedGiven.getFlags() & (1 << 0)) && generatedHttpproxy) {
			generatedBits.setTunnel_proxy(1/*************************************************************
			   * Figure out the remote port number and fix it in the URL
			   *************************************************************/);
		} 
		result = ModernizedCProgram.parse_remote_port(data, conn);
		if (result) {
			;
		} 
		Byte generatedUser = conn.getUser();
		Byte generatedPasswd = conn.getPasswd();
		Byte generatedOptions = conn.getOptions();
		result = ModernizedCProgram.override_login(data, conn, generatedUser, generatedPasswd, generatedOptions);
		if (result) {
			;
		} 
		result = /* default credentials */conn.set_login();
		if (result) {
			;
		} 
		result = ModernizedCProgram.parse_connect_to_slist(data, conn, generatedSet.getConnect_to());
		if (result) {
			;
		} 
		hostname generatedHost = conn.getHost();
		result = ModernizedCProgram.idnconvert_hostname(conn, generatedHost);
		if (result) {
			;
		} 
		Object generatedConn_to_host = generatedBits.getConn_to_host();
		if (generatedConn_to_host) {
			result = ModernizedCProgram.idnconvert_hostname(conn, generatedConn_to_host);
			if (result) {
				;
			} 
		} 
		if (generatedHttpproxy) {
			result = ModernizedCProgram.idnconvert_hostname(conn, generatedHost);
			if (result) {
				;
			} 
		} 
		Object generatedSocksproxy = generatedBits.getSocksproxy();
		if (generatedSocksproxy) {
			result = ModernizedCProgram.idnconvert_hostname(conn, generatedHost);
			if (result) {
				;
			} 
		} 
		Byte generatedName = generatedHost.getName();
		if (generatedConn_to_host && ModernizedCProgram.Curl_strcasecompare(generatedConn_to_host.getName(), generatedName)) {
			generatedBits.setConn_to_host(0/*************************************************************
			   * Check whether the port and the "connect to port" are equal.
			   * Do this after the remote port number has been fixed in the URL.
			   *************************************************************/);
		} 
		Object generatedConn_to_port = generatedBits.getConn_to_port();
		int generatedRemote_port = conn.getRemote_port();
		if (generatedConn_to_port && generatedConn_to_port == generatedRemote_port) {
			generatedBits.setConn_to_port(0/*************************************************************
			   * If the "connect to" feature is used with an HTTP proxy,
			   * we set the tunnel_proxy bit.
			   *************************************************************/);
		} 
		if ((generatedConn_to_host || generatedConn_to_port) && generatedHttpproxy) {
			generatedBits.setTunnel_proxy(1/*************************************************************
			   * Setup internals depending on protocol. Needs to be done after
			   * we figured out what/if proxy to use.
			   *************************************************************/);
		} 
		result = conn.setup_connection_internals();
		if (result) {
			;
		} 
		Object generatedRecv = conn.getRecv();
		generatedRecv[0] = ModernizedCProgram.Curl_recv_plain;
		Object generatedSend = conn.getSend();
		generatedSend[0] = ModernizedCProgram.Curl_send_plain;
		generatedRecv[1] = ModernizedCProgram.Curl_recv_plain;
		generatedSend[1] = ModernizedCProgram.Curl_send_plain;
		generatedBits.setTcp_fastopen(generatedSet.getTcp_fastopen());
		Object generatedHandler = conn.getHandler();
		Object generatedTcpconnect = generatedBits.getTcpconnect();
		Object generatedState = data.getState();
		if (generatedHandler.getFlags() & (1 << 4)) {
			bool done = new bool();
			do {
			} while (0);
			conn.Curl_persistconninfo();
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, done);
			if (!/* Setup a "faked" transfer that'll do nothing */result) {
				generatedTcpconnect[0] = /* we are "connected */1;
				result = ModernizedCProgram.Curl_conncache_add_conn(generatedState.getConn_cache(), conn);
				if (result) {
					;
				} 
				result = data.setup_range();
				if (result) {
					do {
					} while (0);
					(Object).UNRECOGNIZEDFUNCTIONNAME(conn, result, /* we ignore the return code for the protocol-specific DONE */0);
					;
				} 
				ModernizedCProgram.Curl_attach_connnection(data, conn);
				data.Curl_setup_transfer(-1, -1, 0, -1);
			} 
			ModernizedCProgram.Curl_init_do(data, /* since we skip do_init() */conn);
			;
		} 
		generatedSet.getSsl().getPrimary().setCApath(generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setCApath(generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_PROXY]);
		generatedSet.getSsl().getPrimary().setCAfile(generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setCAfile(generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_PROXY]);
		generatedSet.getSsl().getPrimary().setRandom_file(generatedSet.getStr()[dupstring.STRING_SSL_RANDOM_FILE]);
		generatedSet.getProxy_ssl().getPrimary().setRandom_file(generatedSet.getStr()[dupstring.STRING_SSL_RANDOM_FILE]);
		generatedSet.getSsl().getPrimary().setEgdsocket(generatedSet.getStr()[dupstring.STRING_SSL_EGDSOCKET]);
		generatedSet.getProxy_ssl().getPrimary().setEgdsocket(generatedSet.getStr()[dupstring.STRING_SSL_EGDSOCKET]);
		generatedSet.getSsl().getPrimary().setCipher_list(generatedSet.getStr()[dupstring.STRING_SSL_CIPHER_LIST_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setCipher_list(generatedSet.getStr()[dupstring.STRING_SSL_CIPHER_LIST_PROXY]);
		generatedSet.getSsl().getPrimary().setCipher_list13(generatedSet.getStr()[dupstring.STRING_SSL_CIPHER13_LIST_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setCipher_list13(generatedSet.getStr()[dupstring.STRING_SSL_CIPHER13_LIST_PROXY]);
		generatedSet.getSsl().getPrimary().setPinned_key(generatedSet.getStr()[dupstring.STRING_SSL_PINNEDPUBLICKEY_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setPinned_key(generatedSet.getStr()[dupstring.STRING_SSL_PINNEDPUBLICKEY_PROXY]);
		generatedSet.getSsl().setCRLfile(generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_ORIG]);
		generatedSet.getProxy_ssl().setCRLfile(generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_PROXY]);
		generatedSet.getSsl().setIssuercert(generatedSet.getStr()[dupstring.STRING_SSL_ISSUERCERT_ORIG]);
		generatedSet.getProxy_ssl().setIssuercert(generatedSet.getStr()[dupstring.STRING_SSL_ISSUERCERT_PROXY]);
		generatedSet.getSsl().setCert(generatedSet.getStr()[dupstring.STRING_CERT_ORIG]);
		generatedSet.getProxy_ssl().setCert(generatedSet.getStr()[dupstring.STRING_CERT_PROXY]);
		generatedSet.getSsl().setCert_type(generatedSet.getStr()[dupstring.STRING_CERT_TYPE_ORIG]);
		generatedSet.getProxy_ssl().setCert_type(generatedSet.getStr()[dupstring.STRING_CERT_TYPE_PROXY]);
		generatedSet.getSsl().setKey(generatedSet.getStr()[dupstring.STRING_KEY_ORIG]);
		generatedSet.getProxy_ssl().setKey(generatedSet.getStr()[dupstring.STRING_KEY_PROXY]);
		generatedSet.getSsl().setKey_type(generatedSet.getStr()[dupstring.STRING_KEY_TYPE_ORIG]);
		generatedSet.getProxy_ssl().setKey_type(generatedSet.getStr()[dupstring.STRING_KEY_TYPE_PROXY]);
		generatedSet.getSsl().setKey_passwd(generatedSet.getStr()[dupstring.STRING_KEY_PASSWD_ORIG]);
		generatedSet.getProxy_ssl().setKey_passwd(generatedSet.getStr()[dupstring.STRING_KEY_PASSWD_PROXY]);
		generatedSet.getSsl().getPrimary().setClientcert(generatedSet.getStr()[dupstring.STRING_CERT_ORIG]);
		generatedSet.getProxy_ssl().getPrimary().setClientcert(generatedSet.getStr()[dupstring.STRING_CERT_PROXY]);
		ssl_primary_config generatedSsl_config = conn.getSsl_config();
		if (!generatedSet.getSsl().getPrimary().Curl_clone_primary_ssl_config(generatedSsl_config)) {
			result = CURLE_OUT_OF_MEMORY;
			;
		} 
		ssl_primary_config generatedProxy_ssl_config = conn.getProxy_ssl_config();
		if (!generatedSet.getProxy_ssl().getPrimary().Curl_clone_primary_ssl_config(generatedProxy_ssl_config)) {
			result = CURLE_OUT_OF_MEMORY;
			;
		} 
		data/*************************************************************
		   * Check the current list of connections to see if we can
		   * re-use an already existing one or if we have to create a
		   * new one.
		   *************************************************************/.prune_dead_connections();
		do {
		} while (0);
		do {
		} while (0/* reuse_fresh is TRUE if we are told to use a new connection by force, but
		     we only acknowledge this option if this is not a re-used connection
		     already (which happens due to follow-location or during a HTTP
		     authentication phase). CONNECT_ONLY transfers also refuse reuse. */);
		if ((generatedSet.getReuse_fresh() && !generatedState.getThis_is_a_follow()) || generatedSet.getConnect_only()) {
			reuse = 0;
		} else {
				reuse = ModernizedCProgram.ConnectionExists(data, conn, conn_temp, force_reuse, waitpipe);
		} 
		curl_llist generatedEasyq = (conn_temp).getEasyq();
		Object generatedSize = generatedEasyq.getSize();
		long generatedConnection_id = conn_temp.getConnection_id();
		if (reuse && !force_reuse && ModernizedCProgram.IsMultiplexingPossible(data, /* If we found a reusable connection that is now marked as in use, we may
		     still want to open a new connection if we are multiplexing. */conn_temp)) {
			size_t multiplexed = (generatedSize);
			if (multiplexed > 0) {
				data.Curl_infof("Found connection %ld, with %zu requests on it\n", generatedConnection_id, multiplexed);
				if (conn_temp.Curl_conncache_bundle_size() < max_host_connections && data.Curl_conncache_size() < max_total_connections) {
					reuse = /* We want a new connection anyway */0;
					data.Curl_infof("We can reuse, but we want a new connection anyway\n");
					conn_temp.Curl_conncache_return_conn();
				} 
			} 
		} 
		Object generatedProxy = generatedBits.getProxy();
		Object generatedDispname = generatedHost.getDispname();
		connectbundle connectbundle = new connectbundle();
		Object generatedNum_connections = bundle.getNum_connections();
		connectdata connectdata = new connectdata();
		connectdata connectdata = new connectdata();
		if (reuse/*
		     * We already have a connection for this, we got the former connection
		     * in the conn_temp variable and thus we need to cleanup the one we
		     * just allocated before we can move along and use the previously
		     * existing one.
		     */) {
			conn.reuse_conn(conn_temp);
			.Curl_cfree(/* we don't need this anymore */conn);
			conn = conn_temp;
			in_connect = conn;
			data.Curl_infof("Re-using existing connection! (#%ld) with %s %s\n", generatedConnection_id, generatedProxy ? "proxy" : "host", generatedName ? generatedDispname : generatedName ? generatedDispname : generatedDispname);
		} else {
				if (generatedHandler.getFlags() & (1 << 8/* The protocol wants it, so set the bits if enabled in the easy handle
				         (default) */)) {
					if (generatedSet.getSsl_enable_alpn()) {
						generatedBits.setTls_enable_alpn(1);
					} 
					if (generatedSet.getSsl_enable_npn()) {
						generatedBits.setTls_enable_npn(1);
					} 
				} 
				if (waitpipe/* There is a connection that *might* become usable for multiplexing
				         "soon", and we wait for that */) {
					connections_available = 0;
				} else {
						byte bundlehost;
						connectbundle bundle = connectbundle.Curl_conncache_find_bundle(conn, generatedState.getConn_cache(), bundlehost);
						if (max_host_connections > 0 && bundle && (generatedNum_connections >= max_host_connections)) {
							connectdata conn_candidate = new connectdata();
							conn_candidate = connectdata.Curl_conncache_extract_bundle(data, /* The bundle is full. Extract the oldest connection. */bundle);
							data.Curl_conncache_unlock();
							if (conn_candidate) {
								(Object)ModernizedCProgram.Curl_disconnect(data, conn_candidate, /* dead_connection */0);
							} else {
									data.Curl_infof("No more connections allowed to host %s: %zu\n", bundlehost, max_host_connections);
									connections_available = 0;
							} 
						} else {
								data.Curl_conncache_unlock();
						} 
				} 
				if (connections_available && (max_total_connections > 0) && (data.Curl_conncache_size() >= max_total_connections)) {
					connectdata conn_candidate = new connectdata();
					conn_candidate = connectdata.Curl_conncache_extract_oldest(/* The cache is full. Let's see if we can kill a connection. */data);
					if (conn_candidate) {
						(Object)ModernizedCProgram.Curl_disconnect(data, conn_candidate, /* dead_connection */0);
					} else {
							data.Curl_infof("No connections available in cache\n");
							connections_available = 0;
					} 
				} 
				if (!connections_available) {
					data.Curl_infof("No connections available.\n");
					conn.conn_free();
					in_connect = ((Object)0);
					result = CURLE_NO_CONNECTION_AVAILABLE;
					;
				} else {
						result = ModernizedCProgram.Curl_conncache_add_conn(generatedState.getConn_cache(), conn);
						if (result) {
							;
						} 
				} 
				if ((generatedState.getAuthhost().getPicked() & (CURLAUTH_NTLM | /* If NTLM is requested in a part of this connection, make sure we don't
				       assume the state is fine as this is a fresh connection and NTLM is
				       connection based. */CURLAUTH_NTLM_WB)) && generatedState.getAuthhost().getDone()) {
					data.Curl_infof("NTLM picked AND auth done set, clear picked!\n");
					generatedState.getAuthhost().setPicked(CURLAUTH_NONE);
					generatedState.getAuthhost().setDone(0);
				} 
				if ((generatedState.getAuthproxy().getPicked() & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) && generatedState.getAuthproxy().getDone()) {
					data.Curl_infof("NTLM-proxy picked AND auth done set, clear picked!\n");
					generatedState.getAuthproxy().setPicked(CURLAUTH_NONE);
					generatedState.getAuthproxy().setDone(0);
				} 
		} 
		ModernizedCProgram.Curl_init_do(data, /* Setup and init stuff before DO starts, in preparing for the transfer. */conn/*
		   * Setup whatever necessary for a resumed transfer
		   */);
		result = data.setup_range();
		if (result) {
			;
		} 
		conn.setSeek_func(generatedSet.getSeek_func());
		conn.setSeek_client(generatedSet.getSeek_client());
		result = ModernizedCProgram.resolve_server(data, conn, async);
		generatedHost.strip_trailing_dot();
		if (generatedHttpproxy) {
			generatedHost.strip_trailing_dot();
		} 
		if (generatedSocksproxy) {
			generatedHost.strip_trailing_dot();
		} 
		if (generatedConn_to_host) {
			generatedConn_to_host.strip_trailing_dot();
		} 
	}
	public static Object Curl_init_do(Curl_easy data, connectdata conn) {
		Object generatedReq = data.getReq();
		SingleRequest k = generatedReq;
		ConnectBits generatedBits = conn.getBits();
		Object generatedState = data.getState();
		Object generatedHandler = conn.getHandler();
		if (conn) {
			generatedBits.setDo_more(/* by default there's no curl_do_more() to
			                                   use */0);
			if (generatedState.getWildcardmatch() && !(generatedHandler.getFlags() & (1 << 12))) {
				generatedState.setWildcardmatch(0);
			} 
		} 
		generatedState.setDone(/* *_done() is not called yet */0);
		generatedState.setExpect100header(0);
		Object generatedSet = data.getSet();
		if (generatedSet.getOpt_no_body()) {
			generatedSet.setHttpreq(/* in HTTP lingo, no body means using the HEAD request... */.HTTPREQ_HEAD);
		}  else if (.HTTPREQ_HEAD == generatedSet.getHttpreq()) {
			generatedSet.setHttpreq(.HTTPREQ_GET);
		} 
		curltime curltime = new curltime();
		k.setStart(curltime.Curl_now());
		curltime generatedStart = k.getStart();
		k.setNow(generatedStart);
		k.setHeader(/* assume header */1);
		k.setBytecount(0);
		k.setBuf(generatedState.getBuffer());
		k.setHbufp(generatedState.getHeaderbuff());
		k.setIgnorebody(0);
		data.Curl_speedinit();
		data.Curl_pgrsSetUploadCounter(0);
		data.Curl_pgrsSetDownloadCounter(0);
		return CURLE_OK/*
		* get_protocol_family()
		*
		* This is used to return the protocol family for a given protocol.
		*
		* Parameters:
		*
		* protocol  [in]  - A single bit protocol identifier such as HTTP or HTTPS.
		*
		* Returns the family as a single bit protocol identifier.
		*/;
	}
	public static int get_protocol_family(int protocol) {
		int family;
		switch (protocol) {
		case CURLPROTO_RTSP:
				family = CURLPROTO_RTSP;
				break;
		case CURLPROTO_RTMPT:
		case CURLPROTO_LDAPS:
				family = CURLPROTO_LDAP;
				break;
		case CURLPROTO_DICT:
				family = CURLPROTO_DICT;
				break;
		case CURLPROTO_HTTP:
		case CURLPROTO_LDAP:
		case CURLPROTO_RTMPTE:
				family = CURLPROTO_RTMPTE;
				break;
		case CURLPROTO_FILE:
				family = CURLPROTO_FILE;
				break;
		case CURLPROTO_RTMPE:
				family = CURLPROTO_RTMPE;
				break;
		case CURLPROTO_FTP:
		case CURLPROTO_SFTP:
				family = CURLPROTO_SFTP;
				break;
		case CURLPROTO_IMAP:
		case CURLPROTO_RTMPS:
				family = CURLPROTO_RTMP;
				break;
		case CURLPROTO_FTPS:
				family = CURLPROTO_FTP;
				break;
		case CURLPROTO_RTMPTS:
				family = CURLPROTO_RTMPT;
				break;
		case CURLPROTO_SMB:
		case CURLPROTO_HTTPS:
				family = CURLPROTO_HTTP;
				break;
		case CURLPROTO_GOPHER:
				family = CURLPROTO_GOPHER;
				break;
		case CURLPROTO_TELNET:
				family = CURLPROTO_TELNET;
				break;
		case CURLPROTO_TFTP:
				family = CURLPROTO_TFTP;
				break;
		case CURLPROTO_POP3:
		case CURLPROTO_SMTP:
		case CURLPROTO_POP3S:
				family = CURLPROTO_POP3;
				break;
		case CURLPROTO_SMTPS:
				family = CURLPROTO_SMTP;
				break;
		case CURLPROTO_IMAPS:
				family = CURLPROTO_IMAP;
				break;
		case CURLPROTO_SMBS:
				family = CURLPROTO_SMB;
				break;
		case CURLPROTO_RTMP:
		case CURLPROTO_SCP:
				family = CURLPROTO_SCP;
				break;
		default:
				family = 0;
				break;
		}
		return family;
	}
	/* Some parts of the code (e.g. chunked encoding) assume this buffer has at
	 * more than just a few bytes to play with. Don't let it become too small or
	 * bad things will happen.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2004 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static Object curl_easy_strerror(Object error) {
		switch (error) {
		case CURLE_FTP_PORT_FAILED:
				return "FTP: command PORT failed";
		case CURLE_TFTP_ILLEGAL:
				return "TFTP: Illegal operation";
		case CURLE_FTP_WEIRD_PASS_REPLY:
				return "FTP: unknown PASS reply";
		case CURLE_FTP_COULDNT_USE_REST:
				return "FTP: command REST failed";
		case CURLE_UPLOAD_FAILED:
				return "Upload failed (at start/before it took off)";
		case CURLE_SSL_SHUTDOWN_FAILED:
				return "Failed to shut down the SSL connection";
		case /* error codes not used by current libcurl */CURLE_OBSOLETE20:
		case CURLE_URL_MALFORMAT:
				return "URL using bad/illegal format or missing URL";
		case CURLE_COULDNT_RESOLVE_PROXY:
				return "Couldn't resolve proxy name";
		case CURLE_WRITE_ERROR:
				return "Failed writing received data to disk/application";
		case CURLE_OBSOLETE32:
		case CURLE_OUT_OF_MEMORY:
				return "Out of memory";
		case CURLE_BAD_FUNCTION_ARGUMENT:
				return "A libcurl function was given a bad argument";
		case CURLE_OK:
				return "No error";
		case CURLE_REMOTE_ACCESS_DENIED:
				return "Access denied to remote resource";
		case CURLE_FILE_COULDNT_READ_FILE:
				return "Couldn't read a file:// file";
		case CURLE_CONV_FAILED:
				return "Conversion failed";
		case CURLE_COULDNT_CONNECT:
				return "Couldn't connect to server";
		case CURLE_CONV_REQD:
				return "Caller must register CURLOPT_CONV_ callback options";
		case CURLE_TFTP_NOSUCHUSER:
				return "TFTP: No such user";
		case CURLE_REMOTE_DISK_FULL:
				return "Disk full or allocation exceeded";
		case CURLE_SSL_CONNECT_ERROR:
				return "SSL connect error";
		case CURLE_FTP_PRET_FAILED:
				return "FTP: The server did not accept the PRET command.";
		case CURLE_SSL_CERTPROBLEM:
				return "Problem with the local SSL certificate";
		case CURLE_FTP_COULDNT_SET_TYPE:
				return "FTP: couldn't set file type";
		case CURLE_SSL_ENGINE_SETFAILED:
				return "Can not set SSL crypto engine as default";
		case CURLE_TFTP_UNKNOWNID:
				return "TFTP: Unknown transfer ID";
		case CURLE_FTP_BAD_FILE_LIST:
				return "Unable to parse FTP file list";
		case CURLE_FTP_ACCEPT_FAILED:
				return "FTP: The server failed to connect to data port";
		case CURLE_SSL_CIPHER:
				return "Couldn't use specified SSL cipher";
		case CURLE_FILESIZE_EXCEEDED:
				return "Maximum file size exceeded";
		case CURLE_AGAIN:
				return "Socket not ready for send/recv";
		case CURLE_RANGE_ERROR:
				return "Requested range was not delivered by the server";
		case CURLE_RECV_ERROR:
				return "Failure when receiving data from the peer";
		case CURLE_REMOTE_FILE_EXISTS:
				return "Remote file already exists";
		case CURLE_OBSOLETE44:
		case CURLE_FTP_ACCEPT_TIMEOUT:
				return "FTP: Accepting server connect has timed out";
		case CURLE_SSL_ENGINE_NOTFOUND:
				return "SSL crypto engine not found";
		case CURL_LAST:
				break;
		case CURLE_RTSP_CSEQ_ERROR:
				return "RTSP CSeq mismatch or invalid CSeq";
		case CURLE_NOT_BUILT_IN:
				return "A requested feature, protocol or option was not found built-in in this libcurl due to a build-time decision.";
		case CURLE_OBSOLETE51:
		case CURLE_LDAP_CANNOT_BIND:
				return "LDAP: cannot bind";
		case CURLE_BAD_CONTENT_ENCODING:
				return "Unrecognized or bad HTTP Content or Transfer-Encoding";
		case CURLE_NO_CONNECTION_AVAILABLE:
				return "The max connection limit is reached";
		case CURLE_UNKNOWN_OPTION:
				return "An unknown option was passed in to libcurl";
		case CURLE_SSL_PINNEDPUBKEYNOTMATCH:
				return "SSL public key does not match pinned public key";
		case CURLE_REMOTE_FILE_NOT_FOUND:
				return "Remote file not found";
		case CURLE_PARTIAL_FILE:
				return "Transferred a partial file";
		case CURLE_FTP_COULDNT_RETR_FILE:
				return "FTP: couldn't retrieve (RETR failed) the specified file";
		case CURLE_OBSOLETE24:
		case CURLE_FTP_WEIRD_PASV_REPLY:
				return "FTP: unknown PASV reply";
		case CURLE_RECURSIVE_API_CALL:
				return "API function called from within callback";
		case CURLE_SEND_ERROR:
				return "Failed sending data to the peer";
		case CURLE_TOO_MANY_REDIRECTS:
				return "Number of redirects hit maximum amount";
		case CURLE_OBSOLETE40:
		case CURLE_TFTP_NOTFOUND:
				return "TFTP: File Not Found";
		case CURLE_OBSOLETE29:
		case CURLE_HTTP2_STREAM:
				return "Stream error in the HTTP/2 framing layer";
		case CURLE_LOGIN_DENIED:
				return "Login denied";
		case CURLE_ABORTED_BY_CALLBACK:
				return "Operation was aborted by an application callback";
		case CURLE_AUTH_ERROR:
				return "An authentication function returned an error";
		case CURLE_QUOTE_ERROR:
				return "Quote command returned error";
		case CURLE_TELNET_OPTION_SYNTAX:
				return "Malformed telnet option";
		case CURLE_HTTP2:
				return "Error in the HTTP2 framing layer";
		case CURLE_LDAP_SEARCH_FAILED:
				return "LDAP: search failed";
		case CURLE_SSL_CACERT_BADFILE:
				return "Problem with the SSL CA cert (path? access rights?)";
		case CURLE_FUNCTION_NOT_FOUND:
				return "A required function in the library was not found";
		case CURLE_READ_ERROR:
				return "Failed to open/read local data from file/application";
		case CURLE_FAILED_INIT:
				return "Failed initialization";
		case CURLE_INTERFACE_FAILED:
				return "Failed binding local connection end";
		case CURLE_UNSUPPORTED_PROTOCOL:
				return "Unsupported protocol";
		case CURLE_HTTP_POST_ERROR:
				return "Internal problem setting up the POST";
		case CURLE_SSL_CRL_BADFILE:
				return "Failed to load CRL file (path? access rights?, format?)";
		case CURLE_RTSP_SESSION_ERROR:
				return "RTSP session error";
		case CURLE_SSH:
				return "Error in the SSH layer";
		case CURLE_FTP_CANT_GET_HOST:
				return "FTP: can't figure out the host in the PASV response";
		case CURLE_OBSOLETE46:
		case CURLE_OPERATION_TIMEDOUT:
				return "Timeout was reached";
		case CURLE_LDAP_INVALID_URL:
				return "Invalid LDAP URL";
		case CURLE_SSL_INVALIDCERTSTATUS:
				return "SSL server certificate status verification FAILED";
		case CURLE_SSL_ENGINE_INITFAILED:
				return "Failed to initialise SSL crypto engine";
		case CURLE_SSL_ISSUER_ERROR:
				return "Issuer check against peer certificate failed";
		case CURLE_PEER_FAILED_VERIFICATION:
				return "SSL peer certificate or SSH remote key was not OK";
		case CURLE_OBSOLETE50:
		case CURLE_COULDNT_RESOLVE_HOST:
				return "Couldn't resolve host name";
		case CURLE_TFTP_PERM:
				return "TFTP: Access Violation";
		case CURLE_USE_SSL_FAILED:
				return "Requested SSL level failed";
		case CURLE_FTP_WEIRD_227_FORMAT:
				return "FTP: unknown 227 response format";
		case CURLE_SEND_FAIL_REWIND:
				return "Send failed since rewinding of the data stream failed";
		case CURLE_CHUNK_FAILED:
				return "Chunk callback failed";
		case CURLE_WEIRD_SERVER_REPLY:
				return "Weird server reply";
		case CURLE_BAD_DOWNLOAD_RESUME:
				return "Couldn't resume download";
		case CURLE_OBSOLETE57:
		case CURLE_HTTP_RETURNED_ERROR:
				return "HTTP response code said error";
		case CURLE_GOT_NOTHING:
				return "Server returned nothing (no headers, no data)";
		}
		return "Unknown error";
	}
	public static Object curl_multi_strerror(Object error) {
		switch (error) {
		case CURLM_INTERNAL_ERROR:
				return "Internal error";
		case CURLM_UNKNOWN_OPTION:
				return "Unknown option";
		case CURLM_ADDED_ALREADY:
				return "The easy handle is already added to a multi handle";
		case CURLM_OUT_OF_MEMORY:
				return "Out of memory";
		case CURLM_OK:
				return "No error";
		case CURLM_BAD_EASY_HANDLE:
				return "Invalid easy handle";
		case CURLM_LAST:
				break;
		case CURLM_CALL_MULTI_PERFORM:
				return "Please call curl_multi_perform() soon";
		case CURLM_BAD_HANDLE:
				return "Invalid multi handle";
		case CURLM_RECURSIVE_API_CALL:
				return "API function called from within callback";
		case CURLM_BAD_SOCKET:
				return "Invalid socket argument";
		}
		return "Unknown error";
	}
	public static Object curl_share_strerror(Object error) {
		switch (error) {
		case CURLSHE_NOMEM:
				return "Out of memory";
		case CURLSHE_IN_USE:
				return "Share currently in use";
		case CURLSHE_OK:
				return "No error";
		case CURLSHE_NOT_BUILT_IN:
				return "Feature not enabled in this library";
		case CURLSHE_LAST:
				break;
		case CURLSHE_BAD_OPTION:
				return "Unknown share option";
		case CURLSHE_INVALID:
				return "Invalid share handle";
		}
		return "CURLSHcode unknown";
	}
	/* This function handles most / all (?) Winsock errors curl is able to produce.
	 */
	public static Object get_winsock_error(int err, Byte buf, Object len) {
		DWORD old_win_err = .GetLastError();
		int old_errno = (._errno());
		byte p;
		switch (err) {
		case /* missing in SalfordC! */-1024:
				p = "Disconnected";
				break;
		case -1024:
				p = "Network has been reset";
				break;
		case -1024:
				p = "Too many users";
				break;
		case -1024:
				p = "Bad access";
				break;
		case -1024:
				p = "Process limit reached";
				break;
		case /* Extended Winsock errors */-1024:
				p = "Winsock library is not ready";
				break;
		case -1024:
				p = "Connection was reset";
				break;
		case -1024:
				p = "Winsock library not initialised";
				break;
		case -1024:
				p = "Operation not supported";
				break;
		case -1024:
		case -1024:
				p = "Network unreachable";
				break;
		case -1024:
				p = "Protocol is unsupported";
				break;
		case /* Non-Authoritative: Host not found, or SERVERFAIL */-1024:
				p = "Host not found, try again";
				break;
		case -1024:
				p = "Bad file";
				break;
		case -1024:
				p = "Connection refused";
				break;
		case -1024:
				p = "Socket is unsupported";
				break;
		case -1024:
				p = "Blocking call in progress";
				break;
		case -1024:
				p = "Bad argument";
				break;
		case -1024:
				p = "Call interrupted";
				break;
		case -1024:
				p = "Socket is already connected";
				break;
		case -1024:
				p = "Out of file descriptors";
				break;
		case -1024:
				p = "Socket has been shut down";
				break;
		case -1024:
				p = "Need destination address";
				break;
		case -1024:
				p = "Call would block";
				break;
		case /* getXbyY() errors (already handled in herrmsg):
		     * Authoritative Answer: Host not found */-1024:
				p = "Host not found";
				break;
		case /* Valid name, no data record of requested type */-1024:
				p = "No data record of requested type";
				break;
		case -1024:
				p = "Invalid arguments";
				break;
		case -1024:
				p = "Address already in use";
				break;
		case -1024:
				p = "Bad message size";
				break;
		case -1024:
				p = "Loop??";
				break;
		case -1024:
				p = "Host down";
				break;
		case -1024:
				p = "Name too long";
				break;
		case -1024:
				p = "Timed out";
				break;
		case -1024:
				p = "Address not available";
				break;
		case -1024:
				p = "Address family not supported";
				break;
		case -1024:
				p = "No buffer space";
				break;
		case -1024:
				p = "Bad protocol";
				break;
		case -1024:
				p = "Not empty";
				break;
		case -1024:
				p = "Host unreachable";
				break;
		case -1024:
				p = "Descriptor is not a socket";
				break;
		case -1024:
				p = "Too many references";
				break;
		case -1024:
				p = "Protocol option is unsupported";
				break;
		case -1024:
				p = "Winsock version not supported";
				break;
		case -1024:
				p = "Connection was aborted";
				break;
		case -1024:
				p = "Network down";
				break;
		case -1024:
				p = "Socket is not connected";
				break;
		case -1024:
				p = "Protocol family not supported";
				break;
		case -1024:
				p = "Remote error";
				break;
		case /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */-1024:
				p = "Unrecoverable error in call to nameserver";
				break;
		case -1024:
				p = "Bad quota";
				break;
		case -1024:
				p = "Something is stale";
				break;
		default:
				return ((Object)0);
		}
		.strncpy(buf, p, len);
		buf[len - 1] = (byte)'\0';
		if ((._errno()) != old_errno) {
			(._errno()) = old_errno;
		} 
		if (old_win_err != .GetLastError()) {
			.SetLastError(old_win_err);
		} 
		return buf/* USE_WINSOCK *//*
		 * Our thread-safe and smart strerror() replacement.
		 *
		 * The 'err' argument passed in to this function MUST be a true errno number
		 * as reported on this system. We do no range checking on the number before
		 * we pass it to the "number-to-message" conversion function and there might
		 * be systems that don't do proper range checking in there themselves.
		 *
		 * We don't do range checking (on systems other than Windows) since there is
		 * no good reliable and portable way to do it.
		 */;
	}
	public static Object Curl_strerror(int err, byte buf, Object buflen) {
		DWORD old_win_err = .GetLastError();
		int old_errno = (._errno());
		byte p;
		size_t max = new size_t();
		do {
		} while (0);
		max = buflen - 1;
		buf = (byte)'\0';
		if (err >= 0 && err < /* 'sys_nerr' is the maximum errno number, it is not widely portable */_sys_nerr) {
			.strncpy(buf, .strerror(err), max);
		} else {
				if (!ModernizedCProgram.get_winsock_error(err, buf, max) && !.FormatMessageA(4096, ((Object)0), err, -1024, buf, (DWORD)max, ((Object)0))) {
					ModernizedCProgram.curl_msnprintf(buf, max, "Unknown error %d (%#x)", err, err/* not USE_WINSOCK coming up *//*
					  * The POSIX-style strerror_r() may set errno to ERANGE if insufficient
					  * storage is supplied via 'strerrbuf' and 'buflen' to hold the generated
					  * message string, or EINVAL if 'errnum' is not a valid error number.
					  */);
				} 
		} 
		/*
		  * The glibc-style strerror_r() only *might* use the buffer we pass to
		  * the function, but it always returns the error message as a pointer,
		  * so we must copy that string unconditionally (if non-NULL).
		  */
		/*
		  * The vxworks-style strerror_r() does use the buffer we pass to the function.
		  * The buffer size should be at least NAME_MAX (256)
		  *//*
		  * The vxworks-style strerror_r() does use the buffer we pass to the function.
		  * The buffer size should be at least NAME_MAX (256)
		  */buf[max] = /* end of ! USE_WINSOCK *//* make sure the string is zero terminated */(byte)'\0';
		p = .strrchr(buf, /* strip trailing '\r\n' or '\n'. */(byte)'\n');
		if (p && (p - buf) >= 2) {
			p = (byte)'\0';
		} 
		p = .strrchr(buf, (byte)'\r');
		if (p && (p - buf) >= 1) {
			p = (byte)'\0';
		} 
		if ((._errno()) != old_errno) {
			(._errno()) = old_errno;
		} 
		if (old_win_err != .GetLastError()) {
			.SetLastError(old_win_err);
		} 
		return buf;
	}
	/* strip trailing '\r\n' or '\n' */
	/* USE_WINDOWS_SSPI */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* zlib pollutes the namespace with this definition */
	/* buffer size for decompressed data */
	/* Comment this out if zlib is always going to be at least ver. 1.2.0.4
	   (doing so will reduce code size slightly). */
	/* gzip flag byte */
	/* bit 0 set: file probably ascii text */
	/* bit 1 set: header CRC present */
	/* bit 2 set: extra field present */
	/* bit 3 set: original file name present */
	/* bit 4 set: file comment present */
	/* bits 5..7: reserved */
	/* uninitialized */
	/* initialized */
	/* inflating started. */
	/* reading external trailer */
	/* reading gzip header */
	/* inflating gzip stream */
	/* initialized in transparent gzip mode */
	/* Writer parameters. */
	/* zlib init state */
	/* Remaining trailer byte count. */
	/* State structure for zlib. */
	/* not a typo, keep it calloc() */
	/* Consume expected trailer bytes. Terminate stream if exhausted.
	     Issue an error if unexpected bytes follow. */
	/* Only occurs for gzip with zlib < 1.2.0.4 or raw deflate. */
	/* zlib state structure */
	/* Curl_client_write status */
	/* Put the decompressed data here. */
	/* Check state. */
	/* Dynamically allocate a buffer for decompression because it's uncommonly
	     large to hold on the stack */
	/* because the buffer size is fixed, iteratively decompress and transfer to
	     the client via downstream_write function. */
	/* zlib status */
	/* (re)set buffer for decompressed output for every iteration */
	/* Z_BLOCK is only available in zlib ver. >= 1.2.0.5 */
	/* fallback for zlib ver. < 1.2.0.5 */
	/* Flush output data if some. */
	/* Data started. */
	/* Dispatch by inflate() status. */
	/* Always loop: there may be unflushed latched data in zlib state. */
	/* No more data to flush: just exit loop. */
	/* some servers seem to not generate zlib headers, so this is an attempt
	         to fix and continue anyway */
	/* Do not use inflateReset2(): only available since zlib 1.2.3.4. */
	/* don't care about the return code */
	/* Tolerate up to 4 unknown trailer bytes. */
	/* inflateEnd() already called. */
	/* FALLTHROUGH */
	/* We're about to leave this call so the `nread' data bytes won't be seen
	     again. If we are in a state that would wrongly allow restart in raw mode
	     at the next call, assume output has already started. */
	/* Cannot restart anymore. */
	/* Deflate handler. */
	/* zlib state structure */
	/* Initialize zlib */
	/* zlib state structure */
	/* Set the compressed input when this function is called */
	/* Now uncompress the data */
	/* zlib state structure */
	/* Gzip handler. */
	/* zlib state structure */
	/* Initialize zlib */
	/* zlib ver. >= 1.2.0.4 supports transparent gzip decompressing */
	/* Transparent gzip decompress state */
	/* we must parse the gzip header and trailer ourselves */
	/* A CRC-32 and a 32-bit input size (RFC 1952, 2.2) */
	/* Initial call state */
	/* Skip over the gzip header */
	/* The shortest header is 10 bytes */
	/* Can't handle this compression method or unknown flag */
	/* Skip over time, xflags, OS code and all previous bytes */
	/* Skip over NUL-terminated file name */
	/* Skip over the NUL */
	/* Skip over NUL-terminated comment */
	/* Skip over the NUL */
	/* zlib state structure */
	/* Let zlib handle the gzip decompression entirely */
	/* Now uncompress the data */
	/* Support for old zlib versions is compiled away and we are running with
	     an old version, so return an error. */
	/* This next mess is to get around the potential case where there isn't
	   * enough data passed in to skip over the gzip header.  If that happens, we
	   * malloc a block and copy what we have then wait for the next call.  If
	   * there still isn't enough (this is definitely a worst-case scenario), we
	   * make the block bigger, copy the next part in and keep waiting.
	   *
	   * This is only required with zlib versions < 1.2.0.4 as newer versions
	   * can handle the gzip header themselves.
	   */
	/* Skip over gzip header? */
	/* Initial call state */
	/* Inflating stream state */
	/* We need more data so we can find the end of the gzip header.  It's
	       * possible that the memory block we malloc here will never be freed if
	       * the transfer abruptly aborts after this point.  Since it's unlikely
	       * that circumstances will be right for this code path to be followed in
	       * the first place, and it's even more unlikely for a transfer to fail
	       * immediately afterwards, it should seldom be a problem.
	       */
	/* Need more gzip header data state */
	/* We don't have any data to inflate yet */
	/* Need more gzip header data state */
	/* Append the new block of data to the previous one */
	/* This is the zlib stream data */
	/* Don't point into the malloced block since we just freed it */
	/* Inflating stream state */
	/* We still don't have any data to inflate! */
	/* Inflating stream state */
	/* We don't have any data to inflate; wait until next time */
	/* We've parsed the header, now uncompress the data */
	/* zlib state structure */
	/* HAVE_LIBZ */
	/* Writer parameters. */
	/* State structure for brotli. */
	/* Stream already ended. */
	/* Identity handler. */
	public static Object identity_init_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		contenc_writer_s generatedDownstream = writer.getDownstream();
		return generatedDownstream ? CURLE_OK : CURLE_WRITE_ERROR;
	}
	public static Object identity_unencode_write(connectdata conn, contenc_writer_s writer, Object buf, Object nbytes) {
		contenc_writer_s generatedDownstream = writer.getDownstream();
		return ModernizedCProgram.Curl_unencode_write(conn, generatedDownstream, buf, nbytes);
	}
	public static void identity_close_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Return a list of comma-separated names of supported encodings. */
	public static Byte Curl_all_content_encodings() {
		size_t len = 0;
		content_encoding cep = new content_encoding();
		content_encoding ce = new content_encoding();
		byte ace;
		for (cep = ModernizedCProgram.encodings; cep; cep++) {
			ce = cep;
			if (!ModernizedCProgram.Curl_strcasecompare(ce.getName(), "identity")) {
				len += .strlen(ce.getName()) + 2;
			} 
		}
		if (!len) {
			return .Curl_cstrdup("identity");
		} 
		ace = .Curl_cmalloc(len);
		if (ace) {
			byte p = ace;
			for (cep = ModernizedCProgram.encodings; cep; cep++) {
				ce = cep;
				if (!ModernizedCProgram.Curl_strcasecompare(ce.getName(), "identity")) {
					.strcpy(p, ce.getName());
					p += .strlen(p);
					p++ = (byte)',';
					p++ = (byte)' ';
				} 
			}
			p[-2] = (byte)'\0';
		} 
		return ace;
	}
	/* Real client writer: no downstream. */
	public static Object client_init_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		contenc_writer_s generatedDownstream = writer.getDownstream();
		return generatedDownstream ? CURLE_WRITE_ERROR : CURLE_OK;
	}
	public static Object client_unencode_write(connectdata conn, contenc_writer_s writer, Object buf, Object nbytes) {
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Object generatedReq = data.getReq();
		SingleRequest k = generatedReq;
		(Object)writer;
		Object generatedIgnorebody = k.getIgnorebody();
		if (!nbytes || generatedIgnorebody) {
			return CURLE_OK;
		} 
		return conn.Curl_client_write((1 << 0), (byte)buf, nbytes);
	}
	public static void client_close_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Deferred error dummy writer. */
	public static Object error_init_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		contenc_writer_s generatedDownstream = writer.getDownstream();
		return generatedDownstream ? CURLE_OK : CURLE_WRITE_ERROR;
	}
	public static Object error_unencode_write(connectdata conn, contenc_writer_s writer, Object buf, Object nbytes) {
		byte all = ModernizedCProgram.Curl_all_content_encodings();
		(Object)writer;
		(Object)buf;
		(Object)nbytes;
		if (!all) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Curl_easy generatedData = conn.getData();
		generatedData.Curl_failf("Unrecognized content encoding type. libcurl understands %s content encodings.", all);
		.Curl_cfree(all);
		return CURLE_BAD_CONTENT_ENCODING;
	}
	public static void error_close_writer(connectdata conn, contenc_writer_s writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Write data using an unencoding writer stack. */
	public static Object Curl_unencode_write(connectdata conn, contenc_writer_s writer, Object buf, Object nbytes) {
		if (!nbytes) {
			return CURLE_OK;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(conn, writer, buf, nbytes);
	}
	/* Find the content encoding by name. */
	public static Object find_encoding(Object name, Object len) {
		content_encoding cep = new content_encoding();
		for (cep = ModernizedCProgram.encodings; cep; cep++) {
			content_encoding ce = cep;
			if ((ModernizedCProgram.Curl_strncasecompare(name, ce.getName(), len) && !ce.getName()[len]) || (ce.getAlias() && ModernizedCProgram.Curl_strncasecompare(name, ce.getAlias(), len) && !ce.getAlias()[len])) {
				return ce;
			} 
		}
		return ((Object)0);
	}
	public static int progress_callback(Object clientp, double dltotal, double dlnow, double ultotal, double ulnow) {
		int prev_ultotal = -1;
		int prev_ulnow = -1;
		(Object)/* UNUSED */clientp;
		(Object)/* UNUSED */dltotal;
		(Object)/* UNUSED */dlnow/* to avoid depending on timing, which will cause this progress function to
		     get called a different number of times depending on circumstances, we
		     only log these lines if the numbers are different from the previous
		     invoke */;
		if ((prev_ultotal != (int)ultotal) || (prev_ulnow != (int)ulnow)) {
			FILE moo = .fopen(ModernizedCProgram.libtest_arg2, "ab");
			if (moo) {
				moo.curl_mfprintf("Progress callback called with UL %d out of %d\n", (int)ulnow, (int)ultotal);
				.fclose(moo);
			} 
			prev_ulnow = (int)ulnow;
			prev_ultotal = (int)ultotal;
		} 
		return 0;
		FILE moo = .fopen(ModernizedCProgram.libtest_arg2, "wb");
		(Object)/* UNUSED */clientp;
		(Object)/* UNUSED */dltotal;
		(Object)/* UNUSED */dlnow;
		if (moo) {
			if ((size_t)ultotal == ModernizedCProgram.data_size && (size_t)ulnow == ModernizedCProgram.data_size) {
				moo.curl_mfprintf("PASSED, UL data matched data size\n");
			} else {
					moo.curl_mfprintf("Progress callback called with UL %f out of %f\n", ulnow, ultotal);
			} 
			.fclose(moo);
		} 
		return 0;
		(Object)clientp;
		(Object)ulnow;
		(Object)ultotal;
		if ((dltotal > 0.0) && (dlnow > dltotal)) {
			ModernizedCProgram.curl_mprintf("%.0f > %.0f !!\n", dltotal, /* this should not happen with test case 599 */dlnow);
			return -1;
		} 
		return 0;
	}
	public static int trailers_callback(Object list, Object userdata) {
		(Object)userdata;
		list = list.curl_slist_append("my-super-awesome-trailer: trail1");
		list = list.curl_slist_append("my-other-awesome-trailer: trail2");
		return CURL_TRAILERFUNC_OK;
	}
	/*
	 * Returns zero on success.
	 */
	public static int parsenetrc(Object host, byte loginp, byte passwordp,  login_changed,  password_changed, Byte netrcfile) {
		FILE file = new FILE();
		int retcode = 1;
		byte login = loginp;
		byte password = passwordp;
		bool specific_login = (login && login != 0);
		bool login_alloc = 0;
		bool password_alloc = 0;
		host_lookup_state state = host_lookup_state.NOTHING;
		byte state_login = /* Found a login keyword */0;
		byte state_password = /* Found a password keyword */0;
		int state_our_login = /* With specific_login, found *our* login
		                                   name */0;
		do {
		} while (0);
		file = .fopen(netrcfile, "rt");
		return retcode/*
		 * @unittest: 1304
		 *
		 * *loginp and *passwordp MUST be allocated if they aren't NULL when passed
		 * in.
		 */;
	}
	public static int Curl_parsenetrc(Object host, Byte loginp, Byte passwordp,  login_changed,  password_changed, Byte netrcfile) {
		int retcode = 1;
		byte filealloc = ((Object)0);
		if (!netrcfile) {
			byte home = ((Object)0);
			byte homea = ModernizedCProgram.curl_getenv(/* portable environment reader */"HOME");
			if (homea) {
				home = homea;
			} 
			if (!home) {
				return /* no home directory found (or possibly out of
				                         memory) */retcode;
			} 
			filealloc = ModernizedCProgram.curl_maprintf("%s%s.netrc", home, "\\");
			if (!filealloc) {
				.Curl_cfree(homea);
				return -1;
			} 
			retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, filealloc);
			.Curl_cfree(filealloc);
			if (retcode == 1) {
				filealloc = ModernizedCProgram.curl_maprintf("%s%s_netrc", home, /* fallback to the old-style "_netrc" file */"\\");
				if (!filealloc) {
					.Curl_cfree(homea);
					return -1;
				} 
				retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, filealloc);
				.Curl_cfree(filealloc);
			} 
			.Curl_cfree(homea);
		} else {
				retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, netrcfile);
		} 
		return retcode;
	}
	public static  Curl_HMAC_init(Object hashparams, Object key, int keylen) {
		size_t i = new size_t();
		HMAC_context ctxt = new HMAC_context();
		byte hkey;
		byte b;
		i =  + 2 * hashparams.getHmac_ctxtsize() + hashparams.getHmac_resultlen();
		ctxt = .Curl_cmalloc(i);
		if (!ctxt) {
			return ctxt;
		} 
		ctxt.setHmac_hash(hashparams);
		ctxt.setHmac_hashctxt1((Object)(ctxt + 1));
		Object generatedHmac_hashctxt1 = ctxt.getHmac_hashctxt1();
		ctxt.setHmac_hashctxt2((Object)((byte)generatedHmac_hashctxt1 + hashparams.getHmac_ctxtsize()));
		Object generatedHmac_hashctxt2 = ctxt.getHmac_hashctxt2();
		if (keylen > hashparams.getHmac_maxkeylen()) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1);
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1, key, keylen);
			hkey = (byte)generatedHmac_hashctxt2 + hashparams.getHmac_ctxtsize();
			.UNRECOGNIZEDFUNCTIONNAME(hkey, generatedHmac_hashctxt1);
			key = hkey;
			keylen = hashparams.getHmac_resultlen();
		} 
		.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1);
		.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt2);
		for (i = 0; i < keylen; i++) {
			b = (byte)(key ^ ModernizedCProgram.hmac_ipad);
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1, b, 1);
			b = (byte)(key++ ^ ModernizedCProgram.hmac_opad);
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt2, b, 1);
		}
		for (; i < hashparams.getHmac_maxkeylen(); i++) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1, ModernizedCProgram.hmac_ipad, 1);
			.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt2, ModernizedCProgram.hmac_opad, 1);
		}
		return /* Done, return pointer to HMAC context. */ctxt;
	}
	public static int Curl_HMAC_update(Object data, int len) {
		Object generatedHmac_hashctxt1 = this.getHmac_hashctxt1();
		.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt1, data, /* Update first hash calculation. */len);
		return 0;
	}
	public static int Curl_HMAC_final(Byte result) {
		Object generatedHmac_hash = this.getHmac_hash();
		HMAC_params hashparams = generatedHmac_hash;
		Object generatedHmac_hashctxt2 = this.getHmac_hashctxt2();
		if (!result) {
			result = (byte)generatedHmac_hashctxt2 + generatedHmac_hash.getHmac_ctxtsize();
		} 
		Object generatedHmac_hashctxt1 = this.getHmac_hashctxt1();
		.UNRECOGNIZEDFUNCTIONNAME(result, generatedHmac_hashctxt1);
		.UNRECOGNIZEDFUNCTIONNAME(generatedHmac_hashctxt2, result, hashparams.getHmac_resultlen());
		.UNRECOGNIZEDFUNCTIONNAME(result, generatedHmac_hashctxt2);
		.Curl_cfree((byte)ctxt);
		return 0/* CURL_DISABLE_CRYPTO_AUTH */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* zlib pollutes the namespace with this definition */
	public static void Curl_version_init() {
		ModernizedCProgram.curl_version();
		ModernizedCProgram.curl_version_info(CURLVERSION_NOW);
	}
	/* For thread safety purposes this function is called by global_init so that
	   the static data in both version functions is initialized. */
	public static Byte curl_version() {
		bool initialized = new bool();
		byte[] version = new byte[250];
		byte ptr = version;
		size_t len = new size_t();
		size_t left = ;
		if (initialized) {
			return version;
		} 
		len = .strlen(ptr);
		left -= len;
		ptr += len;
		len = .Curl_ssl_version(ptr + 1, left - 1);
		if (len > 0) {
			ptr = (byte)' ';
			left -= ++len;
			ptr += len;
		} 
		/* this function is only present in c-ares, not in the original ares *//* version unknown *//* _LIBICONV_VERSION */
		(Object)/*
		  If another lib version is added below this one, this code would
		  also have to do:
		
		    len = what msnprintf() returned
		
		    left -= len;
		    ptr += len;
		*//* Silent scan-build even if librtmp is not enabled. */left;
		(Object)ptr;
		initialized = .bool_true;
		return version/* data for curl_version_info
		
		   Keep the list sorted alphabetically. It is also written so that each
		   protocol line has its own #if line to make things easier on the eye.
		 */;
	}
	public static Object curl_version_info(Object stamp) {
		bool initialized = new bool();
		if (initialized) {
			return ModernizedCProgram.version_info;
		} 
		/* libz left NULL if non-existing *//* This returns a version string if we use the given version or later,
		     otherwise it returns NULL */
		/* version unknown *//* _LIBICONV_VERSION *//* version unknown *//* _LIBICONV_VERSION */(Object)/* avoid compiler warnings, we don't use this */stamp;
		initialized = .bool_true;
		return ModernizedCProgram.version_info;
	}
	public static Object Curl_speedcheck(Curl_easy data, curltime now) {
		Object generatedProgress = data.getProgress();
		Object generatedSet = data.getSet();
		Object generatedState = data.getState();
		if ((generatedProgress.getCurrent_speed() >= 0) && generatedSet.getLow_speed_time()) {
			if (generatedProgress.getCurrent_speed() < generatedSet.getLow_speed_limit()) {
				if (!generatedState.getKeeps_speed().getTv_sec()) {
					generatedState.setKeeps_speed(/* under the limit at this very moment */now);
				} else {
						timediff_t howlong = now.Curl_timediff(generatedState.getKeeps_speed());
						if (howlong >= generatedSet.getLow_speed_time() * 1000) {
							/* too long */data.Curl_failf("Operation too slow. Less than %ld bytes/sec transferred the last %ld seconds", generatedSet.getLow_speed_limit(), generatedSet.getLow_speed_time());
							return CURLE_OPERATION_TIMEDOUT;
						} 
				} 
			} else {
					generatedState.getKeeps_speed().setTv_sec(/* faster right now */0);
			} 
		} 
		if (generatedSet.getLow_speed_limit()) {
			data.Curl_expire(1000, .EXPIRE_SPEEDCHECK);
		} 
		return CURLE_OK;
	}
	public static Object Curl_read_plain(Object sockfd, Byte buf, Object bytesfromsocket, Object n) {
		ssize_t nread = (ssize_t).recv((SOCKET)(sockfd), (byte)(buf), (int)(bytesfromsocket), (int)(false));
		if (-1 == nread) {
			int err = ((int).WSAGetLastError());
			int return_error;
			return_error = -1024 == err;
			if (return_error) {
				return CURLE_AGAIN;
			} 
			return CURLE_RECV_ERROR;
		} 
		n = /* we only return number of bytes read when we return OK */nread;
		return CURLE_OK/*
		 * Internal read-from-socket function. This is meant to deal with plain
		 * sockets, SSL sockets and kerberos sockets.
		 *
		 * Returns a regular CURLcode value.
		 */;
	}
	public static int sockopt_callback(Object clientp, Object curlfd, Object purpose) {
		int sndbufsize = 4 * /* 4KB send buffer */1024;
		(Object)clientp;
		(Object)purpose;
		.setsockopt(curlfd, -1024, -1024, (byte)sndbufsize, );
		return CURL_SOCKOPT_OK;
		(Object)clientp;
		(Object)curlfd;
		(Object)purpose;
		return /* This return code was added in libcurl 7.21.5 */CURL_SOCKOPT_ALREADY_CONNECTED;
	}
	public static void main_checkfds() {
	}
	/* Out of handles. This isn't really a big problem now, but
	                   will be when we try to create a socket later. */
	/* if CURL_MEMDEBUG is set, this starts memory tracking message logging */
	/* use the value as file name */
	public static void configure_terminal() {
		.memset(TerminalSettings, 0, );
		TerminalSettings.setHStdOut(.GetStdHandle((DWORD)(/* Enable VT output */true)));
		Object generatedHStdOut = TerminalSettings.getHStdOut();
		Object generatedDwOutputMode = TerminalSettings.getDwOutputMode();
		if ((generatedHStdOut != (HANDLE)(true)) && (.GetConsoleMode(generatedHStdOut, generatedDwOutputMode))) {
			.SetConsoleMode(generatedHStdOut, generatedDwOutputMode | -1024);
		} 
	}
	/*
	   * If we're running Windows, enable VT output.
	   * Note: VT mode flag can be set on any version of Windows, but VT
	   * processing only performed on Win10 >= Creators Update)
	   */
	public static void restore_terminal() {
		Object generatedHStdOut = TerminalSettings.getHStdOut();
		Object generatedDwOutputMode = TerminalSettings.getDwOutputMode();
		.SetConsoleMode(generatedHStdOut, generatedDwOutputMode);
	}
	public static Object WriteMemoryCallback(Object contents, Object size, Object nmemb, Object userp) {
		size_t realsize = size * nmemb;
		MemoryStruct mem = (MemoryStruct)userp;
		Byte generatedMemory = mem.getMemory();
		Object generatedSize = mem.getSize();
		byte ptr = .realloc(generatedMemory, generatedSize + realsize + 1);
		if (!ptr) {
			.printf(/* out of memory! */"not enough memory (realloc returned NULL)\n");
			return 0;
		} 
		mem.setMemory(ptr);
		.memcpy((generatedMemory[generatedSize]), contents, realsize);
		generatedSize += realsize;
		generatedMemory[generatedSize] = 0;
		return realsize;
		size_t realsize = size * nmemb;
		MemoryStruct mem = (MemoryStruct)userp;
		Byte generatedMemory = mem.getMemory();
		Object generatedSize = mem.getSize();
		byte ptr = .realloc(generatedMemory, generatedSize + realsize + 1);
		if (ptr == ((Object)0)) {
			.printf(/* out of memory! */"not enough memory (realloc returned NULL)\n");
			return 0;
		} 
		mem.setMemory(ptr);
		.memcpy((generatedMemory[generatedSize]), contents, realsize);
		generatedSize += realsize;
		generatedMemory[generatedSize] = 0;
		return realsize;
	}
	/* the dummy thread function */
	public static Object fire(Object ptr) {
		 code = new ();
		curl_slist headers = new curl_slist();
		Tdata tdata = (Tdata)ptr;
		 curl = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			return ((Object)0);
		} 
		headers = ((Object)0).sethost();
		curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		curl.curl_easy_setopt(CURLOPT_HTTPHEADER, headers);
		Byte generatedUrl = tdata.getUrl();
		curl.curl_easy_setopt(CURLOPT_URL, generatedUrl);
		curl.curl_easy_setopt(CURLOPT_COOKIEFILE, "");
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		Object generatedShare = tdata.getShare();
		curl.curl_easy_setopt(CURLOPT_SHARE, generatedShare);
		ModernizedCProgram.curl_mprintf("PERFORM\n");
		code = curl.curl_easy_perform();
		if (code) {
			int i = 0;
			(_iob[2]).curl_mfprintf("perform url '%s' repeat %d failed, curlcode %d\n", generatedUrl, i, (int)code);
		} 
		ModernizedCProgram.curl_mprintf("CLEANUP\n");
		curl.curl_easy_cleanup();
		headers.curl_slist_free_all();
		return ((Object)0);
		 code = new ();
		Tdata tdata = (Tdata)ptr;
		 curl = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			return ((Object)0);
		} 
		curl.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
		curl.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		Byte generatedUrl = tdata.getUrl();
		curl.curl_easy_setopt(CURLOPT_URL, generatedUrl);
		ModernizedCProgram.curl_mprintf("CURLOPT_SHARE\n");
		Object generatedShare = tdata.getShare();
		curl.curl_easy_setopt(CURLOPT_SHARE, generatedShare);
		ModernizedCProgram.curl_mprintf("PERFORM\n");
		code = curl.curl_easy_perform();
		if (code != CURLE_OK) {
			int i = 0;
			(_iob[2]).curl_mfprintf("perform url '%s' repeat %d failed, curlcode %d\n", generatedUrl, i, (int)code);
		} 
		ModernizedCProgram.curl_mprintf("CLEANUP\n");
		curl.curl_easy_cleanup();
		return ((Object)0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Uses the CURLINFO_TLS_SESSION data.
	 * </DESC>
	 */
	/* Note that this example currently requires curl to be linked against
	   GnuTLS (and this program must also be linked against -lgnutls). */
	public static Object wrfu(Object ptr, Object size, Object nmemb, Object stream) {
		curl_tlssessioninfo info = new curl_tlssessioninfo();
		int cert_list_size;
		 chainp = new ();
		 res = new ();
		(Object)stream;
		(Object)ptr;
		res = ModernizedCProgram.curl.curl_easy_getinfo(CURLINFO_TLS_SESSION, info);
		if (!res) {
			switch (info.getCurl_tlssessioninfo()) {
			case CURLSSLBACKEND_GNUTLS:
					chainp = .gnutls_certificate_get_peers(info.getCurl_tlssessioninfo(), /* info->internals is now the gnutls_session_t */cert_list_size);
					if ((chainp) && (cert_list_size)) {
						int i;
						for (i = 0; i < cert_list_size; i++) {
							 cert = new ();
							 dn = new ();
							if (GNUTLS_E_SUCCESS == .gnutls_x509_crt_init(cert)) {
								if (GNUTLS_E_SUCCESS == .gnutls_x509_crt_import(cert, chainp[i], GNUTLS_X509_FMT_DER)) {
									if (GNUTLS_E_SUCCESS == .gnutls_x509_crt_print(cert, GNUTLS_CRT_PRINT_FULL, dn)) {
										.fprintf((_iob[2]), "Certificate #%u: %.*s", i, dn.getSize(), dn.getData());
										.gnutls_free(dn.getData());
									} 
								} 
								.gnutls_x509_crt_deinit(cert);
							} 
						}
					} 
					break;
			case CURLSSLBACKEND_NONE:
			default:
					break;
			}
		} 
		return size * nmemb;
		(Object)stream;
		(Object)ptr;
		return size * nmemb;
	}
	public static void setup(Object hnd) {
		hnd.curl_easy_setopt(CURLOPT_URL, /* set the same URL */"https://localhost:8443/index.html");
		hnd.curl_easy_setopt(CURLOPT_HTTP_VERSION, /* HTTP/2 please */CURL_HTTP_VERSION_2_0);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, /* we use a self-signed test server, skip verification during debugging */-1024);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
		hnd.curl_easy_setopt(CURLOPT_WRITEFUNCTION, /* write data to a struct  */write_cb);
		ModernizedCProgram.files[0].init_memory();
		hnd.curl_easy_setopt(CURLOPT_WRITEDATA, ModernizedCProgram.files[0]);
		hnd.curl_easy_setopt(CURLOPT_PIPEWAIT, /* wait for pipe connection to confirm */-1024);
		byte[] filename = new byte[128];
		 hnd = new ();
		Curl_easy curl_easy = new Curl_easy();
		hnd = t.setEasy(curl_easy.curl_easy_init());
		.snprintf(filename, 128, "dl-%d", num);
		t.setOut(.fopen(filename, "wb"));
		_iobuf generatedOut = t.getOut();
		hnd.curl_easy_setopt(CURLOPT_WRITEDATA, generatedOut);
		hnd.curl_easy_setopt(CURLOPT_URL, /* set the same URL */"https://localhost:8443/index.html");
		hnd.curl_easy_setopt(CURLOPT_VERBOSE, /* please be verbose */-1024);
		hnd.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, my_trace);
		hnd.curl_easy_setopt(CURLOPT_DEBUGDATA, t);
		hnd.curl_easy_setopt(CURLOPT_HTTP_VERSION, /* HTTP/2 please */CURL_HTTP_VERSION_2_0);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, /* we use a self-signed test server, skip verification during debugging */-1024);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024/* wait for pipe connection to confirm */);
		FILE out = .fopen("dl", "wb");
		if (!out) {
			return /* failed */1;
		} 
		hnd.curl_easy_setopt(CURLOPT_WRITEDATA, /* write to this file */out);
		hnd.curl_easy_setopt(CURLOPT_URL, /* set the same URL */"https://localhost:8443/index.html");
		hnd.curl_easy_setopt(CURLOPT_VERBOSE, /* please be verbose */-1024);
		hnd.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, my_trace);
		hnd.curl_easy_setopt(CURLOPT_HTTP_VERSION, /* HTTP/2 please */CURL_HTTP_VERSION_2_0);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, /* we use a self-signed test server, skip verification during debugging */-1024);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
		return /* wait for pipe connection to confirm *//* all is good */0;
		FILE out = new FILE();
		byte[] url = new byte[256];
		byte[] filename = new byte[128];
		stat file_info = new stat();
		 uploadsize = new ();
		 hnd = new ();
		Curl_easy curl_easy = new Curl_easy();
		hnd = i.setHnd(curl_easy.curl_easy_init());
		i.setNum(num);
		.snprintf(filename, 128, "dl-%d", num);
		out = .fopen(filename, "wb");
		.snprintf(url, 256, "https://localhost:8443/upload-%d", num);
		.stat(upload, /* get the file size of the local file */file_info);
		Object generatedSt_size = file_info.getSt_size();
		uploadsize = generatedSt_size;
		i.setIn(.fopen(upload, "rb"));
		hnd.curl_easy_setopt(CURLOPT_WRITEDATA, /* write to this file */out);
		hnd.curl_easy_setopt(CURLOPT_READFUNCTION, /* we want to use our own read function */read_callback);
		hnd.curl_easy_setopt(CURLOPT_READDATA, /* read from this file */i);
		hnd.curl_easy_setopt(CURLOPT_INFILESIZE_LARGE, /* provide the size of the upload */uploadsize);
		hnd.curl_easy_setopt(CURLOPT_URL, /* send in the URL to store the upload as */url);
		hnd.curl_easy_setopt(CURLOPT_UPLOAD, /* upload please */-1024);
		hnd.curl_easy_setopt(CURLOPT_VERBOSE, /* please be verbose */-1024);
		hnd.curl_easy_setopt(CURLOPT_DEBUGFUNCTION, my_trace);
		hnd.curl_easy_setopt(CURLOPT_DEBUGDATA, i);
		hnd.curl_easy_setopt(CURLOPT_HTTP_VERSION, /* HTTP/2 please */CURL_HTTP_VERSION_2_0);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, /* we use a self-signed test server, skip verification during debugging */-1024);
		hnd.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024/* wait for pipe connection to confirm */);
	}
	/* called when there's an incoming push */
	public static int server_push_callback(Object parent, Object easy, Object num_headers, Object headers, Object userp) {
		byte headp;
		int transfers = (int)userp;
		(Object)/* we have no use for this */parent;
		(Object)/* unused */num_headers;
		if (ModernizedCProgram.pushindex == 10) {
			return /* can't fit anymore */CURL_PUSH_DENY;
		} 
		ModernizedCProgram.files[/* write to this buffer */ModernizedCProgram.pushindex].init_memory();
		easy.curl_easy_setopt(CURLOPT_WRITEDATA, ModernizedCProgram.files[ModernizedCProgram.pushindex]);
		ModernizedCProgram.pushindex++;
		headp = ModernizedCProgram.curl_pushheader_byname(headers, ":path");
		if (headp) {
			.fprintf((_iob[2]), "* Pushed :path '%s'\n", /* skip :path + colon */headp);
		} 
		(/* one more */transfers)++;
		return CURL_PUSH_OK;
		byte headp;
		size_t i = new size_t();
		int transfers = (int)userp;
		byte[] filename = new byte[128];
		FILE out = new FILE();
		int count = 0;
		(Object)/* we have no use for this */parent;
		.snprintf(filename, 128, "push%u", count++);
		out = .fopen(filename, /* here's a new stream, save it in a new file for each new push */"wb");
		if (!out) {
			.fprintf((_iob[2]), /* if we can't save it, deny it */"Failed to create output file for push\n");
			return CURL_PUSH_DENY;
		} 
		easy.curl_easy_setopt(CURLOPT_WRITEDATA, /* write to this file */out);
		.fprintf((_iob[2]), "**** push callback approves stream %u, got %lu headers!\n", count, (long)num_headers);
		for (i = 0; i < num_headers; i++) {
			headp = ModernizedCProgram.curl_pushheader_bynum(headers, i);
			.fprintf((_iob[2]), "**** header %lu: %s\n", (long)i, headp);
		}
		headp = ModernizedCProgram.curl_pushheader_byname(headers, ":path");
		if (headp) {
			.fprintf((_iob[2]), "**** The PATH is %s\n", /* skip :path + colon */headp);
		} 
		(/* one more */transfers)++;
		return CURL_PUSH_OK;
	}
	public static  is_fatal_error(Object code) {
		switch (code) {
		case CURLE_BAD_FUNCTION_ARGUMENT:
				return /* critical error */1;
		case CURLE_OUT_OF_MEMORY:
		case CURLE_FAILED_INIT:
		case CURLE_FUNCTION_NOT_FOUND:
		case CURLE_UNKNOWN_OPTION:
		default:
				break;
		}
		return /* no error or not critical */0/*
		 * Check if a given string is a PKCS#11 URI
		 */;
	}
	public static  is_pkcs11_uri(Object string) {
		if (ModernizedCProgram.curl_strnequal(string, "pkcs11:", 7)) {
			return 1;
		} else {
				return 0/*
				 * get_vms_file_size does what it takes to get the real size of the file
				 *
				 * For fixed files, find out the size of the EOF block and adjust.
				 *
				 * For all others, have to read the entire file in, discarding the contents.
				 * Most posted text files will be small, and binary files like zlib archives
				 * and CD/DVD images should be either a STREAM_LF format or a fixed format.
				 *
				 */;
		} 
	}
	/* !checksrc! disable FOPENMODE 1 */
	/* VMS */
	public static Object pre_transfer(GlobalConfig global, per_transfer per) {
		 uploadfilesize = -1;
		_stati64 fileinfo = new _stati64();
		 result = CURLE_OK;
		Byte generatedSeparator_err = per.getSeparator_err();
		_iobuf generatedErrors = global.getErrors();
		if (generatedSeparator_err) {
			generatedErrors.curl_mfprintf("%s\n", generatedSeparator_err);
		} 
		Byte generatedSeparator = per.getSeparator();
		if (generatedSeparator) {
			ModernizedCProgram.curl_mprintf("%s\n", generatedSeparator);
		} 
		Byte generatedUploadfile = per.getUploadfile();
		int generatedInfd = per.getInfd();
		Object generatedSt_mode = fileinfo.getSt_mode();
		Object generatedSt_size = fileinfo.getSt_size();
		Object generatedCurl = per.getCurl();
		InStruct generatedInput = per.getInput();
		if (generatedUploadfile && !ModernizedCProgram.stdin_upload(generatedUploadfile)/* Calculate the real upload size for VMS */) {
			per.setInfd(.open(generatedUploadfile, 0 | -1024));
			if ((generatedInfd == -1) || ._fstati64(generatedInfd, fileinfo)) {
				generatedErrors.helpf("Can't open '%s'!\n", generatedUploadfile);
				if (generatedInfd != -1) {
					.close(generatedInfd);
					per.setInfd(0);
				} 
				return CURLE_READ_ERROR;
			} 
			per.setInfdopen(1);
			if ((((generatedSt_mode) & -1024) == /* we ignore file size for char/block devices, sockets, etc. */-1024)) {
				uploadfilesize = generatedSt_size;
			} 
			if (uploadfilesize != -1) {
				do {
					if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_INFILESIZE_LARGE)) {
						result = (global.tool_setopt(generatedCurl, 0, "CURLOPT_INFILESIZE_LARGE", CURLOPT_INFILESIZE_LARGE, uploadfilesize));
						if (result) {
							break;
						} 
					} 
				} while (0);
			} 
			generatedInput.setFd(generatedInfd);
		} 
		return result/*
		 * Call this after a transfer has completed.
		 */;
	}
	public static Object post_per_transfer(GlobalConfig global, per_transfer per, Object result,  retryp) {
		OutStruct generatedOuts = per.getOuts();
		OutStruct outs = generatedOuts;
		Object generatedCurl = per.getCurl();
		 curl = generatedCurl;
		OperationConfig generatedConfig = per.getConfig();
		OperationConfig config = generatedConfig;
		if (!curl || !config) {
			return result;
		} 
		retryp = 0;
		 generatedInfdopen = per.getInfdopen();
		int generatedInfd = per.getInfd();
		if (generatedInfdopen) {
			.close(generatedInfd);
		} 
		 generatedSynthetic_error = config.getSynthetic_error();
		int generatedShowerror = global.getShowerror();
		_iobuf generatedErrors = global.getErrors();
		Object generatedErrorbuffer = per.getErrorbuffer();
		if (generatedSynthetic_error) {
			;
		}  else if (result && generatedShowerror) {
			generatedErrors.curl_mfprintf("curl: (%d) %s\n", result, (generatedErrorbuffer[0]) ? generatedErrorbuffer : ModernizedCProgram.curl_easy_strerror(result));
			if (result == CURLE_PEER_FAILED_VERIFICATION) {
				.fputs("More details here: https://curl.haxx.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n", generatedErrors);
			} 
		} 
		 generatedXattr = config.getXattr();
		 generatedFopened = outs.getFopened();
		_iobuf generatedStream = outs.getStream();
		Object generated_file = (generatedStream).get_file();
		GlobalConfig generatedGlobal = config.getGlobal();
		if (!result && generatedXattr && generatedFopened && generatedStream) {
			int rc = ModernizedCProgram.fwrite_xattr(curl, (generated_file));
			if (rc) {
				generatedGlobal.warnf("Error setting extended attributes: %s\n", .strerror((._errno())));
			} 
		} 
		Object generatedBytes = outs.getBytes();
		if (!result && !generatedStream && !generatedBytes) {
			long cond_unmet = -1024/* do not create (or even overwrite) the file in case we get no
			       data because of unmet condition */;
			curl.curl_easy_getinfo(CURLINFO_CONDITION_UNMET, cond_unmet);
			if (!cond_unmet && !outs.tool_create_output_file()) {
				result = CURLE_WRITE_ERROR;
			} 
		} 
		 generatedS_isreg = outs.getS_isreg();
		if (!generatedS_isreg && generatedStream) {
			int rc = .fflush(generatedStream);
			if (!result && rc) {
				result = /* something went wrong in the writing process */CURLE_WRITE_ERROR;
				generatedErrors.curl_mfprintf("(%d) Failed writing body\n", result);
			} 
		} 
		 generatedIs_cd_filename = outs.getIs_cd_filename();
		 generatedMute = global.getMute();
		byte generatedFilename = outs.getFilename();
		if (generatedIs_cd_filename && generatedStream && !generatedMute && generatedFilename) {
			ModernizedCProgram.curl_mprintf("curl: Saved to filename '%s'\n", generatedFilename);
		} 
		long generatedRetry_numretries = per.getRetry_numretries();
		long generatedRetry_maxtime = config.getRetry_maxtime();
		timeval timeval = new timeval();
		timeval generatedRetrystart = per.getRetrystart();
		 generatedRetry_connrefused = config.getRetry_connrefused();
		 generatedFailonerror = config.getFailonerror();
		long generatedRetry_sleep = per.getRetry_sleep();
		long generatedRetry_delay = config.getRetry_delay();
		int generatedProgressmode = global.getProgressmode();
		ProgressData generatedProgressbar = per.getProgressbar();
		int generatedCalls = generatedProgressbar.getCalls();
		_iobuf generatedOut = generatedProgressbar.getOut();
		if ((generatedProgressmode == 1) && generatedCalls) {
			.fputs("\n", generatedOut);
		} 
		Byte generatedWriteout = config.getWriteout();
		if (generatedWriteout) {
			generatedOuts.ourWriteOut(generatedCurl, generatedWriteout);
		} 
		if (generatedFopened && generatedStream) {
			int rc = .fclose(generatedStream);
			if (!result && rc) {
				result = /* something went wrong in the writing process */CURLE_WRITE_ERROR;
				generatedErrors.curl_mfprintf("(%d) Failed writing body\n", result);
			} 
		} 
		 generatedRemote_time = config.getRemote_time();
		if (!result && generatedRemote_time && generatedS_isreg && generatedFilename) {
			 filetime = -/* Ask libcurl if we got a remote file time */1;
			curl.curl_easy_getinfo(CURLINFO_FILETIME_T, filetime);
			generatedErrors.setfiletime(filetime, generatedFilename);
		} 
		if (generatedFopened && generatedStream) {
			.fclose(generatedStream);
		} 
		OutStruct generatedHeads = per.getHeads();
		 generatedAlloc_filename = generatedHeads.getAlloc_filename();
		if (generatedAlloc_filename) {
			do {
				.free((generatedFilename));
				(generatedFilename) = ((Object)0);
			} while (0);
		} 
		generatedCurl.curl_easy_cleanup();
		if (generatedAlloc_filename) {
			.free(generatedFilename);
		} 
		Byte generatedThis_url = per.getThis_url();
		.free(generatedThis_url);
		Byte generatedSeparator_err = per.getSeparator_err();
		.free(generatedSeparator_err);
		Byte generatedSeparator = per.getSeparator();
		.free(generatedSeparator);
		Byte generatedOutfile = per.getOutfile();
		.free(generatedOutfile);
		Byte generatedUploadfile = per.getUploadfile();
		.free(generatedUploadfile);
		return CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* libcurl's debug builds provide an extra function */
	/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
	   source code but yet it doesn't ruin anything */
	/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
	   source code but yet it doesn't ruin anything */
	/* create the next (singular) transfer */
	public static Object single_transfer(GlobalConfig global, OperationConfig config, Object share,  capath_from_env,  added) {
		 result = CURLE_OK;
		getout urlnode = new getout();
		metalinkfile mlfile_last = ((Object)0);
		 generatedNoprogress = global.getNoprogress();
		bool orig_noprogress = generatedNoprogress;
		 generatedIsatty = global.getIsatty();
		bool orig_isatty = generatedIsatty;
		State generatedState = config.getState();
		State state = generatedState;
		Byte generatedHttpgetfields = state.getHttpgetfields();
		byte httpgetfields = generatedHttpgetfields;
		added = /* not yet */0;
		Byte generatedPostfields = config.getPostfields();
		 generatedUse_httpget = config.getUse_httpget();
		_iobuf generatedErrors = global.getErrors();
		 generatedNo_body = config.getNo_body();
		 generatedHttpreq = config.getHttpreq();
		if (generatedPostfields) {
			if (generatedUse_httpget) {
				if (!httpgetfields) {
					httpgetfields = state.setHttpgetfields(.strdup(generatedPostfields));
					do {
						.free((generatedPostfields));
						(generatedPostfields) = ((Object)0);
					} while (0);
					if (!httpgetfields) {
						generatedErrors.helpf("out of memory\n");
						result = CURLE_OUT_OF_MEMORY;
					}  else if (config.SetHTTPrequest((generatedNo_body ? .HTTPREQ_HEAD : .HTTPREQ_GET), generatedHttpreq)) {
						result = CURLE_FAILED_INIT;
					} 
				} 
			} else {
					if (config.SetHTTPrequest(.HTTPREQ_SIMPLEPOST, generatedHttpreq)) {
						result = CURLE_FAILED_INIT;
					} 
			} 
			if (result) {
				return result;
			} 
		} 
		getout generatedUrlnode = state.getUrlnode();
		getout generatedUrl_list = config.getUrl_list();
		if (!generatedUrlnode) {
			state.setUrlnode(generatedUrl_list);
			state.setInfilenum(1);
		} 
		 generatedInglob = state.getInglob();
		int generatedFlags = urlnode.getFlags();
		metalinkfile generatedMetalinkfile_list = config.getMetalinkfile_list();
		metalinkfile generatedNext = mlfile_last.getNext();
		metalink_resource generatedResource = mlfile.getResource();
		Byte generatedUrl = urlnode.getUrl();
		byte generatedOutfile = urlnode.getOutfile();
		Byte generatedInfile = urlnode.getInfile();
		Byte generatedOutfiles = state.getOutfiles();
		 generatedGloboff = config.getGloboff();
		long generatedInfilenum = state.getInfilenum();
		int generatedShowerror = global.getShowerror();
		long generatedUp = state.getUp();
		Byte generatedUploadfile = state.getUploadfile();
		long generatedUrlnum = state.getUrlnum();
		 generatedUrls = state.getUrls();
		long generatedLi = state.getLi();
		Curl_easy curl_easy = new Curl_easy();
		OutStruct generatedHeads = per.getHeads();
		Byte generatedHeaderfile = config.getHeaderfile();
		GlobalConfig generatedGlobal = config.getGlobal();
		_iobuf generatedStream = heads.getStream();
		HdrCbData generatedHdrcbdata = per.getHdrcbdata();
		OutStruct generatedOuts = per.getOuts();
		InStruct generatedInput = per.getInput();
		Byte generatedFilename = mlfile.getFilename();
		Byte generatedThis_url = per.getThis_url();
		 generatedUse_metalink = config.getUse_metalink();
		 generatedContent_disposition = config.getContent_disposition();
		 generatedCreate_dirs = config.getCreate_dirs();
		 generatedResume_from_current = config.getResume_from_current();
		Object generatedSt_size = fileinfo.getSt_size();
		Object generatedResume_from = config.getResume_from();
		long generatedAuthtype = config.getAuthtype();
		 generatedProxyanyauth = config.getProxyanyauth();
		int generatedInfd = per.getInfd();
		Object generated_file = (generatedStream).get_file();
		 generatedMute = global.getMute();
		 generatedUse_ascii = config.getUse_ascii();
		 generatedTcp_nodelay = config.getTcp_nodelay();
		 generatedTcp_fastopen = config.getTcp_fastopen();
		Object generatedRecvpersecond = config.getRecvpersecond();
		Byte generatedOauth_bearer = config.getOauth_bearer();
		Byte generatedProxy = config.getProxy();
		int generatedProxyver = config.getProxyver();
		Byte generatedProxyuserpwd = config.getProxyuserpwd();
		 generatedProxytunnel = config.getProxytunnel();
		Byte generatedPreproxy = config.getPreproxy();
		 generatedProxynegotiate = config.getProxynegotiate();
		 generatedProxyntlm = config.getProxyntlm();
		 generatedProxydigest = config.getProxydigest();
		 generatedProxybasic = config.getProxybasic();
		Byte generatedNoproxy = config.getNoproxy();
		 generatedSuppress_connect_headers = config.getSuppress_connect_headers();
		 generatedFailonerror = config.getFailonerror();
		Byte generatedRequest_target = config.getRequest_target();
		 generatedDirlistonly = config.getDirlistonly();
		 generatedFtp_append = config.getFtp_append();
		 generatedNetrc_opt = config.getNetrc_opt();
		 generatedNetrc = config.getNetrc();
		Byte generatedNetrc_file = config.getNetrc_file();
		Byte generatedLogin_options = config.getLogin_options();
		Byte generatedUserpwd = config.getUserpwd();
		Byte generatedRange = config.getRange();
		Object generatedErrorbuffer = per.getErrorbuffer();
		double generatedTimeout = config.getTimeout();
		Object generatedPostfieldsize = config.getPostfieldsize();
		tool_mime generatedMimeroot = config.getMimeroot();
		Object generatedMimepost = config.getMimepost();
		curl_slist generatedHeaders = config.getHeaders();
		Byte generatedReferer = config.getReferer();
		Byte generatedUseragent = config.getUseragent();
		 generatedFollowlocation = config.getFollowlocation();
		 generatedUnrestricted_auth = config.getUnrestricted_auth();
		 generatedAutoreferer = config.getAutoreferer();
		curl_slist generatedProxyheaders = config.getProxyheaders();
		long generatedMaxredirs = config.getMaxredirs();
		long generatedHttpversion = config.getHttpversion();
		 generatedPost301 = config.getPost301();
		 generatedPost302 = config.getPost302();
		 generatedPost303 = config.getPost303();
		 generatedEncoding = config.getEncoding();
		 generatedTr_encoding = config.getTr_encoding();
		 generatedHttp09_allowed = config.getHttp09_allowed();
		Byte generatedFtpport = config.getFtpport();
		long generatedLow_speed_limit = config.getLow_speed_limit();
		long generatedLow_speed_time = config.getLow_speed_time();
		Object generatedSendpersecond = config.getSendpersecond();
		 generatedUse_resume = config.getUse_resume();
		Byte generatedKey_passwd = config.getKey_passwd();
		Byte generatedProxy_key_passwd = config.getProxy_key_passwd();
		Byte generatedKey = config.getKey();
		Byte generatedPubkey = config.getPubkey();
		Byte generatedHostpubmd5 = config.getHostpubmd5();
		 generatedSsh_compression = config.getSsh_compression();
		Byte generatedCacert = config.getCacert();
		Byte generatedProxy_cacert = config.getProxy_cacert();
		Byte generatedCapath = config.getCapath();
		Byte generatedProxy_capath = config.getProxy_capath();
		Byte generatedCrlfile = config.getCrlfile();
		Byte generatedProxy_crlfile = config.getProxy_crlfile();
		Byte generatedPinnedpubkey = config.getPinnedpubkey();
		Byte generatedCert = config.getCert();
		Byte generatedCert_type = config.getCert_type();
		Byte generatedKey_type = config.getKey_type();
		Byte generatedProxy_cert = config.getProxy_cert();
		Byte generatedProxy_cert_type = config.getProxy_cert_type();
		Byte generatedProxy_key = config.getProxy_key();
		Byte generatedProxy_key_type = config.getProxy_key_type();
		 generatedInsecure_ok = config.getInsecure_ok();
		 generatedProxy_insecure_ok = config.getProxy_insecure_ok();
		 generatedVerifystatus = config.getVerifystatus();
		 generatedFalsestart = config.getFalsestart();
		long generatedSsl_version = config.getSsl_version();
		long generatedSsl_version_max = config.getSsl_version_max();
		long generatedProxy_ssl_version = config.getProxy_ssl_version();
		 generatedPath_as_is = config.getPath_as_is();
		 generatedRemote_time = config.getRemote_time();
		 generatedCrlf = config.getCrlf();
		curl_slist generatedQuote = config.getQuote();
		curl_slist generatedPostquote = config.getPostquote();
		curl_slist generatedPrequote = config.getPrequote();
		Byte generatedCookie = config.getCookie();
		Byte generatedCookiefile = config.getCookiefile();
		Byte generatedCookiejar = config.getCookiejar();
		 generatedCookiesession = config.getCookiesession();
		Object generatedTimecond = config.getTimecond();
		Object generatedCondtime = config.getCondtime();
		Byte generatedCustomrequest = config.getCustomrequest();
		Byte generatedIface = config.getIface();
		Byte generatedKrblevel = config.getKrblevel();
		ProgressData generatedProgressbar = per.getProgressbar();
		int generatedProgressmode = global.getProgressmode();
		Byte generatedDns_servers = config.getDns_servers();
		Byte generatedDns_interface = config.getDns_interface();
		Byte generatedDns_ipv4_addr = config.getDns_ipv4_addr();
		Byte generatedDns_ipv6_addr = config.getDns_ipv6_addr();
		curl_slist generatedTelnet_options = config.getTelnet_options();
		Byte generatedRandom_file = config.getRandom_file();
		Byte generatedEgd_file = config.getEgd_file();
		double generatedConnecttimeout = config.getConnecttimeout();
		Byte generatedDoh_url = config.getDoh_url();
		Byte generatedCipher_list = config.getCipher_list();
		Byte generatedProxy_cipher_list = config.getProxy_cipher_list();
		Byte generatedCipher13_list = config.getCipher13_list();
		Byte generatedProxy_cipher13_list = config.getProxy_cipher13_list();
		 generatedDisable_epsv = config.getDisable_epsv();
		 generatedDisable_eprt = config.getDisable_eprt();
		 generatedTracetype = global.getTracetype();
		Byte generatedEngine = config.getEngine();
		 generatedFtp_create_dirs = config.getFtp_create_dirs();
		Object generatedMax_filesize = config.getMax_filesize();
		long generatedIp_version = config.getIp_version();
		 generatedFtp_ssl_reqd = config.getFtp_ssl_reqd();
		 generatedFtp_ssl = config.getFtp_ssl();
		 generatedFtp_ssl_control = config.getFtp_ssl_control();
		 generatedFtp_ssl_ccc = config.getFtp_ssl_ccc();
		int generatedFtp_ssl_ccc_mode = config.getFtp_ssl_ccc_mode();
		int generatedSocks5_gssapi_nec = config.getSocks5_gssapi_nec();
		long generatedSocks5_auth = config.getSocks5_auth();
		Byte generatedProxy_service_name = config.getProxy_service_name();
		Byte generatedService_name = config.getService_name();
		Byte generatedFtp_account = config.getFtp_account();
		 generatedIgnorecl = config.getIgnorecl();
		 generatedFtp_skip_ip = config.getFtp_skip_ip();
		int generatedFtp_filemethod = config.getFtp_filemethod();
		long generatedLocalport = config.getLocalport();
		long generatedLocalportrange = config.getLocalportrange();
		Byte generatedFtp_alternative_to_user = config.getFtp_alternative_to_user();
		 generatedDisable_sessionid = config.getDisable_sessionid();
		 generatedRaw = config.getRaw();
		 generatedNokeepalive = config.getNokeepalive();
		long generatedAlivetime = config.getAlivetime();
		long generatedTftp_blksize = config.getTftp_blksize();
		Byte generatedMail_from = config.getMail_from();
		curl_slist generatedMail_rcpt = config.getMail_rcpt();
		 generatedFtp_pret = config.getFtp_pret();
		 generatedProto_present = config.getProto_present();
		long generatedProto = config.getProto();
		 generatedProto_redir_present = config.getProto_redir_present();
		long generatedProto_redir = config.getProto_redir();
		curl_slist generatedResolve = config.getResolve();
		curl_slist generatedConnect_to = config.getConnect_to();
		Byte generatedTls_username = config.getTls_username();
		Byte generatedTls_password = config.getTls_password();
		Byte generatedTls_authtype = config.getTls_authtype();
		Byte generatedProxy_tls_username = config.getProxy_tls_username();
		Byte generatedProxy_tls_password = config.getProxy_tls_password();
		Byte generatedProxy_tls_authtype = config.getProxy_tls_authtype();
		long generatedGssapi_delegation = config.getGssapi_delegation();
		 generatedSsl_allow_beast = config.getSsl_allow_beast();
		 generatedSsl_no_revoke = config.getSsl_no_revoke();
		 generatedProxy_ssl_allow_beast = config.getProxy_ssl_allow_beast();
		Byte generatedMail_auth = config.getMail_auth();
		Byte generatedSasl_authzid = config.getSasl_authzid();
		 generatedSasl_ir = config.getSasl_ir();
		 generatedNonpn = config.getNonpn();
		 generatedNoalpn = config.getNoalpn();
		Byte generatedUnix_socket_path = config.getUnix_socket_path();
		 generatedAbstract_unix_socket = config.getAbstract_unix_socket();
		Byte generatedProto_default = config.getProto_default();
		double generatedExpect100timeout = config.getExpect100timeout();
		 generatedTftp_no_options = config.getTftp_no_options();
		long generatedHappy_eyeballs_timeout_ms = config.getHappy_eyeballs_timeout_ms();
		 generatedHaproxy_protocol = config.getHaproxy_protocol();
		 generatedDisallow_username_in_url = config.getDisallow_username_in_url();
		long generatedRetry_delay = config.getRetry_delay();
		long generatedReq_retry = config.getReq_retry();
		long generatedRetry_sleep_default = per.getRetry_sleep_default();
		timeval timeval = new timeval();
		while (generatedUrlnode) {
			byte infiles;
			URLGlob inglob = generatedInglob;
			bool metalink = /* metalink download? */0;
			metalinkfile mlfile = new metalinkfile();
			metalink_resource mlres = new metalink_resource();
			urlnode = generatedUrlnode;
			if (generatedFlags & (1 << 5)) {
				metalink = 1;
				if (mlfile_last == ((Object)0)) {
					mlfile_last = generatedMetalinkfile_list;
				} 
				mlfile = mlfile_last;
				mlfile_last = generatedNext;
				mlres = generatedResource;
			} else {
					mlfile = ((Object)0);
					mlres = ((Object)0);
			} 
			if (!generatedUrl) {
				do {
					.free((generatedOutfile));
					(generatedOutfile) = ((Object)0);
				} while (0);
				do {
					.free((generatedInfile));
					(generatedInfile) = ((Object)0);
				} while (0);
				urlnode.setFlags(0);
				generatedState.setUrlnode(generatedNext);
				state.setUp(0);
				continue;
			} 
			if (generatedOutfile && !generatedOutfiles) {
				state.setOutfiles(.strdup(generatedOutfile));
				if (!generatedOutfiles) {
					generatedErrors.helpf("out of memory\n");
					result = CURLE_OUT_OF_MEMORY;
					break;
				} 
			} 
			infiles = generatedInfile;
			if (!generatedGloboff && infiles && !inglob) {
				result = ModernizedCProgram.glob_url(inglob, infiles, generatedInfilenum, generatedShowerror ? generatedErrors : ((Object)0));
				if (result) {
					break;
				} 
				generatedState.setInglob(inglob);
			} 
			{ 
				int separator;
				long urlnum;
				if (!generatedUp && !infiles) {
					do {
					} while (0);
				} else {
						if (!generatedUploadfile) {
							if (inglob) {
								result = inglob.glob_next_url(generatedUploadfile);
								if (result == CURLE_OUT_OF_MEMORY) {
									generatedErrors.helpf("out of memory\n");
								} 
							}  else if (!generatedUp) {
								state.setUploadfile(.strdup(infiles));
								if (!generatedUploadfile) {
									generatedErrors.helpf("out of memory\n");
									result = CURLE_OUT_OF_MEMORY;
								} 
							} 
						} 
						if (result) {
							break;
						} 
				} 
				if (!generatedUrlnum) {
					if (metalink/* For Metalink download, we don't use glob. Instead we use
					             the number of resources as urlnum. */) {
						urlnum = 0;
					}  else if (!generatedGloboff) {
						result = ModernizedCProgram.glob_url(generatedUrls, generatedUrl, generatedUrlnum, generatedShowerror ? generatedErrors : ((Object)0));
						if (result) {
							break;
						} 
						urlnum = generatedUrlnum;
					} else {
							urlnum = /* without globbing, this is a single URL */1;
					} 
				} else {
						urlnum = generatedUrlnum;
				} 
				separator = ((!generatedOutfiles || !.strcmp(generatedOutfiles, "-")) && urlnum > 1);
				if (generatedLi >= /* Here's looping around each globbed URL */urlnum) {
					state.setLi(0);
					generatedUp++;
				} 
				if (generatedUp < generatedInfilenum) {
					per_transfer per = new per_transfer();
					OutStruct outs = new OutStruct();
					InStruct input = new InStruct();
					OutStruct heads = new OutStruct();
					HdrCbData hdrcbdata = ((Object)0);
					 curl = curl_easy.curl_easy_init();
					result = per.add_per_transfer();
					if (result || !ModernizedCProgram.curl) {
						ModernizedCProgram.curl.curl_easy_cleanup();
						result = CURLE_OUT_OF_MEMORY;
						break;
					} 
					if (generatedUploadfile) {
						per.setUploadfile(.strdup(generatedUploadfile));
						if (!generatedUploadfile) {
							ModernizedCProgram.curl.curl_easy_cleanup();
							result = CURLE_OUT_OF_MEMORY;
							break;
						} 
					} 
					added = 1;
					per.setConfig(config);
					per.setCurl(ModernizedCProgram.curl);
					heads = generatedHeads;
					heads.setStream((_iob[1]));
					heads.setConfig(config);
					if (generatedHeaderfile) {
						if (.strcmp(generatedHeaderfile, /* open file for output: */"-")) {
							FILE newfile = .fopen(generatedHeaderfile, "wb");
							if (!newfile) {
								generatedGlobal.warnf("Failed to open %s\n", generatedHeaderfile);
								result = CURLE_WRITE_ERROR;
								break;
							} else {
									heads.setFilename(generatedHeaderfile);
									heads.setS_isreg(1);
									heads.setFopened(1);
									heads.setStream(newfile);
							} 
						} else {
								generatedStream.set_binmode();
						} 
					} 
					hdrcbdata = generatedHdrcbdata;
					outs = generatedOuts;
					ModernizedCProgram.input = generatedInput;
					per.setOutfile(((Object)0));
					per.setInfdopen(0);
					per.setInfd(0);
					outs.setStream((_iob[/* default output stream is stdout */1]));
					outs.setConfig(config);
					if (metalink/* For Metalink download, use name in Metalink file as
					             filename. */) {
						per.setOutfile(.strdup(generatedFilename));
						if (!generatedOutfile) {
							result = CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setThis_url(.strdup(generatedUrl));
						if (!generatedThis_url) {
							result = CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setMlfile(mlfile);
					} else {
							if (generatedUrls) {
								result = generatedUrls.glob_next_url(generatedThis_url);
								if (result) {
									break;
								} 
							}  else if (!generatedLi) {
								per.setThis_url(.strdup(generatedUrl));
								if (!generatedThis_url) {
									result = CURLE_OUT_OF_MEMORY;
									break;
								} 
							} else {
									per.setThis_url(((Object)0));
							} 
							if (!generatedThis_url) {
								break;
							} 
							if (generatedOutfiles) {
								per.setOutfile(.strdup(generatedOutfiles));
								if (!generatedOutfile) {
									result = CURLE_OUT_OF_MEMORY;
									break;
								} 
							} 
					} 
					if (((generatedFlags & (1 << 2)) || (generatedOutfile && .strcmp("-", generatedOutfile))) && (metalink || !generatedUse_metalink)) {
						if (!generatedOutfile) {
							result = ModernizedCProgram.get_url_file_name(generatedOutfile, generatedThis_url);
							if (result) {
								break;
							} 
							if (!generatedOutfile && !generatedContent_disposition) {
								generatedErrors.helpf("Remote file name has no length!\n");
								result = CURLE_WRITE_ERROR;
								break;
							} 
						}  else if (generatedUrls) {
							byte storefile = generatedOutfile;
							result = generatedUrls.glob_match_url(generatedOutfile, storefile);
							do {
								.free((storefile));
								(storefile) = ((Object)0);
							} while (0);
							if (result) {
								generatedGlobal.warnf(/* bad globbing */"bad output glob!\n");
								break;
							} 
						} 
						if (generatedCreate_dirs || /* Create the directory hierarchy, if not pre-existent to a multiple
						             file output call */metalink) {
							result = generatedErrors.create_dir_hierarchy(generatedOutfile);
							if (/* create_dir_hierarchy shows error upon CURLE_WRITE_ERROR */result) {
								break;
							} 
						} 
						if ((generatedFlags & (1 << 2)) && generatedContent_disposition) {
							do {
							} while (/* Our header callback MIGHT set the filename */0);
						} 
						if (generatedResume_from_current) {
							_stati64 fileinfo = new _stati64();
							if (0 == ._stati64(generatedOutfile, /* VMS -- Danger, the filesize is only valid for stream files */fileinfo)) {
								config.setResume_from(generatedSt_size);
							} else {
									config.setResume_from(/* let offset be 0 */0);
							} 
						} 
						if (generatedResume_from) {
							FILE file = .fopen(generatedOutfile, /* open file for output: */"ab");
							if (!file) {
								generatedErrors.helpf("Can't open '%s'!\n", generatedOutfile);
								result = CURLE_WRITE_ERROR;
								break;
							} 
							outs.setFopened(1);
							outs.setStream(file);
							outs.setInit(generatedResume_from);
						} else {
								outs.setStream(((Object)/* open when needed */0));
						} 
						outs.setFilename(generatedOutfile);
						outs.setS_isreg(1);
					} 
					if (generatedUploadfile && !ModernizedCProgram.stdin_upload(generatedUploadfile)) {
						byte nurl = ModernizedCProgram.add_file_name_to_url(generatedThis_url, generatedUploadfile);
						if (!nurl) {
							result = CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setThis_url(nurl);
					}  else if (generatedUploadfile && ModernizedCProgram.stdin_upload(generatedUploadfile)) {
						int authbits = 0;
						int bitcheck = 0;
						while (bitcheck < 32) {
							if (generatedAuthtype & (-1024 << bitcheck++)) {
								authbits++;
								if (authbits > 1/* more than one, we're done! */) {
									break;
								} 
							} 
						}
						if (generatedProxyanyauth || (authbits > /*
						           * If the user has also selected --anyauth or --proxy-anyauth
						           * we should warn him/her.
						           */1)) {
							generatedGlobal.warnf("Using --anyauth or --proxy-anyauth with upload from stdin involves a big risk of it not working. Use a temporary file or a fixed auth type instead!\n");
						} 
						do {
						} while (0);
						do {
						} while (0);
						(_iob[0]).set_binmode();
						if (!.strcmp(generatedUploadfile, ".")) {
							if (ModernizedCProgram.curlx_nonblock(()generatedInfd, 1) < 0) {
								generatedGlobal.warnf("fcntl failed on fd=%d: %s\n", generatedInfd, .strerror((._errno())));
							} 
						} 
					} 
					if (generatedUploadfile && generatedResume_from_current) {
						config.setResume_from(-/* -1 will then force get-it-yourself */1);
					} 
					if (ModernizedCProgram.output_expected(generatedThis_url, generatedUploadfile) && generatedStream && .isatty((generated_file))) {
						global.setNoprogress(global.setIsatty(1));
					} else {
							global.setNoprogress(/* progress meter is per download, so restore config
							             values */orig_noprogress);
							global.setIsatty(orig_isatty);
					} 
					if (urlnum > 1 && !generatedMute) {
						per.setSeparator_err(ModernizedCProgram.curl_maprintf("\n[%lu/%lu]: %s --> %s", generatedLi + 1, urlnum, generatedThis_url, generatedOutfile ? generatedOutfile : "<stdout>"));
						if (separator) {
							per.setSeparator(ModernizedCProgram.curl_maprintf("%s%s", "--_curl_--", generatedThis_url));
						} 
					} 
					if (httpgetfields) {
						byte urlbuffer;
						byte pc = .strstr(generatedThis_url, /* Find out whether the url contains a file name */"://");
						byte sep = (byte)'?';
						if (pc) {
							pc += 3;
						} else {
								pc = generatedThis_url;
						} 
						pc = .strrchr(pc, /* check for a slash */(byte)'/');
						if (pc/* there is a slash present in the URL */) {
							if (.strchr(pc, (byte)'?'/* Ouch, there's already a question mark in the URL string, we
							                 then append the data with an ampersand separator instead! */)) {
								sep = (byte)'&'/*
								           * Then append ? followed by the get fields to the url.
								           */;
							} 
						} 
						if (pc) {
							urlbuffer = ModernizedCProgram.curl_maprintf("%s%c%s", generatedThis_url, sep, httpgetfields/* Append  / before the ? to create a well-formed url
							               if the url contains a hostname only
							            */);
						} else {
								urlbuffer = ModernizedCProgram.curl_maprintf("%s/?%s", generatedThis_url, httpgetfields);
						} 
						if (!urlbuffer) {
							result = CURLE_OUT_OF_MEMORY;
							break;
						} 
						do {
							.free((generatedThis_url));
							(generatedThis_url) = ((Object)0);
						} while (/* free previous URL */0);
						per.setThis_url(/* use our new URL instead! */urlbuffer);
					} 
					if (!generatedErrors) {
						global.setErrors((_iob[2]));
					} 
					if ((!generatedOutfile || !.strcmp(generatedOutfile, "-")) && !generatedUse_ascii) {
						(_iob[1]).set_binmode();
					} 
					/* explicitly passed to stdout means okaying binary gunk */config.setTerminal_binary_ok((generatedOutfile && !.strcmp(generatedOutfile, "-")));
					result = ModernizedCProgram.curl.curl_easy_setopt(CURLOPT_SHARE, /* Avoid having this setopt added to the --libcurl source output. */share);
					if (result) {
						break;
					} 
					if (!generatedTcp_nodelay) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_NODELAY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_NODELAY", CURLOPT_TCP_NODELAY, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedTcp_fastopen) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_FASTOPEN)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_FASTOPEN", CURLOPT_TCP_FASTOPEN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_WRITEDATA)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_WRITEDATA", CURLOPT_WRITEDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (/* where to store */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_INTERLEAVEDATA)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_INTERLEAVEDATA", CURLOPT_INTERLEAVEDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (metalink || !generatedUse_metalink) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_WRITEFUNCTION)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_WRITEFUNCTION", CURLOPT_WRITEFUNCTION, ModernizedCProgram.tool_write_cb));
								if (result) {
									break;
								} 
							} 
						} while (/* what call to write */0/* Set Metalink specific write callback function to parse
						             XML data progressively. */);
					} 
					ModernizedCProgram.input.setConfig(/* USE_METALINK *//* for uploads */config/* Note that if CURLOPT_READFUNCTION is fread (the default), then
					         * lib/telnet.c will Curl_poll() on the input file descriptor
					         * rather then calling the READFUNCTION at regular intervals.
					         * The circumstances in which it is preferable to enable this
					         * behaviour, by omitting to set the READFUNCTION & READDATA options,
					         * have not been determined.
					         */);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_READDATA)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_READDATA", CURLOPT_READDATA, ModernizedCProgram.input));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_READFUNCTION)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_READFUNCTION", CURLOPT_READFUNCTION, ModernizedCProgram.tool_read_cb));
							if (result) {
								break;
							} 
						} 
					} while (/* what call to read */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SEEKDATA)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SEEKDATA", CURLOPT_SEEKDATA, ModernizedCProgram.input));
							if (result) {
								break;
							} 
						} 
					} while (/* in 7.18.0, the CURLOPT_SEEKFUNCTION/DATA pair is taking over what
					           CURLOPT_IOCTLFUNCTION/DATA pair previously provided for seeking */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SEEKFUNCTION)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SEEKFUNCTION", CURLOPT_SEEKFUNCTION, ModernizedCProgram.tool_seek_cb));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedRecvpersecond && (generatedRecvpersecond < (100 * 1024))) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_BUFFERSIZE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_BUFFERSIZE", CURLOPT_BUFFERSIZE, (long)generatedRecvpersecond));
								if (result) {
									break;
								} 
							} 
						} while (/* use a smaller sized buffer for better sleeps */0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_BUFFERSIZE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_BUFFERSIZE", CURLOPT_BUFFERSIZE, (long)(100 * 1024)));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_URL)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_URL", CURLOPT_URL, generatedThis_url));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NOPROGRESS)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_NOPROGRESS", CURLOPT_NOPROGRESS, generatedNoprogress ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedNo_body) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NOBODY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_NOBODY", CURLOPT_NOBODY, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedOauth_bearer) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_XOAUTH2_BEARER)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_XOAUTH2_BEARER", CURLOPT_XOAUTH2_BEARER, generatedOauth_bearer));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					{ 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY", CURLOPT_PROXY, generatedProxy));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (generatedProxy) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYTYPE)) {
									result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_PROXYTYPE", CURLOPT_PROXYTYPE, ModernizedCProgram.setopt_nv_CURLPROXY, generatedProxyver));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYUSERPWD)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXYUSERPWD", CURLOPT_PROXYUSERPWD, generatedProxyuserpwd));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTPPROXYTUNNEL)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HTTPPROXYTUNNEL", CURLOPT_HTTPPROXYTUNNEL, generatedProxytunnel ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.3 */0);
						if (generatedPreproxy) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PRE_PROXY)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PRE_PROXY", CURLOPT_PRE_PROXY, generatedPreproxy));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedProxyanyauth) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYAUTH)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_PROXYAUTH", CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)CURLAUTH_ANY));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (generatedProxynegotiate) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYAUTH)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_PROXYAUTH", CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)CURLAUTH_GSSNEGOTIATE));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (generatedProxyntlm) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYAUTH)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_PROXYAUTH", CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)CURLAUTH_NTLM));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (generatedProxydigest) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYAUTH)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_PROXYAUTH", CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)CURLAUTH_DIGEST));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (generatedProxybasic) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYAUTH)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_PROXYAUTH", CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)CURLAUTH_BASIC));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NOPROXY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_NOPROXY", CURLOPT_NOPROXY, generatedNoproxy));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.19.4 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SUPPRESS_CONNECT_HEADERS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SUPPRESS_CONNECT_HEADERS", CURLOPT_SUPPRESS_CONNECT_HEADERS, generatedSuppress_connect_headers ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FAILONERROR)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FAILONERROR", CURLOPT_FAILONERROR, generatedFailonerror ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_REQUEST_TARGET)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_REQUEST_TARGET", CURLOPT_REQUEST_TARGET, generatedRequest_target));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_UPLOAD)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_UPLOAD", CURLOPT_UPLOAD, generatedUploadfile ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DIRLISTONLY)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_DIRLISTONLY", CURLOPT_DIRLISTONLY, generatedDirlistonly ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_APPEND)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_APPEND", CURLOPT_APPEND, generatedFtp_append ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedNetrc_opt) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NETRC)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_NETRC", CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_OPTIONAL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (generatedNetrc || generatedNetrc_file) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NETRC)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_NETRC", CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_REQUIRED));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NETRC)) {
									result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_NETRC", CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_IGNORED));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (generatedNetrc_file) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_NETRC_FILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_NETRC_FILE", CURLOPT_NETRC_FILE, generatedNetrc_file));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TRANSFERTEXT)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TRANSFERTEXT", CURLOPT_TRANSFERTEXT, generatedUse_ascii ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedLogin_options) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_LOGIN_OPTIONS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_LOGIN_OPTIONS", CURLOPT_LOGIN_OPTIONS, generatedLogin_options));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_USERPWD)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_USERPWD", CURLOPT_USERPWD, generatedUserpwd));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_RANGE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_RANGE", CURLOPT_RANGE, generatedRange));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_ERRORBUFFER)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_ERRORBUFFER", CURLOPT_ERRORBUFFER, generatedErrorbuffer));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TIMEOUT_MS)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TIMEOUT_MS", CURLOPT_TIMEOUT_MS, (long)(generatedTimeout * 1000)));
							if (result) {
								break;
							} 
						} 
					} while (0);
					switch (generatedHttpreq) {
					case .HTTPREQ_SIMPLEPOST:
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_POSTFIELDS)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_POSTFIELDS", CURLOPT_POSTFIELDS, generatedPostfields));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_POSTFIELDSIZE_LARGE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_POSTFIELDSIZE_LARGE", CURLOPT_POSTFIELDSIZE_LARGE, generatedPostfieldsize));
									if (result) {
										break;
									} 
								} 
							} while (0);
							break;
					case .HTTPREQ_MIMEPOST:
							result = generatedMimeroot.tool2curlmime(ModernizedCProgram.curl, generatedMimepost);
							if (result) {
								break;
							} 
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MIMEPOST)) {
									result = (global.tool_setopt_mimepost(ModernizedCProgram.curl, "CURLOPT_MIMEPOST", CURLOPT_MIMEPOST, generatedMimepost));
									if (result) {
										break;
									} 
								} 
							} while (0);
							break;
					default:
							break;
					}
					if (result) {
						break;
					} 
					if (generatedAuthtype) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTPAUTH)) {
								result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_HTTPAUTH", CURLOPT_HTTPAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)generatedAuthtype));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTPHEADER)) {
							result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_HTTPHEADER", CURLOPT_HTTPHEADER, generatedHeaders));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (ModernizedCProgram.built_in_protos & (CURLPROTO_HTTP | CURLPROTO_RTSP)) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_REFERER)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_REFERER", CURLOPT_REFERER, generatedReferer));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_USERAGENT)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_USERAGENT", CURLOPT_USERAGENT, generatedUseragent));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.built_in_protos & CURLPROTO_HTTP) {
						long postRedir = 0;
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FOLLOWLOCATION)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FOLLOWLOCATION", CURLOPT_FOLLOWLOCATION, generatedFollowlocation ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_UNRESTRICTED_AUTH)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_UNRESTRICTED_AUTH", CURLOPT_UNRESTRICTED_AUTH, generatedUnrestricted_auth ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_AUTOREFERER)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_AUTOREFERER", CURLOPT_AUTOREFERER, generatedAutoreferer ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (generatedProxyheaders) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXYHEADER)) {
									result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_PROXYHEADER", CURLOPT_PROXYHEADER, generatedProxyheaders));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HEADEROPT)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HEADEROPT", CURLOPT_HEADEROPT, CURLHEADER_SEPARATE));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAXREDIRS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_MAXREDIRS", CURLOPT_MAXREDIRS, generatedMaxredirs));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.5 */0);
						if (generatedHttpversion) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTP_VERSION)) {
									result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_HTTP_VERSION", CURLOPT_HTTP_VERSION, ModernizedCProgram.setopt_nv_CURL_HTTP_VERSION, generatedHttpversion));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (ModernizedCProgram.curlinfo.getFeatures() & CURL_VERSION_HTTP2) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTP_VERSION)) {
									result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_HTTP_VERSION", CURLOPT_HTTP_VERSION, ModernizedCProgram.setopt_nv_CURL_HTTP_VERSION, CURL_HTTP_VERSION_2TLS));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedPost301) {
							postRedir |=  CURL_REDIR_POST_301;
						} 
						if (generatedPost302) {
							postRedir |=  CURL_REDIR_POST_302;
						} 
						if (generatedPost303) {
							postRedir |=  CURL_REDIR_POST_303;
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_POSTREDIR)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_POSTREDIR", CURLOPT_POSTREDIR, postRedir));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (generatedEncoding) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_ACCEPT_ENCODING)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_ACCEPT_ENCODING", CURLOPT_ACCEPT_ENCODING, ""));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedTr_encoding) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TRANSFER_ENCODING)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TRANSFER_ENCODING", CURLOPT_TRANSFER_ENCODING, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTP09_ALLOWED)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HTTP09_ALLOWED", CURLOPT_HTTP09_ALLOWED, generatedHttp09_allowed ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.64.0 */0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTPPORT)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_FTPPORT", CURLOPT_FTPPORT, generatedFtpport));
							if (result) {
								break;
							} 
						} 
					} while (/* (built_in_protos & CURLPROTO_HTTP) */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_LOW_SPEED_LIMIT)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_LOW_SPEED_LIMIT", CURLOPT_LOW_SPEED_LIMIT, generatedLow_speed_limit));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_LOW_SPEED_TIME)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_LOW_SPEED_TIME", CURLOPT_LOW_SPEED_TIME, generatedLow_speed_time));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAX_SEND_SPEED_LARGE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_MAX_SEND_SPEED_LARGE", CURLOPT_MAX_SEND_SPEED_LARGE, generatedSendpersecond));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAX_RECV_SPEED_LARGE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_MAX_RECV_SPEED_LARGE", CURLOPT_MAX_RECV_SPEED_LARGE, generatedRecvpersecond));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedUse_resume) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_RESUME_FROM_LARGE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_RESUME_FROM_LARGE", CURLOPT_RESUME_FROM_LARGE, generatedResume_from));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_RESUME_FROM_LARGE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_RESUME_FROM_LARGE", CURLOPT_RESUME_FROM_LARGE, .CURL_OFF_T_C(0)));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_KEYPASSWD)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_KEYPASSWD", CURLOPT_KEYPASSWD, generatedKey_passwd));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_KEYPASSWD)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_KEYPASSWD", CURLOPT_PROXY_KEYPASSWD, generatedProxy_key_passwd));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (ModernizedCProgram.built_in_protos & (CURLPROTO_SCP | CURLPROTO_SFTP)) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSH_PRIVATE_KEYFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSH_PRIVATE_KEYFILE", CURLOPT_SSH_PRIVATE_KEYFILE, generatedKey));
								if (result) {
									break;
								} 
							} 
						} while (/* SSH and SSL private key uses same command-line option *//* new in libcurl 7.16.1 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSH_PUBLIC_KEYFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSH_PUBLIC_KEYFILE", CURLOPT_SSH_PUBLIC_KEYFILE, generatedPubkey));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.16.1 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSH_HOST_PUBLIC_KEY_MD5)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSH_HOST_PUBLIC_KEY_MD5", CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, generatedHostpubmd5));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.17.1: SSH host key md5 checking allows us
						             to fail if we are not talking to who we think we should */0);
						if (generatedSsh_compression) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSH_COMPRESSION)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSH_COMPRESSION", CURLOPT_SSH_COMPRESSION, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} 
					if (generatedCacert) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CAINFO)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_CAINFO", CURLOPT_CAINFO, generatedCacert));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProxy_cacert) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_CAINFO)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_CAINFO", CURLOPT_PROXY_CAINFO, generatedProxy_cacert));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedCapath) {
						result = global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_CAPATH", CURLOPT_CAPATH, generatedCapath);
						if (result == CURLE_NOT_BUILT_IN) {
							generatedGlobal.warnf("ignoring %s, not supported by libcurl\n", capath_from_env ? "SSL_CERT_DIR environment variable" : "--capath");
						}  else if (result) {
							break;
						} 
					} 
					if ((generatedProxy_capath || generatedCapath) && !ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_CAPATH)) {
						result = global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_CAPATH", CURLOPT_PROXY_CAPATH, (generatedProxy_capath ? generatedProxy_capath : generatedCapath));
						if (result == CURLE_NOT_BUILT_IN) {
							if (generatedProxy_capath) {
								generatedGlobal.warnf("ignoring --proxy-capath, not supported by libcurl\n");
							} 
						}  else if (result) {
							break;
						} 
					} 
					if (generatedCrlfile) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CRLFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_CRLFILE", CURLOPT_CRLFILE, generatedCrlfile));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProxy_crlfile) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_CRLFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_CRLFILE", CURLOPT_PROXY_CRLFILE, generatedProxy_crlfile));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (generatedCrlfile) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_CRLFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_CRLFILE", CURLOPT_PROXY_CRLFILE, generatedCrlfile));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedPinnedpubkey) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PINNEDPUBLICKEY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PINNEDPUBLICKEY", CURLOPT_PINNEDPUBLICKEY, generatedPinnedpubkey));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.curlinfo.getFeatures() & CURL_VERSION_SSL/* Check if config->cert is a PKCS#11 URI and set the
					           * config->cert_type if necessary */) {
						if (generatedCert) {
							if (!generatedCert_type) {
								if (ModernizedCProgram.is_pkcs11_uri(generatedCert)) {
									config.setCert_type(.strdup("ENG"));
								} 
							} 
						} 
						if (generatedKey) {
							if (!generatedKey_type) {
								if (ModernizedCProgram.is_pkcs11_uri(generatedKey)) {
									config.setKey_type(.strdup("ENG"));
								} 
							} 
						} 
						if (generatedProxy_cert) {
							if (!generatedProxy_cert_type) {
								if (ModernizedCProgram.is_pkcs11_uri(generatedProxy_cert)) {
									config.setProxy_cert_type(.strdup("ENG"));
								} 
							} 
						} 
						if (generatedProxy_key) {
							if (!generatedProxy_key_type) {
								if (ModernizedCProgram.is_pkcs11_uri(generatedProxy_key)) {
									config.setProxy_key_type(.strdup("ENG"));
								} 
							} 
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSLCERT)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSLCERT", CURLOPT_SSLCERT, generatedCert));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSLCERT)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SSLCERT", CURLOPT_PROXY_SSLCERT, generatedProxy_cert));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSLCERTTYPE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSLCERTTYPE", CURLOPT_SSLCERTTYPE, generatedCert_type));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSLCERTTYPE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SSLCERTTYPE", CURLOPT_PROXY_SSLCERTTYPE, generatedProxy_cert_type));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSLKEY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSLKEY", CURLOPT_SSLKEY, generatedKey));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSLKEY)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SSLKEY", CURLOPT_PROXY_SSLKEY, generatedProxy_key));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSLKEYTYPE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSLKEYTYPE", CURLOPT_SSLKEYTYPE, generatedKey_type));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSLKEYTYPE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SSLKEYTYPE", CURLOPT_PROXY_SSLKEYTYPE, generatedProxy_key_type));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (generatedInsecure_ok) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_VERIFYPEER)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_VERIFYPEER", CURLOPT_SSL_VERIFYPEER, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_VERIFYHOST)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_VERIFYHOST", CURLOPT_SSL_VERIFYHOST, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_VERIFYPEER)) {
										result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_VERIFYPEER", CURLOPT_SSL_VERIFYPEER, -1024));
										if (result) {
											break;
										} 
									} 
								} while (0/* libcurl default is strict verifyhost -> 2L   */);
						} 
						if (generatedProxy_insecure_ok) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSL_VERIFYPEER)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_PROXY_SSL_VERIFYPEER", CURLOPT_PROXY_SSL_VERIFYPEER, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSL_VERIFYHOST)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_PROXY_SSL_VERIFYHOST", CURLOPT_PROXY_SSL_VERIFYHOST, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSL_VERIFYPEER)) {
										result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_PROXY_SSL_VERIFYPEER", CURLOPT_PROXY_SSL_VERIFYPEER, -1024));
										if (result) {
											break;
										} 
									} 
								} while (0);
						} 
						if (generatedVerifystatus) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_VERIFYSTATUS)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_VERIFYSTATUS", CURLOPT_SSL_VERIFYSTATUS, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedFalsestart) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_FALSESTART)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_FALSESTART", CURLOPT_SSL_FALSESTART, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSLVERSION)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_SSLVERSION", CURLOPT_SSLVERSION, ModernizedCProgram.setopt_nv_CURL_SSLVERSION, generatedSsl_version | generatedSsl_version_max));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSLVERSION)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_PROXY_SSLVERSION", CURLOPT_PROXY_SSLVERSION, ModernizedCProgram.setopt_nv_CURL_SSLVERSION, generatedProxy_ssl_version));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedPath_as_is) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PATH_AS_IS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_PATH_AS_IS", CURLOPT_PATH_AS_IS, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.built_in_protos & (CURLPROTO_SCP | CURLPROTO_SFTP)) {
						if (!generatedInsecure_ok) {
							byte home;
							byte file;
							result = CURLE_OUT_OF_MEMORY;
							home = ModernizedCProgram.homedir();
							if (home) {
								file = ModernizedCProgram.curl_maprintf("%s/.ssh/known_hosts", home);
								if (file) {
									result = global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSH_KNOWNHOSTS", CURLOPT_SSH_KNOWNHOSTS, /* new in curl 7.19.6 */file);
									ModernizedCProgram.curl_free(file);
									if (result == CURLE_UNKNOWN_OPTION) {
										result = /* libssh2 version older than 1.1.1 */CURLE_OK;
									} 
								} 
								do {
									.free((home));
									(home) = ((Object)0);
								} while (0);
							} 
							if (result) {
								break;
							} 
						} 
					} 
					if (generatedNo_body || generatedRemote_time) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FILETIME)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FILETIME", CURLOPT_FILETIME, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* no body or use remote time */0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CRLF)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_CRLF", CURLOPT_CRLF, generatedCrlf ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_QUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_QUOTE", CURLOPT_QUOTE, generatedQuote));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_POSTQUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_POSTQUOTE", CURLOPT_POSTQUOTE, generatedPostquote));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PREQUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_PREQUOTE", CURLOPT_PREQUOTE, generatedPrequote));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedCookie) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_COOKIE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_COOKIE", CURLOPT_COOKIE, generatedCookie));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedCookiefile) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_COOKIEFILE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_COOKIEFILE", CURLOPT_COOKIEFILE, generatedCookiefile));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedCookiejar) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_COOKIEJAR)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_COOKIEJAR", CURLOPT_COOKIEJAR, generatedCookiejar));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_COOKIESESSION)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_COOKIESESSION", CURLOPT_COOKIESESSION, generatedCookiesession ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.9.7 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TIMECONDITION)) {
							result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_TIMECONDITION", CURLOPT_TIMECONDITION, ModernizedCProgram.setopt_nv_CURL_TIMECOND, (long)generatedTimecond));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TIMEVALUE_LARGE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TIMEVALUE_LARGE", CURLOPT_TIMEVALUE_LARGE, generatedCondtime));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CUSTOMREQUEST)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_CUSTOMREQUEST", CURLOPT_CUSTOMREQUEST, generatedCustomrequest));
							if (result) {
								break;
							} 
						} 
					} while (0);
					config.customrequest_helper(generatedHttpreq, generatedCustomrequest);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_STDERR)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_STDERR", CURLOPT_STDERR, generatedErrors));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_INTERFACE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_INTERFACE", CURLOPT_INTERFACE, generatedIface));
							if (result) {
								break;
							} 
						} 
					} while (/* three new ones in libcurl 7.3: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_KRBLEVEL)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_KRBLEVEL", CURLOPT_KRBLEVEL, generatedKrblevel));
							if (result) {
								break;
							} 
						} 
					} while (0);
					ModernizedCProgram.progressbarinit(generatedProgressbar, config);
					if ((generatedProgressmode == 1) && !generatedNoprogress && !generatedMute) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_XFERINFOFUNCTION)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_XFERINFOFUNCTION", CURLOPT_XFERINFOFUNCTION, ModernizedCProgram.tool_progress_cb));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_XFERINFODATA)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_XFERINFODATA", CURLOPT_XFERINFODATA, generatedProgressbar));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDns_servers) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DNS_SERVERS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DNS_SERVERS", CURLOPT_DNS_SERVERS, generatedDns_servers));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDns_interface) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DNS_INTERFACE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DNS_INTERFACE", CURLOPT_DNS_INTERFACE, generatedDns_interface));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDns_ipv4_addr) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DNS_LOCAL_IP4)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DNS_LOCAL_IP4", CURLOPT_DNS_LOCAL_IP4, generatedDns_ipv4_addr));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDns_ipv6_addr) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DNS_LOCAL_IP6)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DNS_LOCAL_IP6", CURLOPT_DNS_LOCAL_IP6, generatedDns_ipv6_addr));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TELNETOPTIONS)) {
							result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_TELNETOPTIONS", CURLOPT_TELNETOPTIONS, generatedTelnet_options));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.6.2: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_RANDOM_FILE)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_RANDOM_FILE", CURLOPT_RANDOM_FILE, generatedRandom_file));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.7: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_EGDSOCKET)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_EGDSOCKET", CURLOPT_EGDSOCKET, generatedEgd_file));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CONNECTTIMEOUT_MS)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_CONNECTTIMEOUT_MS", CURLOPT_CONNECTTIMEOUT_MS, (long)(generatedConnecttimeout * 1000)));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedDoh_url) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DOH_URL)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DOH_URL", CURLOPT_DOH_URL, generatedDoh_url));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedCipher_list) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_CIPHER_LIST)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSL_CIPHER_LIST", CURLOPT_SSL_CIPHER_LIST, generatedCipher_list));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProxy_cipher_list) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSL_CIPHER_LIST)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SSL_CIPHER_LIST", CURLOPT_PROXY_SSL_CIPHER_LIST, generatedProxy_cipher_list));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedCipher13_list) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TLS13_CIPHERS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_TLS13_CIPHERS", CURLOPT_TLS13_CIPHERS, generatedCipher13_list));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProxy_cipher13_list) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_TLS13_CIPHERS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_TLS13_CIPHERS", CURLOPT_PROXY_TLS13_CIPHERS, generatedProxy_cipher13_list));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDisable_epsv) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_USE_EPSV)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_USE_EPSV", CURLOPT_FTP_USE_EPSV, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (generatedDisable_eprt) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_USE_EPRT)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_USE_EPRT", CURLOPT_FTP_USE_EPRT, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (generatedTracetype != .TRACE_NONE) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DEBUGFUNCTION)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_DEBUGFUNCTION", CURLOPT_DEBUGFUNCTION, ModernizedCProgram.tool_debug_cb));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DEBUGDATA)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_DEBUGDATA", CURLOPT_DEBUGDATA, config));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_VERBOSE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_VERBOSE", CURLOPT_VERBOSE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedEngine) {
						result = global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SSLENGINE", CURLOPT_SSLENGINE, generatedEngine);
						if (result) {
							break;
						} 
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_CREATE_MISSING_DIRS)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_CREATE_MISSING_DIRS", CURLOPT_FTP_CREATE_MISSING_DIRS, (long)(generatedFtp_create_dirs ? CURLFTP_CREATE_DIR_RETRY : CURLFTP_CREATE_DIR_NONE)));
							if (result) {
								break;
							} 
						} 
					} while (/* new in curl 7.10.7, extended in 7.19.4. Modified to use
					           CREATE_DIR_RETRY in 7.49.0 */0);
					if (generatedMax_filesize) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAXFILESIZE_LARGE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_MAXFILESIZE_LARGE", CURLOPT_MAXFILESIZE_LARGE, generatedMax_filesize));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (4 == generatedIp_version) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_IPRESOLVE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_IPRESOLVE", CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (6 == generatedIp_version) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_IPRESOLVE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_IPRESOLVE", CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_IPRESOLVE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_IPRESOLVE", CURLOPT_IPRESOLVE, CURL_IPRESOLVE_WHATEVER));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (generatedFtp_ssl_reqd) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_USE_SSL)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_USE_SSL", CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long)CURLUSESSL_ALL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (generatedFtp_ssl) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_USE_SSL)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_USE_SSL", CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long)CURLUSESSL_TRY));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (generatedFtp_ssl_control) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_USE_SSL)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_USE_SSL", CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long)CURLUSESSL_CONTROL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedFtp_ssl_ccc) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_SSL_CCC)) {
								result = (global.tool_setopt_enum(ModernizedCProgram.curl, "CURLOPT_FTP_SSL_CCC", CURLOPT_FTP_SSL_CCC, ModernizedCProgram.setopt_nv_CURLFTPSSL_CCC, (long)generatedFtp_ssl_ccc_mode));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedSocks5_gssapi_nec) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SOCKS5_GSSAPI_NEC)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SOCKS5_GSSAPI_NEC", CURLOPT_SOCKS5_GSSAPI_NEC, generatedSocks5_gssapi_nec));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedSocks5_auth) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SOCKS5_AUTH)) {
								result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_SOCKS5_AUTH", CURLOPT_SOCKS5_AUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)generatedSocks5_auth));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProxy_service_name) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SERVICE_NAME)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_SERVICE_NAME", CURLOPT_PROXY_SERVICE_NAME, generatedProxy_service_name));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedService_name) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SERVICE_NAME)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SERVICE_NAME", CURLOPT_SERVICE_NAME, generatedService_name));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_ACCOUNT)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_FTP_ACCOUNT", CURLOPT_FTP_ACCOUNT, generatedFtp_account));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.13.0 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_IGNORE_CONTENT_LENGTH)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_IGNORE_CONTENT_LENGTH", CURLOPT_IGNORE_CONTENT_LENGTH, generatedIgnorecl ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_SKIP_PASV_IP)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_SKIP_PASV_IP", CURLOPT_FTP_SKIP_PASV_IP, generatedFtp_skip_ip ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.14.2 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_FILEMETHOD)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_FILEMETHOD", CURLOPT_FTP_FILEMETHOD, (long)generatedFtp_filemethod));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.15.1 */0);
					if (generatedLocalport) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_LOCALPORT)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_LOCALPORT", CURLOPT_LOCALPORT, generatedLocalport));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_LOCALPORTRANGE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_LOCALPORTRANGE", CURLOPT_LOCALPORTRANGE, generatedLocalportrange));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_ALTERNATIVE_TO_USER)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_FTP_ALTERNATIVE_TO_USER", CURLOPT_FTP_ALTERNATIVE_TO_USER, generatedFtp_alternative_to_user));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.15.5 */0);
					if (generatedDisable_sessionid) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_SESSIONID_CACHE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_SESSIONID_CACHE", CURLOPT_SSL_SESSIONID_CACHE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (generatedRaw) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTP_CONTENT_DECODING)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HTTP_CONTENT_DECODING", CURLOPT_HTTP_CONTENT_DECODING, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HTTP_TRANSFER_DECODING)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HTTP_TRANSFER_DECODING", CURLOPT_HTTP_TRANSFER_DECODING, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (!generatedNokeepalive) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_KEEPALIVE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_KEEPALIVE", CURLOPT_TCP_KEEPALIVE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (generatedAlivetime != 0) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_KEEPIDLE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_KEEPIDLE", CURLOPT_TCP_KEEPIDLE, generatedAlivetime));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_KEEPINTVL)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_KEEPINTVL", CURLOPT_TCP_KEEPINTVL, generatedAlivetime));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TCP_KEEPALIVE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TCP_KEEPALIVE", CURLOPT_TCP_KEEPALIVE, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (generatedTftp_blksize) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TFTP_BLKSIZE)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TFTP_BLKSIZE", CURLOPT_TFTP_BLKSIZE, generatedTftp_blksize));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedMail_from) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAIL_FROM)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_MAIL_FROM", CURLOPT_MAIL_FROM, generatedMail_from));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedMail_rcpt) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAIL_RCPT)) {
								result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_MAIL_RCPT", CURLOPT_MAIL_RCPT, generatedMail_rcpt));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedFtp_pret) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_FTP_USE_PRET)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_FTP_USE_PRET", CURLOPT_FTP_USE_PRET, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProto_present) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROTOCOLS)) {
								result = (global.tool_setopt_flags(ModernizedCProgram.curl, "CURLOPT_PROTOCOLS", CURLOPT_PROTOCOLS, ModernizedCProgram.setopt_nv_CURLPROTO, generatedProto));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedProto_redir_present) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_REDIR_PROTOCOLS)) {
								result = (global.tool_setopt_flags(ModernizedCProgram.curl, "CURLOPT_REDIR_PROTOCOLS", CURLOPT_REDIR_PROTOCOLS, ModernizedCProgram.setopt_nv_CURLPROTO, generatedProto_redir));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedContent_disposition && (generatedFlags & (1 << 2))) {
						hdrcbdata.setHonor_cd_filename(1);
					} else {
							hdrcbdata.setHonor_cd_filename(0);
					} 
					hdrcbdata.setOuts(outs);
					hdrcbdata.setHeads(heads);
					hdrcbdata.setGlobal(global);
					hdrcbdata.setConfig(config);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HEADERFUNCTION)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HEADERFUNCTION", CURLOPT_HEADERFUNCTION, ModernizedCProgram.tool_header_cb));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HEADERDATA)) {
							result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HEADERDATA", CURLOPT_HEADERDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (generatedResolve) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_RESOLVE)) {
								result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_RESOLVE", CURLOPT_RESOLVE, generatedResolve));
								if (result) {
									break;
								} 
							} 
						} while (/* new in 7.21.3 */0);
					} 
					if (generatedConnect_to) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_CONNECT_TO)) {
								result = (ModernizedCProgram.tool_setopt_slist(ModernizedCProgram.curl, global, "CURLOPT_CONNECT_TO", CURLOPT_CONNECT_TO, generatedConnect_to));
								if (result) {
									break;
								} 
							} 
						} while (/* new in 7.49.0 */0);
					} 
					if (ModernizedCProgram.curlinfo.getFeatures() & /* new in 7.21.4 */CURL_VERSION_TLSAUTH_SRP) {
						if (generatedTls_username) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TLSAUTH_USERNAME)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_TLSAUTH_USERNAME", CURLOPT_TLSAUTH_USERNAME, generatedTls_username));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedTls_password) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TLSAUTH_PASSWORD)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_TLSAUTH_PASSWORD", CURLOPT_TLSAUTH_PASSWORD, generatedTls_password));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedTls_authtype) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TLSAUTH_TYPE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_TLSAUTH_TYPE", CURLOPT_TLSAUTH_TYPE, generatedTls_authtype));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedProxy_tls_username) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_TLSAUTH_USERNAME)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_TLSAUTH_USERNAME", CURLOPT_PROXY_TLSAUTH_USERNAME, generatedProxy_tls_username));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedProxy_tls_password) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_TLSAUTH_PASSWORD)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_TLSAUTH_PASSWORD", CURLOPT_PROXY_TLSAUTH_PASSWORD, generatedProxy_tls_password));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (generatedProxy_tls_authtype) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_TLSAUTH_TYPE)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_PROXY_TLSAUTH_TYPE", CURLOPT_PROXY_TLSAUTH_TYPE, generatedProxy_tls_authtype));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} 
					if (generatedGssapi_delegation) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_GSSAPI_DELEGATION)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_GSSAPI_DELEGATION", CURLOPT_GSSAPI_DELEGATION, generatedGssapi_delegation));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					{ 
						long mask = (generatedSsl_allow_beast ? CURLSSLOPT_ALLOW_BEAST : /* new in 7.25.0 and 7.44.0 */0) | (generatedSsl_no_revoke ? CURLSSLOPT_NO_REVOKE : 0);
						if (mask) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_OPTIONS)) {
									result = (global.tool_setopt_bitmask(ModernizedCProgram.curl, "CURLOPT_SSL_OPTIONS", CURLOPT_SSL_OPTIONS, ModernizedCProgram.setopt_nv_CURLSSLOPT, mask));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					}
					if (generatedProxy_ssl_allow_beast) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_PROXY_SSL_OPTIONS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_PROXY_SSL_OPTIONS", CURLOPT_PROXY_SSL_OPTIONS, (long)CURLSSLOPT_ALLOW_BEAST));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedMail_auth) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_MAIL_AUTH)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_MAIL_AUTH", CURLOPT_MAIL_AUTH, generatedMail_auth));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedSasl_authzid) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SASL_AUTHZID)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_SASL_AUTHZID", CURLOPT_SASL_AUTHZID, generatedSasl_authzid));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedSasl_ir) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SASL_IR)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SASL_IR", CURLOPT_SASL_IR, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedNonpn) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_ENABLE_NPN)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_ENABLE_NPN", CURLOPT_SSL_ENABLE_NPN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedNoalpn) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_SSL_ENABLE_ALPN)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_SSL_ENABLE_ALPN", CURLOPT_SSL_ENABLE_ALPN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedUnix_socket_path) {
						if (generatedAbstract_unix_socket) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_ABSTRACT_UNIX_SOCKET)) {
									result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_ABSTRACT_UNIX_SOCKET", CURLOPT_ABSTRACT_UNIX_SOCKET, generatedUnix_socket_path));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_UNIX_SOCKET_PATH)) {
										result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_UNIX_SOCKET_PATH", CURLOPT_UNIX_SOCKET_PATH, generatedUnix_socket_path));
										if (result) {
											break;
										} 
									} 
								} while (0);
						} 
					} 
					if (generatedProto_default) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DEFAULT_PROTOCOL)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_DEFAULT_PROTOCOL", CURLOPT_DEFAULT_PROTOCOL, generatedProto_default));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedExpect100timeout > /* new in 7.47.0 */0) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_EXPECT_100_TIMEOUT_MS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 1, "CURLOPT_EXPECT_100_TIMEOUT_MS", CURLOPT_EXPECT_100_TIMEOUT_MS, (long)(generatedExpect100timeout * 1000)));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedTftp_no_options) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_TFTP_NO_OPTIONS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_TFTP_NO_OPTIONS", CURLOPT_TFTP_NO_OPTIONS, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedHappy_eyeballs_timeout_ms != /* new in 7.59.0 */CURL_HET_DEFAULT) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS", CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, generatedHappy_eyeballs_timeout_ms));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedHaproxy_protocol) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_HAPROXYPROTOCOL)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_HAPROXYPROTOCOL", CURLOPT_HAPROXYPROTOCOL, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (generatedDisallow_username_in_url) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(CURLOPT_DISALLOW_USERNAME_IN_URL)) {
								result = (global.tool_setopt(ModernizedCProgram.curl, 0, "CURLOPT_DISALLOW_USERNAME_IN_URL", CURLOPT_DISALLOW_USERNAME_IN_URL, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0/* only if explicitly enabled in configure */);
					} 
					per.setMetalink(/* USE_METALINK */metalink);
					per.setRetry_sleep_default((generatedRetry_delay) ? generatedRetry_delay * -1024 : /* ms */-1024);
					per.setRetry_numretries(generatedReq_retry);
					per.setRetry_sleep(generatedRetry_sleep_default);
					per.setRetrystart(timeval.tvnow());
					generatedLi++;
				} else {
						do {
							.free((generatedOutfile));
							(generatedOutfile) = ((Object)0);
						} while (/* Free this URL node data without destroying the
						           the node itself nor modifying next pointer. */0);
						do {
							.free((generatedInfile));
							(generatedInfile) = ((Object)0);
						} while (0);
						urlnode.setFlags(0);
						generatedUrls.glob_cleanup();
						state.setUrls(((Object)0));
						state.setUrlnum(0);
						do {
							.free((generatedOutfiles));
							(generatedOutfiles) = ((Object)0);
						} while (0);
						do {
							.free((generatedUploadfile));
							(generatedUploadfile) = ((Object)0);
						} while (0);
						if (generatedInglob) {
							generatedInglob.glob_cleanup();
							state.setInglob(((Object)0));
						} 
						generatedState.setUrlnode(generatedNext);
						state.setUp(0);
						continue;
				} 
			}
			break;
		}
		if (!added || result) {
			added = 0;
			config.single_transfer_cleanup();
		} 
		return result/* number of easy handles currently added *//*
		 * add_parallel_transfers() sets 'morep' to TRUE if there are more transfers
		 * to add even after this call returns. sets 'addedp' to TRUE if one or more
		 * transfers were added.
		 */;
	}
	/* setup a transfer for the given config */
	public static Object transfer_per_config(GlobalConfig global, OperationConfig config, Object share,  added) {
		 result = CURLE_OK;
		bool capath_from_env = new bool();
		added = 0;
		getout generatedUrl_list = config.getUrl_list();
		Byte generatedUrl = generatedUrl_list.getUrl();
		_iobuf generatedErrors = global.getErrors();
		if (!generatedUrl_list || !generatedUrl) {
			generatedErrors.helpf("no URL specified!\n");
			return CURLE_FAILED_INIT/* On WIN32 we can't set the path to curl-ca-bundle.crt
			   * at compile time. So we look here for the file in two ways:
			   * 1: look at the environment variable CURL_CA_BUNDLE for a path
			   * 2: if #1 isn't found, use the windows API function SearchPath()
			   *    to find it along the app's path (includes app's dir and CWD)
			   *
			   * We support the environment variable thing for non-Windows platforms
			   * too. Just for the sake of it.
			   */;
		} 
		capath_from_env = .bool_false;
		Byte generatedCacert = config.getCacert();
		Byte generatedCapath = config.getCapath();
		 generatedInsecure_ok = config.getInsecure_ok();
		Curl_easy curl_easy = new Curl_easy();
		Object generatedCurl_tlssessioninfo = tls_backend_info.getCurl_tlssessioninfo();
		if (!generatedCacert && !generatedCapath && !generatedInsecure_ok) {
			 curltls = curl_easy.curl_easy_init();
			curl_tlssessioninfo tls_backend_info = ((Object)0/* With the addition of CAINFO support for Schannel, this search could find
			     * a certificate bundle that was previously ignored. To maintain backward
			     * compatibility, only perform this search if not using Schannel.
			     */);
			result = curltls.curl_easy_getinfo(CURLINFO_TLS_SSL_PTR, tls_backend_info);
			if (result) {
				return result/* Set the CA cert locations specified in the environment. For Windows if
				     * no environment-specified filename is found then check for CA bundle
				     * default filename curl-ca-bundle.crt in the user's PATH.
				     *
				     * If Schannel is the selected SSL backend then these locations are
				     * ignored. We allow setting CA location for schannel only when explicitly
				     * specified by the user via CURLOPT_CAINFO / --cacert.
				     */;
			} 
			if (generatedCurl_tlssessioninfo != CURLSSLBACKEND_SCHANNEL) {
				byte env;
				env = ModernizedCProgram.curl_getenv("CURL_CA_BUNDLE");
				if (env) {
					config.setCacert(.strdup(env));
					if (!generatedCacert) {
						ModernizedCProgram.curl_free(env);
						generatedErrors.helpf("out of memory\n");
						return CURLE_OUT_OF_MEMORY;
					} 
				} else {
						env = ModernizedCProgram.curl_getenv("SSL_CERT_DIR");
						if (env) {
							config.setCapath(.strdup(env));
							if (!generatedCapath) {
								ModernizedCProgram.curl_free(env);
								generatedErrors.helpf("out of memory\n");
								return CURLE_OUT_OF_MEMORY;
							} 
							capath_from_env = .bool_true;
						} else {
								env = ModernizedCProgram.curl_getenv("SSL_CERT_FILE");
								if (env) {
									config.setCacert(.strdup(env));
									if (!generatedCacert) {
										ModernizedCProgram.curl_free(env);
										generatedErrors.helpf("out of memory\n");
										return CURLE_OUT_OF_MEMORY;
									} 
								} 
						} 
				} 
				if (env) {
					ModernizedCProgram.curl_free(env);
				} else {
						result = config.FindWin32CACert(generatedCurl_tlssessioninfo, "curl-ca-bundle.crt");
				} 
			} 
			curltls.curl_easy_cleanup();
		} 
		if (!result) {
			result = ModernizedCProgram.single_transfer(global, config, share, capath_from_env, added);
		} 
		return result/*
		 * 'create_transfer' gets the details and sets up a new transfer if 'added'
		 * returns TRUE.
		 */;
	}
	public static void thdbufdestroy(Object private) {
		Object generatedBuf = p.getBuf();
		if (private) {
			buffer_t p = (buffer_t)private;
			localkey_t i = new localkey_t();
			for (i = (localkey_t)0; i < .LK_LAST; i++) {
				.free(generatedBuf);
				p++;
			}
			.free(private);
		} 
	}
	public static void terminate() {
		if (ModernizedCProgram.Curl_thread_buffer == ModernizedCProgram.buffer_threaded) {
			ModernizedCProgram.locbufs = .pthread_getspecific(ModernizedCProgram.thdkey);
			.pthread_setspecific(ModernizedCProgram.thdkey, (Object)((Object)0));
			.pthread_key_delete(ModernizedCProgram.thdkey);
		} 
		if (ModernizedCProgram.Curl_thread_buffer != ModernizedCProgram.buffer_undef) {
			ModernizedCProgram.thdbufdestroy((Object)ModernizedCProgram.locbufs);
			ModernizedCProgram.locbufs = (buffer_t)((Object)0);
		} 
		ModernizedCProgram.Curl_thread_buffer = ModernizedCProgram.buffer_undef;
	}
	public static Byte get_buffer(long size) {
		byte cp;
		/* If `size' >= 0, make sure buffer at `buf' is at least `size'-byte long.
		     Return the buffer address. */
		if (size < 0) {
			return ModernizedCProgram.buf.getBuf();
		} 
		if (!ModernizedCProgram.buf.getBuf()) {
			ModernizedCProgram.buf.setBuf(.malloc(size));
			if (ModernizedCProgram.buf.getBuf()) {
				ModernizedCProgram.buf.setSize(size);
			} 
			return ModernizedCProgram.buf.getBuf();
		} 
		if ((long)size <= ModernizedCProgram.buf.getSize()) {
			if (ModernizedCProgram.buf.getSize() - size < 1024) {
				return ModernizedCProgram.buf.getBuf();
			} 
		} 
		cp = .realloc(ModernizedCProgram.buf.getBuf(), /* Resize the buffer. */size);
		if (cp) {
			ModernizedCProgram.buf.setBuf(cp);
			ModernizedCProgram.buf.setSize(size);
		}  else if (size <= ModernizedCProgram.buf.getSize()) {
			cp = ModernizedCProgram.buf.getBuf();
		} 
		return cp;
	}
	public static Byte buffer_unthreaded( key, long size) {
		return ModernizedCProgram.locbufs + key.get_buffer(size);
	}
	public static Byte buffer_threaded( key, long size) {
		buffer_t bufs = new buffer_t();
		/* Get the buffer for the given local key in the current thread, and
		     make sure it is at least `size'-byte long. Set `size' to < 0 to get
		     its address only. */
		bufs = (buffer_t).pthread_getspecific(ModernizedCProgram.thdkey);
		if (!bufs) {
			if (size < 0) {
				return (byte)((Object)/* No buffer yet. */0);
			} 
			bufs = .calloc((size_t).LK_LAST, );
			if (!bufs) {
				return (byte)((Object)0);
			} 
			if (.pthread_setspecific(ModernizedCProgram.thdkey, (Object)bufs)) {
				.free(bufs);
				return (byte)((Object)0);
			} 
		} 
		return bufs + key.get_buffer(size);
	}
	public static Byte buffer_undef( key, long size) {
		.pthread_mutex_lock(ModernizedCProgram.mutex);
		if (ModernizedCProgram.Curl_thread_buffer == /* Determine if we can use pthread-specific data. *//* If unchanged during lock. */ModernizedCProgram.buffer_undef) {
			if (!.pthread_key_create(ModernizedCProgram.thdkey, thdbufdestroy)) {
				ModernizedCProgram.Curl_thread_buffer = ModernizedCProgram.buffer_threaded;
			}  else if (!(ModernizedCProgram.locbufs = .calloc((size_t).LK_LAST, ))) {
				.pthread_mutex_unlock(ModernizedCProgram.mutex);
				return (byte)((Object)0);
			} else {
					ModernizedCProgram.Curl_thread_buffer = ModernizedCProgram.buffer_unthreaded;
			} 
			.atexit(terminate);
		} 
		.pthread_mutex_unlock(ModernizedCProgram.mutex);
		return .Curl_thread_buffer(key, size);
	}
	/* Define the buffer system, get the buffer for the given local key in
	     the current thread, and make sure it is at least `size'-byte long.
	     Set `size' to < 0 to get its address only. */
	public static Byte set_thread_string( key, Object s) {
		int i;
		byte cp;
		if (!s) {
			return (byte)((Object)0);
		} 
		i = .strlen(s) + 1;
		cp = .Curl_thread_buffer(key, 4 * i + 1);
		if (cp) {
			i = .QadrtConvertE2A(cp, s, 4 * i, i);
			cp[i] = (byte)'\0';
		} 
		return cp;
	}
	public static int Curl_getnameinfo_a(Object sa, Object salen, Byte nodename, Object nodenamelen, Byte servname, Object servnamelen, int flags) {
		byte enodename = ((Object)0);
		byte eservname = ((Object)0);
		int status;
		if (nodename && nodenamelen) {
			enodename = .malloc(nodenamelen);
			if (!enodename) {
				return EAI_MEMORY;
			} 
		} 
		if (servname && servnamelen) {
			eservname = .malloc(servnamelen);
			if (!eservname) {
				.free(enodename);
				return EAI_MEMORY;
			} 
		} 
		status = .getnameinfo(sa, salen, enodename, nodenamelen, eservname, servnamelen, flags);
		if (!status) {
			int i;
			if (enodename) {
				i = .QadrtConvertE2A(nodename, enodename, nodenamelen - 1, .strlen(enodename));
				nodename[i] = (byte)'\0';
			} 
			if (eservname) {
				i = .QadrtConvertE2A(servname, eservname, servnamelen - 1, .strlen(eservname));
				servname[i] = (byte)'\0';
			} 
		} 
		.free(enodename);
		.free(eservname);
		return status;
	}
	public static int Curl_getaddrinfo_a(Object nodename, Object servname, Object hints, Object res) {
		byte enodename;
		byte eservname;
		int status;
		int i;
		enodename = (byte)((Object)0);
		eservname = (byte)((Object)0);
		if (nodename) {
			i = .strlen(nodename);
			enodename = .malloc(i + 1);
			if (!enodename) {
				return EAI_MEMORY;
			} 
			i = .QadrtConvertA2E(enodename, nodename, i, i);
			enodename[i] = (byte)'\0';
		} 
		if (servname) {
			i = .strlen(servname);
			eservname = .malloc(i + 1);
			if (!eservname) {
				.free(enodename);
				return EAI_MEMORY;
			} 
			.QadrtConvertA2E(eservname, servname, i, i);
			eservname[i] = (byte)'\0';
		} 
		status = .getaddrinfo(enodename, eservname, hints, res);
		.free(enodename);
		.free(eservname);
		return status/* ASCII wrappers for the GSKit procedures. *//*
		 * EBCDIC --> ASCII string mapping table.
		 * Some strings returned by GSKit are dynamically allocated and automatically
		 * released when closing the handle.
		 * To provide the same functionality, we use a "private" handle that
		 * holds the GSKit handle and a list of string mappings. This will allow
		 * avoid conversion of already converted strings and releasing them upon
		 * close time.
		 */;
	}
	public static int Curl_gsk_environment_open(Object my_env_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		int rc;
		if (!my_env_handle) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		p = (Curl_gsk_descriptor).malloc();
		if (!p) {
			return GSK_INSUFFICIENT_STORAGE;
		} 
		p.setStrlist((gskstrlist)((Object)0));
		Object generatedH = p.getH();
		rc = .gsk_environment_open(generatedH);
		if (rc != GSK_OK) {
			.free(p);
		} else {
				my_env_handle = ()p;
		} 
		return rc;
	}
	public static int Curl_gsk_secure_soc_open(Object my_env_handle, Object my_session_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		 h = new ();
		int rc;
		if (!my_env_handle) {
			return GSK_INVALID_HANDLE;
		} 
		if (!my_session_handle) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		h = ((Curl_gsk_descriptor)my_env_handle).getH();
		p = (Curl_gsk_descriptor).malloc();
		if (!p) {
			return GSK_INSUFFICIENT_STORAGE;
		} 
		p.setStrlist((gskstrlist)((Object)0));
		Object generatedH = p.getH();
		rc = .gsk_secure_soc_open(h, generatedH);
		if (rc != GSK_OK) {
			.free(p);
		} else {
				my_session_handle = ()p;
		} 
		return rc;
	}
	public static int Curl_gsk_environment_close(Object my_env_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		int rc;
		if (!my_env_handle) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		if (!my_env_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_env_handle;
		Object generatedH = p.getH();
		rc = .gsk_environment_close(generatedH);
		if (rc == GSK_OK) {
			p.gsk_free_handle();
			my_env_handle = .UNRECOGNIZEDFUNCTIONNAME((Object)0);
		} 
		return rc;
	}
	public static int Curl_gsk_secure_soc_close(Object my_session_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		int rc;
		if (!my_session_handle) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		rc = .gsk_secure_soc_close(generatedH);
		if (rc == GSK_OK) {
			p.gsk_free_handle();
			my_session_handle = .UNRECOGNIZEDFUNCTIONNAME((Object)0);
		} 
		return rc;
	}
	public static int Curl_gsk_environment_init(Object my_env_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_env_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_env_handle;
		Object generatedH = p.getH();
		return .gsk_environment_init(generatedH);
	}
	public static int Curl_gsk_secure_soc_init(Object my_session_handle) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		return .gsk_secure_soc_init(generatedH);
	}
	public static int Curl_gsk_attribute_set_buffer_a(Object my_gsk_handle, Object bufID, Object buffer, int bufSize) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		byte ebcdicbuf;
		int rc;
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		if (!buffer) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		if (bufSize < 0) {
			return GSK_ATTRIBUTE_INVALID_LENGTH;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		if (!bufSize) {
			bufSize = .strlen(buffer);
		} 
		ebcdicbuf = .malloc(bufSize + 1);
		if (!ebcdicbuf) {
			return GSK_INSUFFICIENT_STORAGE;
		} 
		.QadrtConvertA2E(ebcdicbuf, buffer, bufSize, bufSize);
		ebcdicbuf[bufSize] = (byte)'\0';
		Object generatedH = p.getH();
		rc = .gsk_attribute_set_buffer(generatedH, bufID, ebcdicbuf, bufSize);
		.free(ebcdicbuf);
		return rc;
	}
	public static int Curl_gsk_attribute_set_enum(Object my_gsk_handle, Object enumID, Object enumValue) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_set_enum(generatedH, enumID, enumValue);
	}
	public static int Curl_gsk_attribute_set_numeric_value(Object my_gsk_handle, Object numID, int numValue) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_set_numeric_value(generatedH, numID, numValue);
	}
	public static int Curl_gsk_attribute_set_callback(Object my_gsk_handle, Object callBackID, Object callBackAreaPtr) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_set_callback(generatedH, callBackID, callBackAreaPtr);
	}
	public static int Curl_gsk_attribute_get_buffer_a(Object my_gsk_handle, Object bufID, Object buffer, int bufSize) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		int rc;
		byte mybuf;
		int mylen;
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		if (!buffer || !bufSize) {
			return GSK_OS400_ERROR_INVALID_POINTER;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		rc = .gsk_attribute_get_buffer(generatedH, bufID, mybuf, mylen);
		if (rc != GSK_OK) {
			return rc;
		} 
		rc = p.cachestring(mybuf, mylen, buffer);
		if (rc == GSK_OK) {
			bufSize = mylen;
		} 
		return rc;
	}
	public static int Curl_gsk_attribute_get_enum(Object my_gsk_handle, Object enumID, Object enumValue) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_get_enum(generatedH, enumID, enumValue);
	}
	public static int Curl_gsk_attribute_get_numeric_value(Object my_gsk_handle, Object numID, Integer numValue) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_get_numeric_value(generatedH, numID, numValue);
	}
	public static int Curl_gsk_attribute_get_cert_info(Object my_gsk_handle, Object certID, Object certDataElem, Integer certDataElementCount) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_gsk_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_gsk_handle;
		Object generatedH = p.getH();
		return .gsk_attribute_get_cert_info(generatedH, /* No need to convert code: text results are already in ASCII. */certID, certDataElem, certDataElementCount);
	}
	public static int Curl_gsk_secure_soc_misc(Object my_session_handle, Object miscID) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		return .gsk_secure_soc_misc(generatedH, miscID);
	}
	public static int Curl_gsk_secure_soc_read(Object my_session_handle, Byte readBuffer, int readBufSize, Integer amtRead) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		return .gsk_secure_soc_read(generatedH, readBuffer, readBufSize, amtRead);
	}
	public static int Curl_gsk_secure_soc_write(Object my_session_handle, Byte writeBuffer, int writeBufSize, Integer amtWritten) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		return .gsk_secure_soc_write(generatedH, writeBuffer, writeBufSize, amtWritten);
	}
	public static Object Curl_gsk_strerror_a(int gsk_return_value) {
		return ModernizedCProgram.set_thread_string(.LK_GSK_ERROR, .gsk_strerror(gsk_return_value));
	}
	public static int Curl_gsk_secure_soc_startInit(Object my_session_handle, int IOCompletionPort, Object communicationsArea) {
		Curl_gsk_descriptor p = new Curl_gsk_descriptor();
		if (!my_session_handle) {
			return GSK_INVALID_HANDLE;
		} 
		p = (Curl_gsk_descriptor)my_session_handle;
		Object generatedH = p.getH();
		return .gsk_secure_soc_startInit(generatedH, IOCompletionPort, communicationsArea/* USE_GSKIT */);
	}
	/* ASCII wrappers for the GSSAPI procedures. */
	public static int Curl_gss_convert_in_place(Object minor_status, Object buf) {
		int i = buf.getLength();
		if (i) {
			byte t = .malloc(i);
			if (!t) {
				ModernizedCProgram.gss_release_buffer(minor_status, buf);
				if (minor_status) {
					minor_status = 12;
				} 
				return -1;
			} 
			.QadrtConvertE2A(t, buf.getValue(), i, i);
			.memcpy(buf.getValue(), t, i);
			.free(t);
		} 
		return 0;
	}
	public static Object Curl_gss_import_name_a(Object minor_status, Object in_name, Object in_name_type, Object out_name) {
		int rc;
		int i;
		 in = new ();
		if (!in_name || !in_name.getValue() || !in_name.getLength()) {
			return ModernizedCProgram.gss_import_name(minor_status, in_name, in_name_type, out_name);
		} 
		.memcpy((byte)in, (byte)in_name, );
		i = in.getLength();
		in.setValue(.malloc(i + 1));
		if (!in.getValue()) {
			if (minor_status) {
				minor_status = 12;
			} 
			return GSS_S_FAILURE;
		} 
		.QadrtConvertA2E(in.getValue(), in_name.getValue(), i, i);
		((byte)in.getValue())[i] = (byte)'\0';
		rc = ModernizedCProgram.gss_import_name(minor_status, in, in_name_type, out_name);
		.free(in.getValue());
		return rc;
	}
	public static Object Curl_gss_display_status_a(Object minor_status, Object status_value, int status_type, Object mech_type, Object message_context, Object status_string) {
		int rc;
		rc = ModernizedCProgram.gss_display_status(minor_status, status_value, status_type, mech_type, message_context, status_string);
		if (rc != GSS_S_COMPLETE || !status_string || !status_string.getLength() || !status_string.getValue()) {
			return rc/* No way to allocate a buffer here, because it will be released by
			     gss_release_buffer(). The solution is to overwrite the EBCDIC buffer
			     with ASCII to return it. */;
		} 
		if (ModernizedCProgram.Curl_gss_convert_in_place(minor_status, status_string)) {
			return GSS_S_FAILURE;
		} 
		return rc;
	}
	public static Object Curl_gss_init_sec_context_a(Object minor_status, Object cred_handle, Object context_handle, Object target_name, Object mech_type, Object req_flags, Object time_req, Object input_chan_bindings, Object input_token, Object actual_mech_type, Object output_token, Object ret_flags, Object time_rec) {
		int rc;
		 in = new ();
		 inp = new ();
		in.setValue(((Object)0));
		inp = input_token;
		if (inp) {
			if (inp.getLength() && inp.getValue()) {
				int i = inp.getLength();
				in.setValue(.malloc(i + 1));
				if (!in.getValue()) {
					if (minor_status) {
						minor_status = 12;
					} 
					return GSS_S_FAILURE;
				} 
				.QadrtConvertA2E(in.getValue(), input_token.getValue(), i, i);
				((byte)in.getValue())[i] = (byte)'\0';
				in.setLength(i);
				inp = in;
			} 
		} 
		rc = ModernizedCProgram.gss_init_sec_context(minor_status, cred_handle, context_handle, target_name, mech_type, req_flags, time_req, input_chan_bindings, inp, actual_mech_type, output_token, ret_flags, time_rec);
		.free(in.getValue());
		if (rc != GSS_S_COMPLETE || !output_token || !output_token.getLength() || !output_token.getValue()) {
			return rc/* No way to allocate a buffer here, because it will be released by
			     gss_release_buffer(). The solution is to overwrite the EBCDIC buffer
			     with ASCII to return it. */;
		} 
		if (ModernizedCProgram.Curl_gss_convert_in_place(minor_status, output_token)) {
			return GSS_S_FAILURE;
		} 
		return rc;
	}
	public static Object Curl_gss_delete_sec_context_a(Object minor_status, Object context_handle, Object output_token) {
		int rc;
		rc = ModernizedCProgram.gss_delete_sec_context(minor_status, context_handle, output_token);
		if (rc != GSS_S_COMPLETE || !output_token || !output_token.getLength() || !output_token.getValue()) {
			return rc/* No way to allocate a buffer here, because it will be released by
			     gss_release_buffer(). The solution is to overwrite the EBCDIC buffer
			     with ASCII to return it. */;
		} 
		if (ModernizedCProgram.Curl_gss_convert_in_place(minor_status, output_token)) {
			return GSS_S_FAILURE;
		} 
		return rc/* HAVE_GSSAPI */;
	}
	/* ASCII wrappers for the LDAP procedures. */
	/* ASCII wrappers for the LDAP procedures. */
	public static Object Curl_ldap_init_a(Byte host, int port) {
		int i;
		byte ehost;
		Object result;
		if (!host) {
			return (Object).ldap_init(host, port);
		} 
		i = .strlen(host);
		ehost = .malloc(i + 1);
		if (!ehost) {
			return (Object)((Object)0);
		} 
		.QadrtConvertA2E(ehost, host, i, i);
		ehost[i] = (byte)'\0';
		result = (Object).ldap_init(ehost, port);
		.free(ehost);
		return result;
	}
	public static int Curl_ldap_simple_bind_s_a(Object ld, Byte dn, Byte passwd) {
		int i;
		byte edn;
		byte epasswd;
		edn = (byte)((Object)0);
		epasswd = (byte)((Object)0);
		if (dn) {
			i = .strlen(dn);
			edn = .malloc(i + 1);
			if (!edn) {
				return LDAP_NO_MEMORY;
			} 
			.QadrtConvertA2E(edn, dn, i, i);
			edn[i] = (byte)'\0';
		} 
		if (passwd) {
			i = .strlen(passwd);
			epasswd = .malloc(i + 1);
			if (!epasswd) {
				.free(edn);
				return LDAP_NO_MEMORY;
			} 
			.QadrtConvertA2E(epasswd, passwd, i, i);
			epasswd[i] = (byte)'\0';
		} 
		i = .ldap_simple_bind_s(ld, edn, epasswd);
		.free(epasswd);
		.free(edn);
		return i;
	}
	public static int Curl_ldap_search_s_a(Object ld, Byte base, int scope, Byte filter, Byte attrs, int attrsonly, Object res) {
		int i;
		int j;
		byte ebase;
		byte efilter;
		byte eattrs;
		int status;
		ebase = (byte)((Object)0);
		efilter = (byte)((Object)0);
		eattrs = (byte)((Object)0);
		status = LDAP_SUCCESS;
		if (base) {
			i = .strlen(base);
			ebase = .malloc(i + 1);
			if (!ebase) {
				status = LDAP_NO_MEMORY;
			} else {
					.QadrtConvertA2E(ebase, base, i, i);
					ebase[i] = (byte)'\0';
			} 
		} 
		if (filter && status == LDAP_SUCCESS) {
			i = .strlen(filter);
			efilter = .malloc(i + 1);
			if (!efilter) {
				status = LDAP_NO_MEMORY;
			} else {
					.QadrtConvertA2E(efilter, filter, i, i);
					efilter[i] = (byte)'\0';
			} 
		} 
		if (attrs && status == LDAP_SUCCESS) {
			for (i = 0; attrs[i++]; ) {
				;
			}
			eattrs = .calloc(i, );
			if (!eattrs) {
				status = LDAP_NO_MEMORY;
			} else {
					for (j = 0; attrs[j]; j++) {
						i = .strlen(attrs[j]);
						eattrs[j] = .malloc(i + 1);
						if (!eattrs[j]) {
							status = LDAP_NO_MEMORY;
							break;
						} 
						.QadrtConvertA2E(eattrs[j], attrs[j], i, i);
						eattrs[j][i] = (byte)'\0';
					}
			} 
		} 
		if (status == LDAP_SUCCESS) {
			status = .ldap_search_s(ld, ebase ? ebase : "", scope, efilter ? efilter : "(objectclass=*)", eattrs, attrsonly, res);
		} 
		if (eattrs) {
			for (j = 0; eattrs[j]; j++) {
				.free(eattrs[j]);
			}
			.free(eattrs);
		} 
		.free(efilter);
		.free(ebase);
		return status;
	}
	public static berval Curl_ldap_get_values_len_a(Object ld, Object entry, Object attr) {
		byte cp;
		berval result = new berval();
		cp = (byte)((Object)0);
		if (attr) {
			int i = .strlen(attr);
			cp = .malloc(i + 1);
			if (!cp) {
				.ldap_set_lderrno(ld, LDAP_NO_MEMORY, ((Object)0), .ldap_err2string(LDAP_NO_MEMORY));
				return (berval)((Object)0);
			} 
			.QadrtConvertA2E(cp, attr, i, i);
			cp[i] = (byte)'\0';
		} 
		result = .ldap_get_values_len(ld, entry, cp);
		.free(cp/* Result data are binary in nature, so they haven't been
		     converted to EBCDIC. Therefore do not convert. */);
		return result;
	}
	public static Byte Curl_ldap_err2string_a(int error) {
		return ModernizedCProgram.set_thread_string(.LK_LDAP_ERROR, .ldap_err2string(error));
	}
	public static Byte Curl_ldap_get_dn_a(Object ld, Object entry) {
		int i;
		byte cp;
		byte cp2;
		cp = .ldap_get_dn(ld, entry);
		if (!cp) {
			return cp;
		} 
		i = .strlen(cp);
		cp2 = .malloc(i + 1);
		if (!cp2) {
			return cp2;
		} 
		.QadrtConvertE2A(cp2, cp, i, i);
		cp2[i] = (byte)'\0'/* No way to allocate a buffer here, because it will be released by
		     ldap_memfree() and ldap_memalloc() does not exist. The solution is to
		     overwrite the EBCDIC buffer with ASCII to return it. */;
		.strcpy(cp, cp2);
		.free(cp2);
		return cp;
	}
	public static Byte Curl_ldap_first_attribute_a(Object ld, Object entry, Object berptr) {
		int i;
		byte cp;
		byte cp2;
		cp = .ldap_first_attribute(ld, entry, berptr);
		if (!cp) {
			return cp;
		} 
		i = .strlen(cp);
		cp2 = .malloc(i + 1);
		if (!cp2) {
			return cp2;
		} 
		.QadrtConvertE2A(cp2, cp, i, i);
		cp2[i] = (byte)'\0'/* No way to allocate a buffer here, because it will be released by
		     ldap_memfree() and ldap_memalloc() does not exist. The solution is to
		     overwrite the EBCDIC buffer with ASCII to return it. */;
		.strcpy(cp, cp2);
		.free(cp2);
		return cp;
	}
	public static Byte Curl_ldap_next_attribute_a(Object ld, Object entry, Object berptr) {
		int i;
		byte cp;
		byte cp2;
		cp = .ldap_next_attribute(ld, entry, berptr);
		if (!cp) {
			return cp;
		} 
		i = .strlen(cp);
		cp2 = .malloc(i + 1);
		if (!cp2) {
			return cp2;
		} 
		.QadrtConvertE2A(cp2, cp, i, i);
		cp2[i] = (byte)'\0'/* No way to allocate a buffer here, because it will be released by
		     ldap_memfree() and ldap_memalloc() does not exist. The solution is to
		     overwrite the EBCDIC buffer with ASCII to return it. */;
		.strcpy(cp, cp2);
		.free(cp2);
		return cp/* CURL_DISABLE_LDAP */;
	}
	public static int sockaddr2ebcdic(Object dstaddr, Object srcaddr, int srclen) {
		sockaddr_un srcu = new sockaddr_un();
		sockaddr_un dstu = new sockaddr_un();
		int i;
		int dstsize;
		if (!srcaddr || srclen < ((size_t)((Object)0).getSa_family()) +  || srclen > ) {
			(._errno()) = 22;
			return -1;
		} 
		.memcpy((byte)dstaddr, (byte)srcaddr, srclen);
		Object generatedSockaddr_un = dstu.getSockaddr_un();
		switch (srcaddr.getSa_family()) {
		case AF_UNIX:
				srcu = (sockaddr_un)srcaddr;
				dstu = (sockaddr_un)dstaddr;
				dstsize =  - ((size_t)((sockaddr_un)0).getSockaddr_un());
				srclen -= ((size_t)((sockaddr_un)0).getSockaddr_un());
				i = .QadrtConvertA2E(generatedSockaddr_un, generatedSockaddr_un, dstsize - 1, srclen);
				generatedSockaddr_un[i] = (byte)'\0';
				srclen = i + ((size_t)generatedSockaddr_un);
		}
		return srclen;
	}
	public static int sockaddr2ascii(Object dstaddr, int dstlen, Object srcaddr, int srclen) {
		sockaddr_un srcu = new sockaddr_un();
		sockaddr_un dstu = new sockaddr_un();
		int dstsize;
		if (!/* Convert a socket address to ASCII, if needed. */srclen) {
			return 0;
		} 
		if (srclen > dstlen) {
			srclen = dstlen;
		} 
		if (!srcaddr || srclen < 0) {
			(._errno()) = 22;
			return -1;
		} 
		.memcpy((byte)dstaddr, (byte)srcaddr, srclen);
		Object generatedSockaddr_un = dstu.getSockaddr_un();
		if (srclen >= ((size_t)((Object)0).getSs_family()) + ) {
			switch (srcaddr.getSs_family()) {
			case AF_UNIX:
					srcu = (sockaddr_un)srcaddr;
					dstu = (sockaddr_un)dstaddr;
					dstsize = dstlen - ((size_t)((sockaddr_un)0).getSockaddr_un());
					srclen -= ((size_t)((sockaddr_un)0).getSockaddr_un());
					if (dstsize > 0 && srclen > 0) {
						srclen = .QadrtConvertE2A(generatedSockaddr_un, generatedSockaddr_un, dstsize - 1, srclen);
						generatedSockaddr_un[srclen] = (byte)'\0';
					} 
					srclen += ((size_t)generatedSockaddr_un);
			}
		} 
		return srclen;
	}
	public static int Curl_os400_connect(int sd, Object destaddr, int addrlen) {
		int i;
		sockaddr_storage laddr = new sockaddr_storage();
		i = ModernizedCProgram.sockaddr2ebcdic(laddr, destaddr, addrlen);
		if (i < 0) {
			return -1;
		} 
		return .connect(sd, (Object)laddr, i);
	}
	public static int Curl_os400_bind(int sd, Object localaddr, int addrlen) {
		int i;
		sockaddr_storage laddr = new sockaddr_storage();
		i = ModernizedCProgram.sockaddr2ebcdic(laddr, localaddr, addrlen);
		if (i < 0) {
			return -1;
		} 
		return .bind(sd, (Object)laddr, i);
	}
	public static int Curl_os400_sendto(int sd, Byte buffer, int buflen, int flags, Object dstaddr, int addrlen) {
		int i;
		sockaddr_storage laddr = new sockaddr_storage();
		i = ModernizedCProgram.sockaddr2ebcdic(laddr, dstaddr, addrlen);
		if (i < 0) {
			return -1;
		} 
		return .sendto(sd, buffer, buflen, flags, (Object)laddr, i);
	}
	public static int Curl_os400_recvfrom(int sd, Byte buffer, int buflen, int flags, Object fromaddr, int addrlen) {
		int rcvlen;
		sockaddr_storage laddr = new sockaddr_storage();
		int laddrlen = ;
		if (!fromaddr || !addrlen || addrlen <= 0) {
			return .recvfrom(sd, buffer, buflen, flags, fromaddr, addrlen);
		} 
		laddr.setSockaddr_storage(/* To detect if unused. */AF_UNSPEC);
		rcvlen = .recvfrom(sd, buffer, buflen, flags, (Object)laddr, laddrlen);
		if (rcvlen < 0) {
			return rcvlen;
		} 
		Object generatedSockaddr_storage = laddr.getSockaddr_storage();
		if (generatedSockaddr_storage == AF_UNSPEC) {
			laddrlen = 0;
		} else {
				laddrlen = ModernizedCProgram.sockaddr2ascii(fromaddr, addrlen, laddr, laddrlen);
				if (laddrlen < 0) {
					return laddrlen;
				} 
		} 
		addrlen = laddrlen;
		return rcvlen;
	}
	public static int Curl_os400_getpeername(int sd, Object addr, int addrlen) {
		sockaddr_storage laddr = new sockaddr_storage();
		int laddrlen = ;
		int retcode = .getpeername(sd, (Object)laddr, laddrlen);
		if (!retcode) {
			laddrlen = ModernizedCProgram.sockaddr2ascii(addr, addrlen, laddr, laddrlen);
			if (laddrlen < 0) {
				return laddrlen;
			} 
			addrlen = laddrlen;
		} 
		return retcode;
	}
	public static int Curl_os400_getsockname(int sd, Object addr, int addrlen) {
		sockaddr_storage laddr = new sockaddr_storage();
		int laddrlen = ;
		int retcode = .getsockname(sd, (Object)laddr, laddrlen);
		if (!retcode) {
			laddrlen = ModernizedCProgram.sockaddr2ascii(addr, addrlen, laddr, laddrlen);
			if (laddrlen < 0) {
				return laddrlen;
			} 
			addrlen = laddrlen;
		} 
		return retcode;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static Object randit(Object data, int rnd) {
		int r;
		 result = CURLE_OK;
		int randseed;
		bool seeded = 0;
		result = .Curl_ssl_random(data, (byte)rnd, );
		if (result != CURLE_NOT_BUILT_IN/* only if there is no random function in the TLS backend do the non crypto
		       version, otherwise return result */) {
			return result/* ---- non-cryptographic version following ---- *//* if there's a random file to read a seed from, use it */;
		} 
		curltime curltime = new curltime();
		Object generatedCurltime = now.getCurltime();
		if (!/* read random data into the randseed variable */seeded) {
			curltime now = curltime.Curl_now();
			data.Curl_infof("WARNING: Using weak random seed\n");
			randseed += (int)generatedCurltime + (int)generatedCurltime;
			randseed = randseed * 1103515245 + 12345;
			randseed = randseed * 1103515245 + 12345;
			randseed = randseed * 1103515245 + 12345;
			seeded = 1;
		} 
		r = randseed = randseed * 1103515245 + /* Return an unsigned 32-bit pseudo-random number. */12345;
		rnd = (r << 16) | ((r >> 16) & -1024);
		return CURLE_OK/*
		 * Curl_rand() stores 'num' number of random unsigned integers in the buffer
		 * 'rndptr' points to.
		 *
		 * If libcurl is built without TLS support or with a TLS backend that lacks a
		 * proper random API (Gskit or mbedTLS), this function will use "weak" random.
		 *
		 * When built *with* TLS support and a backend that offers strong random, it
		 * will return error if it cannot provide strong random values.
		 *
		 * NOTE: 'data' may be passed in as NULL when coming from external API without
		 * easy handle!
		 *
		 */;
	}
	public static Object Curl_rand(Object data, byte rnd, Object num) {
		 result = CURLE_BAD_FUNCTION_ARGUMENT;
		do {
		} while (0);
		while (num) {
			int r;
			size_t left = num <  ? num : ;
			result = ModernizedCProgram.randit(data, r);
			if (result) {
				return result;
			} 
			while (left) {
				rnd++ = (byte)(r & -1024);
				r >>=  8;
				--num;
				--left;
			}
		}
		return result/*
		 * Curl_rand_hex() fills the 'rnd' buffer with a given 'num' size with random
		 * hexadecimal digits PLUS a zero terminating byte. It must be an odd number
		 * size.
		 */;
	}
	public static Object Curl_rand_hex(Object data, byte rnd, Object num) {
		 result = CURLE_BAD_FUNCTION_ARGUMENT;
		byte hex = "0123456789abcdef";
		byte[] buffer = new byte[128];
		byte bufp = buffer;
		do {
		} while (0/* This silences a scan-build warning about accessing this buffer with
		     uninitialized memory. */);
		if ((num / 2 >= ) || !(num & 1)) {
			return /* make sure it fits in the local buffer and that it is an odd number! */CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		/* save one for zero termination */num--;
		result = ModernizedCProgram.Curl_rand(data, buffer, num / 2);
		if (result) {
			return result;
		} 
		while (num/* clang-tidy warns on this line without this comment: */) {
			rnd++ = hex[(bufp & -1024) >> /* NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult) */4];
			rnd++ = hex[bufp & -1024];
			bufp++;
			num -= 2;
		}
		rnd = 0;
		return result;
	}
	public static int Curl_ssl_backend() {
		return (int)CURLSSLBACKEND_NONE/* "global" init done? *//**
		 * Global SSL init
		 *
		 * @retval 0 error initializing SSL
		 * @retval 1 SSL initialized successfully
		 */;
	}
	/* make sure this is only done once */
	/* never again */
	/* Global cleanup */
	/* only cleanup if we did a previous init */
	/* check for CURLOPT_SSLVERSION invalid parameter value */
	/* The pointers to the ssl backend data, which is opaque here, are swapped
	       rather than move the contents. */
	/* mark this is being ssl-enabled from here on. */
	/* SSL is connected */
	/* mark this is being ssl requested from here on. */
	/* SSL is connected */
	/*
	 * Lock shared SSL session data
	 */
	/*
	 * Unlock shared SSL session data
	 */
	/*
	 * Check if there's a session ID for the given connection in the cache, and if
	 * there's one suitable, it is provided. Returns TRUE when no entry matched.
	 */
	/* set 0 if unknown */
	/* session ID re-use is disabled */
	/* Lock if shared */
	/* not session ID means blank entry */
	/* yes, we have a session ID! */
	/* increase general age */
	/* set this as used in this age */
	/*
	 * Kill a single session ID entry in the cache.
	 */
	/* defensive check */
	/* free the ID the SSL-layer specific way */
	/* fresh */
	/*
	 * Delete the given session ID from the cache.
	 */
	/*
	 * Store session id in the session cache. The ID passed on to this function
	 * must already have been extracted and allocated the proper way for the SSL
	 * layer. Curl_XXXX_session_free() will be called to free/kill the session ID
	 * later on.
	 */
	/* the mother of all structs */
	/* zero if unused */
	/* bail out */
	/* bail out */
	/* Now we should add the session ID and the host name to the cache, (remove
	     the oldest if necessary) */
	/* If using shared SSL session, lock! */
	/* find an empty slot for us, or find the oldest */
	/* cache is full, we must "kill" the oldest entry! */
	/* use this slot */
	/* now init the session struct wisely */
	/* set current age */
	/* free it if there's one already present */
	/* clone host name */
	/* clone connect to host name */
	/* connect to port number */
	/* port number */
	/* let caller free sessionid */
	/* kill the session ID cache if not shared */
	/* the single-killer function handles empty table slots */
	/* free the cache data */
	/* write mode */
	/* read mode */
	/* USE_OPENSSL || USE_GNUTLS || USE_SCHANNEL || USE_SECTRANSP || USE_NSS */
	/* get back to ordinary socket usage */
	/* Selects an SSL crypto engine
	 */
	/* Selects the default SSL crypto engine
	 */
	/* Return list of OpenSSL crypto engine names. */
	/*
	 * This sets up a session ID cache to the specified size. Make sure this code
	 * is agnostic to what underlying SSL technology we use.
	 */
	/* this is just a precaution to prevent multiple inits */
	/* store the info in the SSL section */
	/* this is brand new */
	/*
	 * This function tries to determine connection status.
	 *
	 * Return codes:
	 *     1 means the connection is still in place
	 *     0 means the connection has been closed
	 *    -1 means the connection status is unknown
	 */
	/* free all individual lists used */
	/* free the actual array too */
	/* Free any previous certificate information structures */
	/* Allocate the required certificate information structures */
	/*
	 * 'value' is NOT a zero terminated string
	 */
	/* label:value\0 */
	/* sprintf the label and colon */
	/* memcpy the value (it might not be zero terminated) */
	/* zero terminate the output */
	/*
	 * This is a convenience function for push_certinfo_len that takes a zero
	 * terminated value.
	 */
	/*
	 * Public key pem to der conversion
	 */
	/* if no pem, exit. */
	/* Invalid if not at beginning AND not directly following \n */
	/* 26 is length of "-----BEGIN PUBLIC KEY-----" */
	/* Invalid if not directly following \n */
	/*
	   * Here we loop through the pem array one character at a time between the
	   * correct indices, and place each character that is not '\n' or '\r'
	   * into the stripped_pem array, which should represent the raw base64 string
	   */
	/* Place the null terminator in the correct place */
	/*
	 * Generic pinned public key check.
	 */
	/* if a path wasn't specified, don't pin */
	/* only do this if pinnedpubkey starts with "sha256//", length 8 */
	/* without sha256 support, this cannot match */
	/* compute sha256sum of public key */
	/* it starts with sha256//, copy so we can modify it */
	/* point begin_pos to the copy, and start extracting keys */
	/*
	       * if there is an end_pos, null terminate,
	       * otherwise it'll go to the end of the original string
	       */
	/* compare base64 sha256 digests, 8 is the length of "sha256//" */
	/*
	       * change back the null-terminator we changed earlier,
	       * and look for next begin
	       */
	/* Determine the file's size */
	/*
	     * if the size of our certificate is bigger than the file
	     * size then it can't match
	     */
	/*
	     * Allocate buffer for the pinned key
	     * With 1 additional byte for null terminator in case of PEM key
	     */
	/* Returns number of elements read, which should be 1 */
	/* If the sizes are the same, it can't be base64 encoded, must be der */
	/*
	     * Otherwise we will assume it's PEM and try to decode it
	     * after placing null terminator
	     */
	/* if it wasn't read successfully, exit */
	/*
	     * if the size of our certificate doesn't match the size of
	     * the decoded file, they can't be the same, otherwise compare
	     */
	/* input */
	/* output */
	/*
	 * Check whether the SSL backend supports the status_request extension.
	 */
	/*
	 * Check whether the SSL backend supports false start.
	 */
	/*
	 * Check whether the SSL backend supports setting TLS 1.3 cipher suites
	 */
	/*
	 * Default implementations for unsupported functions.
	 */
	/* info */
	/* supports nothing */
	/* something insanely large to be on the safe side */
	/* init */
	/* cleanup */
	/* version */
	/* check_cxn */
	/* shutdown */
	/* data_pending */
	/* random */
	/* cert_status_request */
	/* connect */
	/* connect_nonblocking */
	/* get_internals */
	/* close_one */
	/* close_all */
	/* session_free */
	/* set_engine */
	/* set_engine_default */
	/* engines_list */
	/* false_start */
	/* md5sum */
	/* sha256sum */
	/* Fall back to first available backend */
	/* USE_SSL */
	public static Object curl_global_sslset(Object id, Object name, Object avail) {
		(Object)id;
		(Object)name;
		(Object)avail;
		return CURLSSLSET_NO_BACKENDS/* !USE_SSL */;
	}
	public static void smb_format_message(connectdata conn, smb_header h, byte cmd, Object len) {
		 generatedProto = conn.getProto();
		Object generatedSmbc = generatedProto.getSmbc();
		smb_conn smbc = generatedSmbc;
		Curl_easy generatedData = conn.getData();
		Object generatedReq = generatedData.getReq();
		smb_request req = generatedReq.getProtop();
		int pid;
		.memset(h, 0, );
		h.setNbt_length(.htons((int)( -  + len)));
		Object generatedMagic = h.getMagic();
		.memcpy((byte)generatedMagic, "\xffSMB", 4);
		h.setCommand(cmd);
		h.setFlags(-1024 | -1024);
		h.setFlags2((-1024 | -1024));
		int generatedUid = smbc.getUid();
		h.setUid((generatedUid));
		int generatedTid = req.getTid();
		h.setTid((generatedTid));
		pid = ._getpid();
		h.setPid_high(((int)(pid >> 16)));
		h.setPid(((int)pid));
	}
	public static void get_posix_time(Object out, Object timestamp) {
		timestamp -= -1024;
		timestamp /= 10000000;
		if (timestamp > INT_MAX) {
			out = INT_MAX;
		}  else if (timestamp < INT_MIN) {
			out = INT_MIN;
		} else {
				out = (time_t)timestamp;
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NTLM details:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 * https://www.innovation.ch/java/ntlm.html
	 */
	/* Please keep the SSL backend-specific #if branches in this order:
	
	   1. USE_OPENSSL
	   2. USE_GNUTLS_NETTLE
	   3. USE_GNUTLS
	   4. USE_NSS
	   5. USE_MBEDTLS
	   6. USE_SECTRANSP
	   7. USE_OS400CRYPTO
	   8. USE_WIN32_CRYPTO
	
	   This ensures that:
	   - the same SSL branch gets activated throughout this source
	     file even if multiple backends are enabled at the same time.
	   - OpenSSL and NSS have higher priority than Windows Crypt, due
	     to issues with the latter supporting NTLM2Session responses
	     in NTLM type-3 messages.
	 */
	/* mih/cipher */
	/* The last 3 #include files should be in this order */
	/*
	* Turns a 56-bit key into being 64-bit wide.
	*/
	public static void extend_key_56_to_64(Object key_56, Byte key) {
		key[0] = key_56[0];
		key[1] = (byte)(((key_56[0] << 7) & -1024) | (key_56[1] >> 1));
		key[2] = (byte)(((key_56[1] << 6) & -1024) | (key_56[2] >> 2));
		key[3] = (byte)(((key_56[2] << 5) & -1024) | (key_56[3] >> 3));
		key[4] = (byte)(((key_56[3] << 4) & -1024) | (key_56[4] >> 4));
		key[5] = (byte)(((key_56[4] << 3) & -1024) | (key_56[5] >> 5));
		key[6] = (byte)(((key_56[5] << 2) & -1024) | (key_56[6] >> 6));
		key[7] = (byte)((key_56[6] << 1) & -1024/*
		 * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The
		 * key schedule ks is also set.
		 */);
	}
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Set the key */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Set the key */
	/*
	 * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.
	 */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Set the key */
	/*
	 * Expands a 56 bit key KEY_56 to 64 bit and encrypts 64 bit of data, using
	 * the expanded key.  The caller is responsible for giving 64 bit of valid
	 * data is IN and (at least) 64 bit large buffer as OUT.
	 */
	/* DES cipher in ECB mode */
	/* expanded 64 bit key */
	/* not used, required by NSS */
	/* use internal slot for DES encryption (requires NSS to be initialized) */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Import the key */
	/* Create the DES encryption context */
	/* no IV in ECB mode */
	/* Perform the encryption */
	/* outbuflen */
	/* inbuflen */
	/* all OK */
	/* cleanup */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	/* inbuflen */
	/* outbuflen */
	/* Setup the cipher control structure */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	public static  encrypt_des(Object in, Byte out, Object key_56) {
		HCRYPTPROV hprov = new HCRYPTPROV();
		HCRYPTKEY hkey = new HCRYPTKEY();
		Object blob;
		DWORD len = 8;
		if (!.CryptAcquireContextA(hprov, ((Object)0), ((Object)0), /* Acquire the crypto provider */1, -1024)) {
			return 0;
		} 
		.memset(blob, 0, );
		Object generatedHdr = blob.getHdr();
		generatedHdr.setBType(8);
		generatedHdr.setBVersion(2);
		generatedHdr.setAiKeyAlg((24576 | 1536 | 1));
		Object generatedKey = blob.getKey();
		blob.setLen();
		ModernizedCProgram.extend_key_56_to_64(key_56, generatedKey);
		ModernizedCProgram.Curl_des_set_odd_parity((byte)generatedKey, );
		if (!.CryptImportKey(hprov, (BYTE)blob, , 0, 0, /* Import the key */hkey)) {
			.CryptReleaseContext(hprov, 0);
			return 0;
		} 
		.memcpy(out, in, 8);
		.CryptEncrypt(hkey, 0, 0, 0, out, len, /* Perform the encryption */len);
		.CryptDestroyKey(hkey);
		.CryptReleaseContext(hprov, 0);
		return 1/* defined(USE_WIN32_CRYPTO) *//*
		  * takes a 21 byte array and treats it as 3 56-bit DES keys. The
		  * 8 byte plaintext is encrypted with each key and the resulting 24
		  * bytes are stored in the results array.
		  */;
	}
	public static void Curl_ntlm_core_lm_resp(Object keys, Object plaintext, Byte results) {
		ModernizedCProgram.encrypt_des(plaintext, results, keys);
		ModernizedCProgram.encrypt_des(plaintext, results + 8, keys + 7);
		ModernizedCProgram.encrypt_des(plaintext, results + 16, keys + 14);
	}
	public static void ascii_to_unicode_le(Byte dest, Object src, Object srclen) {
		size_t i = new size_t();
		for (i = 0; i < srclen; i++) {
			dest[2 * i] = (byte)src[i];
			dest[2 * i + 1] = (byte)'\0';
		}
	}
	public static void ascii_uppercase_to_unicode_le(Byte dest, Object src, Object srclen) {
		size_t i = new size_t();
		for (i = 0; i < srclen; i++) {
			dest[2 * i] = (byte)(ModernizedCProgram.Curl_raw_toupper(src[i]));
			dest[2 * i + 1] = (byte)'\0'/* USE_NTLM_V2 && !USE_WINDOWS_SSPI */;
		}
	}
	/* This returns the HMAC MD5 digest */
	public static Object hmac_md5(Object key, int keylen, Object data, int datalen, Byte output) {
		HMAC_context ctxt = ModernizedCProgram.Curl_HMAC_init(ModernizedCProgram.Curl_HMAC_MD5, key, keylen);
		if (!ctxt) {
			return CURLE_OUT_OF_MEMORY;
		} 
		ctxt.Curl_HMAC_update(data, /* Update the digest with the given challenge */datalen);
		ctxt.Curl_HMAC_final(/* Finalise the digest */output);
		return CURLE_OK/* This creates the NTLMv2 hash by using NTLM hash as the key and Unicode
		 * (uppercase UserName + Domain) as the data
		 */;
	}
	public static Object Curl_ntlm_core_mk_ntlmv2_hash(Object user, Object userlen, Object domain, Object domlen, Byte ntlmhash, Byte ntlmv2hash) {
		/* Unicode representation */size_t identity_len = new size_t();
		byte identity;
		 result = CURLE_OK;
		if ((userlen > -1024 / /* we do the length checks below separately to avoid integer overflow risk
		     on extreme data lengths */2) || (domlen > -1024 / 2) || ((userlen + domlen) > -1024 / 2)) {
			return CURLE_OUT_OF_MEMORY;
		} 
		identity_len = (userlen + domlen) * 2;
		identity = .Curl_cmalloc(identity_len);
		if (!identity) {
			return CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.ascii_uppercase_to_unicode_le(identity, user, userlen);
		ModernizedCProgram.ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);
		result = ModernizedCProgram.hmac_md5(ntlmhash, 16, identity, ModernizedCProgram.curlx_uztoui(identity_len), ntlmv2hash);
		.Curl_cfree(identity);
		return result/*
		 * Curl_ntlm_core_mk_ntlmv2_resp()
		 *
		 * This creates the NTLMv2 response as set in the ntlm type-3 message.
		 *
		 * Parameters:
		 *
		 * ntlmv2hash       [in] - The ntlmv2 hash (16 bytes)
		 * challenge_client [in] - The client nonce (8 bytes)
		 * ntlm             [in] - The ntlm data struct being used to read TargetInfo
		                           and Server challenge received in the type-2 message
		 * ntresp          [out] - The address where a pointer to newly allocated
		 *                         memory holding the NTLMv2 response.
		 * ntresp_len      [out] - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static Object Curl_ntlm_core_mk_lmv2_resp(Byte ntlmv2hash, Byte challenge_client, Byte challenge_server, Byte lmresp) {
		byte[] data = new byte[16];
		byte[] hmac_output = new byte[16];
		 result = CURLE_OK;
		.memcpy(data[0], challenge_server, 8);
		.memcpy(data[8], challenge_client, 8);
		result = ModernizedCProgram.hmac_md5(ntlmv2hash, 16, data[0], 16, hmac_output);
		if (result) {
			return result;
		} 
		.memcpy(lmresp, hmac_output, /* Concatenate the HMAC MD5 output  with the client nonce */16);
		.memcpy(lmresp + 16, challenge_client, 8);
		return result/* USE_NTLM_V2 && !USE_WINDOWS_SSPI *//* USE_NTRESPONSES *//* !USE_WINDOWS_SSPI || USE_WIN32_CRYPTO *//* USE_NTLM */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* nghttp2_session_callbacks_set_error_callback is present in nghttp2 1.9.0 or
	   later */
	/*
	 * Curl_http2_init_state() is called when the easy handle is created and
	 * allows for HTTP/2 specific init of state.
	 */
	/*
	 * Curl_http2_init_userset() is called when the easy handle is created and
	 * allows for HTTP/2 specific user-set fields.
	 */
	/* in a HTTP/2 connection we can basically always get a frame so we should
	     always be ready for one */
	/* we're still uploading or the HTTP/2 layer wants to send data */
	/*
	 * http2_stream_free() free HTTP2 stream related data
	 */
	/*
	 * Disconnects *a* connection used for HTTP/2. It might be an old one from the
	 * connection cache and not the "main" one. Don't touch the easy handle!
	 */
	/*
	 * The server may send us data at any point (e.g. PING frames). Therefore,
	 * we cannot assume that an HTTP/2 socket is dead just because it is readable.
	 *
	 * Instead, if it is readable, run Curl_connalive() to peek at the socket
	 * and distinguish between closed and data.
	 */
	/* timeout */
	/* socket is in an error state */
	/* readable with no error. could still be closed */
	/* This happens before we've sent off a request and the connection is
	         not in use by any other transfer, there shouldn't be any data here,
	         only "protocol frames" */
	/* if called "too early", this pointer isn't setup yet! */
	/* the read failed so let's say this is dead anyway */
	/* Perform an HTTP/2 PING */
	/* Successfully added a PING frame to the session. Need to flag this
	           so the frame is sent. */
	/* called from http_setup_conn */
	/* called from http_setup_conn */
	/*
	 * HTTP2 handler interface. This isn't added to the general list of protocols
	 * but will be used at run-time when the protocol is dynamically switched from
	 * HTTP to HTTP2.
	 */
	/* scheme */
	/* setup_connection */
	/* do_it */
	/* done */
	/* do_more */
	/* connect_it */
	/* connecting */
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	/* scheme */
	/* setup_connection */
	/* do_it */
	/* done */
	/* do_more */
	/* connect_it */
	/* connecting */
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	/*
	 * Store nghttp2 version info in this buffer, Prefix with a space.  Return
	 * total length written.
	 */
	/* HTTP/2 error code to name based on the Error Code Registry.
	https://tools.ietf.org/html/rfc7540#page-77
	nghttp2_error_code enums are identical.
	*/
	/* 0x0 */
	/* 0x1 */
	/* 0x2 */
	/* 0x3 */
	/* 0x4 */
	/* 0x5 */
	/* 0x6 */
	/* 0x7 */
	/* 0x8 */
	/* 0x9 */
	/* 0xA */
	/* 0xB */
	/* 0xC */
	/* 0xD */
	/*
	 * The implementation of nghttp2_send_callback type. Here we write |data| with
	 * size |length| to the network and return the number of bytes actually
	 * written. See the documentation of nghttp2_send_callback for the details.
	 */
	/* called before setup properly! */
	/* We pass a pointer to this struct in the push callback, but the contents of
	   the struct are hidden from the user. */
	/*
	 * push header access function. Only to be used from within the push callback
	 */
	/* Verify that we got a good easy handle in the push header struct, mostly to
	     detect rubbish input fast(er). */
	/*
	 * push header access function. Only to be used from within the push callback
	 */
	/* Verify that we got a good easy handle in the push header struct,
	     mostly to detect rubbish input fast(er). Also empty header name
	     is just a rubbish too. We have to allow ":" at the beginning of
	     the header, but header == ":" must be rejected. If we have ':' in
	     the middle of header, it could be matched in middle of the value,
	     this is because we do prefix match.*/
	/* sub-match, make sure that it is followed by a colon */
	/*
	 * This specific transfer on this connection has been "drained".
	 */
	/*
	 * Mark this transfer to get "drained".
	 */
	/* setup the request struct */
	/* clone the parent */
	/* FAIL HARD */
	/* ask the application */
	/* free the headers again */
	/* denied, kill off the new handle again */
	/* approved, add to the multi handle and immediately switch to PERFORM
	       state with the given connection !*/
	/*
	 * multi_connchanged() is called to tell that there is a connection in
	 * this multi handle that has changed state (multiplexing become possible, the
	 * number of allowed streams changed or similar), and a subsequent use of this
	 * multi handle should move CONNECT_PEND handles back to CONNECT to have them
	 * retry.
	 */
	/* stream ID zero is for connection-oriented stuff */
	/* only signal change if the value actually changed */
	/* If body started on this stream, then receiving DATA is illegal. */
	/* Only valid HEADERS after body started is trailer HEADERS.  We
	         buffer them in on_header callback. */
	/* nghttp2 guarantees that :status is received, and we store it to
	       stream->status_code. Fuzzing has proven this can still be reached
	       without status code having been set. */
	/* Only final status code signals the end of header */
	/* get the pointer from userp again since it was re-assigned above */
	/* if we receive data for another handle, wake that up */
	/* deny! */
	/* should never be a zero stream ID here */
	/* get the stream from the hash based on Stream ID */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	       internal error more than anything else! */
	/* if we receive data for another handle, wake that up */
	/* pause execution of nghttp2 if we received data for another handle
	     in order to process them first. */
	/* get the stream from the hash based on Stream ID, stream ID zero is for
	       connection-oriented stuff */
	/* We could get stream ID not in the hash.  For example, if we
	         decided to reject stream (e.g., PUSH_PROMISE). */
	/* remove the entry from the hash as the stream is now gone */
	/* cleared */
	/* Decode HTTP status code.  Returns -1 if no valid status code was
	   decoded. */
	/* frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PUSH_PROMISE */
	/* should never be a zero stream ID here */
	/* get the stream from the hash based on Stream ID */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	       internal error more than anything else! */
	/* Store received PUSH_PROMISE headers to be used when the subsequent
	     PUSH_PROMISE callback comes */
	/* pseudo headers are lower case */
	/* no memory */
	/* This is push is not for the same authority that was asked for in
	         * the URL. RFC 7540 section 8.2 says: "A client MUST treat a
	         * PUSH_PROMISE for which the server is not authoritative as a stream
	         * error of type PROTOCOL_ERROR."
	         */
	/* This is trailer fields. */
	/* 4 is for ": " and "\r\n". */
	/* nghttp2 guarantees :status is received first and only once, and
	       value is 3 digits status code, and decode_status_code always
	       succeeds. */
	/* the space character after the status code is mandatory */
	/* if we receive data for another handle, wake that up */
	/* nghttp2 guarantees that namelen > 0, and :status was already
	     received, and this is not pseudo-header field . */
	/* convert to a HTTP1-style header */
	/* if we receive data for another handle, wake that up */
	/* 0 is successful */
	/* get the stream from the hash based on Stream ID, stream ID zero is for
	       connection-oriented stuff */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	         internal error more than anything else! */
	/* there might be allocated resources done before this got the 'h2' pointer
	     setup */
	/* if they weren't used and then freed before */
	/* not HTTP/2 ? */
	/* RST_STREAM */
	/* -1 means unassigned and 0 means cleared */
	/*
	 * Initialize nghttp2 for a Curl connection
	 */
	/* most likely at least */
	/* nghttp2_send_callback */
	/* nghttp2_on_frame_recv_callback */
	/* nghttp2_on_data_chunk_recv_callback */
	/* nghttp2_on_stream_close_callback */
	/* nghttp2_on_begin_headers_callback */
	/* nghttp2_on_header_callback */
	/* The nghttp2 session is not yet setup, do it */
	/* most likely at least */
	/*
	 * Append headers to ask for a HTTP1.1 to HTTP2 upgrade.
	 */
	/* this returns number of bytes it wrote */
	/*
	 * Returns nonzero if current HTTP/2 session should be closed.
	 */
	/*
	 * h2_process_pending_input() processes pending input left in
	 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
	 * This function returns 0 if it succeeds, or -1 and error code will
	 * be assigned to *err.
	 */
	/* not an error per se, but should still close the connection */
	/*
	 * Called from transfer.c:done_sending when we stop uploading.
	 */
	/* make sure this is only attempted for HTTP/2 transfers */
	/* If the stream still thinks there's data left to upload. */
	/* DONE! */
	/* resume sending here to trigger the callback to get called again so
	         that it can signal EOF to nghttp2 */
	/* Reset to FALSE to prevent infinite loop in readwrite_data function. */
	/* don't use this anymore */
	/* trigger Curl_retry_request() later */
	/*
	 * h2_pri_spec() fills in the pri_spec struct, used by nghttp2 to send weight
	 * and dependency to the peer. It also stores the updated values in the state
	 * struct.
	 */
	/*
	 * h2_session_send() checks if there's been an update in the priority /
	 * dependency settings and if so it submits a PRIORITY frame with the updated
	 * info.
	 */
	/* send new weight and/or dependency */
	/* we always do HTTP2 on sockindex 0 */
	/* already marked for closure, return OK and we're done */
	/* Nullify here because we call nghttp2_session_send() and they
	     might refer to the old buffer. */
	/*
	   * At this point 'stream' is just in the Curl_easy the connection
	   * identifies as its owner at this time.
	   */
	/* If there is body data pending for this stream to return, do that */
	/* if we didn't get the same buffer this time, we must move the data to
	         the beginning */
	/* We have paused nghttp2, but we have no pause data (see
	         on_data_chunk_recv). */
	/* When NGHTTP2_ERR_PAUSE is returned from
	         data_source_read_callback, we might not process DATA frame
	         fully.  Calling nghttp2_session_mem_recv() again will
	         continue to process DATA frame, but if there is no incoming
	         frames, then we have to call it again with 0-length data.
	         Without this, on_stream_close callback will not be called,
	         and stream could be hanged. */
	/* If a stream paused nghttp2_session_mem_recv previously, and has
	       not processed all data, it still refers to the buffer in
	       nghttp2_session.  If we call nghttp2_session_mem_recv(), we may
	       overwrite that buffer.  To avoid that situation, just return
	       here with CURLE_AGAIN.  This could be busy loop since data in
	       socket is not read.  But it seems that usually streams are
	       notified with its drain property, and socket is read again
	       quickly. */
	/* closed overrides paused */
	/* remember where to store incoming data for this stream and how big the
	       buffer is */
	/* received when the stream was already closed! */
	/* Always send pending frames in nghttp2 session, because
	       nghttp2_session_mem_recv() may queue new frame */
	/* data for this stream is returned now, but this stream caused a pause
	         already so we need it called again asap */
	/* this stream is closed, trigger a another read ASAP to detect that */
	/* If this stream is closed, return 0 to signal the http routine to close
	     the connection */
	/* Index where :authority header field will appear in request header
	   field list. */
	/* USHRT_MAX is 65535 == 0xffff */
	/*
	 * Check header memory for the token "trailers".
	 * Parse the tokens as separated by comma and surrounded by whitespace.
	 * Returns TRUE if found or FALSE if not.
	 */
	/* skip to next token */
	/* Send header to server */
	/* Don't send header to server */
	/* Discard header, and replace it with "te: trailers" */
	/* Decides how to treat given header field. */
	/*
	   * Currently, we send request in this function, but this function is also
	   * used to send request body. It would be nice to add dedicated function for
	   * request.
	   */
	/* If stream_id != -1, we have dispatched request HEADERS, and now
	       are going to send or sending request body in DATA frame */
	/* Nullify here because we call nghttp2_session_send() and they
	       might refer to the old buffer. */
	/* we are sure that we have more data to send here.  Calling the
	         following API will make nghttp2_session_want_write() return
	         nonzero if remote window allows it, which then libcurl checks
	         socket is writable or not.  See http2_perform_getsock(). */
	/* Calculate number of headers contained in [mem, mem + len) */
	/* Here, we assume the curl http code generate *correct* HTTP header
	     field block */
	/* We counted additional 2 \r\n in the first and last line. We need 3
	     new headers: :method, :path and :scheme. Therefore we need one
	     more space. */
	/* Extract :method, :path from request line
	     We do line endings with CRLF so checking for CR is enough */
	/* Method does not contain spaces */
	/* Path may contain spaces so scan backwards */
	/* check for next CR, but only within the piece of data left in the given
	       buffer */
	/* header continuation lines are not supported */
	/* Lower case the header name for HTTP/2 */
	/* skip header fields prohibited by HTTP/2 specification. */
	/* :authority must come before non-pseudo header fields */
	/* Warn stream may be rejected if cumulative length of headers is too large.
	     It appears nghttp2 will not send a header frame larger than 64KB. */
	/* <64KB to account for some overhead */
	/* data sending without specifying the data amount up front */
	/* unknown, but not zero */
	/* this does not call h2_session_send() since there can not have been any
	   * priority upodate since the nghttp2_submit_request() call above */
	/* If whole HEADERS frame was sent off to the underlying socket, the nghttp2
	     library calls data_source_read_callback. But only it found that no data
	     available, so it deferred the DATA transmission. Which means that
	     nghttp2_session_want_write() returns 0 on http2_perform_getsock(), which
	     results that no writable socket check is performed. To workaround this,
	     we issue nghttp2_session_resume_data() here to bring back DATA
	     transmission from deferred state. */
	/* already done */
	/* at least potentially multiplexed */
	/* stream 1 is opened implicitly on upgrade */
	/* queue SETTINGS frame (again) */
	/* stream ID is unknown at this point */
	/* we are going to copy mem to httpc->inbuf.  This is required since
	     mem is part of buffer pointed by stream->mem, and callbacks
	     called by nghttp2_session_mem_recv() will write stream specific
	     data into stream->mem, overwriting data already there. */
	/* Try to send some frames since we may read SETTINGS already. */
	/* Only call this function for a transfer that already got a HTTP/2
	   CURLE_HTTP2_STREAM error! */
	/* !USE_NGHTTP2 */
	/* Satisfy external references even if http2 is not compiled in. */
	public static Byte curl_pushheader_bynum(Object h, Object num) {
		(Object)h;
		(Object)num;
		return ((Object)0);
	}
	public static Byte curl_pushheader_byname(Object h, Object header) {
		(Object)h;
		(Object)header;
		return ((Object)0/* USE_NGHTTP2 */);
	}
	/***********************************************************************
	 *
	 * imap_matchresp()
	 *
	 * Determines whether the untagged response is related to the specified
	 * command by checking if it is in format "* <command-name> ..." or
	 * "* <number> <command-name> ...".
	 *
	 * The "* " marker is assumed to have already been checked by the caller.
	 */
	public static  imap_matchresp(Object line, Object len, Object cmd) {
		byte end = line + len;
		size_t cmd_len = .strlen(cmd);
		line += /* Skip the untagged response marker */2;
		if (line < end && (ModernizedCProgram.Curl_isdigit((int)((byte)/* Do we have a number after the marker? */line/* Skip the number */)))) {
			do {
				line++;
			} while (line < end && (ModernizedCProgram.Curl_isdigit((int)((byte)line))));
			if (line == end || line != /* Do we have the space character? */(byte)' ') {
				return 0;
			} 
			line++;
		} 
		if (line + cmd_len <= end && ModernizedCProgram.Curl_strncasecompare(line, cmd, /* Does the command name match and is it followed by a space character or at
		     the end of line? */cmd_len) && (line[cmd_len] == (byte)' ' || line + cmd_len + 2 == end)) {
			return 1;
		} 
		return 0/***********************************************************************
		 *
		 * imap_endofresp()
		 *
		 * Checks whether the given string is a valid tagged, untagged or continuation
		 * response which can be processed by the response handler.
		 */;
	}
	public static void imap_get_message(Byte buffer, byte outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 2) {
			len -= /* Find the start of the message */2;
			for (message = buffer + 2; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change IMAP state!
		 */;
	}
	/*
	 * IMAP protocol handler.
	 */
	public static Byte imap_atom(Object str,  escape_only) {
		byte[] atom_specials = /* !checksrc! disable PARENBRACE 1 */"(){ %*]";
		byte p1;
		byte p2;
		size_t backsp_count = 0;
		size_t quote_count = 0;
		bool others_exists = 0;
		size_t newlen = 0;
		byte newstr = ((Object)0);
		if (!str) {
			return ((Object)0);
		} 
		p1 = /* Look for "atom-specials", counting the backslash and quote characters as
		     these will need escaping */str;
		while (p1) {
			if (p1 == (byte)'\\') {
				backsp_count++;
			}  else if (p1 == (byte)'"') {
				quote_count++;
			}  else if (!escape_only) {
				byte p3 = atom_specials;
				while (p3 && !others_exists) {
					if (p1 == p3) {
						others_exists = 1;
					} 
					p3++;
				}
			} 
			p1++;
		}
		if (!backsp_count && !quote_count && !/* Does the input contain any "atom-special" characters? */others_exists) {
			return .Curl_cstrdup(str);
		} 
		newlen = .strlen(str) + backsp_count + quote_count + (escape_only ? 0 : /* Calculate the new string length */2);
		newstr = (byte).Curl_cmalloc((newlen + 1) * /* Allocate the new string */);
		if (!newstr) {
			return ((Object)0);
		} 
		p2 = /* Surround the string in quotes if necessary */newstr;
		if (!escape_only) {
			newstr[0] = (byte)'"';
			newstr[newlen - 1] = (byte)'"';
			p2++;
		} 
		p1 = /* Copy the string, escaping backslash and quote characters along the way */str;
		while (p1) {
			if (p1 == (byte)'\\' || p1 == (byte)'"') {
				p2 = (byte)'\\';
				p2++;
			} 
			p2 = p1;
			p1++;
			p2++;
		}
		newstr[newlen] = /* Terminate the string */(byte)'\0';
		return newstr/***********************************************************************
		 *
		 * imap_is_bchar()
		 *
		 * Portable test of whether the specified char is a "bchar" as defined in the
		 * grammar of RFC-5092.
		 */;
	}
	public static  imap_is_bchar(byte ch) {
		switch (ch) {
		case (byte)'c':
		case (byte)'0':
		case (byte)'R':
		case (byte)'p':
		case (byte)'K':
		case (byte)'G':
		case (byte)'m':
		case (byte)'Y':
		case (byte)')':
		case (byte)'O':
		case (byte)'-':
		case (byte)'a':
		case (byte)'i':
		case (byte)'H':
		case (byte)'2':
		case (byte)'X':
		case (byte)'8':
		case (byte)'d':
		case (byte)'@':
		case (byte)'b':
		case (byte)'y':
		case (byte)'F':
		case (byte)'E':
		case (byte)'5':
		case /* bchar */(byte)'/':
		case (byte)'s':
		case (byte)'3':
		case (byte)'A':
		case (byte)'w':
		case (byte)'Z':
		case (byte)'r':
		case /* bchar -> achar -> uchar -> unreserved */(byte)'6':
		case (byte)'J':
		case /* bchar -> achar */(byte)'=':
		case /* bchar -> achar -> uchar -> sub-delims-sh */(byte)'*':
		case (byte)'\'':
		case (byte)'I':
		case (byte)'4':
		case (byte)'z':
		case (byte)'o':
		case (byte)'x':
		case (byte)'!':
		case (byte)':':
		case (byte)'T':
		case /* bchar -> achar -> uchar -> pct-encoded *//* HEXDIG chars are already included above */(byte)'%':
				return .bool_true;
		case (byte)'L':
		case (byte)'k':
		case (byte)'V':
		case (byte)'.':
		case (byte)'u':
		case (byte)'+':
		case (byte)'_':
		case (byte)'t':
		case (byte)'v':
		case (byte)'M':
		case (byte)'U':
		case (byte)'e':
		case (byte)'W':
		case (byte)'7':
		case (byte)'~':
		case (byte)'j':
		case (byte)'D':
		case (byte)'9':
		case (byte)'g':
		case (byte)'$':
		case (byte)'h':
		case (byte)'(':
		case (byte)',':
		case (byte)'P':
		case (byte)'Q':
		case (byte)'S':
		case (byte)'l':
		case (byte)'n':
		case (byte)'f':
		case (byte)'C':
		case (byte)'N':
		case (byte)'q':
		case (byte)'&':
		case (byte)'1':
		case (byte)'B':
		default:
				return .bool_false/***********************************************************************
				 *
				 * imap_parse_url_options()
				 *
				 * Parse the URL login options.
				 */;
		}
	}
	/*
	 * Copyright (C) 1996-2001  Internet Software Consortium.
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
	 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
	 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
	 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
	 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
	 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
	 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	 */
	/*
	 * Original code by Paul Vixie. "curlified" by Gisle Vanem.
	 */
	/*
	 * Format an IPv4 address, more or less like inet_ntoa().
	 *
	 * Returns `dst' (as a const)
	 * Note:
	 *  - uses no statics
	 *  - takes a unsigned char* not an in_addr as input
	 */
	public static Byte inet_ntop4(Object src, Byte dst, Object size) {
		byte[] tmp = new byte[];
		size_t len = new size_t();
		do {
		} while (0);
		tmp[0] = (byte)'\0';
		(Object)ModernizedCProgram.curl_msnprintf(tmp, , "%d.%d.%d.%d", ((int)((byte)src[0])) & -1024, ((int)((byte)src[1])) & -1024, ((int)((byte)src[2])) & -1024, ((int)((byte)src[3])) & -1024);
		len = .strlen(tmp);
		if (len == 0 || len >= size) {
			(._errno()) = 28;
			return (((Object)0));
		} 
		.strcpy(dst, tmp);
		return dst/*
		 * Convert IPv6 binary address into presentation (printable) format.
		 *//*
		   * Note that int32_t and int16_t need only be "at least" large enough
		   * to contain a value of the specified size.  On some systems, like
		   * Crays, there is no such thing as an integer variable with 16 bits.
		   * Keep this in mind if you think this function should have been coded
		   * to use pointer overlays.  All the world's not a VAX.
		   */;
	}
	/* Preprocess:
	   *  Copy the input (bytewise) array into a wordwise array.
	   *  Find the longest run of 0x00's in src[] for :: shorthanding.
	   */
	/* Format the result. */
	/* Are we inside the best run of 0x00's? */
	/* Are we following an initial run of 0x00s or any real hex?
	     */
	/* Is this address an encapsulated IPv4?
	     */
	/* Was it a trailing run of 0x00's?
	   */
	/* Check for overflow, copy, and we're done.
	   */
	/* ENABLE_IPV6 */
	/*
	 * Convert a network format address to presentation format.
	 *
	 * Returns pointer to presentation format address (`buf').
	 * Returns NULL on error and errno set with the specific
	 * error, EAFNOSUPPORT or ENOSPC.
	 *
	 * On Windows we store the error in the thread errno, not
	 * in the winsock error code. This is to avoid losing the
	 * actual last winsock error. So when this function returns
	 * NULL, check errno not SOCKERRNO.
	 */
	public static Byte Curl_inet_ntop(int af, Object src, Byte buf, Object size) {
		switch (af) {
		case 2:
				return ModernizedCProgram.inet_ntop4((byte)src, buf, size);
		default:
				(._errno()) = -1024;
				return ((Object)0/* HAVE_INET_NTOP */);
		}
	}
	public static void mydtor(Object p) {
		(Object)/* Data are statically allocated *//* unused */p;
		int ptr = (int)p;
		.free(ptr);
	}
	public static Byte data_to_hex(Byte data, Object len) {
		byte[] buf = new byte[256 * 3];
		size_t i = new size_t();
		byte optr = buf;
		byte iptr = data;
		if (len > 255) {
			len = 255;
		} 
		for (i = 0; i < len; i++) {
			if ((data[i] >= -1024) && (data[i] < -1024)) {
				optr++ = iptr++;
			} else {
					ModernizedCProgram.curl_msnprintf(optr, 4, "%%%02x", iptr++);
					optr += 3;
			} 
		}
		optr = /* in case no sprintf was used */0;
		return buf;
	}
	public static void logmsg(Object msg) {
		va_list ap = new va_list();
		byte[] buffer = new byte[2048 + 1];
		FILE logfp = new FILE();
		timeval tv = new timeval();
		time_t sec = new time_t();
		tm now = new tm();
		byte[] timebuf = new byte[20];
		time_t epoch_offset = new time_t();
		int known_offset;
		if (!ModernizedCProgram.serverlogfile) {
			(_iob[2]).curl_mfprintf("Error: serverlogfile not set\n");
			return ;
		} 
		timeval timeval = new timeval();
		tv = timeval.tvnow();
		long generatedTv_sec = tv.getTv_sec();
		if (!known_offset) {
			epoch_offset = .time(((Object)0)) - generatedTv_sec;
			known_offset = 1;
		} 
		sec = epoch_offset + generatedTv_sec;
		now = .localtime(/* not thread safe but we don't care */sec);
		Object generatedTm_hour = now.getTm_hour();
		Object generatedTm_min = now.getTm_min();
		Object generatedTm_sec = now.getTm_sec();
		long generatedTv_usec = tv.getTv_usec();
		ModernizedCProgram.curl_msnprintf(timebuf, , "%02d:%02d:%02d.%06ld", (int)generatedTm_hour, (int)generatedTm_min, (int)generatedTm_sec, (long)generatedTv_usec);
		.__builtin_va_start(ap, msg);
		ModernizedCProgram.curl_mvsnprintf(buffer, , msg, ap);
		.__builtin_va_end(ap);
		logfp = .fopen(ModernizedCProgram.serverlogfile, "ab");
		if (logfp) {
			logfp.curl_mfprintf("%s %s\n", timebuf, buffer);
			.fclose(logfp);
		} else {
				int error = (._errno());
				(_iob[2]).curl_mfprintf("fopen() failed with error: %d %s\n", error, .strerror(error));
				(_iob[2]).curl_mfprintf("Error opening file: %s\n", ModernizedCProgram.serverlogfile);
				(_iob[2]).curl_mfprintf("Msg not logged: %s %s\n", timebuf, buffer);
		} 
	}
	/* use instead of perror() on generic windows */
	public static void win32_perror(Object msg) {
		byte[] buf = new byte[512];
		DWORD err = ((int).WSAGetLastError());
		if (!.FormatMessageA(4096, ((Object)0), err, -1024, buf, , ((Object)0))) {
			ModernizedCProgram.curl_msnprintf(buf, , "Unknown error %lu (%#lx)", err, err);
		} 
		if (msg) {
			(_iob[2]).curl_mfprintf("%s: ", msg);
		} 
		(_iob[2]).curl_mfprintf("%s\n", buf/* WIN32 */);
	}
	public static void win32_init() {
		WORD wVersionRequested = new WORD();
		WSADATA wsaData = new WSADATA();
		int err;
		wVersionRequested = ((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(true))) << 8)));
		err = .WSAStartup(wVersionRequested, wsaData);
		if (err != 0) {
			ModernizedCProgram.win32_perror("Winsock init failed");
			ModernizedCProgram.logmsg("Error initialising winsock -- aborting");
			.exit(1);
		} 
		Object generatedWVersion = wsaData.getWVersion();
		if (((BYTE)(generatedWVersion)) != 2 || ((BYTE)(((WORD)(generatedWVersion) >> 8) & -1024)) != 2) {
			.WSACleanup();
			ModernizedCProgram.win32_perror("Winsock init failed");
			ModernizedCProgram.logmsg("No suitable winsock.dll found -- aborting");
			.exit(1);
		} 
	}
	public static void win32_cleanup() {
		.WSACleanup();
	}
	public static Byte test2file(long testno) {
		byte[] filename = new byte[256];
		ModernizedCProgram.curl_msnprintf(filename, , "%s/data/test%ld", ModernizedCProgram.path, testno);
		return filename/*
		 * Portable function used for waiting a specific amount of ms.
		 * Waiting indefinitely with this function is not allowed, a
		 * zero or negative timeout value will return immediately.
		 *
		 * Return values:
		 *   -1 = system call error, or invalid timeout value
		 *    0 = specified timeout has elapsed
		 */;
	}
	public static int wait_ms(int timeout_ms) {
		int r = 0;
		if (!timeout_ms) {
			return 0;
		} 
		if (timeout_ms < 0) {
			(._errno()) = 22;
			return -1;
		} 
		.Sleep(timeout_ms);
		/* HAVE_POLL_FINE */if (/* USE_WINSOCK */r) {
			r = -1;
		} 
		return r;
		timeval t = new timeval();
		t.setTv_sec(ms / 1000);
		long generatedTv_sec = t.getTv_sec();
		ms -= (int)generatedTv_sec * 1000;
		t.setTv_usec(ms * 1000);
		ModernizedCProgram.select_wrapper(0, ((Object)0), ((Object)0), ((Object)0), t);
	}
	public static int write_pidfile(Object filename) {
		FILE pidfile = new FILE();
		long pid;
		pid = (long).getpid();
		pidfile = .fopen(filename, "wb");
		if (!pidfile) {
			ModernizedCProgram.logmsg("Couldn't write pid file: %s %s", filename, .strerror((._errno())));
			return /* fail */0;
		} 
		pidfile.curl_mfprintf("%ld\n", pid);
		.fclose(pidfile);
		ModernizedCProgram.logmsg("Wrote pid %ld to %s", pid, filename);
		return /* success */1;
	}
	public static void set_advisor_read_lock(Object filename) {
		FILE lockfile = new FILE();
		int error = 0;
		int res;
		do {
			lockfile = .fopen(filename, "wb");
		} while ((lockfile == ((Object)0)) && ((error = (._errno())) == 4));
		if (lockfile == ((Object)0)) {
			ModernizedCProgram.logmsg("Error creating lock file %s error: %d %s", filename, error, .strerror(error));
			return ;
		} 
		do {
			res = .fclose(lockfile);
		} while (res && ((error = (._errno())) == 4));
		if (res) {
			ModernizedCProgram.logmsg("Error closing lock file %s error: %d %s", filename, error, .strerror(error));
		} 
	}
	public static void clear_advisor_read_lock(Object filename) {
		int error = 0;
		int res;
		/*
		  ** Log all removal failures. Even those due to file not existing.
		  ** This allows to detect if unexpectedly the file has already been
		  ** removed by a process different than the one that should do this.
		  */
		do {
			res = .unlink(filename);
		} while (res && ((error = (._errno())) == 4));
		if (res) {
			ModernizedCProgram.logmsg("Error removing lock file %s error: %d %s", filename, error, .strerror(error));
		} 
	}
	/* Portable, consistent toupper (remember EBCDIC). Do not use toupper() because
	   its behavior is altered by the current locale. */
	public static byte raw_toupper(byte in) {
		if (in >= (byte)'a' && in <= (byte)'z') {
			return (byte)((byte)'A' + in - (byte)'a');
		} 
		return in;
	}
	public static int Curl_strncasecompare(Object first, Object second, Object max) {
		while (first && second && max) {
			if (ModernizedCProgram.raw_toupper(first) != ModernizedCProgram.raw_toupper(second)) {
				break;
			} 
			max--;
			first++;
			second++;
		}
		if (0 == max) {
			return /* they are equal this far */1;
		} 
		return ModernizedCProgram.raw_toupper(first) == ModernizedCProgram.raw_toupper(second);
		while (first && second && max) {
			if (ModernizedCProgram.Curl_raw_toupper(first) != ModernizedCProgram.Curl_raw_toupper(second)) {
				break;
			} 
			max--;
			first++;
			second++;
		}
		if (0 == max) {
			return /* they are equal this far */1;
		} 
		return ModernizedCProgram.Curl_raw_toupper(first) == ModernizedCProgram.Curl_raw_toupper(second/* Copy an upper case version of the string from src to dest.  The
		 * strings may overlap.  No more than n characters of the string are copied
		 * (including any NUL) and the destination string will NOT be
		 * NUL-terminated if that limit is reached.
		 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Portable, consistent toupper (remember EBCDIC). Do not use toupper() because
	   its behavior is altered by the current locale. */
	public static byte Curl_raw_toupper(byte in) {
		if (in >= (byte)'a' && in <= (byte)'z') {
			return (byte)((byte)'A' + in - (byte)'a');
		} 
		return in;
	}
	/* Portable, consistent tolower (remember EBCDIC). Do not use tolower() because
	   its behavior is altered by the current locale. */
	public static byte Curl_raw_tolower(byte in) {
		if (in >= (byte)'A' && in <= (byte)'Z') {
			return (byte)((byte)'a' + in - (byte)'A');
		} 
		return in/*
		 * Curl_strcasecompare() is for doing "raw" case insensitive strings. This is
		 * meant to be locale independent and only compare strings we know are safe
		 * for this.  See
		 * https://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for some
		 * further explanation to why this function is necessary.
		 *
		 * The function is capable of comparing a-z case insensitively even for
		 * non-ascii.
		 *
		 * @unittest: 1301
		 */;
	}
	public static int Curl_strcasecompare(Object first, Object second) {
		while (first && second) {
			if (ModernizedCProgram.Curl_raw_toupper(first) != ModernizedCProgram.Curl_raw_toupper(second/* get out of the loop as soon as they don't match */)) {
				break;
			} 
			first++;
			second/* we do the comparison here (possibly again), just to make sure that if the
			     loop above is skipped because one of the strings reached zero, we must not
			     return this as a successful match */++;
		}
		return (ModernizedCProgram.Curl_raw_toupper(first) == ModernizedCProgram.Curl_raw_toupper(second));
	}
	public static int Curl_safe_strcasecompare(Object first, Object second) {
		if (first && second) {
			return ModernizedCProgram.Curl_strcasecompare(first, /* both pointers point to something then compare them */second);
		} 
		return (((Object)0) == first && ((Object)0) == /* if both pointers are NULL then treat them as equal */second/*
		 * @unittest: 1301
		 */);
	}
	public static void Curl_strntoupper(byte dest, Object src, Object n) {
		if (n < 1) {
			return ;
		} 
		do {
			dest++ = ModernizedCProgram.Curl_raw_toupper(src);
		} while (src++ && --n/* Copy a lower case version of the string from src to dest.  The
		 * strings may overlap.  No more than n characters of the string are copied
		 * (including any NUL) and the destination string will NOT be
		 * NUL-terminated if that limit is reached.
		 */);
	}
	public static void Curl_strntolower(byte dest, Object src, Object n) {
		if (n < 1) {
			return ;
		} 
		do {
			dest++ = ModernizedCProgram.Curl_raw_tolower(src);
		} while (src++ && --n);
	}
	/* --- public functions --- */
	public static int curl_strequal(Object first, Object second) {
		return ModernizedCProgram.Curl_strcasecompare(first, second);
	}
	public static int curl_strnequal(Object first, Object second, Object max) {
		return ModernizedCProgram.Curl_strncasecompare(first, second, max);
	}
	public static int Curl_inet_pton(int af, Object src, Object dst) {
		switch (af) {
		case 2:
				return (ModernizedCProgram.inet_pton4(src, (byte)dst));
		default:
				(._errno()) = -1024;
				return (true/* NOTREACHED *//* int
				 * inet_pton4(src, dst)
				 *      like inet_aton() but without all the hexadecimal and shorthand.
				 * return:
				 *      1 if `src' is a valid dotted quad, else 0.
				 * notice:
				 *      does not touch `dst' unless it's returning 1.
				 * author:
				 *      Paul Vixie, 1996.
				 */);
		}
	}
	/* This is from the BIND 4.9.4 release, modified to compile by itself */
	/* Copyright (c) 1996 by Internet Software Consortium.
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
	 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
	 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
	 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
	 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
	 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
	 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
	 * SOFTWARE.
	 */
	/*
	 * WARNING: Don't even consider trying to compile this on a system where
	 * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
	 */
	public static int inet_pton4(Object src, Byte dst) {
		byte[] digits = "0123456789";
		int saw_digit;
		int octets;
		int ch;
		byte[] tmp = new byte[4];
		byte tp;
		saw_digit = 0;
		octets = 0;
		tp = tmp;
		tp = 0;
		while ((ch = src++) != (byte)'\0') {
			byte pch;
			pch = .strchr(digits, ch);
			if (pch) {
				int val = tp * 10 + (int)(pch - digits);
				if (saw_digit && tp == 0) {
					return (false);
				} 
				if (val > 255) {
					return (false);
				} 
				tp = (byte)val;
				if (!saw_digit) {
					if (++octets > 4) {
						return (false);
					} 
					saw_digit = 1;
				} 
			}  else if (ch == (byte)'.' && saw_digit) {
				if (octets == 4) {
					return (false);
				} 
				++tp = 0;
				saw_digit = 0;
			} else {
					return (false);
			} 
		}
		if (octets < 4) {
			return (false);
		} 
		.memcpy(dst, tmp, 4);
		return (true/* int
		 * inet_pton6(src, dst)
		 *      convert presentation level address to network order binary form.
		 * return:
		 *      1 if `src' is a valid [RFC1884 2.2] address, else 0.
		 * notice:
		 *      (1) does not touch `dst' unless it's returning 1.
		 *      (2) :: in a full address is silently ignored.
		 * credit:
		 *      inspired by Mark Andrews.
		 * author:
		 *      Paul Vixie, 1996.
		 */);
	}
	/* int
	 * inet_pton(af, src, dst)
	 *      convert from presentation format (which usually means ASCII printable)
	 *      to network format (which is usually some kind of binary format).
	 * return:
	 *      1 if the address was valid for the specified address family
	 *      0 if the address wasn't valid (`dst' is untouched in this case)
	 *      -1 if some other error occurred (`dst' is untouched in this case, too)
	 * notice:
	 *      On Windows we store the error in the thread errno, not
	 *      in the winsock error code. This is to avoid losing the
	 *      actual last winsock error. So when this function returns
	 *      -1, check errno not SOCKERRNO.
	 * author:
	 *      Paul Vixie, 1996.
	 */
	/* Leading :: requires some special handling. */
	/* '\0' was seen by inet_pton4(). */
	/*
	     * Since some memmove()'s erroneously fail to handle
	     * overlapping regions, we'll do the shift by hand.
	     */
	/* ENABLE_IPV6 */
	/* HAVE_INET_PTON */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* wraps curl_easy_setopt() with typechecking */
	/* To add a new kind of warning, add an
	 *   if(curlcheck_sometype_option(_curl_opt))
	 *     if(!curlcheck_sometype(value))
	 *       _curl_easy_setopt_err_sometype();
	 * block and define curlcheck_sometype_option, curlcheck_sometype and
	 * _curl_easy_setopt_err_sometype below
	 *
	 * NOTE: We use two nested 'if' statements here instead of the && operator, in
	 *       order to work around gcc bug #32061.  It affects only gcc 4.3.x/4.4.x
	 *       when compiling with -Wlogical-op.
	 *
	 * To add an option that uses the same type as an existing option, you'll just
	 * need to extend the appropriate _curl_*_option macro
	 */
	/* wraps curl_easy_getinfo() with typechecking */
	/*
	 * For now, just make sure that the functions are called with three arguments
	 */
	public static void _curl_easy_setopt_err_long() {
		/* the actual warnings, triggered by calling the _curl_easy_setopt_err*
		 * functions *//* To define a new warning, use _CURL_WARNING(identifier, "message") *//* the actual warnings, triggered by calling the _curl_easy_setopt_err*
		 * functions *//* To define a new warning, use _CURL_WARNING(identifier, "message") */;
	}
	public static void _curl_easy_setopt_err_curl_off_t() {
		;
	}
	public static void _curl_easy_setopt_err_string() {
		;
	}
	public static void _curl_easy_setopt_err_write_callback() {
		;
	}
	public static void _curl_easy_setopt_err_resolver_start_callback() {
		;
	}
	public static void _curl_easy_setopt_err_read_cb() {
		;
	}
	public static void _curl_easy_setopt_err_ioctl_cb() {
		;
	}
	public static void _curl_easy_setopt_err_sockopt_cb() {
		;
	}
	public static void _curl_easy_setopt_err_opensocket_cb() {
		;
	}
	public static void _curl_easy_setopt_err_progress_cb() {
		;
	}
	public static void _curl_easy_setopt_err_debug_cb() {
		;
	}
	public static void _curl_easy_setopt_err_ssl_ctx_cb() {
		;
	}
	public static void _curl_easy_setopt_err_conv_cb() {
		;
	}
	public static void _curl_easy_setopt_err_seek_cb() {
		;
	}
	public static void _curl_easy_setopt_err_cb_data() {
		;
	}
	public static void _curl_easy_setopt_err_error_buffer() {
		;
	}
	public static void _curl_easy_setopt_err_FILE() {
		;
	}
	public static void _curl_easy_setopt_err_postfields() {
		;
	}
	public static void _curl_easy_setopt_err_curl_httpost() {
		;
	}
	public static void _curl_easy_setopt_err_curl_mimepost() {
		;
	}
	public static void _curl_easy_setopt_err_curl_slist() {
		;
	}
	public static void _curl_easy_setopt_err_CURLSH() {
		;
	}
	public static void _curl_easy_getinfo_err_string() {
		;
	}
	public static void _curl_easy_getinfo_err_long() {
		;
	}
	public static void _curl_easy_getinfo_err_double() {
		;
	}
	public static void _curl_easy_getinfo_err_curl_slist() {
		;
	}
	public static void _curl_easy_getinfo_err_curl_tlssesssioninfo() {
		;
	}
	public static void _curl_easy_getinfo_err_curl_certinfo() {
		;
	}
	public static void _curl_easy_getinfo_err_curl_socket() {
		;
	}
	public static void _curl_easy_getinfo_err_curl_off_t() {
		/* groups of curl_easy_setops options that take the same type of argument *//* To add a new option to one of the groups, just add
		 *   (option) == CURLOPT_SOMETHING
		 * to the or-expression. If the option takes a long or curl_off_t, you don't
		 * have to do anything
		 *//* evaluates to true if option takes a long argument */;/* groups of curl_easy_setops options that take the same type of argument *//* To add a new option to one of the groups, just add
		 *   (option) == CURLOPT_SOMETHING
		 * to the or-expression. If the option takes a long or curl_off_t, you don't
		 * have to do anything
		 *//* evaluates to true if option takes a long argument */
	}
	/* evaluates to true if option takes a char* argument */
	/* evaluates to true if option takes a curl_write_callback argument */
	/* evaluates to true if option takes a curl_conv_callback argument */
	/* evaluates to true if option takes a data argument to pass to a callback */
	/* evaluates to true if option takes a POST data argument (void* or char*) */
	/* evaluates to true if option takes a struct curl_slist * argument */
	/* groups of curl_easy_getinfo infos that take the same type of argument */
	/* evaluates to true if info expects a pointer to char * argument */
	/* evaluates to true if info expects a pointer to long argument */
	/* evaluates to true if info expects a pointer to double argument */
	/* true if info expects a pointer to struct curl_slist * argument */
	/* true if info expects a pointer to struct curl_tlssessioninfo * argument */
	/* true if info expects a pointer to struct curl_certinfo * argument */
	/* true if info expects a pointer to struct curl_socket_t argument */
	/* true if info expects a pointer to curl_off_t argument */
	/* typecheck helpers -- check whether given expression has requested type*/
	/* For pointers, you can use the curlcheck_ptr/curlcheck_arr macros,
	 * otherwise define a new macro. Search for __builtin_types_compatible_p
	 * in the GCC manual.
	 * NOTE: these macros MUST NOT EVALUATE their arguments! The argument is
	 * the actual expression passed to the curl_easy_setopt macro. This
	 * means that you can only apply the sizeof and __typeof__ operators, no
	 * == or whatsoever.
	 */
	/* XXX: should evaluate to true if expr is a pointer */
	/* evaluates to true if expr is NULL */
	/* XXX: must not evaluate expr, so this check is not accurate */
	/* evaluates to true if expr is type*, const type* or NULL */
	/* evaluates to true if expr is one of type[], type*, NULL or const type* */
	/* evaluates to true if expr is a string */
	/* evaluates to true if expr is a long (no matter the signedness)
	 * XXX: for now, int is also accepted (and therefore short and char, which
	 * are promoted to int when passed to a variadic function) */
	/* evaluates to true if expr is of type curl_off_t */
	/* evaluates to true if expr is abuffer suitable for CURLOPT_ERRORBUFFER */
	/* XXX: also check size of an char[] array? */
	/* evaluates to true if expr is of type (const) void* or (const) FILE* */
	/* be less strict */
	/* evaluates to true if expr is of type FILE* */
	/* evaluates to true if expr can be passed as POST data (void* or char*) */
	/* helper: __builtin_types_compatible_p distinguishes between functions and
	 * function pointers, hide it */
	/* evaluates to true if expr is of type curl_resolver_start_callback */
	/* evaluates to true if expr is of type curl_read_callback or "similar" */
	/* evaluates to true if expr is of type curl_write_callback or "similar" */
	/* evaluates to true if expr is of type curl_ioctl_callback or "similar" */
	/* evaluates to true if expr is of type curl_sockopt_callback or "similar" */
	/* evaluates to true if expr is of type curl_opensocket_callback or
	   "similar" */
	/* evaluates to true if expr is of type curl_progress_callback or "similar" */
	/* evaluates to true if expr is of type curl_debug_callback or "similar" */
	/* evaluates to true if expr is of type curl_ssl_ctx_callback or "similar" */
	/* this is getting even messier... */
	/* hack: if we included OpenSSL's ssl.h, we know about SSL_CTX
	 * this will of course break if we're included before OpenSSL headers...
	 */
	/* evaluates to true if expr is of type curl_conv_callback or "similar" */
	/* evaluates to true if expr is of type curl_seek_callback or "similar" */
	/* CURLINC_TYPECHECK_GCC_H */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2014, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static void set_binmode() {
		Object generated_file = (stream).get_file();
		(Object).setmode((generated_file), -1024/* HAVE_SETMODE */);
	}
	/*
	 * vmsfopenread
	 *
	 * For upload to work as expected on VMS, different optional
	 * parameters must be added to the fopen command based on
	 * record format of the file.
	 *
	 */
	/* VMS */
	/*
	  (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004
	  Edition)
	
	  The basename() function shall take the pathname pointed to by path and
	  return a pointer to the final component of the pathname, deleting any
	  trailing '/' characters.
	
	  If the string pointed to by path consists entirely of the '/' character,
	  basename() shall return a pointer to the string "/". If the string pointed
	  to by path is exactly "//", it is implementation-defined whether '/' or "//"
	  is returned.
	
	  If path is a null pointer or points to an empty string, basename() shall
	  return a pointer to the string ".".
	
	  The basename() function may modify the string pointed to by path, and may
	  return a pointer to static storage that may then be overwritten by a
	  subsequent call to basename().
	
	  The basename() function need not be reentrant. A function that is not
	  required to be reentrant is not required to be thread-safe.
	
	*/
	/*
	  (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004
	  Edition)
	
	  The basename() function shall take the pathname pointed to by path and
	  return a pointer to the final component of the pathname, deleting any
	  trailing '/' characters.
	
	  If the string pointed to by path consists entirely of the '/' character,
	  basename() shall return a pointer to the string "/". If the string pointed
	  to by path is exactly "//", it is implementation-defined whether '/' or "//"
	  is returned.
	
	  If path is a null pointer or points to an empty string, basename() shall
	  return a pointer to the string ".".
	
	  The basename() function may modify the string pointed to by path, and may
	  return a pointer to static storage that may then be overwritten by a
	  subsequent call to basename().
	
	  The basename() function need not be reentrant. A function that is not
	  required to be reentrant is not required to be thread-safe.
	
	*/
	public static Byte Curl_basename(Byte path) {
		/* Ignore all the details above for now and make a quick and simple
		     implementation here */byte s1;
		byte s2;
		s1 = .strrchr(path, (byte)'/');
		s2 = .strrchr(path, (byte)'\\');
		if (s1 && s2) {
			path = (s1 > s2 ? s1 : s2) + 1;
		}  else if (s1) {
			path = s1 + 1;
		}  else if (s2) {
			path = s2 + 1;
		} 
		return path;
	}
	/* Set readback state. */
	public static void mimesetstate(mimestate tok, Object ptr) {
		this.setState(mimestate.tok);
		this.setPtr(ptr);
		this.setOffset(0);
	}
	/* Escape header string into allocated memory. */
	public static Byte escape_string(Object src) {
		size_t bytecount = 0;
		size_t i = new size_t();
		byte dst;
		for (i = 0; src[i]; i++) {
			if (src[i] == (byte)'"' || src[i] == (byte)'\\') {
				bytecount++;
			} 
		}
		bytecount += i;
		dst = .Curl_cmalloc(bytecount + 1);
		if (!dst) {
			return ((Object)0);
		} 
		for (i = 0; src; src++) {
			if (src == (byte)'"' || src == (byte)'\\') {
				dst[i++] = (byte)'\\';
			} 
			dst[i++] = src;
		}
		dst[i] = (byte)'\0';
		return dst;
	}
	public static Byte strippath(Object fullfile) {
		byte filename;
		byte base;
		filename = .Curl_cstrdup(/* duplicate since basename() may ruin the
		                                  buffer it works on */fullfile);
		if (!filename) {
			return ((Object)0);
		} 
		base = .Curl_cstrdup(ModernizedCProgram.Curl_basename((filename)));
		.Curl_cfree(/* free temporary buffer */filename);
		return /* returns an allocated string or NULL ! */base;
	}
	/* Initialize data encoder state. */
	public static void cleanup_encoder_state() {
		this.setPos(0);
		this.setBufbeg(0);
		this.setBufend(0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* Encoders. */
	/* Dummy encoder. This is used for 8bit and binary content encodings. */
	public static Object encoder_nop_read(Byte buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		Object generatedBufend = st.getBufend();
		Object generatedBufbeg = st.getBufbeg();
		size_t insize = generatedBufend - generatedBufbeg;
		(Object)ateof;
		if (size > insize) {
			size = insize;
		} 
		Object generatedBuf = st.getBuf();
		if (size) {
			.memcpy(buffer, generatedBuf, size);
		} 
		generatedBufbeg += size;
		return size;
	}
	public static Object encoder_nop_size(Object part) {
		return part.getDatasize();
	}
	/* 7bit encoder: the encoder is just a data validity check. */
	public static Object encoder_7bit_read(byte buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		Object generatedBufend = st.getBufend();
		Object generatedBufbeg = st.getBufbeg();
		size_t cursize = generatedBufend - generatedBufbeg;
		(Object)ateof;
		if (size > cursize) {
			size = cursize;
		} 
		Object generatedBuf = st.getBuf();
		for (cursize = 0; cursize < size; cursize++) {
			buffer = generatedBuf[generatedBufbeg];
			if (buffer++ & -1024) {
				return cursize ? cursize : ((size_t)-1);
			} 
			generatedBufbeg++;
		}
		return cursize;
	}
	/* Base64 content encoder. */
	public static Object encoder_base64_read(Byte buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		size_t cursize = 0;
		int i;
		byte ptr = buffer;
		Object generatedBufbeg = st.getBufbeg();
		Object generatedBufend = st.getBufend();
		Object generatedPos = st.getPos();
		Object generatedBuf = st.getBuf();
		while (generatedBufbeg < generatedBufend) {
			if (generatedPos > 76 - /* Line full ? */4) {
				if (size < /* Yes, we need 2 characters for CRLF. */2) {
					break;
				} 
				ptr++ = (byte)'\r';
				ptr++ = (byte)'\n';
				st.setPos(0);
				cursize += 2;
				size -= 2;
			} 
			if (size < 4 || generatedBufend - generatedBufbeg < /* Be sure there is enough space and input data for a base64 group. */3) {
				break;
			} 
			i = generatedBuf[generatedBufbeg++] & /* Encode three bytes as four characters. */-1024;
			i = (i << 8) | (generatedBuf[generatedBufbeg++] & -1024);
			i = (i << 8) | (generatedBuf[generatedBufbeg++] & -1024);
			ptr++ = ModernizedCProgram.base64[(i >> 18) & -1024];
			ptr++ = ModernizedCProgram.base64[(i >> 12) & -1024];
			ptr++ = ModernizedCProgram.base64[(i >> 6) & -1024];
			ptr++ = ModernizedCProgram.base64[i & -1024];
			cursize += 4;
			generatedPos += 4;
			size -= 4;
		}
		if (ateof && size >= /* If at eof, we have to flush the buffered data. */4) {
			ptr[2] = ptr[3] = /* Buffered data size can only be 0, 1 or 2. */(byte)'=';
			i = 0;
			switch (generatedBufend - generatedBufbeg) {
			case /* FALLTHROUGH */1:
					i |=  (generatedBuf[generatedBufbeg] & -1024) << 16;
					ptr[0] = ModernizedCProgram.base64[(i >> 18) & -1024];
					ptr[1] = ModernizedCProgram.base64[(i >> 12) & -1024];
					if (++generatedBufbeg != generatedBufend) {
						ptr[2] = ModernizedCProgram.base64[(i >> 6) & -1024];
						generatedBufbeg++;
					} 
					cursize += 4;
					generatedPos += 4;
					break;
			case 2:
					i = (generatedBuf[generatedBufbeg + 1] & -1024) << 8;
			}
		} 
		return cursize;
	}
	public static Object encoder_base64_size(Object part) {
		 size = part.getDatasize();
		if (size <= 0) {
			return /* Unknown size or no data. */size;
		} 
		size = 4 * (1 + (size - 1) / /* Compute base64 character count. */3);
		return size + 2 * ((size - 1) / /* Effective character count must include CRLFs. */76/* Quoted-printable lookahead.
		 *
		 * Check if a CRLF or end of data is in input buffer at current position + n.
		 * Return -1 if more data needed, 1 if CRLF or end of data, else 0.
		 */);
	}
	public static int qp_lookahead_eol(int ateof, Object n) {
		Object generatedBufbeg = this.getBufbeg();
		n += generatedBufbeg;
		Object generatedBufend = this.getBufend();
		if (n >= generatedBufend && ateof) {
			return 1;
		} 
		if (n + 2 > generatedBufend) {
			return ateof ? 0 : -1;
		} 
		Object generatedBuf = this.getBuf();
		if (ModernizedCProgram.qp_class[generatedBuf[n] & -1024] == 3 && ModernizedCProgram.qp_class[generatedBuf[n + 1] & -1024] == 4) {
			return 1;
		} 
		return 0;
	}
	/* Quoted-printable encoder. */
	public static Object encoder_qp_read(Byte buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		byte ptr = buffer;
		size_t cursize = 0;
		int softlinebreak;
		byte[] buf = new byte[4/* On all platforms, input is supposed to be ASCII compatible: for this
		     reason, we use hexadecimal ASCII codes in this function rather than
		     character constants that can be interpreted as non-ascii on some
		     platforms. Preserve ASCII encoding on output too. */];
		Object generatedBufbeg = st.getBufbeg();
		Object generatedBufend = st.getBufend();
		Object generatedBuf = st.getBuf();
		Object generatedPos = st.getPos();
		while (generatedBufbeg < generatedBufend) {
			size_t len = 1;
			size_t consumed = 1;
			int i = generatedBuf[generatedBufbeg];
			buf[0] = (byte)i;
			buf[1] = ModernizedCProgram.aschex[(i >> 4) & -1024];
			buf[2] = ModernizedCProgram.aschex[i & -1024];
			switch (ModernizedCProgram.qp_class[generatedBuf[generatedBufbeg] & -1024]) {
			case /* Carriage return. */3/* If followed by a line-feed, output the CRLF pair.
			         Else escape it. */:
					switch (st.qp_lookahead_eol(ateof, 0)) {
					case /* CRLF found. */1:
							buf[len++] = /* Append '\n'. */(byte)'\x0A';
							ModernizedCProgram.consumed = 2;
							break;
					case -/* Need more data. */1:
							return cursize;
					default:
							buf[0] = /* '=' */(byte)'\x3D';
							len = 3;
							break;
					}
					break;
			case /* Space or tab. */2:
					switch (st.qp_lookahead_eol(ateof, /* Spacing must be escaped if followed by CRLF. */1)) {
					case /* No encoding needed. */0:
							break;
					case -/* More input data needed. */1:
							return cursize;
					default:
							buf[0] = /* '=' */(byte)'\x3D';
							len = 3;
							break;
					}
					break;
			case /* Not a special character. */1:
					break;
			default:
					buf[0] = /* '=' */(byte)'\x3D';
					len = 3;
					break;
			}
			if (buf[len - 1] != /* Be sure the encoded character fits within maximum line length. *//* '\n' */(byte)'\x0A') {
				softlinebreak = generatedPos + len > 76;
				if (!softlinebreak && generatedPos + len == 76/* We may use the current line only if end of data or followed by
				           a CRLF. */) {
					switch (st.qp_lookahead_eol(ateof, ModernizedCProgram.consumed)) {
					case -/* Need more data. */1:
							return cursize;
							break;
					case /* Not followed by a CRLF. */0:
							softlinebreak = 1;
							break;
					}
				} 
				if (softlinebreak) {
					.strcpy(buf, /* "=\r\n" */"\x3D\x0D\x0A");
					len = 3;
					ModernizedCProgram.consumed = 0;
				} 
			} 
			if (len > /* If the output buffer would overflow, do not store. */size) {
				break;
			} 
			.memcpy(ptr, buf, /* Append to output buffer. */len);
			cursize += len;
			ptr += len;
			size -= len;
			generatedPos += len;
			if (buf[len - 1] == /* '\n' */(byte)'\x0A') {
				st.setPos(0);
			} 
			generatedBufbeg += ModernizedCProgram.consumed;
		}
		return cursize;
	}
	public static Object encoder_qp_size(Object part) {
		return part.getDatasize() ? -1 : /* Determining the size can only be done by reading the data: unless the
		     data size is 0, we return it as unknown (-1). */0;
	}
	/* In-memory data callbacks. */
	/* Argument is a pointer to the mime part. */
	public static Object mime_mem_read(Byte buffer, Object size, Object nitems, Object instream) {
		 part = ()instream;
		size_t sz = (size_t)part.getDatasize() - part.getState().getOffset();
		(Object)/* Always 1.*/size;
		if (sz > nitems) {
			sz = nitems;
		} 
		if (sz) {
			.memcpy(buffer, (byte)part.getData()[part.getState().getOffset()], sz);
		} 
		part.getState().getOffset() += sz;
		return sz;
	}
	public static int mime_mem_seek(Object instream, Object offset, int whence) {
		 part = ()instream;
		switch (whence) {
		case 2:
				offset += part.getDatasize();
				break;
		case 1:
				offset += part.getState().getOffset();
				break;
		}
		if (offset < 0 || offset > part.getDatasize()) {
			return CURL_SEEKFUNC_FAIL;
		} 
		part.getState().setOffset((size_t)offset);
		return CURL_SEEKFUNC_OK;
	}
	public static void mime_mem_free(Object ptr) {
		do {
			.Curl_cfree(((()ptr).getData()));
			((()ptr).getData()) = ((Object)0);
		} while (0);
	}
	/* Named file callbacks. */
	/* Argument is a pointer to the mime part. */
	public static int mime_open_file(Object part) {
		if (part.getFp()) {
			return 0;
		} 
		part.setFp(.fopen(part.getData(), "rb"));
		return part.getFp() ? 0 : -1;
	}
	public static Object mime_file_read(Byte buffer, Object size, Object nitems, Object instream) {
		 part = ()instream;
		if (ModernizedCProgram.mime_open_file(part)) {
			return ((size_t)-1);
		} 
		return .fread(buffer, size, nitems, part.getFp());
	}
	public static int mime_file_seek(Object instream, Object offset, int whence) {
		 part = ()instream;
		if (whence == 0 && !offset && !part.getFp()) {
			return /* Not open: implicitly already at BOF. */CURL_SEEKFUNC_OK;
		} 
		if (ModernizedCProgram.mime_open_file(part)) {
			return CURL_SEEKFUNC_FAIL;
		} 
		return .fseek(part.getFp(), (long)offset, whence) ? CURL_SEEKFUNC_CANTSEEK : CURL_SEEKFUNC_OK;
	}
	public static void mime_file_free(Object ptr) {
		 part = ()ptr;
		if (part.getFp()) {
			.fclose(part.getFp());
			part.setFp(((Object)0));
		} 
		do {
			.Curl_cfree((part.getData()));
			(part.getData()) = ((Object)0);
		} while (0);
		part.setData(((Object)0/* Subparts callbacks. */));
	}
	/* Argument is a pointer to the mime structure. */
	/* Readback a byte string segment. */
	public static Object readback_bytes(Byte buffer, Object bufsize, Object bytes, Object numbytes, Object trail) {
		size_t sz = new size_t();
		Object generatedOffset = this.getOffset();
		if (numbytes > generatedOffset) {
			sz = numbytes - generatedOffset;
			bytes += generatedOffset;
		} else {
				size_t tsz = .strlen(trail);
				sz = generatedOffset - numbytes;
				if (sz >= tsz) {
					return 0;
				} 
				bytes = trail + sz;
				sz = tsz - sz;
		} 
		if (sz > bufsize) {
			sz = bufsize;
		} 
		.memcpy(buffer, bytes, sz);
		generatedOffset += sz;
		return sz;
	}
	/* Read a non-encoded part content. */
	public static Object read_part_content(Object part, Byte buffer, Object bufsize) {
		size_t sz = 0;
		if (part.getReadfunc()) {
			sz = .UNRECOGNIZEDFUNCTIONNAME(buffer, 1, bufsize, part.getArg());
		} 
		return sz;
	}
	/* Read and encode part content. */
	public static Object read_encoded_part_content(Object part, Byte buffer, Object bufsize) {
		mime_encoder_state st = part.getEncstate();
		size_t cursize = 0;
		size_t sz = new size_t();
		bool ateof = 0;
		Object generatedBufbeg = st.getBufbeg();
		Object generatedBufend = st.getBufend();
		Object generatedBuf = st.getBuf();
		while (bufsize) {
			if (generatedBufbeg < generatedBufend || ateof) {
				sz = .UNRECOGNIZEDFUNCTIONNAME(buffer, bufsize, ateof, /* Encode buffered data. */part);
				switch (sz) {
				case CURL_READFUNC_ABORT:
				case ((size_t)-1):
						return cursize ? cursize : sz;
				case 0:
						if (ateof) {
							return cursize;
						} 
						break;
				case CURL_READFUNC_PAUSE:
				default:
						cursize += sz;
						buffer += sz;
						bufsize -= sz;
						continue;
				}
			} 
			if (generatedBufbeg) {
				size_t len = generatedBufend - generatedBufbeg;
				if (len) {
					.memmove(generatedBuf, generatedBuf + generatedBufbeg, len);
				} 
				st.setBufbeg(0);
				st.setBufend(len);
			} 
			if (generatedBufend >= ) {
				return cursize ? cursize : ((size_t)-/* Buffer full. */1);
			} 
			sz = ModernizedCProgram.read_part_content(part, generatedBuf + generatedBufend,  - generatedBufend);
			switch (sz) {
			case 0:
					ateof = 1;
					break;
			case CURL_READFUNC_ABORT:
			case ((size_t)-1):
					return cursize ? cursize : sz;
			case CURL_READFUNC_PAUSE:
			default:
					generatedBufend += sz;
					break;
			}
		}
		return cursize;
	}
	/* Readback a mime part. */
	public static Object readback_part(Object part, Byte buffer, Object bufsize) {
		size_t cursize = 0;
		Object generatedCurl_slist = hdr.getCurl_slist();
		while (/* Readback from part. */bufsize) {
			size_t sz = 0;
			curl_slist hdr = (curl_slist)part.getState().getPtr();
			switch (part.getState().getState()) {
			case mimestate.MIMESTATE_BEGIN:
					part.getState().mimesetstate((part.getFlags() & (1 << 1)) ? mimestate.MIMESTATE_BODY : mimestate.MIMESTATE_CURLHEADERS, part.getCurlheaders());
					break;
			case mimestate.MIMESTATE_CONTENT:
					if (part.getEncoder()) {
						sz = ModernizedCProgram.read_encoded_part_content(part, buffer, bufsize);
					} else {
							sz = ModernizedCProgram.read_part_content(part, buffer, bufsize);
					} 
					switch (sz) {
					case ((size_t)-1):
							return cursize ? cursize : sz;
					case 0:
							part.getState().mimesetstate(mimestate.MIMESTATE_END, ((Object)0));
							if (part.getKind() == mimekind.MIMEKIND_FILE && part.getFp()) {
								.fclose(part.getFp());
								part.setFp(((Object)0));
							} 
					case /* FALLTHROUGH */CURL_READFUNC_ABORT:
					case CURL_READFUNC_PAUSE:
					}
					break;
			case mimestate.MIMESTATE_BODY:
					part.getEncstate().cleanup_encoder_state();
					part.getState().mimesetstate(mimestate.MIMESTATE_CONTENT, ((Object)0));
					break;
			case mimestate.MIMESTATE_EOH:
					sz = part.getState().readback_bytes(buffer, bufsize, "\r\n", 2, "");
					if (!sz) {
						part.getState().mimesetstate(mimestate.MIMESTATE_BODY, ((Object)0));
					} 
					break;
			case /* FALLTHROUGH */mimestate.MIMESTATE_CURLHEADERS:
					if (!hdr) {
						part.getState().mimesetstate(mimestate.MIMESTATE_USERHEADERS, part.getUserheaders());
					} else {
							sz = part.getState().readback_bytes(buffer, bufsize, generatedCurl_slist, .strlen(generatedCurl_slist), "\r\n");
							if (!sz) {
								part.getState().mimesetstate(part.getState().getState(), generatedCurl_slist);
							} 
					} 
					break;
			case mimestate.MIMESTATE_USERHEADERS:
					if (!hdr) {
						part.getState().mimesetstate(mimestate.MIMESTATE_EOH, ((Object)0));
						break;
					} 
					if (hdr.match_header("Content-Type", 12)) {
						part.getState().mimesetstate(mimestate.MIMESTATE_USERHEADERS, generatedCurl_slist);
						break;
					} 
			case mimestate.MIMESTATE_END:
					return cursize;
			default:
					break;
			}
			cursize += /* Bump buffer and counters according to read size. */sz;
			buffer += sz;
			bufsize -= sz;
		}
		return cursize;
	}
	/* Readback from mime. */
	public static Object mime_subparts_read(Byte buffer, Object size, Object nitems, Object instream) {
		 mime = ()instream;
		size_t cursize = 0;
		(Object)/* Always 1. */size;
		while (nitems) {
			size_t sz = 0;
			 part = mime.getState().getPtr();
			switch (mime.getState().getState()) {
			case mimestate.MIMESTATE_END:
					return cursize;
			case mimestate.MIMESTATE_BODY:
					mime.getState().mimesetstate(mimestate.MIMESTATE_BOUNDARY1, mime.getFirstpart());
					mime.getState().getOffset() += 2;
					break;
			case mimestate.MIMESTATE_BOUNDARY1:
					sz = mime.getState().readback_bytes(buffer, nitems, "\r\n--", 4, "");
					if (!sz) {
						mime.getState().mimesetstate(mimestate.MIMESTATE_BOUNDARY2, part);
					} 
					break;
			case mimestate.MIMESTATE_CONTENT:
					if (!part) {
						mime.getState().mimesetstate(mimestate.MIMESTATE_END, ((Object)0));
						break;
					} 
					sz = ModernizedCProgram.readback_part(part, buffer, nitems);
					switch (sz) {
					case 0:
							mime.getState().mimesetstate(mimestate.MIMESTATE_BOUNDARY1, part.getNextpart());
							break;
					case ((size_t)-1):
							return cursize ? cursize : sz;
					case CURL_READFUNC_ABORT:
					case CURL_READFUNC_PAUSE:
					}
					break;
			case mimestate.MIMESTATE_BOUNDARY2:
					sz = mime.getState().readback_bytes(buffer, nitems, mime.getBoundary(), .strlen(mime.getBoundary()), part ? "\r\n" : "--\r\n");
					if (!sz) {
						mime.getState().mimesetstate(mimestate.MIMESTATE_CONTENT, part);
					} 
					break;
			case mimestate.MIMESTATE_BEGIN:
			default:
					break;
			}
			cursize += /* Bump buffer and counters according to read size. */sz;
			buffer += sz;
			nitems -= sz;
		}
		return cursize;
	}
	public static int mime_part_rewind(Object part) {
		int res = CURL_SEEKFUNC_OK;
		mimestate targetstate = mimestate.MIMESTATE_BEGIN;
		if (part.getFlags() & (1 << 1)) {
			mimestate.targetstate = mimestate.MIMESTATE_BODY;
		} 
		part.getEncstate().cleanup_encoder_state();
		if (part.getState().getState() > mimestate.targetstate) {
			res = CURL_SEEKFUNC_CANTSEEK;
			if (part.getSeekfunc()) {
				res = .UNRECOGNIZEDFUNCTIONNAME(part.getArg(), ()0, 0);
				switch (res) {
				case CURL_SEEKFUNC_OK:
				case CURL_SEEKFUNC_CANTSEEK:
						break;
				case -/* For fseek() error. */1:
						res = CURL_SEEKFUNC_CANTSEEK;
						break;
				case CURL_SEEKFUNC_FAIL:
				default:
						res = CURL_SEEKFUNC_FAIL;
						break;
				}
			} 
		} 
		if (res == CURL_SEEKFUNC_OK) {
			part.getState().mimesetstate(mimestate.targetstate, ((Object)0));
		} 
		return res;
	}
	public static int mime_subparts_seek(Object instream, Object offset, int whence) {
		 mime = ()instream;
		 part = new ();
		int result = CURL_SEEKFUNC_OK;
		if (whence != 0 || offset) {
			return /* Only support full rewind. */CURL_SEEKFUNC_CANTSEEK;
		} 
		if (mime.getState().getState() == mimestate.MIMESTATE_BEGIN) {
			return /* Already rewound. */CURL_SEEKFUNC_OK;
		} 
		for (part = mime.getFirstpart(); part; part = part.getNextpart()) {
			int res = ModernizedCProgram.mime_part_rewind(part);
			if (ModernizedCProgram.res != CURL_SEEKFUNC_OK) {
				result = ModernizedCProgram.res;
			} 
		}
		if (result == CURL_SEEKFUNC_OK) {
			mime.getState().mimesetstate(mimestate.MIMESTATE_BEGIN, ((Object)0));
		} 
		return result;
	}
	/* Release part content. */
	public static void cleanup_part_content(Object part) {
		if (part.getFreefunc()) {
			.UNRECOGNIZEDFUNCTIONNAME(part.getArg());
		} 
		part.setReadfunc(((Object)0));
		part.setSeekfunc(((Object)0));
		part.setFreefunc(((Object)0));
		part.setArg((Object)/* Defaults to part itself. */part);
		part.setData(((Object)0));
		part.setFp(((Object)0));
		part.setDatasize(()/* No size yet. */0);
		part.getEncstate().cleanup_encoder_state();
		part.setKind(mimekind.MIMEKIND_NONE);
	}
	public static void mime_subparts_free(Object ptr) {
		 mime = ()ptr;
		if (mime && mime.getParent()) {
			mime.getParent().setFreefunc(((Object)/* Be sure we won't be called again. */0));
			ModernizedCProgram.cleanup_part_content(mime.getParent());
		} 
		ModernizedCProgram.curl_mime_free(mime);
	}
	/* Do not free subparts: unbind them. This is used for the top level only. */
	public static void mime_subparts_unbind(Object ptr) {
		 mime = ()ptr;
		if (mime && mime.getParent()) {
			mime.getParent().setFreefunc(((Object)/* Be sure we won't be called again. */0));
			ModernizedCProgram.cleanup_part_content(mime.getParent());
			mime.setParent(((Object)0));
		} 
	}
	public static void Curl_mime_cleanpart(Object part) {
		ModernizedCProgram.cleanup_part_content(part);
		part.getCurlheaders().curl_slist_free_all();
		if (part.getFlags() & (1 << 0)) {
			part.getUserheaders().curl_slist_free_all();
		} 
		do {
			.Curl_cfree((part.getMimetype()));
			(part.getMimetype()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((part.getName()));
			(part.getName()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((part.getFilename()));
			(part.getFilename()) = ((Object)0);
		} while (0);
		part.getEasy().Curl_mime_initpart(part);
	}
	/* Recursively delete a mime handle and its parts. */
	public static void curl_mime_free(Object mime) {
		 part = new ();
		if (mime) {
			ModernizedCProgram.mime_subparts_unbind(/* Be sure it's not referenced anymore. */mime);
			while (mime.getFirstpart()) {
				part = mime.getFirstpart();
				mime.setFirstpart(part.getNextpart());
				ModernizedCProgram.Curl_mime_cleanpart(part);
				.Curl_cfree(part);
			}
			.Curl_cfree(mime);
		} 
	}
	public static Object Curl_mime_duppart(Object dst, Object src) {
		 mime = new ();
		 d = new ();
		 s = new ();
		 res = CURLE_OK;
		do {
		} while (0);
		switch (src.getKind()) {
		case mimekind.MIMEKIND_MULTIPART/* No one knows about the cloned subparts, thus always attach ownership
		       to the part. */:
				mime = dst.getEasy().curl_mime_init();
				res = mime ? ModernizedCProgram.curl_mime_subparts(dst, mime) : CURLE_OUT_OF_MEMORY;
				for (s = (()src.getArg()).getFirstpart(); !res && s; s = s.getNextpart()) {
					d = ModernizedCProgram.curl_mime_addpart(mime);
					res = d ? ModernizedCProgram.Curl_mime_duppart(d, s) : CURLE_OUT_OF_MEMORY;
				}
				break;
		case mimekind.MIMEKIND_CALLBACK:
				res = ModernizedCProgram.curl_mime_data_cb(dst, src.getDatasize(), src.getReadfunc(), src.getSeekfunc(), src.getFreefunc(), src.getArg());
				break;
		case mimekind.MIMEKIND_NONE:
				break;
		case mimekind.MIMEKIND_DATA:
				res = ModernizedCProgram.curl_mime_data(dst, src.getData(), (size_t)src.getDatasize());
				break;
		case mimekind.MIMEKIND_FILE:
				res = ModernizedCProgram.curl_mime_filedata(dst, src.getData());
				if (res == /* Do not abort duplication if file is not readable. */CURLE_READ_ERROR) {
					res = CURLE_OK;
				} 
				break;
		default:
				res = /* Internal error? */CURLE_BAD_FUNCTION_ARGUMENT;
				break;
		}
		if (!res && src.getUserheaders()) {
			curl_slist hdrs = src.getUserheaders().Curl_slist_duplicate();
			if (!hdrs) {
				res = CURLE_OUT_OF_MEMORY;
			} else {
					res = hdrs.curl_mime_headers(dst, /* No one but this procedure knows about the new header list,
					         so always take ownership. */1);
					if (res) {
						hdrs.curl_slist_free_all();
					} 
			} 
		} 
		if (!res) {
			dst.setEncoder(src.getEncoder());
			res = ModernizedCProgram.curl_mime_type(dst, src.getMimetype());
		} 
		if (!res) {
			res = ModernizedCProgram.curl_mime_name(dst, src.getName());
		} 
		if (!res) {
			res = ModernizedCProgram.curl_mime_filename(dst, src.getFilename());
		} 
		if (/* If an error occurred, rollback. */res) {
			ModernizedCProgram.Curl_mime_cleanpart(dst);
		} 
		return res/*
		 * Mime build functions.
		 */;
	}
	/* Create a mime part and append it to a mime handle's part list. */
	public static Object curl_mime_addpart(Object mime) {
		 part = new ();
		if (!mime) {
			return ((Object)0);
		} 
		part = ().Curl_cmalloc();
		if (part) {
			mime.getEasy().Curl_mime_initpart(part);
			part.setParent(mime);
			if (mime.getLastpart()) {
				mime.getLastpart().setNextpart(part);
			} else {
					mime.setFirstpart(part);
			} 
			mime.setLastpart(part);
		} 
		return part;
	}
	/* Set mime part name. */
	public static Object curl_mime_name(Object part, Object name) {
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getName()));
			(part.getName()) = ((Object)0);
		} while (0);
		part.setName(((Object)0));
		if (name) {
			part.setName(.Curl_cstrdup(name));
			if (!part.getName()) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		return CURLE_OK;
	}
	/* Set mime part remote file name. */
	public static Object curl_mime_filename(Object part, Object filename) {
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getFilename()));
			(part.getFilename()) = ((Object)0);
		} while (0);
		part.setFilename(((Object)0));
		if (filename) {
			part.setFilename(.Curl_cstrdup(filename));
			if (!part.getFilename()) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		return CURLE_OK;
	}
	/* Set mime part content from memory data. */
	public static Object curl_mime_data(Object part, Object data, Object datasize) {
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (data) {
			if (datasize == CURL_ZERO_TERMINATED) {
				datasize = .strlen(data);
			} 
			part.setData(.Curl_cmalloc(datasize + 1));
			if (!part.getData()) {
				return CURLE_OUT_OF_MEMORY;
			} 
			part.setDatasize(datasize);
			if (datasize) {
				.memcpy(part.getData(), data, datasize);
			} 
			part.getData()[datasize] = /* Set a nul terminator as sentinel. */(byte)'\0';
			part.setReadfunc(mime_mem_read);
			part.setSeekfunc(mime_mem_seek);
			part.setFreefunc(mime_mem_free);
			part.setKind(mimekind.MIMEKIND_DATA);
		} 
		return CURLE_OK;
	}
	/* Set mime part content from named local file. */
	public static Object curl_mime_filedata(Object part, Object filename) {
		 result = CURLE_OK;
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		Object generatedSt_mode = sbuf.getSt_mode();
		Object generatedSt_size = sbuf.getSt_size();
		if (filename) {
			byte base;
			_stati64 sbuf = new _stati64();
			if (._stati64(filename, sbuf) || .access(filename, 4)) {
				result = CURLE_READ_ERROR;
			} 
			part.setData(.Curl_cstrdup(filename));
			if (!part.getData()) {
				result = CURLE_OUT_OF_MEMORY;
			} 
			part.setDatasize(-1);
			if (!result && (((generatedSt_mode) & -1024) == -1024)) {
				part.setDatasize((generatedSt_size));
				part.setSeekfunc(mime_file_seek);
			} 
			part.setReadfunc(mime_file_read);
			part.setFreefunc(mime_file_free);
			part.setKind(mimekind.MIMEKIND_FILE/* As a side effect, set the filename to the current file's base name.
			       It is possible to withdraw this by explicitly calling
			       curl_mime_filename() with a NULL filename argument after the current
			       call. */);
			ModernizedCProgram.base = ModernizedCProgram.strippath(filename);
			if (!ModernizedCProgram.base) {
				result = CURLE_OUT_OF_MEMORY;
			} else {
					 res = ModernizedCProgram.curl_mime_filename(part, ModernizedCProgram.base);
					if (ModernizedCProgram.res) {
						result = ModernizedCProgram.res;
					} 
					.Curl_cfree(ModernizedCProgram.base);
			} 
		} 
		return result;
	}
	/* Set mime part type. */
	public static Object curl_mime_type(Object part, Object mimetype) {
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getMimetype()));
			(part.getMimetype()) = ((Object)0);
		} while (0);
		part.setMimetype(((Object)0));
		if (mimetype) {
			part.setMimetype(.Curl_cstrdup(mimetype));
			if (!part.getMimetype()) {
				return CURLE_OUT_OF_MEMORY;
			} 
		} 
		return CURLE_OK;
	}
	/* Set mime data transfer encoder. */
	public static Object curl_mime_encoder(Object part, Object encoding) {
		 result = CURLE_BAD_FUNCTION_ARGUMENT;
		mime_encoder mep = new mime_encoder();
		if (!part) {
			return result;
		} 
		part.setEncoder(((Object)0));
		if (!encoding) {
			return /* Removing current encoder. */CURLE_OK;
		} 
		for (mep = ModernizedCProgram.encoders; mep.getName(); mep++) {
			if (ModernizedCProgram.Curl_strcasecompare(encoding, mep.getName())) {
				part.setEncoder(mep);
				result = CURLE_OK;
			} 
		}
		return result;
	}
	/* Set mime part content from callback. */
	public static Object curl_mime_data_cb(Object part, Object datasize, Object readfunc, Object seekfunc, Object freefunc, Object arg) {
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (readfunc) {
			part.setReadfunc(readfunc);
			part.setSeekfunc(seekfunc);
			part.setFreefunc(freefunc);
			part.setArg(arg);
			part.setDatasize(datasize);
			part.setKind(mimekind.MIMEKIND_CALLBACK);
		} 
		return CURLE_OK;
	}
	/* Set mime part content from subparts. */
	public static Object Curl_mime_set_subparts(Object part, Object subparts, int take_ownership) {
		 root = new ();
		if (!part) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART && part.getArg() == /* Accept setting twice the same subparts. */subparts) {
			return CURLE_OK;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (subparts) {
			if (part.getEasy() && subparts.getEasy() && part.getEasy() != subparts.getEasy()) {
				return CURLE_BAD_FUNCTION_ARGUMENT;
			} 
			if (subparts.getParent()) {
				return CURLE_BAD_FUNCTION_ARGUMENT;
			} 
			root = part.getParent();
			if (root) {
				while (root.getParent() && root.getParent().getParent()) {
					root = root.getParent().getParent();
				}
				if (subparts == root) {
					if (part.getEasy()) {
						part.getEasy().Curl_failf("Can't add itself as a subpart!");
					} 
					return CURLE_BAD_FUNCTION_ARGUMENT;
				} 
			} 
			subparts.setParent(part);
			part.setReadfunc(mime_subparts_read);
			part.setSeekfunc(mime_subparts_seek);
			part.setFreefunc(take_ownership ? mime_subparts_free : mime_subparts_unbind);
			part.setArg(subparts);
			part.setDatasize(-1);
			part.setKind(mimekind.MIMEKIND_MULTIPART);
		} 
		return CURLE_OK;
	}
	public static Object curl_mime_subparts(Object part, Object subparts) {
		return ModernizedCProgram.Curl_mime_set_subparts(part, subparts, 1);
	}
	/* Readback from top mime. */
	/* Argument is the dummy top part. */
	public static Object Curl_mime_read(Byte buffer, Object size, Object nitems, Object instream) {
		 part = ()instream;
		(Object)/* Always 1. */size;
		return ModernizedCProgram.readback_part(part, buffer, nitems);
	}
	/* Rewind mime stream. */
	public static Object Curl_mime_rewind(Object part) {
		return ModernizedCProgram.mime_part_rewind(part) == CURL_SEEKFUNC_OK ? CURLE_OK : CURLE_SEND_FAIL_REWIND;
	}
	/* Get/compute multipart size. */
	public static Object multipart_size(Object mime) {
		 size = new ();
		size_t boundarysize = new size_t();
		 part = new ();
		if (!mime) {
			return /* Not present -> empty. */0;
		} 
		boundarysize = 4 + .strlen(mime.getBoundary()) + 2;
		size = /* Final boundary - CRLF after headers. */boundarysize;
		for (part = mime.getFirstpart(); part; part = part.getNextpart()) {
			 sz = ModernizedCProgram.Curl_mime_size(part);
			if (sz < 0) {
				size = sz;
			} 
			if (size >= 0) {
				size += boundarysize + sz;
			} 
		}
		return size;
	}
	/* Get/compute mime size. */
	public static Object Curl_mime_size(Object part) {
		 size = new ();
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART) {
			part.setDatasize(ModernizedCProgram.multipart_size(part.getArg()));
		} 
		size = part.getDatasize();
		if (part.getEncoder()) {
			size = .UNRECOGNIZEDFUNCTIONNAME(part);
		} 
		if (size >= 0 && !(part.getFlags() & (1 << 1))) {
			size += part.getCurlheaders().slist_size(2, ((Object)/* Compute total part size. */0));
			size += part.getUserheaders().slist_size(2, "Content-Type");
			size += /* CRLF after headers. */2;
		} 
		return size;
	}
	public static Object Curl_mime_contenttype(Object filename) {
		ContentType[] ctts = new ContentType[]{new ContentType(".gif", "image/gif"), new ContentType(".jpg", "image/jpeg"), new ContentType(".jpeg", "image/jpeg"), new ContentType(".png", "image/png"), new ContentType(".svg", "image/svg+xml"), new ContentType(".txt", "text/plain"), new ContentType(".htm", "text/html"), new ContentType(".html", "text/html"), new ContentType(".pdf", "application/pdf"), new ContentType(".xml", "application/xml")};
		if (filename) {
			size_t len1 = .strlen(filename);
			byte nameend = filename + len1;
			int i;
			for (i = 0; i <  / ; i++) {
				size_t len2 = .strlen(ctts[i].getExtension());
				if (len1 >= len2 && ModernizedCProgram.Curl_strcasecompare(nameend - len2, ctts[i].getExtension())) {
					return ctts[i].getType();
				} 
			}
		} 
		return ((Object)0);
	}
	/*
	   * If no content type was specified, we scan through a few well-known
	   * extensions and pick the first we match!
	   */
	public static Object Curl_mime_prepare_headers(Object part, Object contenttype, Object disposition, mimestrategy strategy) {
		 mime = ((Object)0);
		byte boundary = ((Object)0);
		byte customct;
		byte cte = ((Object)0);
		 ret = CURLE_OK;
		part.getCurlheaders().curl_slist_free_all();
		part.setCurlheaders(((Object)0));
		if (part.getState().getState() == /* Be sure we won't access old headers later. */mimestate.MIMESTATE_CURLHEADERS) {
			part.getState().mimesetstate(mimestate.MIMESTATE_CURLHEADERS, ((Object)0));
		} 
		customct = part.getMimetype();
		if (!customct) {
			customct = part.getUserheaders().search_header("Content-Type");
		} 
		if (customct) {
			contenttype = customct;
		} 
		if (!/* If content type is not specified, try to determine it. */contenttype) {
			switch (part.getKind()) {
			case mimekind.MIMEKIND_MULTIPART:
					contenttype = "multipart/mixed";
					break;
			case mimekind.MIMEKIND_FILE:
					contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getFilename());
					if (!contenttype) {
						contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getData());
					} 
					if (!contenttype && part.getFilename()) {
						contenttype = "application/octet-stream";
					} 
					break;
			default:
					contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getFilename());
					break;
			}
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART) {
			mime = ()part.getArg();
			if (mime) {
				boundary = mime.getBoundary();
			} 
		}  else if (contenttype && !customct && ModernizedCProgram.Curl_strcasecompare(contenttype, "text/plain")) {
			if (mimestrategy.strategy == mimestrategy.MIMESTRATEGY_MAIL || !part.getFilename()) {
				contenttype = ((Object)0);
			} 
		} 
		if (!part.getUserheaders().search_header(/* Issue content-disposition header only if not already set by caller. */"Content-Disposition")) {
			if (!disposition) {
				if (part.getFilename() || part.getName() || (contenttype && !ModernizedCProgram.Curl_strncasecompare(contenttype, "multipart/", 10))) {
					disposition = "attachment";
				} 
			} 
			if (disposition && ModernizedCProgram.curl_strequal(disposition, "attachment") && !part.getName() && !part.getFilename()) {
				disposition = ((Object)0);
			} 
			if (disposition) {
				byte name = ((Object)0);
				byte filename = ((Object)0);
				if (part.getName()) {
					ModernizedCProgram.name = ModernizedCProgram.escape_string(part.getName());
					if (!ModernizedCProgram.name) {
						ret = CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!ret && part.getFilename()) {
					ModernizedCProgram.filename = ModernizedCProgram.escape_string(part.getFilename());
					if (!ModernizedCProgram.filename) {
						ret = CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!ret) {
					ret = part.getCurlheaders().Curl_mime_add_header("Content-Disposition: %s%s%s%s%s%s%s", disposition, ModernizedCProgram.name ? "; name=\"" : "", ModernizedCProgram.name ? ModernizedCProgram.name : "", ModernizedCProgram.name ? "\"" : "", ModernizedCProgram.filename ? "; filename=\"" : "", ModernizedCProgram.filename ? ModernizedCProgram.filename : "", ModernizedCProgram.filename ? "\"" : "");
				} 
				do {
					.Curl_cfree((ModernizedCProgram.name));
					(ModernizedCProgram.name) = ((Object)0);
				} while (0);
				do {
					.Curl_cfree((ModernizedCProgram.filename));
					(ModernizedCProgram.filename) = ((Object)0);
				} while (0);
				if (ret) {
					return ret;
				} 
			} 
		} 
		if (/* Issue Content-Type header. */contenttype) {
			ret = part.getCurlheaders().add_content_type(contenttype, boundary);
			if (ret) {
				return ret;
			} 
		} 
		if (!part.getUserheaders().search_header(/* Content-Transfer-Encoding header. */"Content-Transfer-Encoding")) {
			if (part.getEncoder()) {
				cte = part.getEncoder().getName();
			}  else if (contenttype && mimestrategy.strategy == mimestrategy.MIMESTRATEGY_MAIL && part.getKind() != mimekind.MIMEKIND_MULTIPART) {
				cte = "8bit";
			} 
			if (cte) {
				ret = part.getCurlheaders().Curl_mime_add_header("Content-Transfer-Encoding: %s", cte);
				if (ret) {
					return ret;
				} 
			} 
		} 
		if (part.getState().getState() == /* If we were reading curl-generated headers, restart with new ones (this
		     should not occur). */mimestate.MIMESTATE_CURLHEADERS) {
			part.getState().mimesetstate(mimestate.MIMESTATE_CURLHEADERS, part.getCurlheaders());
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART && /* Process subparts. */mime) {
			 subpart = new ();
			disposition = ((Object)0);
			if (ModernizedCProgram.Curl_strcasecompare(contenttype, "multipart/form-data")) {
				disposition = "form-data";
			} 
			for (subpart = mime.getFirstpart(); subpart; subpart = subpart.getNextpart()) {
				ret = ModernizedCProgram.Curl_mime_prepare_headers(subpart, ((Object)0), disposition, mimestrategy.strategy);
				if (ret) {
					return ret;
				} 
			}
		} 
		return ret/* !CURL_DISABLE_HTTP || !CURL_DISABLE_SMTP || !CURL_DISABLE_IMAP *//* Mime not compiled in: define stubs for externally-referenced functions. */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* ------------------------------------------------------------------ */
	/* Return the scope of the given address. */
	public static int Curl_ipv6_scope(Object sa) {
		(Object)sa/* Handle ULAs */;
		return 0;
	}
	/* We are interested only in interface addresses whose
	                   scope matches the remote address we want to
	                   connect to: global for global, link-local for
	                   link-local, etc... */
	/* Include the scope of this interface as part of the address */
	/* If given, scope id should match. */
	/* With SIOCGIFADDR, we cannot tell the difference between an interface
	       that does not exist and an interface that has no address of the
	       correct family. Assume the interface does not exist */
	public static  Curl_if2ip(int af, int remote_scope, int local_scope_id, Object interf, Byte buf, int buf_size) {
		(Object)af;
		(Object)remote_scope;
		(Object)local_scope_id;
		(Object)interf;
		(Object)buf;
		(Object)buf_size;
		return .IF2IP_NOT_FOUND;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2012 - 2016, Linus Nielsen Feltzing, <linus@haxx.se>
	 * Copyright (C) 2012 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* the debug versions of these macros make extra certain that the lock is
	   never doubly locked or unlocked */
	public static void conn_llist_dtor(Object user, Object element) {
		connectdata conn = element;
		(Object)user;
		conn.setBundle(((Object)0));
	}
	public static Object bundle_create(Curl_easy data, connectbundle cb_ptr) {
		(Object)data;
		do {
		} while (0);
		cb_ptr = .Curl_cmalloc();
		if (!cb_ptr) {
			return CURLE_OUT_OF_MEMORY;
		} 
		(cb_ptr).setNum_connections(0);
		(cb_ptr).setMultiuse(0);
		curl_llist generatedConn_list = (cb_ptr).getConn_list();
		generatedConn_list.Curl_llist_init((curl_llist_dtor)conn_llist_dtor);
		return CURLE_OK;
	}
	/* Add a connection to a bundle */
	public static void bundle_add_conn(connectbundle cb_ptr, connectdata conn) {
		curl_llist generatedConn_list = cb_ptr.getConn_list();
		curl_llist_element generatedTail = generatedConn_list.getTail();
		curl_llist_element generatedBundle_node = conn.getBundle_node();
		ModernizedCProgram.Curl_llist_insert_next(generatedConn_list, generatedTail, conn, generatedBundle_node);
		conn.setBundle(cb_ptr);
		Object generatedNum_connections = cb_ptr.getNum_connections();
		generatedNum_connections++;
	}
	/* Remove a connection from a bundle */
	public static int bundle_remove_conn(connectbundle cb_ptr, connectdata conn) {
		curl_llist_element curr = new curl_llist_element();
		curl_llist generatedConn_list = cb_ptr.getConn_list();
		curl_llist_element generatedHead = generatedConn_list.getHead();
		curr = generatedHead;
		Object generatedPtr = curr.getPtr();
		Object generatedNum_connections = cb_ptr.getNum_connections();
		curl_llist_element generatedNext = curr.getNext();
		while (curr) {
			if (generatedPtr == conn) {
				ModernizedCProgram.Curl_llist_remove(generatedConn_list, curr, ((Object)0));
				generatedNum_connections--;
				conn.setBundle(((Object)0));
				return /* we removed a handle */1;
			} 
			curr = generatedNext;
		}
		return 0;
	}
	public static void free_bundle_hash_entry(Object freethis) {
		connectbundle b = (connectbundle)freethis;
		b.bundle_destroy();
	}
	public static  conncache_add_bundle(conncache connc, Byte key, connectbundle bundle) {
		curl_hash generatedHash = connc.getHash();
		Object p = generatedHash.Curl_hash_add(key, .strlen(key), bundle);
		return p ? 1 : 0;
	}
	public static void conncache_remove_bundle(conncache connc, connectbundle bundle) {
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_hash_element he = new curl_hash_element();
		if (!connc) {
			return ;
		} 
		curl_hash generatedHash = connc.getHash();
		ModernizedCProgram.Curl_hash_start_iterate(generatedHash, iter);
		curl_hash_element curl_hash_element = new curl_hash_element();
		he = curl_hash_element.Curl_hash_next_element(iter);
		Object generatedPtr = he.getPtr();
		Object generatedKey = he.getKey();
		Object generatedKey_len = he.getKey_len();
		while (he) {
			if (generatedPtr == bundle/* The bundle is destroyed by the hash destructor function,
			         free_bundle_hash_entry() */) {
				generatedHash.Curl_hash_delete(generatedKey, generatedKey_len);
				return ;
			} 
			he = curl_hash_element.Curl_hash_next_element(iter);
		}
	}
	public static Object Curl_conncache_add_conn(conncache connc, connectdata conn) {
		 result = CURLE_OK;
		connectbundle bundle = new connectbundle();
		connectbundle new_bundle = ((Object)0);
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Object generatedState = data.getState();
		connectbundle connectbundle = new connectbundle();
		bundle = connectbundle.Curl_conncache_find_bundle(conn, generatedState.getConn_cache(), ((Object)/* *find_bundle() locks the connection cache */0));
		if (!bundle) {
			int rc;
			byte[] key = new byte[128];
			result = ModernizedCProgram.bundle_create(data, new_bundle);
			if (result) {
				;
			} 
			conn.hashkey(key, , ((Object)0));
			rc = ModernizedCProgram.conncache_add_bundle(generatedState.getConn_cache(), key, new_bundle);
			if (!rc) {
				new_bundle.bundle_destroy();
				result = CURLE_OUT_OF_MEMORY;
				;
			} 
			bundle = new_bundle;
		} 
		ModernizedCProgram.bundle_add_conn(bundle, conn);
		long generatedNext_connection_id = connc.getNext_connection_id();
		conn.setConnection_id(generatedNext_connection_id++);
		Object generatedNum_conn = connc.getNum_conn();
		generatedNum_conn++;
		do {
		} while (0);
		return result/*
		 * Removes the connectdata object from the connection cache *and* clears the
		 * ->data pointer association. Pass TRUE/FALSE in the 'lock' argument
		 * depending on if the parent function already holds the lock or not.
		 */;
	}
	public static void Curl_conncache_remove_conn(Curl_easy data, connectdata conn,  lock) {
		connectbundle generatedBundle = conn.getBundle();
		connectbundle bundle = generatedBundle;
		Object generatedState = data.getState();
		conncache connc = generatedState.getConn_cache();
		Object generatedShare = (data).getShare();
		Object generatedNum_connections = bundle.getNum_connections();
		Object generatedNum_conn = connc.getNum_conn();
		if (/* The bundle pointer can be NULL, since this function can be called
		     due to a failed connection attempt, before being added to a bundle */bundle) {
			if (lock) {
				if (generatedShare) {
					(data).Curl_share_lock(CURL_LOCK_DATA_CONNECT, CURL_LOCK_ACCESS_SINGLE);
				} 
			} 
			ModernizedCProgram.bundle_remove_conn(bundle, conn);
			if (generatedNum_connections == 0) {
				ModernizedCProgram.conncache_remove_bundle(connc, bundle);
			} 
			conn.setBundle(((Object)/* removed from it */0));
			if (connc) {
				generatedNum_conn--;
				do {
				} while (0);
			} 
			conn.setData(((Object)/* clear the association */0));
			if (lock) {
				if (generatedShare) {
					(data).Curl_share_unlock(CURL_LOCK_DATA_CONNECT/* This function iterates the entire connection cache and calls the function
					   func() with the connection pointer as the first argument and the supplied
					   'param' argument as the other.
					
					   The conncache lock is still held when the callback is called. It needs it,
					   so that it can safely continue traversing the lists once the callback
					   returns.
					
					   Returns 1 if the loop was aborted due to the callback's return code.
					
					   Return 0 from func() to continue the loop, return 1 to abort it.
					 */);
				} 
			} 
		} 
	}
	public static  Curl_conncache_foreach(Curl_easy data, conncache connc, Object param, Object func) {
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_llist_element curr = new curl_llist_element();
		curl_hash_element he = new curl_hash_element();
		if (!connc) {
			return 0;
		} 
		Object generatedShare = (data).getShare();
		if (generatedShare) {
			(data).Curl_share_lock(CURL_LOCK_DATA_CONNECT, CURL_LOCK_ACCESS_SINGLE);
		} 
		curl_hash generatedHash = connc.getHash();
		ModernizedCProgram.Curl_hash_start_iterate(generatedHash, iter);
		curl_hash_element curl_hash_element = new curl_hash_element();
		he = curl_hash_element.Curl_hash_next_element(iter);
		Object generatedPtr = he.getPtr();
		curl_llist generatedConn_list = bundle.getConn_list();
		curl_llist_element generatedHead = generatedConn_list.getHead();
		curl_llist_element generatedNext = curr.getNext();
		while (he) {
			connectbundle bundle = new connectbundle();
			bundle = generatedPtr;
			he = curl_hash_element.Curl_hash_next_element(iter);
			curr = generatedHead;
			while (curr/* Yes, we need to update curr before calling func(), because func()
			         might decide to remove the connection */) {
				connectdata conn = generatedPtr;
				curr = generatedNext;
				if (1 == .func(conn, param)) {
					if (generatedShare) {
						(data).Curl_share_unlock(CURL_LOCK_DATA_CONNECT);
					} 
					return 1;
				} 
			}
		}
		if (generatedShare) {
			(data).Curl_share_unlock(CURL_LOCK_DATA_CONNECT);
		} 
		return 0/* Return the first connection found in the cache. Used when closing all
		   connections.
		
		   NOTE: no locking is done here as this is presumably only done when cleaning
		   up a cache!
		*/;
	}
	public static void tool_help() {
		int i;
		.puts("Usage: curl [options...] <url>");
		for (i = 0; ModernizedCProgram.helptext[i].getOpt(); i++) {
			.printf(" %-19s %s\n", ModernizedCProgram.helptext[i].getOpt(), ModernizedCProgram.helptext[i].getDesc());
		}
	}
	public static int featcomp(Object p1, Object p2) {
		return .strcmp((byte)p1, (byte)p2);
	}
	/* The arguments to this function are "pointers to pointers to char", but
	     the comparison arguments are "pointers to char", hence the following cast
	     plus dereference */
	public static void tool_version_info() {
		byte proto;
		.printf("Release-Date: %s\n", LIBCURL_TIMESTAMP);
		if (ModernizedCProgram.curlinfo.getProtocols()) {
			.printf("Protocols: ");
			for (proto = ModernizedCProgram.curlinfo.getProtocols(); proto; ++proto) {
				.printf("%s ", proto);
			}
			.puts(/* newline */"");
		} 
		if (ModernizedCProgram.curlinfo.getFeatures()) {
			byte[] featp = new byte[ /  + 1];
			size_t numfeat = 0;
			int i;
			.printf("Features:");
			for (i = 0; i <  / ; i++) {
				if (ModernizedCProgram.curlinfo.getFeatures() & ModernizedCProgram.feats[i].getBitmask()) {
					featp[numfeat++] = (byte)ModernizedCProgram.feats[i].getName();
				} 
			}
			.qsort(featp[0], numfeat, , featcomp);
			for (i = 0; i < numfeat; i++) {
				.printf(" %s", featp[i]);
			}
			.puts(/* newline */"");
		} 
		if (.strcmp(LIBCURL_VERSION, ModernizedCProgram.curlinfo.getVersion())) {
			.printf("WARNING: curl and libcurl versions do not match. Functionality may be affected.\n");
		} 
	}
	public static void tool_list_engines() {
		Curl_easy curl_easy = new Curl_easy();
		 curl = curl_easy.curl_easy_init();
		curl_slist engines = ((Object)0);
		curl.curl_easy_getinfo(CURLINFO_SSL_ENGINES, /* Get the list of engines */engines);
		.puts("Build-time engines:");
		Object generatedCurl_slist = engines.getCurl_slist();
		if (engines) {
			for (; engines; engines = generatedCurl_slist) {
				.printf("  %s\n", generatedCurl_slist);
			}
		} else {
				.puts("  <none>");
		} 
		/* Cleanup the list of engines */engines.curl_slist_free_all();
		curl.curl_easy_cleanup();
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static void tool_go_sleep(long ms) {
		.Sleep(ms);
	}
	public static Object Curl_timeleft(Curl_easy data, curltime nowp,  duringconnect) {
		int timeout_set = 0;
		timediff_t timeout_ms = duringconnect ? 300000 : 0;
		curltime now = new curltime();
		Object generatedSet = data.getSet();
		if (generatedSet.getTimeout() > /* if a timeout is set, use the most restrictive one */0) {
			timeout_set |=  1;
		} 
		if (duringconnect && (generatedSet.getConnecttimeout() > 0)) {
			timeout_set |=  2;
		} 
		switch (timeout_set) {
		case 3:
				if (generatedSet.getTimeout() < generatedSet.getConnecttimeout()) {
					timeout_ms = generatedSet.getTimeout();
				} else {
						timeout_ms = generatedSet.getConnecttimeout();
				} 
				break;
		case 1:
				timeout_ms = generatedSet.getTimeout();
				break;
		case 2:
				timeout_ms = generatedSet.getConnecttimeout();
				break;
		default:
				if (!/* use the default */duringconnect/* if we're not during connect, there's no default timeout so if we're
				         at zero we better just return zero and not make it a negative number
				         by the math below */) {
					return 0;
				} 
				break;
		}
		curltime curltime = new curltime();
		if (!nowp) {
			now = curltime.Curl_now();
			nowp = now;
		} 
		Object generatedProgress = data.getProgress();
		if (/* subtract elapsed time */duringconnect) {
			timeout_ms -= nowp.Curl_timediff(generatedProgress.getT_startsingle());
		} else {
				timeout_ms -= nowp.Curl_timediff(generatedProgress.getT_startop());
		} 
		if (!timeout_ms) {
			return -/* avoid returning 0 as that means no timeout! */1;
		} 
		return timeout_ms;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <netinet/tcp.h> may need it */
	/* for sockaddr_un */
	/* for Curl_safefree() */
	/* required for Curl_sockaddr_storage */
	/* for Curl_ssl_check_cxn() */
	/* The last 3 #include files should be in this order */
	/* This isn't actually supported under Symbian OS */
	public static  verifyconnect(Object sockfd, int error) {
		bool rc = 1;
		int err = 0;
		 errSize = ;
		.SleepEx(0, 0);
		if (0 != .getsockopt(sockfd, -1024, -1024, (Object)err, errSize)) {
			err = ((int).WSAGetLastError());
		} 
		if ((0 == err) || (-1024 == /* Minix 3.1.x doesn't support getsockopt on UDP sockets */err)) {
			rc = /* we are connected, awesome! */1;
		} else {
				rc = /* This wasn't a successful connect */0;
		} 
		if (error) {
			error = err;
		} 
		return rc;
	}
	/* DragonFlyBSD and Windows use millisecond units */
	/* retrieves ip address and port from a sockaddr structure.
	   note it calls Curl_inet_ntop which sets errno on fail, not SOCKERRNO. */
	public static  Curl_addr2string(Object salen, Byte addr, long port) {
		sockaddr_in si = ((Object)0);
		(Object)salen;
		Object generatedSa_family = this.getSa_family();
		Object generatedSin_addr = si.getSin_addr();
		Object generatedSin_port = si.getSin_port();
		switch (generatedSa_family) {
		case 2:
				si = (sockaddr_in)(Object)sa;
				if (ModernizedCProgram.Curl_inet_ntop(generatedSa_family, generatedSin_addr, addr, )) {
					int us_port = .ntohs(generatedSin_port);
					port = us_port;
					return 1;
				} 
				break;
		default:
				break;
		}
		addr[0] = (byte)'\0';
		port = 0;
		(._errno()) = -1024;
		return 0;
	}
	/* When you run a program that uses the Windows Sockets API, you may
	   experience slow performance when you copy data to a TCP server.
	
	   https://support.microsoft.com/kb/823764
	
	   Work-around: Make the Socket Send Buffer Size Larger Than the Program Send
	   Buffer Size
	
	   The problem described in this knowledge-base is applied only to pre-Vista
	   Windows.  Following function trying to detect OS version and skips
	   SO_SNDBUF adjustment for Windows Vista and above.
	*/
	public static void Curl_sndbufset(Object sockfd) {
		int val = CURL_MAX_WRITE_SIZE + 32;
		int curval = 0;
		int curlen = ;
		int detectOsState = 0;
		if (detectOsState == 0) {
			if (ModernizedCProgram.Curl_verify_windows_version(6, 0, .PLATFORM_WINNT, .VERSION_GREATER_THAN_EQUAL)) {
				detectOsState = 2;
			} else {
					detectOsState = 1;
			} 
		} 
		if (detectOsState == 2) {
			return ;
		} 
		if (.getsockopt(sockfd, -1024, -1024, (byte)curval, curlen) == 0) {
			if (curval > val) {
				return ;
			} 
		} 
		.setsockopt(sockfd, -1024, -1024, (byte)val, );
	}
	public static Object Curl_getconnectinfo(Curl_easy data, connectdata connp) {
		do {
		} while (0/* this works for an easy handle:
		   * - that has been used for curl_easy_perform()
		   * - that is associated with a multi handle, and whose connection
		   *   was detached with CURLOPT_CONNECT_ONLY
		   */);
		Object generatedState = data.getState();
		Object generatedMulti_easy = data.getMulti_easy();
		Object generatedMulti = data.getMulti();
		 generatedFound = find.getFound();
		Object generatedSock = c.getSock();
		if (generatedState.getLastconnect() && (generatedMulti_easy || generatedMulti)) {
			connectdata c = generatedState.getLastconnect();
			connfind find = new connfind();
			find.setTofind(generatedState.getLastconnect());
			find.setFound(0);
			ModernizedCProgram.Curl_conncache_foreach(data, generatedMulti_easy ? generatedMulti_easy.getConn_cache() : generatedMulti.getConn_cache(), find, conn_is_conn);
			if (!generatedFound) {
				generatedState.setLastconnect(((Object)0));
				return CURL_SOCKET_BAD;
			} 
			if (connp) {
				connp = /* only store this if the caller cares for it */c;
				c.setData(data);
			} 
			return generatedSock[0];
		} else {
				return CURL_SOCKET_BAD/*
				 * Check if a connection seems to be alive.
				 */;
		} 
	}
	public static Object Curl_socket(connectdata conn, Object ai, Curl_sockaddr_ex addr, Object sockfd) {
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Curl_sockaddr_ex dummy = new Curl_sockaddr_ex();
		if (!addr) {
			addr = /* if the caller doesn't want info back, use a local temp copy */dummy/*
			   * The Curl_sockaddr_ex structure is basically libcurl's external API
			   * curl_sockaddr structure with enough space available to directly hold
			   * any protocol-specific address structures. The variable declared here
			   * will be used to pass / receive data to/from the fopensocket callback
			   * if this has been set, before that, it is initialized from parameters.
			   */;
		} 
		addr.setFamily(ai.getAi_family());
		 generatedTransport = conn.getTransport();
		addr.setSocktype((generatedTransport == .TRNSPRT_TCP) ? 1 : 2);
		addr.setProtocol(generatedTransport != .TRNSPRT_TCP ? 17 : ai.getAi_protocol());
		addr.setAddrlen(ai.getAi_addrlen());
		int generatedAddrlen = addr.getAddrlen();
		if (generatedAddrlen > ) {
			addr.setAddrlen();
		} 
		 generated_sa_ex_u = addr.get_sa_ex_u();
		Object generatedAddr = generated_sa_ex_u.getAddr();
		.memcpy(generatedAddr, ai.getAi_addr(), generatedAddrlen);
		Object generatedSet = data.getSet();
		int generatedFamily = addr.getFamily();
		int generatedSocktype = addr.getSocktype();
		int generatedProtocol = addr.getProtocol();
		if (generatedSet.getFopensocket()) {
			data.Curl_set_in_callback(.bool_true);
			sockfd = .UNRECOGNIZEDFUNCTIONNAME(generatedSet.getOpensocket_client(), CURLSOCKTYPE_IPCXN, (Object)addr);
			data.Curl_set_in_callback(.bool_false);
		} else {
				sockfd = .socket(generatedFamily, generatedSocktype, generatedProtocol);
		} 
		if (sockfd == CURL_SOCKET_BAD) {
			return /* no socket, no connection */CURLE_COULDNT_CONNECT;
		} 
		return CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Escape and unescape URL encoding in strings. The functions return a new
	 * allocated string or NULL if an error occurred.  */
	/* The last 3 #include files should be in this order */
	/* Portable character check (remember EBCDIC). Do not use isalnum() because
	   its behavior is altered by the current locale.
	   See https://tools.ietf.org/html/rfc3986#section-2.3
	*/
	public static  Curl_isunreserved(byte in) {
		switch (in) {
		case (byte)'t':
		case (byte)'p':
		case (byte)'Q':
		case (byte)'Z':
		case (byte)'e':
		case (byte)'x':
		case (byte)'o':
		case (byte)'d':
		case (byte)'6':
		case (byte)'b':
		case (byte)'9':
		case (byte)'-':
		case (byte)'m':
		case (byte)'v':
		case (byte)'A':
		case (byte)'i':
		case (byte)'I':
		case (byte)'R':
		case (byte)'L':
		case (byte)'C':
		case (byte)'D':
		case (byte)'1':
		case (byte)'~':
				return 1;
		case (byte)'G':
		case (byte)'W':
		case (byte)'U':
		case (byte)'_':
		case (byte)'P':
		case (byte)'F':
		case (byte)'Y':
		case (byte)'M':
		case (byte)'.':
		case (byte)'a':
		case (byte)'n':
		case (byte)'k':
		case (byte)'7':
		case (byte)'8':
		case (byte)'y':
		case (byte)'B':
		case (byte)'K':
		case (byte)'s':
		case (byte)'5':
		case (byte)'E':
		case (byte)'2':
		case (byte)'g':
		case (byte)'J':
		case (byte)'V':
		case (byte)'T':
		case (byte)'X':
		case (byte)'f':
		case (byte)'3':
		case (byte)'z':
		case (byte)'O':
		case (byte)'q':
		case (byte)'r':
		case (byte)'S':
		case (byte)'j':
		case (byte)'N':
		case (byte)'c':
		case (byte)'0':
		case (byte)'4':
		case (byte)'l':
		case (byte)'u':
		case (byte)'w':
		case (byte)'h':
		case (byte)'H':
		default:
				break;
		}
		return 0;
	}
	/* for ABI-compatibility with previous versions */
	public static Byte curl_escape(Object string, int inlength) {
		return ((Object)0).curl_easy_escape(string, inlength);
	}
	/* for ABI-compatibility with previous versions */
	public static Byte curl_unescape(Object string, int length) {
		return ((Object)0).curl_easy_unescape(string, length, ((Object)0));
	}
	public static void curl_free(Object p) {
		.Curl_cfree(p);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Import and export cookies with COOKIELIST.
	 * </DESC>
	 */
	public static void print_cookies(Object curl) {
		 res = new ();
		curl_slist cookies = new curl_slist();
		curl_slist nc = new curl_slist();
		int i;
		.printf("Cookies, curl knows:\n");
		res = curl.curl_easy_getinfo(CURLINFO_COOKIELIST, cookies);
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "Curl curl_easy_getinfo failed: %s\n", ModernizedCProgram.curl_easy_strerror(res));
			.exit(1);
		} 
		nc = cookies;
		i = 1;
		Object generatedCurl_slist = nc.getCurl_slist();
		while (nc) {
			.printf("[%d]: %s\n", i, generatedCurl_slist);
			nc = generatedCurl_slist;
			i++;
		}
		if (i == 1) {
			.printf("(none)\n");
		} 
		cookies.curl_slist_free_all();
	}
	/* curl_formget callback to count characters. */
	public static Object count_chars(Object userp, Object buf, Object len) {
		size_t pcounter = (size_t)userp;
		(Object)buf;
		pcounter += len;
		return len;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Show transfer timing info after download completes.
	 * </DESC>
	 */
	/* Example source code to show how the callback function can be used to
	 * download data into a chunk of memory instead of storing it in a file.
	 * After successful download we use curl_easy_getinfo() calls to get the
	 * amount of downloaded bytes, the time used for the whole download, and
	 * the average download speed.
	 * On Linux you can create the download test files with:
	 * dd if=/dev/urandom of=file_1M.bin bs=1M count=1
	 *
	 */
	public static Object WriteCallback(Object ptr, Object size, Object nmemb, Object data) {
		(Object)/* we are not interested in the downloaded bytes itself,
		     so we only return the size we would have saved ... *//* unused */ptr;
		(Object)/* unused */data;
		return (size_t)(size * nmemb);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Similar to ftpget.c but also stores the received response-lines
	 * in a separate file using our own callback!
	 * </DESC>
	 */
	public static Object write_response(Object ptr, Object size, Object nmemb, Object data) {
		FILE writehere = (FILE)data;
		return .fwrite(ptr, size, nmemb, writehere);
	}
	public static Object create_node() {
		ModernizedCProgram.data_key = ModernizedCProgram.curl_maprintf("%s:%d", "dummy", 0);
		if (!ModernizedCProgram.data_key) {
			return CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.data_node = .calloc(1, );
		if (!ModernizedCProgram.data_node) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Curl_addrinfo curl_addrinfo = new Curl_addrinfo();
		ModernizedCProgram.data_node.setAddr(curl_addrinfo.fake_ai());
		if (!ModernizedCProgram.data_node.getAddr()) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * one way to set the necessary OpenSSL locking callbacks if you want to do
	 * multi-threaded transfers with HTTPS/FTPS with libcurl built to use OpenSSL.
	 * </DESC>
	 */
	/*
	 * This is not a complete stand-alone example.
	 *
	 * Author: Jeremy Brown
	 */
	public static void handle_error(Object file, int lineno, Object msg) {
		.fprintf((_iob[2]), "** %s:%d %s\n", file, lineno, msg);
		.ERR_print_errors_fp((_iob[2/* exit(-1); */]));
	}
	public static void locking_function(int mode, int n, Object file, int line) {
		if (mode & CRYPTO_LOCK) {
			.pthread_mutex_lock((ModernizedCProgram.mutex_buf[n]));
		} else {
				.pthread_mutex_unlock((ModernizedCProgram.mutex_buf[n]));
		} 
	}
	public static long id_function() {
		return ((long).pthread_self());
	}
	public static int thread_setup() {
		int i;
		ModernizedCProgram.mutex_buf = .malloc(.CRYPTO_num_locks() * );
		if (!ModernizedCProgram.mutex_buf) {
			return 0;
		} 
		for (i = 0; i < .CRYPTO_num_locks(); i++) {
			.pthread_mutex_init((ModernizedCProgram.mutex_buf[i]), ((Object)0));
		}
		.CRYPTO_set_id_callback(id_function);
		.CRYPTO_set_locking_callback(locking_function);
		return 1;
	}
	public static int thread_cleanup() {
		int i;
		if (!ModernizedCProgram.mutex_buf) {
			return 0;
		} 
		.CRYPTO_set_id_callback(((Object)0));
		.CRYPTO_set_locking_callback(((Object)0));
		for (i = 0; i < .CRYPTO_num_locks(); i++) {
			.pthread_mutex_destroy((ModernizedCProgram.mutex_buf[i]));
		}
		.free(ModernizedCProgram.mutex_buf);
		ModernizedCProgram.mutex_buf = ((Object)0);
		return 1;
	}
	public static Object Curl_chunked_strerror( code) {
		switch (code) {
		case .CHUNKE_PASSTHRU_ERROR:
				do {
				} while (/* never used */0);
				return "";
		case .CHUNKE_BAD_ENCODING:
				return "Bad content-encoding found";
		case .CHUNKE_OUT_OF_MEMORY:
				return "Out of memory"/* CURL_DISABLE_HTTP */;
		case .CHUNKE_BAD_CHUNK:
				return "Malformed encoding found";
		case .CHUNKE_TOO_LONG_HEX:
				return "Too long hexadecimal number";
		case .CHUNKE_ILLEGAL_HEX:
				return "Illegal or missing hexadecimal sequence";
		default:
				return "OK";
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* This test case and code is based on the bug recipe Joe Malicki provided for
	 * bug report #1871269, fixed on Jan 14 2008 before the 7.18.0 release.
	 */
	public static Object myreadfunc(Object ptr, Object size, Object nmemb, Object stream) {
		size_t total = 40960;
		byte[] buf = new byte[1024];
		(Object)stream;
		.memset(buf, (byte)'A', );
		size *= nmemb;
		if (size > total) {
			size = total;
		} 
		if (size > ) {
			size = ;
		} 
		.memcpy(ptr, buf, size);
		total -= size;
		return size;
	}
	public static void resetdefaults() {
		ModernizedCProgram.logmsg("Reset to defaults");
		ModernizedCProgram.config.setVersion(5);
		ModernizedCProgram.config.setNmethods_min(1);
		ModernizedCProgram.config.setNmethods_max(3);
		ModernizedCProgram.config.setResponseversion(5);
		ModernizedCProgram.config.setResponsemethod(0);
		ModernizedCProgram.config.setReqcmd(1);
		ModernizedCProgram.config.setConnectrep(0);
		ModernizedCProgram.config.setPort(ModernizedCProgram.backendport);
		.strcpy(ModernizedCProgram.config.getAddr(), ModernizedCProgram.backendaddr);
		.strcpy(ModernizedCProgram.config.getUser(), "user");
		.strcpy(ModernizedCProgram.config.getPassword(), "password");
	}
	public static byte byteval(Byte value) {
		long num = .strtoul(value, ((Object)0), 10);
		return num & -1024;
	}
	public static int shortval(Byte value) {
		long num = .strtoul(value, ((Object)0), 10);
		return num & -1024;
	}
	public static void getconfig() {
		FILE fp = .fopen(ModernizedCProgram.configfile, "rt");
		ModernizedCProgram.resetdefaults();
		if (fp) {
			byte[] buffer = new byte[512];
			ModernizedCProgram.logmsg("parse config file");
			while (.fgets(ModernizedCProgram.buffer, , fp)) {
				byte[] key = new byte[32];
				byte[] value = new byte[32];
				if (2 == .sscanf(ModernizedCProgram.buffer, "%31s %31s", key, value)) {
					if (!.strcmp(key, "version")) {
						ModernizedCProgram.config.setVersion(ModernizedCProgram.byteval(value));
						ModernizedCProgram.logmsg("version [%d] set", ModernizedCProgram.config.getVersion());
					}  else if (!.strcmp(key, "nmethods_min")) {
						ModernizedCProgram.config.setNmethods_min(ModernizedCProgram.byteval(value));
						ModernizedCProgram.logmsg("nmethods_min [%d] set", ModernizedCProgram.config.getNmethods_min());
					}  else if (!.strcmp(key, "nmethods_max")) {
						ModernizedCProgram.config.setNmethods_max(ModernizedCProgram.byteval(value));
						ModernizedCProgram.logmsg("nmethods_max [%d] set", ModernizedCProgram.config.getNmethods_max());
					}  else if (!.strcmp(key, "backend")) {
						.strcpy(ModernizedCProgram.config.getAddr(), value);
						ModernizedCProgram.logmsg("backend [%s] set", ModernizedCProgram.config.getAddr());
					}  else if (!.strcmp(key, "backendport")) {
						ModernizedCProgram.config.setPort(ModernizedCProgram.shortval(value));
						ModernizedCProgram.logmsg("backendport [%d] set", ModernizedCProgram.config.getPort());
					}  else if (!.strcmp(key, "user")) {
						.strcpy(ModernizedCProgram.config.getUser(), value);
						ModernizedCProgram.logmsg("user [%s] set", ModernizedCProgram.config.getUser());
					}  else if (!.strcmp(key, "password")) {
						.strcpy(ModernizedCProgram.config.getPassword(), value);
						ModernizedCProgram.logmsg("password [%s] set", ModernizedCProgram.config.getPassword());
					}  else if (!.strcmp(key, "method")) {
						ModernizedCProgram.config.setResponsemethod(ModernizedCProgram.byteval(value));
						ModernizedCProgram.logmsg("method [%d] set", ModernizedCProgram.config.getResponsemethod());
					}  else if (!.strcmp(key, "response")) {
						ModernizedCProgram.config.setConnectrep(ModernizedCProgram.byteval(value));
						ModernizedCProgram.logmsg("response [%d] set", ModernizedCProgram.config.getConnectrep());
					} 
				} 
			}
			.fclose(fp/* do-nothing macro replacement for systems which lack siginterrupt() */);
		} 
	}
	public static void loghex(Byte buffer, Object len) {
		byte[] data = new byte[1200];
		ssize_t i = new ssize_t();
		byte ptr = buffer;
		byte optr = data;
		ssize_t width = 0;
		int left = ;
		for (i = 0; i < len && (left >= 0); i++) {
			ModernizedCProgram.curl_msnprintf(optr, left, "%02x", ptr[i]);
			width += 2;
			optr += 2;
			left -= 2;
		}
		if (width) {
			ModernizedCProgram.logmsg("'%s'", data/* RFC 1928, SOCKS5 byte index *//* number of methods that is listed *//* in the request: */);
		} 
	}
	/* connect response */
	/* auth request */
	/* connect to a given IPv4 address, not the one asked for */
	public static Object socksconnect(int connectport, Object connectaddr) {
		int rc;
		srvr_sockaddr_union_t me = new srvr_sockaddr_union_t();
		 sock = .socket(2, 1, 0);
		if (sock == CURL_SOCKET_BAD) {
			return CURL_SOCKET_BAD;
		} 
		Object generatedSa4 = me.getSa4();
		.memset(generatedSa4, 0, );
		generatedSa4.setSin_family(2);
		generatedSa4.setSin_port(.htons(connectport));
		generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
		ModernizedCProgram.Curl_inet_pton(2, connectaddr, generatedSa4.getSin_addr());
		Object generatedSa = me.getSa();
		rc = .connect(sock, generatedSa, );
		if (rc) {
			int error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error connecting to %s:%hu: (%d) %s", connectaddr, connectport, error, .strerror(error));
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Connected fine to %s:%d", connectaddr, connectport);
		return sock;
	}
	public static Object socks4(Object fd, Byte buffer, Object rc) {
		byte[] response = new byte[256 + 16];
		 connfd = new ();
		byte cd;
		int s4port;
		if (buffer[1] != 1) {
			ModernizedCProgram.logmsg("SOCKS4 CD is not 1: %d", buffer[1]);
			return CURL_SOCKET_BAD;
		} 
		if (rc < 9) {
			ModernizedCProgram.logmsg("SOCKS4 connect message too short: %d", rc);
			return CURL_SOCKET_BAD;
		} 
		if (!ModernizedCProgram.config.getPort()) {
			s4port = (int)((buffer[2] << 8) | (buffer[2 + 1]));
		} else {
				s4port = ModernizedCProgram.config.getPort();
		} 
		connfd = ModernizedCProgram.socksconnect(s4port, ModernizedCProgram.config.getAddr());
		if (connfd == CURL_SOCKET_BAD) {
			cd = /* failed */91;
		} else {
				cd = /* success */90;
		} 
		response[0] = /* reply version 0 */0;
		response[1] = /* result */cd;
		.memcpy(response[2], buffer[2], /* copy port and address from connect request */6);
		rc = .UNRECOGNIZEDFUNCTIONNAME(fd, (byte)response, 8, 0);
		if (rc != 8) {
			ModernizedCProgram.logmsg("Sending SOCKS4 response failed!");
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Sent %d bytes", rc);
		ModernizedCProgram.loghex(response, rc);
		if (cd == 90) {
			return /* now do the transfer */connfd;
		} 
		if (connfd != CURL_SOCKET_BAD) {
			.closesocket((connfd));
		} 
		return CURL_SOCKET_BAD;
	}
	public static Object sockit(Object fd) {
		byte[] buffer = new byte[256 + 16];
		byte[] response = new byte[256 + 16];
		ssize_t rc = new ssize_t();
		byte len;
		byte type;
		byte rep = 0;
		byte address;
		int socksport;
		 connfd = CURL_SOCKET_BAD;
		int s5port;
		ModernizedCProgram.getconfig();
		rc = .recv(fd, (byte)buffer, , 0);
		ModernizedCProgram.logmsg("READ %d bytes", rc);
		ModernizedCProgram.loghex(buffer, rc);
		if (buffer[0] == 4) {
			return ModernizedCProgram.socks4(fd, buffer, rc);
		} 
		if (buffer[0] != ModernizedCProgram.config.getVersion()) {
			ModernizedCProgram.logmsg("VERSION byte not %d", ModernizedCProgram.config.getVersion());
			return CURL_SOCKET_BAD;
		} 
		if ((buffer[1] < ModernizedCProgram.config.getNmethods_min()) || (buffer[1] > ModernizedCProgram.config.getNmethods_max())) {
			ModernizedCProgram.logmsg("NMETHODS byte not within %d - %d ", ModernizedCProgram.config.getNmethods_min(), ModernizedCProgram.config.getNmethods_max());
			return CURL_SOCKET_BAD;
		} 
		if (rc != (buffer[1] + /* after NMETHODS follows that many bytes listing the methods the client
		     says it supports */2)) {
			ModernizedCProgram.logmsg("Expected %d bytes, got %d", buffer[1] + 2, rc);
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Incoming request deemed fine!");
		response[0] = ModernizedCProgram.config.getResponseversion();
		response[1] = ModernizedCProgram.config.getResponsemethod();
		rc = .UNRECOGNIZEDFUNCTIONNAME(fd, (byte)response, 2, 0);
		if (rc != 2) {
			ModernizedCProgram.logmsg("Sending response failed!");
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Sent %d bytes", rc);
		ModernizedCProgram.loghex(response, rc);
		rc = .recv(fd, (byte)buffer, , /* expect the request or auth */0);
		ModernizedCProgram.logmsg("READ %d bytes", rc);
		ModernizedCProgram.loghex(buffer, rc);
		if (ModernizedCProgram.config.getResponsemethod() == 2/* RFC 1929 authentication
		       +----+------+----------+------+----------+
		       |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
		       +----+------+----------+------+----------+
		       | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
		       +----+------+----------+------+----------+
		    */) {
			byte ulen;
			byte plen;
			bool login = 1;
			if (rc < 5) {
				ModernizedCProgram.logmsg("Too short auth input: %d", rc);
				return CURL_SOCKET_BAD;
			} 
			if (buffer[0] != 1) {
				ModernizedCProgram.logmsg("Auth VERSION byte not 1, got %d", buffer[0]);
				return CURL_SOCKET_BAD;
			} 
			ulen = buffer[1];
			if (rc < 4 + ulen) {
				ModernizedCProgram.logmsg("Too short packet for username: %d", rc);
				return CURL_SOCKET_BAD;
			} 
			plen = buffer[1 + ulen + 1];
			if (rc < 3 + ulen + plen) {
				ModernizedCProgram.logmsg("Too short packet for ulen %d plen %d: %d", ulen, plen, rc);
				return CURL_SOCKET_BAD;
			} 
			if ((ulen != .strlen(ModernizedCProgram.config.getUser())) || (plen != .strlen(ModernizedCProgram.config.getPassword())) || .memcmp(buffer[2], ModernizedCProgram.config.getUser(), ulen) || .memcmp(buffer[2 + ulen + 1], ModernizedCProgram.config.getPassword(), plen)) {
				ModernizedCProgram.logmsg(/* no match! */"mismatched credentials!");
				ModernizedCProgram.login = 0;
			} 
			response[0] = 1;
			response[1] = ModernizedCProgram.login ? 0 : 1;
			rc = .UNRECOGNIZEDFUNCTIONNAME(fd, (byte)response, 2, 0);
			if (rc != 2) {
				ModernizedCProgram.logmsg("Sending auth response failed!");
				return CURL_SOCKET_BAD;
			} 
			ModernizedCProgram.logmsg("Sent %d bytes", rc);
			ModernizedCProgram.loghex(response, rc);
			if (!ModernizedCProgram.login) {
				return CURL_SOCKET_BAD;
			} 
			rc = .recv(fd, (byte)buffer, , /* expect the request */0);
			ModernizedCProgram.logmsg("READ %d bytes", rc);
			ModernizedCProgram.loghex(buffer, rc);
		} 
		if (rc < 6) {
			ModernizedCProgram.logmsg("Too short for request: %d", rc);
			return CURL_SOCKET_BAD;
		} 
		if (buffer[0] != ModernizedCProgram.config.getVersion()) {
			ModernizedCProgram.logmsg("Request VERSION byte not %d", ModernizedCProgram.config.getVersion());
			return CURL_SOCKET_BAD;
		} 
		if (buffer[1] != ModernizedCProgram.config.getReqcmd()) {
			ModernizedCProgram.logmsg("Request COMMAND byte not %d", ModernizedCProgram.config.getReqcmd());
			return CURL_SOCKET_BAD;
		} 
		if (buffer[2] != /* reserved, should be zero */0) {
			ModernizedCProgram.logmsg("Request COMMAND byte not %d", ModernizedCProgram.config.getReqcmd());
			return CURL_SOCKET_BAD/* ATYP:
			     o  IP V4 address: X'01'
			     o  DOMAINNAME: X'03'
			     o  IP V6 address: X'04'
			  */;
		} 
		type = buffer[3];
		address = buffer[4];
		switch (type) {
		case 3/* The first octet of the address field contains the number of octets of
		       name that follow */:
				len = buffer[4];
				len++;
				break;
		case 4:
				len = /* 16 bytes IPv6 address */16;
				break;
		case 1:
				len = /* 4 bytes IPv4 address */4;
				break;
		default:
				ModernizedCProgram.logmsg("Unknown ATYP %d", type);
				return CURL_SOCKET_BAD;
		}
		if (rc < (4 + len + 2)) {
			ModernizedCProgram.logmsg("Request too short: %d, expected %d", rc, 4 + len + 2);
			return CURL_SOCKET_BAD;
		} 
		if (!ModernizedCProgram.config.getPort()) {
			byte portp = buffer[4 + len];
			s5port = (int)((portp[0] << 8) | (portp[1]));
		} else {
				s5port = ModernizedCProgram.config.getPort();
		} 
		if (!ModernizedCProgram.config.getConnectrep()) {
			connfd = ModernizedCProgram.socksconnect(s5port, ModernizedCProgram.config.getAddr());
		} 
		if (connfd == CURL_SOCKET_BAD) {
			rep = /* failed */1;
		} else {
				rep = ModernizedCProgram.config.getConnectrep();
		} 
		response[0] = ModernizedCProgram.config.getResponseversion();
		response[1] = rep;
		response[2] = /* must be zero */0;
		response[3] = /* address type */type/* mirror back the original addr + port */;
		.memcpy(response[4], address, /* address or hostname */len);
		.memcpy(response[4 + /* port number */len], buffer[4 + len], );
		rc = .UNRECOGNIZEDFUNCTIONNAME(fd, (byte)response, len + 6, 0);
		if (rc != (len + 6)) {
			ModernizedCProgram.logmsg("Sending connect response failed!");
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("Sent %d bytes", rc);
		ModernizedCProgram.loghex(response, rc);
		if (!rep) {
			return connfd;
		} 
		if (connfd != CURL_SOCKET_BAD) {
			.closesocket((connfd));
		} 
		return CURL_SOCKET_BAD;
	}
	/* return non-zero when transfer is done */
	public static int tunnel(perclient cp, fd_set fds) {
		ssize_t nread = new ssize_t();
		ssize_t nwrite = new ssize_t();
		byte[] buffer = new byte[512];
		Object generatedClientfd = cp.getClientfd();
		Object generatedRemotefd = cp.getRemotefd();
		Object generatedFromclient = cp.getFromclient();
		if (.__WSAFDIsSet((SOCKET)(generatedClientfd), (fd_set)(fds))) {
			nread = .recv(generatedClientfd, buffer, , /* read from client, send to remote */0);
			if (nread > 0) {
				nwrite = .send(generatedRemotefd, (byte)buffer, (int)nread, 0);
				if (nwrite != nread) {
					return 1;
				} 
				generatedFromclient += nwrite;
			} else {
					return 1;
			} 
		} 
		Object generatedFromremote = cp.getFromremote();
		if (.__WSAFDIsSet((SOCKET)(generatedRemotefd), (fd_set)(fds))) {
			nread = .recv(generatedRemotefd, buffer, , /* read from remote, send to client */0);
			if (nread > 0) {
				nwrite = .send(generatedClientfd, (byte)buffer, (int)nread, 0);
				if (nwrite != nread) {
					return 1;
				} 
				generatedFromremote += nwrite;
			} else {
					return 1;
			} 
		} 
		return 0/*
		  sockfdp is a pointer to an established stream or CURL_SOCKET_BAD
		
		  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
		  accept()
		*/;
	}
	public static  incoming(Object listenfd) {
		fd_set fds_read = new fd_set();
		fd_set fds_write = new fd_set();
		fd_set fds_err = new fd_set();
		int clients = /* connected clients */0;
		perclient[] c = new perclient();
		.memset(c, 0, );
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("signalled to die, exiting...");
			return 0/* As a last resort, quit if socks5 process becomes orphan. */;
		} 
		 generatedUsed = cp.getUsed();
		Object generatedFromremote = cp.getFromremote();
		Object generatedFromclient = cp.getFromclient();
		Object generatedClientfd = cp.getClientfd();
		Object generatedRemotefd = cp.getRemotefd();
		do {
			int i;
			ssize_t rc = new ssize_t();
			int error = 0;
			 sockfd = listenfd;
			int maxfd = (int)sockfd;
			(((fd_set)(fds_read)).setFd_count(0));
			(((fd_set)(fds_write)).setFd_count(0));
			(((fd_set)(fds_err)).setFd_count(0));
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
					if (((fd_set)(fds_read)).getFd_array()[__i] == (sockfd)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_read)).getFd_count()) {
					if (((fd_set)(fds_read)).getFd_count() < 64) {
						((fd_set)(fds_read)).getFd_array()[__i] = (sockfd);
						((fd_set)(fds_read)).getFd_count()++;
					} 
				} 
			} while (/* there's always a socket to wait for */0);
			for (i = 0; i < 2; i++) {
				if (c[i].getUsed()) {
					 fd = c[i].getClientfd();
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
							if (((fd_set)(fds_read)).getFd_array()[__i] == (fd)) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_read)).getFd_count()) {
							if (((fd_set)(fds_read)).getFd_count() < 64) {
								((fd_set)(fds_read)).getFd_array()[__i] = (fd);
								((fd_set)(fds_read)).getFd_count()++;
							} 
						} 
					} while (0);
					if ((int)fd > maxfd) {
						maxfd = (int)fd;
					} 
					fd = c[i].getRemotefd();
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
							if (((fd_set)(fds_read)).getFd_array()[__i] == (fd)) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_read)).getFd_count()) {
							if (((fd_set)(fds_read)).getFd_count() < 64) {
								((fd_set)(fds_read)).getFd_array()[__i] = (fd);
								((fd_set)(fds_read)).getFd_count()++;
							} 
						} 
					} while (0);
					if ((int)fd > maxfd) {
						maxfd = (int)fd;
					} 
				} 
			}
			do {
				rc = .select(maxfd + 1, fds_read, fds_write, fds_err, ((Object)/* select() blocking behavior call on blocking descriptors please */0));
				if (ModernizedCProgram.got_exit_signal) {
					ModernizedCProgram.logmsg("signalled to die, exiting...");
					return 0;
				} 
			} while ((rc == -1) && ((error = (._errno())) == 4));
			if (rc < 0) {
				ModernizedCProgram.logmsg("select() failed with error: (%d) %s", error, .strerror(error));
				return 0;
			} 
			if ((clients < 2) && .__WSAFDIsSet((SOCKET)(sockfd), (fd_set)(fds_read))) {
				 newfd = .accept(sockfd, ((Object)0), ((Object)0));
				if (CURL_SOCKET_BAD == newfd) {
					error = ((int).WSAGetLastError());
					ModernizedCProgram.logmsg("accept(%d, NULL, NULL) failed with error: (%d) %s", sockfd, error, .strerror(error));
				} else {
						 remotefd = new ();
						ModernizedCProgram.logmsg("====> Client connect, fd %d. Read config from %s", newfd, ModernizedCProgram.configfile);
						remotefd = ModernizedCProgram.sockit(/* SOCKS until done */newfd);
						if (remotefd == CURL_SOCKET_BAD) {
							ModernizedCProgram.logmsg("====> Client disconnect");
							.closesocket((newfd));
						} else {
								perclient cp = c[0];
								ModernizedCProgram.logmsg("====> Tunnel transfer");
								if (c[0].getUsed()) {
									cp = c[1];
								} 
								cp.setFromremote(0);
								cp.setFromclient(0);
								cp.setClientfd(newfd);
								cp.setRemotefd(remotefd);
								cp.setUsed(1);
								clients++;
						} 
				} 
			} 
			for (i = 0; i < 2; i++) {
				perclient cp = c[i];
				if (generatedUsed) {
					if (ModernizedCProgram.tunnel(cp, fds_read)) {
						ModernizedCProgram.logmsg("SOCKS transfer completed. Bytes: < %zu > %zu", generatedFromremote, generatedFromclient);
						.closesocket((generatedClientfd));
						.closesocket((generatedRemotefd));
						cp.setUsed(0);
						clients--;
					} 
				} 
			}
		} while (clients);
		return 1;
	}
	public static Object sockdaemon(Object sock, int listenport) {
		/* passive daemon style */srvr_sockaddr_union_t listener = new srvr_sockaddr_union_t();
		int flag;
		int rc;
		int totdelay = 0;
		int maxretr = 10;
		int delay = 20;
		int attempt = 0;
		int error = 0;
		do {
			attempt++;
			flag = 1;
			rc = .setsockopt(sock, -1024, 4, (Object)flag, );
			if (rc) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed with error: (%d) %s", error, .strerror(error));
				if (maxretr) {
					rc = ModernizedCProgram.wait_ms(delay);
					if (rc) {
						error = (._errno());
						ModernizedCProgram.logmsg("wait_ms() failed with error: (%d) %s", error, .strerror(error));
						.closesocket((sock));
						return CURL_SOCKET_BAD;
					} 
					if (ModernizedCProgram.got_exit_signal) {
						ModernizedCProgram.logmsg("signalled to die, exiting...");
						.closesocket((sock));
						return CURL_SOCKET_BAD;
					} 
					totdelay += delay;
					delay *= /* double the sleep for next attempt */2;
				} 
			} 
		} while (rc && maxretr--);
		if (rc) {
			ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed %d times in %d ms. Error: (%d) %s", attempt, totdelay, error, .strerror(error));
			ModernizedCProgram.logmsg("Continuing anyway..."/* When the specified listener port is zero, it is actually a
			     request to let the system choose a non-zero available port. */);
		} 
		Object generatedSa4 = listener.getSa4();
		.memset(generatedSa4, 0, );
		generatedSa4.setSin_family(2);
		generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
		generatedSa4.setSin_port(.htons(listenport));
		Object generatedSa = listener.getSa();
		rc = .bind(sock, generatedSa, );
		if (/* ENABLE_IPV6 */rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error binding socket on port %hu: (%d) %s", listenport, error, .strerror(error));
			.closesocket((sock));
			return CURL_SOCKET_BAD;
		} 
		if (!listenport/* The system was supposed to choose a port number, figure out which
		       port we actually got and update the listener port value with it. */) {
			 la_size = new ();
			srvr_sockaddr_union_t localaddr = new srvr_sockaddr_union_t();
			la_size = ;
			.memset(generatedSa, 0, (size_t)la_size);
			if (.getsockname(sock, generatedSa, la_size) < 0) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("getsockname() failed with error: (%d) %s", error, .strerror(error));
				.closesocket((sock));
				return CURL_SOCKET_BAD;
			} 
			switch (generatedSa.getSa_family()) {
			case 2:
					listenport = .ntohs(generatedSa4.getSin_port());
					break;
			default:
					break;
			}
			if (!listenport) {
				ModernizedCProgram.logmsg(/* Real failure, listener port shall not be zero beyond this point. */"Apparently getsockname() succeeded, with listener port zero.");
				ModernizedCProgram.logmsg("A valid reason for this failure is a binary built without");
				ModernizedCProgram.logmsg("proper network library linkage. This might not be the only");
				ModernizedCProgram.logmsg("reason, but double check it before anything else.");
				.closesocket((sock));
				return CURL_SOCKET_BAD;
			} 
		} 
		rc = .listen(sock, /* start accepting connections */5);
		if (0 != rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("listen(%d, 5) failed with error: (%d) %s", sock, error, .strerror(error));
			.closesocket((sock));
			return CURL_SOCKET_BAD;
		} 
		return sock;
		/* passive daemon style */srvr_sockaddr_union_t listener = new srvr_sockaddr_union_t();
		int flag;
		int rc;
		int totdelay = 0;
		int maxretr = 10;
		int delay = 20;
		int attempt = 0;
		int error = 0;
		do {
			attempt++;
			flag = 1;
			rc = .setsockopt(sock, -1024, 4, (Object)flag, );
			if (rc) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed with error: (%d) %s", error, .strerror(error));
				if (maxretr) {
					rc = ModernizedCProgram.wait_ms(delay);
					if (rc) {
						error = (._errno());
						ModernizedCProgram.logmsg("wait_ms() failed with error: (%d) %s", error, .strerror(error));
						.closesocket((sock));
						return CURL_SOCKET_BAD;
					} 
					if (ModernizedCProgram.got_exit_signal) {
						ModernizedCProgram.logmsg("signalled to die, exiting...");
						.closesocket((sock));
						return CURL_SOCKET_BAD;
					} 
					totdelay += delay;
					delay *= /* double the sleep for next attempt */2;
				} 
			} 
		} while (rc && maxretr--);
		if (rc) {
			ModernizedCProgram.logmsg("setsockopt(SO_REUSEADDR) failed %d times in %d ms. Error: (%d) %s", attempt, totdelay, error, .strerror(error));
			ModernizedCProgram.logmsg("Continuing anyway..."/* When the specified listener port is zero, it is actually a
			     request to let the system choose a non-zero available port. */);
		} 
		Object generatedSa4 = listener.getSa4();
		.memset(generatedSa4, 0, );
		generatedSa4.setSin_family(2);
		generatedSa4.getSin_addr().getS_un().setS_addr((u_long)0);
		generatedSa4.setSin_port(.htons(listenport));
		Object generatedSa = listener.getSa();
		rc = .bind(sock, generatedSa, );
		if (/* ENABLE_IPV6 */rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error binding socket on port %hu: (%d) %s", listenport, error, .strerror(error));
			.closesocket((sock));
			return CURL_SOCKET_BAD;
		} 
		if (!listenport/* The system was supposed to choose a port number, figure out which
		       port we actually got and update the listener port value with it. */) {
			 la_size = new ();
			srvr_sockaddr_union_t localaddr = new srvr_sockaddr_union_t();
			la_size = ;
			.memset(generatedSa, 0, (size_t)la_size);
			if (.getsockname(sock, generatedSa, la_size) < 0) {
				error = ((int).WSAGetLastError());
				ModernizedCProgram.logmsg("getsockname() failed with error: (%d) %s", error, .strerror(error));
				.closesocket((sock));
				return CURL_SOCKET_BAD;
			} 
			switch (generatedSa.getSa_family()) {
			case 2:
					listenport = .ntohs(generatedSa4.getSin_port());
					break;
			default:
					break;
			}
			if (!listenport) {
				ModernizedCProgram.logmsg(/* Real failure, listener port shall not be zero beyond this point. */"Apparently getsockname() succeeded, with listener port zero.");
				ModernizedCProgram.logmsg("A valid reason for this failure is a binary built without");
				ModernizedCProgram.logmsg("proper network library linkage. This might not be the only");
				ModernizedCProgram.logmsg("reason, but double check it before anything else.");
				.closesocket((sock));
				return CURL_SOCKET_BAD;
			} 
		} 
		if (/* bindonly option forces no listening */ModernizedCProgram.bind_only) {
			ModernizedCProgram.logmsg("instructed to bind port without listening");
			return sock;
		} 
		rc = .listen(sock, /* start accepting connections */5);
		if (0 != rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("listen(%d, 5) failed with error: (%d) %s", sock, error, .strerror(error));
			.closesocket((sock));
			return CURL_SOCKET_BAD;
		} 
		return sock;
	}
	public static Object custom_calloc(Object nmemb, Object size) {
		if (!ModernizedCProgram.seen_calloc) {
			ModernizedCProgram.curl_mprintf("seen custom_calloc()\n");
			ModernizedCProgram.seen_calloc = 1;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(nmemb, size);
	}
	public static Object custom_malloc(Object size) {
		if (!ModernizedCProgram.seen_malloc && ModernizedCProgram.seen_calloc) {
			ModernizedCProgram.curl_mprintf("seen custom_malloc()\n");
			ModernizedCProgram.seen_malloc = 1;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(size);
	}
	public static Byte custom_strdup(Object ptr) {
		if (!ModernizedCProgram.seen_strdup && ModernizedCProgram.seen_malloc/* currently (2013.03.13), memory tracking enabled builds do not call
		       the strdup callback, in this case malloc callback and memcpy are used
		       instead. If some day this is changed the following printf() should be
		       uncommented, and a line added to test definition.
		    printf("seen custom_strdup()\n");
		    */) {
			ModernizedCProgram.seen_strdup = 1;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(ptr);
	}
	public static Object custom_realloc(Object ptr, Object size) {
		if (!ModernizedCProgram.seen_realloc && ModernizedCProgram.seen_malloc) {
			ModernizedCProgram.curl_mprintf("seen custom_realloc()\n");
			ModernizedCProgram.seen_realloc = 1;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(ptr, size);
	}
	public static void custom_free(Object ptr) {
		if (!ModernizedCProgram.seen_free && ModernizedCProgram.seen_realloc) {
			ModernizedCProgram.curl_mprintf("seen custom_free()\n");
			ModernizedCProgram.seen_free = 1;
		} 
		.UNRECOGNIZEDFUNCTIONNAME(ptr);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/***********************************************************************
	 * Only for builds using asynchronous name resolves
	 **********************************************************************/
	/* The last #include file should be: */
	/*
	 * Curl_addrinfo_callback() gets called by ares, gethostbyname_thread()
	 * or getaddrinfo_thread() when we got the name resolved (or not!).
	 *
	 * If the status argument is CURL_ASYNC_SUCCESS, this function takes
	 * ownership of the Curl_addrinfo passed, storing the resolved data
	 * in the DNS cache.
	 *
	 * The storage operation locks and unlocks the DNS cache.
	 */
	public static Object Curl_addrinfo_callback(connectdata conn, int status, Curl_addrinfo ai) {
		Curl_dns_entry dns = ((Object)0);
		 result = CURLE_OK;
		Curl_async generatedAsync = conn.getAsync();
		generatedAsync.setStatus(status);
		Curl_easy generatedData = conn.getData();
		Byte generatedHostname = generatedAsync.getHostname();
		int generatedPort = generatedAsync.getPort();
		Curl_dns_entry curl_dns_entry = new Curl_dns_entry();
		if (CURLE_OK == status) {
			if (ai) {
				Curl_easy data = generatedData;
				if (ModernizedCProgram.data.getShare()) {
					ModernizedCProgram.data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
				} 
				dns = curl_dns_entry.Curl_cache_addr(ModernizedCProgram.data, ai, generatedHostname, generatedPort);
				if (ModernizedCProgram.data.getShare()) {
					ModernizedCProgram.data.Curl_share_unlock(CURL_LOCK_DATA_DNS);
				} 
				if (!dns) {
					/* failed to store, cleanup and return error */ai.Curl_freeaddrinfo();
					result = CURLE_OUT_OF_MEMORY;
				} 
			} else {
					result = CURLE_OUT_OF_MEMORY;
			} 
		} 
		generatedAsync.setDns(dns/* Set async.done TRUE last in this function since it may be used multi-
		    threaded and once this is TRUE the other thread may read fields from the
		    async struct */);
		generatedAsync.setDone(1);
		return /* IPv4: The input hostent struct will be freed by ares when we return from
		     this function */result/*
		 * Curl_getaddrinfo() is the generic low-level name resolve API within this
		 * source file. There are several versions of this function - for different
		 * name resolve layers (selected at build-time). They all take this same set
		 * of arguments
		 */;
	}
	public static int Curl_isspace(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & (1 << 3));
	}
	public static int Curl_isdigit(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & (1 << 2));
	}
	public static int Curl_isalnum(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 0) | (1 << 1)));
	}
	public static int Curl_isxdigit(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6)));
	}
	public static int Curl_isgraph(int c) {
		if ((c < 0) || (c >= -1024) || (c == (byte)' ')) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6) | (1 << 0) | (1 << 1) | (1 << 4) | (1 << 3)));
	}
	public static int Curl_isprint(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6) | (1 << 0) | (1 << 1) | (1 << 4) | (1 << 3)));
	}
	public static int Curl_isalpha(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 0) | (1 << 1)));
	}
	public static int Curl_isupper(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 0)));
	}
	public static int Curl_islower(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 1)));
	}
	public static int Curl_iscntrl(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 5/* !CURL_DOES_CONVERSIONS */)));
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static void show_dir_errno(Object name) {
		switch ((._errno())) {
		case -1024:
				ModernizedCProgram.errors.curl_mfprintf("Cannot create directory %s because you exceeded your quota.\n", name);
				break;
		case 13:
				ModernizedCProgram.errors.curl_mfprintf("You don't have permission to create %s.\n", name);
				break;
		case 30:
				ModernizedCProgram.errors.curl_mfprintf("%s resides on a read-only file system.\n", name);
				break;
		case 38:
				ModernizedCProgram.errors.curl_mfprintf("The directory name %s is too long.\n", name);
				break;
		case 28:
				ModernizedCProgram.errors.curl_mfprintf("No space left on the file system that will contain the directory %s.\n", name);
				break;
		default:
				ModernizedCProgram.errors.curl_mfprintf("Error creating directory %s.\n", name);
				break;
		}
	}
	/* systems that may use either or when specifying a path */
	public static Object create_dir_hierarchy(Object outfile) {
		byte tempdir;
		byte tempdir2;
		byte outdup;
		byte dirbuildup;
		 result = CURLE_OK;
		size_t outlen = new size_t();
		outlen = .strlen(outfile);
		outdup = .strdup(outfile);
		if (!outdup) {
			return CURLE_OUT_OF_MEMORY;
		} 
		dirbuildup = .malloc(outlen + 1);
		if (!dirbuildup) {
			do {
				.free((outdup));
				(outdup) = ((Object)0);
			} while (0);
			return CURLE_OUT_OF_MEMORY;
		} 
		dirbuildup[0] = (byte)'\0';
		tempdir = .strtok(outdup, /* Allow strtok() here since this isn't used threaded *//* !checksrc! disable BANNEDFUNC 2 */"\\/");
		while (tempdir != ((Object)0)) {
			tempdir2 = .strtok(((Object)0), "\\/"/* since strtok returns a token for the last word even
			       if not ending with DIR_CHAR, we need to prune it */);
			if (tempdir2 != ((Object)0)) {
				size_t dlen = .strlen(dirbuildup);
				if (dlen) {
					ModernizedCProgram.curl_msnprintf(dirbuildup[dlen], outlen - dlen, "%s%s", "\\", tempdir);
				} else {
						if (outdup == tempdir) {
							.strcpy(dirbuildup, /* the output string doesn't start with a separator */tempdir);
						} else {
								ModernizedCProgram.curl_msnprintf(dirbuildup, outlen, "%s%s", "\\", tempdir);
						} 
				} 
				if ((-1 == .UNRECOGNIZEDFUNCTIONNAME((dirbuildup))) && ((._errno()) != 17)) {
					ModernizedCProgram.errors.show_dir_errno(dirbuildup);
					result = CURLE_WRITE_ERROR;
					break;
				} 
			} 
			tempdir = tempdir2;
		}
		do {
			.free((dirbuildup));
			(dirbuildup) = ((Object)0);
		} while (0);
		do {
			.free((outdup));
			(outdup) = ((Object)0);
		} while (0);
		return result;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2015, Steve Holme, <steve_holme@hotmail.com>.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_des_set_odd_parity()
	 *
	 * This is used to apply odd parity to the given byte array. It is typically
	 * used by when a cryptography engines doesn't have it's own version.
	 *
	 * The function is a port of the Java based oddParity() function over at:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 *
	 * Parameters:
	 *
	 * bytes       [in/out] - The data whose parity bits are to be adjusted for
	 *                        odd parity.
	 * len         [out]    - The length of the data.
	 */
	public static void Curl_des_set_odd_parity(Byte bytes, Object len) {
		size_t i = new size_t();
		for (i = 0; i < len; i++) {
			byte b = bytes[i];
			bool needs_parity = (((b >> 7) ^ (b >> 6) ^ (b >> 5) ^ (b >> 4) ^ (b >> 3) ^ (b >> 2) ^ (b >> 1)) & -1024) == 0;
			if (needs_parity) {
				bytes[i] |=  -1024;
			} else {
					bytes[i] &=  -1024/* USE_NTLM && !USE_OPENSSL */;
			} 
		}
	}
	public static int once(Byte URL,  oldstyle) {
		 curl = new ();
		 res = CURLE_OK;
		 formrc = new ();
		curl_httppost formpost = ((Object)0);
		curl_httppost lastptr = ((Object)0);
		WriteThis pooh = new WriteThis();
		WriteThis pooh2 = new WriteThis();
		pooh.setReadptr(ModernizedCProgram.data);
		pooh.setSizeleft(.strlen(ModernizedCProgram.data));
		Object generatedSizeleft = pooh.getSizeleft();
		if (/* Fill in the file upload field */oldstyle) {
			formrc = formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "sendfile", CURLFORM_STREAM, pooh, CURLFORM_CONTENTSLENGTH, (long)generatedSizeleft, CURLFORM_FILENAME, "postit2.c", CURLFORM_END);
		} else {
				formrc = /* new style */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "sendfile alternative", CURLFORM_STREAM, pooh, CURLFORM_CONTENTLEN, ()generatedSizeleft, CURLFORM_FILENAME, "file name 2", CURLFORM_END);
		} 
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(1) = %d\n", (int)formrc/* Now add the same data with another name and make it not look like
			     a file upload but still using the callback */);
		} 
		pooh2.setReadptr(ModernizedCProgram.data);
		pooh2.setSizeleft(.strlen(ModernizedCProgram.data));
		formrc = /* Fill in the file upload field */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "callbackdata", CURLFORM_STREAM, pooh2, CURLFORM_CONTENTSLENGTH, (long)generatedSizeleft, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(2) = %d\n", (int)formrc);
		} 
		formrc = /* Fill in the filename field */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "filename"/* ASCII representation with escape
		                           sequences for non-ASCII platforms */, CURLFORM_COPYCONTENTS, "postit2.c", CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(3) = %d\n", (int)formrc);
		} 
		formrc = /* Fill in a submit field too */formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "submit"/* ASCII representation with escape
		                           sequences for non-ASCII platforms */, CURLFORM_COPYCONTENTS, "send", CURLFORM_CONTENTTYPE, "text/plain", CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(4) = %d\n", (int)formrc);
		} 
		formrc = formpost.curl_formadd(lastptr, CURLFORM_COPYNAME, "somename", CURLFORM_BUFFER, "somefile.txt", CURLFORM_BUFFERPTR, "blah blah", CURLFORM_BUFFERLENGTH, (long)9, CURLFORM_END);
		if (formrc) {
			ModernizedCProgram.curl_mprintf("curl_formadd(5) = %d\n", (int)formrc);
		} 
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			formpost.curl_formfree();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POST), (true))) != /* Now specify we want to POST data */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_POSTFIELDSIZE), ((long)generatedSizeleft))) != /* Set the expected POST size */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_READFUNCTION), (read_callback))) != /* we want to use our own read function */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPPOST), (formpost))) != /* send a multi-part formpost */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		/* now cleanup the formpost chain */formpost.curl_formfree();
		return res;
		 curl = new ();
		 res = CURLE_OK;
		 mime = ((Object)0);
		 part = ((Object)0);
		WriteThis pooh = new WriteThis();
		WriteThis pooh2 = new WriteThis();
		 datasize = -1;
		pooh.setReadptr(ModernizedCProgram.data);
		datasize = ().strlen(ModernizedCProgram.data);
		pooh.setSizeleft(datasize);
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (!curl) {
			(_iob[2]).curl_mfprintf("curl_easy_init() failed\n");
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		mime = curl.curl_mime_init();
		if (!mime) {
			(_iob[2]).curl_mfprintf("curl_mime_init() failed\n");
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		part = ModernizedCProgram.curl_mime_addpart(mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart(1) failed\n");
			ModernizedCProgram.curl_mime_free(mime);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		if (/* Fill in the file upload part */oldstyle) {
			res = ModernizedCProgram.curl_mime_name(part, "sendfile");
			if (!res) {
				res = ModernizedCProgram.curl_mime_data_cb(part, datasize, read_callback, ((Object)0), ((Object)0), pooh);
			} 
			if (!res) {
				res = ModernizedCProgram.curl_mime_filename(part, "postit2.c");
			} 
		} else {
				res = ModernizedCProgram.curl_mime_name(part, /* new style */"sendfile alternative");
				if (!res) {
					res = ModernizedCProgram.curl_mime_data_cb(part, datasize, read_callback, ((Object)0), ((Object)0), pooh);
				} 
				if (!res) {
					res = ModernizedCProgram.curl_mime_filename(part, "file name 2");
				} 
		} 
		if (res) {
			ModernizedCProgram.curl_mprintf("curl_mime_xxx(1) = %s\n", ModernizedCProgram.curl_easy_strerror(res/* Now add the same data with another name and make it not look like
			     a file upload but still using the callback */));
		} 
		pooh2.setReadptr(ModernizedCProgram.data);
		datasize = ().strlen(ModernizedCProgram.data);
		pooh2.setSizeleft(datasize);
		part = ModernizedCProgram.curl_mime_addpart(mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart(2) failed\n");
			ModernizedCProgram.curl_mime_free(mime);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.curl_mime_name(part, /* Fill in the file upload part */"callbackdata");
		if (!res) {
			res = ModernizedCProgram.curl_mime_data_cb(part, datasize, read_callback, ((Object)0), ((Object)0), pooh2);
		} 
		if (res) {
			ModernizedCProgram.curl_mprintf("curl_mime_xxx(2) = %s\n", ModernizedCProgram.curl_easy_strerror(res));
		} 
		part = ModernizedCProgram.curl_mime_addpart(mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart(3) failed\n");
			ModernizedCProgram.curl_mime_free(mime);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.curl_mime_name(part, /* Fill in the filename field */"filename");
		if (!res) {
			res = ModernizedCProgram.curl_mime_data(part/* ASCII representation with escape
			                            sequences for non-ASCII platforms */, "postit2.c", CURL_ZERO_TERMINATED);
		} 
		if (res) {
			ModernizedCProgram.curl_mprintf("curl_mime_xxx(3) = %s\n", ModernizedCProgram.curl_easy_strerror(res));
		} 
		part = ModernizedCProgram.curl_mime_addpart(/* Fill in a submit field too */mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart(4) failed\n");
			ModernizedCProgram.curl_mime_free(mime);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.curl_mime_name(part, "submit");
		if (!res) {
			res = ModernizedCProgram.curl_mime_data(part/* ASCII representation with escape
			                            sequences for non-ASCII platforms */, "send", CURL_ZERO_TERMINATED);
		} 
		if (res) {
			ModernizedCProgram.curl_mprintf("curl_mime_xxx(4) = %s\n", ModernizedCProgram.curl_easy_strerror(res));
		} 
		part = ModernizedCProgram.curl_mime_addpart(mime);
		if (!part) {
			(_iob[2]).curl_mfprintf("curl_mime_addpart(5) failed\n");
			ModernizedCProgram.curl_mime_free(mime);
			curl.curl_easy_cleanup();
			ModernizedCProgram.curl_global_cleanup();
			return 126;
		} 
		res = ModernizedCProgram.curl_mime_name(part, "somename");
		if (!res) {
			res = ModernizedCProgram.curl_mime_filename(part, "somefile.txt");
		} 
		if (!res) {
			res = ModernizedCProgram.curl_mime_data(part, "blah blah", 9);
		} 
		if (res) {
			ModernizedCProgram.curl_mprintf("curl_mime_xxx(5) = %s\n", ModernizedCProgram.curl_easy_strerror(res));
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (URL))) != /* First set the URL that is about to receive our POST. */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_MIMEPOST), (mime))) != /* send a multi-part mimepost */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != /* get verbose debug output please */CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != /* include headers in the output */CURLE_OK) {
			;
		} 
		res = /* Perform the request, res will get the return code */curl.curl_easy_perform();
		ModernizedCProgram.curl_mime_free(/* now cleanup the mimepost structure */mime);
		return res;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* argv1 = URL
	 * argv2 = main auth type
	 * argv3 = second auth type
	 */
	public static Object send_request(Object curl, Object url, int seq, long auth_scheme, Object userpwd) {
		 res = new ();
		size_t len = .strlen(url) + 4 + 1;
		byte full_url = .malloc(len);
		if (!full_url) {
			(_iob[2]).curl_mfprintf("Not enough memory for full url\n");
			return CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.curl_msnprintf(full_url, len, "%s%04d", url, seq);
		(_iob[2]).curl_mfprintf("Sending new request %d to %s with credential %s (auth %ld)\n", seq, full_url, userpwd, auth_scheme);
		if ((res = (curl).curl_easy_setopt((CURLOPT_URL), (full_url))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_VERBOSE), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HEADER), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPGET), (true))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_USERPWD), (userpwd))) != CURLE_OK) {
			;
		} 
		if ((res = (curl).curl_easy_setopt((CURLOPT_HTTPAUTH), (auth_scheme))) != CURLE_OK) {
			;
		} 
		res = curl.curl_easy_perform();
		return res;
	}
	public static Object send_wrong_password(Object curl, Object url, int seq, long auth_scheme) {
		return ModernizedCProgram.send_request(curl, url, seq, auth_scheme, "testuser:wrongpass");
	}
	public static Object send_right_password(Object curl, Object url, int seq, long auth_scheme) {
		return ModernizedCProgram.send_request(curl, url, seq, auth_scheme, "testuser:testpass");
	}
	public static long parse_auth_name(Object arg) {
		if (!arg) {
			return CURLAUTH_NONE;
		} 
		if (ModernizedCProgram.curl_strequal(arg, "basic")) {
			return CURLAUTH_BASIC;
		} 
		if (ModernizedCProgram.curl_strequal(arg, "digest")) {
			return CURLAUTH_DIGEST;
		} 
		if (ModernizedCProgram.curl_strequal(arg, "ntlm")) {
			return CURLAUTH_NTLM;
		} 
		return CURLAUTH_NONE;
	}
	public static Object trhash(Object key, Object key_length, Object slots_num) {
		size_t keyval = (size_t)(Curl_easy)key;
		(Object)key_length;
		return (keyval % slots_num);
	}
	public static Object trhash_compare(Object k1, Object k1_len, Object k2, Object k2_len) {
		(Object)k1_len;
		(Object)k2_len;
		return (Curl_easy)k1 == (Curl_easy)k2;
	}
	public static void trhash_dtor(Object nada) {
		(Object)nada;
	}
	/* delete the given socket + handle from the hash */
	public static void sh_delentry(Curl_sh_entry entry, curl_hash sh, Object s) {
		curl_hash generatedTransfers = entry.getTransfers();
		generatedTransfers.Curl_hash_destroy();
		sh.Curl_hash_delete((byte)s, /* We remove the hash entry. This will end up in a call to
		     sh_freeentry(). *//*
		 * free a sockhash entry
		 */);
	}
	public static void sh_freeentry(Object freethis) {
		Curl_sh_entry p = (Curl_sh_entry)freethis;
		.Curl_cfree(p);
	}
	public static Object fd_key_compare(Object k1, Object k1_len, Object k2, Object k2_len) {
		(Object)k1_len;
		(Object)k2_len;
		return ((()k1)) == ((()k2));
	}
	public static Object hash_fd(Object key, Object key_length, Object slots_num) {
		 fd = (()key);
		(Object)key_length;
		return (fd % slots_num/*
		 * sh_init() creates a new socket hash and returns the handle for it.
		 *
		 * Quote from README.multi_socket:
		 *
		 * "Some tests at 7000 and 9000 connections showed that the socket hash lookup
		 * is somewhat of a bottle neck. Its current implementation may be a bit too
		 * limiting. It simply has a fixed-size array, and on each entry in the array
		 * it has a linked list with entries. So the hash only checks which list to
		 * scan through. The code I had used so for used a list with merely 7 slots
		 * (as that is what the DNS hash uses) but with 7000 connections that would
		 * make an average of 1000 nodes in each list to run through. I upped that to
		 * 97 slots (I believe a prime is suitable) and noticed a significant speed
		 * increase.  I need to reconsider the hash implementation or use a rather
		 * large default value like this. At 9000 connections I was still below 10us
		 * per call."
		 *
		 */);
	}
	public static Object multi_addmsg(Curl_multi multi, Curl_message msg) {
		curl_llist generatedMsglist = multi.getMsglist();
		curl_llist_element generatedTail = generatedMsglist.getTail();
		curl_llist_element generatedList = msg.getList();
		ModernizedCProgram.Curl_llist_insert_next(generatedMsglist, generatedTail, msg, generatedList);
		return CURLM_OK;
	}
	public static Object curl_multi_add_handle(Curl_multi multi, Curl_easy data) {
		long generatedType = (multi).getType();
		if (!((multi) && generatedType == /* First, make some basic checks that the CURLM handle is a good handle */-1024)) {
			return CURLM_BAD_HANDLE;
		} 
		Object generatedMagic = (data).getMagic();
		if (!((data) && (generatedMagic == /* Verify that we got a somewhat good easy handle too */-1024))) {
			return CURLM_BAD_EASY_HANDLE;
		} 
		Object generatedMulti = data.getMulti();
		if (generatedMulti) {
			return CURLM_ADDED_ALREADY;
		} 
		Object generatedIn_callback = multi.getIn_callback();
		if (generatedIn_callback) {
			return CURLM_RECURSIVE_API_CALL;
		} 
		Object generatedState = data.getState();
		generatedState.getTimeoutlist().Curl_llist_init(((Object)/* Initialize timeout list for this handle */0/*
		   * No failure allowed in this function beyond this point. And no
		   * modification of easy nor multi handle allowed before this except for
		   * potential multi's connection cache growing which won't be undone in this
		   * function no matter what.
		   */));
		Object generatedSet = data.getSet();
		if (generatedSet.getErrorbuffer()) {
			generatedSet.getErrorbuffer()[0] = 0;
		} 
		data.mstate(/* set the easy handle */.CURLM_STATE_INIT);
		Object generatedDns = data.getDns();
		curl_hash generatedHostcache = multi.getHostcache();
		if (!generatedDns.getHostcache() || (generatedDns.getHostcachetype() == .HCACHE_NONE)) {
			generatedDns.setHostcache(generatedHostcache);
			generatedDns.setHostcachetype(.HCACHE_MULTI);
		} 
		Object generatedShare = data.getShare();
		conncache generatedConn_cache = multi.getConn_cache();
		if (generatedShare && (generatedShare.getCurl_share() & (1 << /* Point to the shared or multi handle connection cache */CURL_LOCK_DATA_CONNECT))) {
			generatedState.setConn_cache(generatedShare.getCurl_share());
		} else {
				generatedState.setConn_cache(generatedConn_cache);
		} 
		data.setNext(((Object)/* We add the new entry last in the list. *//* end of the line */0));
		Curl_easy generatedEasyp = multi.getEasyp();
		Curl_easy generatedEasylp = multi.getEasylp();
		if (generatedEasyp) {
			Curl_easy last = generatedEasylp;
			last.setNext(data);
			data.setPrev(last);
			multi.setEasylp(/* the new last node */data);
		} else {
				data.setPrev(((Object)/* first node, make prev NULL! */0));
				multi.setEasylp(multi.setEasyp(/* both first and last */data));
		} 
		data.setMulti(/* make the Curl_easy refer back to this multi handle */multi/* Set the timeout for this handle to expire really soon so that it will
		     be taken care of even when this handle is added in the midst of operation
		     when only the curl_multi_socket() API is used. During that flow, only
		     sockets that time-out or have actions will be dealt with. Since this
		     handle has no action yet, we make sure it times out to get things to
		     happen. */);
		data.Curl_expire(0, .EXPIRE_RUN_NOW);
		int generatedNum_easy = multi.getNum_easy();
		generatedNum_easy++;
		int generatedNum_alive = multi.getNum_alive();
		generatedNum_alive++;
		curltime generatedTimer_lastcall = multi.getTimer_lastcall();
		.memset(generatedTimer_lastcall, 0, );
		generatedSet.setTimeout(generatedSet.getTimeout());
		generatedSet.setServer_response_timeout(generatedSet.getServer_response_timeout());
		generatedSet.setNo_signal(generatedSet.getNo_signal());
		multi.Curl_update_timer();
		return CURLM_OK/* Debug-function, used like this:
		 *
		 * Curl_hash_print(multi->sockhash, debug_print_sock_hash);
		 *
		 * Enable the hash print function first by editing hash.c
		 */;
	}
	public static Object curl_multi_remove_handle(Curl_multi multi, Curl_easy data) {
		Curl_easy easy = data;
		bool premature = new bool();
		bool easy_owns_conn = new bool();
		curl_llist_element e = new curl_llist_element();
		long generatedType = (multi).getType();
		if (!((multi) && generatedType == /* First, make some basic checks that the CURLM handle is a good handle */-1024)) {
			return CURLM_BAD_HANDLE;
		} 
		Object generatedMagic = (data).getMagic();
		if (!((data) && (generatedMagic == /* Verify that we got a somewhat good easy handle too */-1024))) {
			return CURLM_BAD_EASY_HANDLE;
		} 
		Object generatedMulti = data.getMulti();
		if (!generatedMulti) {
			return /* it is already removed so let's say it is fine! */CURLM_OK;
		} 
		Object generatedIn_callback = multi.getIn_callback();
		if (generatedIn_callback) {
			return CURLM_RECURSIVE_API_CALL;
		} 
		Object generatedMstate = data.getMstate();
		premature = (generatedMstate < .CURLM_STATE_COMPLETED) ? 1 : 0;
		Object generatedConn = data.getConn();
		easy_owns_conn = (generatedConn && (generatedConn.getData() == easy)) ? 1 : 0;
		int generatedNum_alive = multi.getNum_alive();
		if (/* If the 'state' is not INIT or COMPLETED, we might need to do something
		     nice to put the easy_handle in a good known state when this returns. */premature/* this handle is "alive" so we need to count down the total number of
		       alive connections when this is removed */) {
			generatedNum_alive--;
		} 
		if (generatedConn && generatedMstate > .CURLM_STATE_DO && generatedMstate < .CURLM_STATE_COMPLETED/* Set connection owner so that the DONE function closes it.  We can
		       safely do this here since connection is killed. */) {
			generatedConn.setData(easy);
			generatedConn.Curl_conncontrol(2);
			easy_owns_conn = 1;
		} 
		/* The timer must be shut down before data->multi is set to NULL,
		     else the timenode will remain in the splay tree after
		     curl_easy_cleanup is called. */data.Curl_expire_clear();
		Object generatedResult = data.getResult();
		if (generatedConn) {
			if (/* we must call multi_done() here (if we still own the connection) so that
			       we don't leave a half-baked one around */easy_owns_conn/* multi_done() clears the conn->data field to lose the association
			         between the easy handle and the connection
			
			         Note that this ignores the return code simply because there's
			         nothing really useful to do with it anyway! */) {
				(Object)data.multi_done(generatedResult, premature);
			} 
		} 
		Object generatedConnect_queue = data.getConnect_queue();
		curl_llist generatedPending = multi.getPending();
		if (generatedConnect_queue.getPtr()) {
			ModernizedCProgram.Curl_llist_remove(generatedPending, generatedConnect_queue, ((Object)0));
		} 
		Object generatedDns = data.getDns();
		if (generatedDns.getHostcachetype() == .HCACHE_MULTI/* stop using the multi handle's DNS cache, *after* the possible
		       multi_done() call above */) {
			generatedDns.setHostcache(((Object)0));
			generatedDns.setHostcachetype(.HCACHE_NONE);
		} 
		Object generatedWildcard = data.getWildcard();
		generatedWildcard.Curl_wildcard_dtor();
		Object generatedState = data.getState();
		generatedState.getTimeoutlist().Curl_llist_destroy(((Object)/* destroy the timeout list that is held in the easy handle, do this *after*
		     multi_done() as that may actually call Curl_expire that uses this */0));
		generatedState.setConn_cache(((Object)/* as this was using a shared connection cache we clear the pointer to that
		     since we're not part of that multi handle anymore */0));
		data.setMstate(/* change state without using multistate(), only to make singlesocket() do
		     what we want */.CURLM_STATE_COMPLETED);
		ModernizedCProgram.singlesocket(multi, /* to let the application know what sockets that
		                                vanish with this handle */easy);
		if (generatedConn) {
			generatedConn.setData(((Object)0));
			data/* Remove the PSL association. */.detach_connnection();
		} 
		data.setMulti(((Object)/* clear the association to this multi handle */0/* make sure there's no pending message in the queue sent from this easy
		     handle */));
		Object generatedPtr = e.getPtr();
		CURLMsg generatedExtmsg = msg.getExtmsg();
		Object generatedCURLMsg = generatedExtmsg.getCURLMsg();
		curl_llist generatedMsglist = multi.getMsglist();
		curl_llist_element generatedNext = e.getNext();
		curl_llist_element generatedHead = generatedMsglist.getHead();
		for (e = generatedHead; e; e = generatedNext) {
			Curl_message msg = generatedPtr;
			if (generatedCURLMsg == easy) {
				ModernizedCProgram.Curl_llist_remove(generatedMsglist, e, ((Object)0/* there can only be one from this specific handle */));
				break;
			} 
		}
		Object generatedPrev = data.getPrev();
		if (generatedPrev) {
			generatedPrev.setNext(generatedNext);
		} else {
				multi.setEasyp(generatedNext);
		} 
		if (generatedNext) {
			generatedNext.setPrev(generatedPrev);
		} else {
				multi.setEasylp(generatedPrev);
		} 
		int generatedNum_easy = multi.getNum_easy();
		generatedNum_easy--;
		multi.Curl_update_timer();
		return CURLM_OK;
	}
	/* Return TRUE if the application asked for multiplexing */
	public static  Curl_multiplex_wanted(Object multi) {
		return (multi && (multi.getMultiplexing()));
	}
	/* This is the only function that should assign data->conn */
	public static void Curl_attach_connnection(Curl_easy data, connectdata conn) {
		do {
		} while (0);
		do {
		} while (0);
		data.setConn(conn);
		curl_llist generatedEasyq = conn.getEasyq();
		curl_llist_element generatedTail = generatedEasyq.getTail();
		Object generatedConn_queue = data.getConn_queue();
		ModernizedCProgram.Curl_llist_insert_next(generatedEasyq, generatedTail, data, generatedConn_queue);
	}
	public static Object curl_multi_fdset(Curl_multi multi, fd_set read_fd_set, fd_set write_fd_set, fd_set exc_fd_set, int max_fd) {
		/* Scan through all the easy handles to get the file descriptors set.
		     Some easy handles may not have connected to the remote host yet,
		     and then we must make sure that is done. */Curl_easy data = new Curl_easy();
		int this_max_fd = -1;
		[] sockbunch = new ();
		int i;
		(Object)/* not used */exc_fd_set;
		long generatedType = (multi).getType();
		if (!((multi) && generatedType == -1024)) {
			return CURLM_BAD_HANDLE;
		} 
		Object generatedIn_callback = multi.getIn_callback();
		if (generatedIn_callback) {
			return CURLM_RECURSIVE_API_CALL;
		} 
		Curl_easy generatedEasyp = multi.getEasyp();
		data = generatedEasyp;
		Object generatedNext = data.getNext();
		while (data) {
			int bitmap = data.multi_getsock(sockbunch);
			for (i = 0; i < 5; i++) {
				 s = CURL_SOCKET_BAD;
				if ((bitmap & (1 << (i))) && true) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(read_fd_set)).getFd_count(); __i++) {
							if (((fd_set)(read_fd_set)).getFd_array()[__i] == (sockbunch[i])) {
								break;
							} 
						}
						if (__i == ((fd_set)(read_fd_set)).getFd_count()) {
							if (((fd_set)(read_fd_set)).getFd_count() < 64) {
								((fd_set)(read_fd_set)).getFd_array()[__i] = (sockbunch[i]);
								((fd_set)(read_fd_set)).getFd_count()++;
							} 
						} 
					} while (0);
					s = sockbunch[i];
				} 
				if ((bitmap & (1 << (16 + (i)))) && true) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(write_fd_set)).getFd_count(); __i++) {
							if (((fd_set)(write_fd_set)).getFd_array()[__i] == (sockbunch[i])) {
								break;
							} 
						}
						if (__i == ((fd_set)(write_fd_set)).getFd_count()) {
							if (((fd_set)(write_fd_set)).getFd_count() < 64) {
								((fd_set)(write_fd_set)).getFd_array()[__i] = (sockbunch[i]);
								((fd_set)(write_fd_set)).getFd_count()++;
							} 
						} 
					} while (0);
					s = sockbunch[i];
				} 
				if (s == CURL_SOCKET_BAD/* this socket is unused, break out of loop */) {
					break;
				} 
				if ((int)s > this_max_fd) {
					this_max_fd = (int)s;
				} 
			}
			data = generatedNext;
		}
		max_fd = this_max_fd;
		return CURLM_OK;
	}
	public static Object Curl_multi_add_perform(Curl_multi multi, Curl_easy data, connectdata conn) {
		 rc = new ();
		Object generatedIn_callback = multi.getIn_callback();
		if (generatedIn_callback) {
			return CURLM_RECURSIVE_API_CALL;
		} 
		rc = ModernizedCProgram.curl_multi_add_handle(multi, data);
		Object generatedReq = data.getReq();
		int generatedKeepon = k.getKeepon();
		if (!rc) {
			SingleRequest k = generatedReq;
			ModernizedCProgram.Curl_init_do(data, ((Object)/* pass in NULL for 'conn' here since we don't want to init the
			       connection, only this transfer */0));
			data.mstate(/* take this handle to the perform state right away */.CURLM_STATE_PERFORM);
			ModernizedCProgram.Curl_attach_connnection(data, conn);
			generatedKeepon |=  (1 << /* setup to receive! */0);
		} 
		return rc/*
		 * do_complete is called when the DO actions are complete.
		 *
		 * We init chunking and trailer bits to their default values here immediately
		 * before receiving any header data for the current request.
		 */;
	}
	public static Object multi_runsingle(Curl_multi multi, curltime now, Curl_easy data) {
		Curl_message msg = ((Object)0);
		bool connected = new bool();
		bool async = new bool();
		bool protocol_connected = 0;
		bool dophase_done = 0;
		bool done = 0;
		 rc = new ();
		 result = CURLE_OK;
		timediff_t timeout_ms = new timediff_t();
		timediff_t recv_timeout_ms = new timediff_t();
		timediff_t send_timeout_ms = new timediff_t();
		int control;
		Object generatedMagic = (data).getMagic();
		if (!((data) && (generatedMagic == -1024))) {
			return CURLM_BAD_EASY_HANDLE;
		} 
		Object generatedConn = data.getConn();
		Object generatedMstate = data.getMstate();
		data.setResult(result);
		return rc;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	  CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97
	  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every
	  CURL handle takes 45-50 K memory, therefore this 3K are not significant.
	*/
	public static Object singlesocket(Curl_multi multi, Curl_easy data) {
		[] socks = new ();
		int i;
		Curl_sh_entry entry = new Curl_sh_entry();
		 s = new ();
		int num;
		int curraction;
		int[] actions = new int[5];
		for (i = 0; i < 5; i++) {
			socks[i] = CURL_SOCKET_BAD;
		}
		curraction = data.multi_getsock(/* Fill in the 'current' struct with the state as it is now: what sockets to
		     supervise and for what actions */socks/* We have 0 .. N sockets already and we get to know about the 0 .. M
		     sockets we should have from now on. Detect the differences, remove no
		     longer supervised ones and add new ones */);
		curl_hash generatedSockhash = multi.getSockhash();
		Curl_sh_entry curl_sh_entry = new Curl_sh_entry();
		Object generatedNumsocks = data.getNumsocks();
		Object generatedSockets = data.getSockets();
		Object generatedActions = data.getActions();
		Curl_sh_entry curl_sh_entry = new Curl_sh_entry();
		int generatedReaders = entry.getReaders();
		int generatedWriters = entry.getWriters();
		int generatedUsers = entry.getUsers();
		curl_hash generatedTransfers = entry.getTransfers();
		int generatedAction = entry.getAction();
		Object generatedSocket_cb = multi.getSocket_cb();
		Object generatedSocket_userp = multi.getSocket_userp();
		Object generatedSocketp = entry.getSocketp();
		for (i = 0; (i < /* walk over the sockets we got right now */5) && (curraction & ((1 << (i)) | (1 << (16 + (i))))); i++) {
			int action = CURL_POLL_NONE;
			int prevaction = 0;
			int comboaction;
			bool sincebefore = 0;
			s = socks[i];
			entry = curl_sh_entry.sh_getentry(generatedSockhash, /* get it from the hash */s);
			if (curraction & (1 << (i))) {
				action |=  CURL_POLL_IN;
			} 
			if (curraction & (1 << (16 + (i)))) {
				action |=  CURL_POLL_OUT;
			} 
			actions[i] = action;
			if (entry/* check if new for this transfer */) {
				int j;
				for (ModernizedCProgram.j = 0; ModernizedCProgram.j < generatedNumsocks; ModernizedCProgram.j++) {
					if (s == generatedSockets[ModernizedCProgram.j]) {
						prevaction = generatedActions[ModernizedCProgram.j];
						sincebefore = 1;
						break;
					} 
				}
			} else {
					entry = curl_sh_entry.sh_addentry(generatedSockhash, /* this is a socket we didn't have before, add it to the hash! */s);
					if (!entry) {
						return /* fatal */CURLM_OUT_OF_MEMORY;
					} 
			} 
			if (sincebefore && (prevaction != action)) {
				if (prevaction & /* Socket was used already, but different action now */CURL_POLL_IN) {
					generatedReaders--;
				} 
				if (prevaction & CURL_POLL_OUT) {
					generatedWriters--;
				} 
				if (action & CURL_POLL_IN) {
					generatedReaders++;
				} 
				if (action & CURL_POLL_OUT) {
					generatedWriters++;
				} 
			}  else if (!sincebefore) {
				generatedUsers++;
				if (action & CURL_POLL_IN) {
					generatedReaders++;
				} 
				if (action & CURL_POLL_OUT) {
					generatedWriters++;
				} 
				if (!generatedTransfers.Curl_hash_add((byte)/* add 'data' to the transfer hash on this socket! *//* hash key */data, , data)) {
					return CURLM_OUT_OF_MEMORY;
				} 
			} 
			comboaction = (generatedWriters ? CURL_POLL_OUT : 0) | (generatedReaders ? CURL_POLL_IN : 0);
			if (sincebefore && (generatedAction == /* socket existed before and has the same action set as before */comboaction/* same, continue */)) {
				continue;
			} 
			if (generatedSocket_cb) {
				.UNRECOGNIZEDFUNCTIONNAME(data, s, comboaction, generatedSocket_userp, generatedSocketp);
			} 
			entry.setAction(/* store the current action state */comboaction);
		}
		num = /* number of sockets */i;
		for (i = 0; i < generatedNumsocks; /* when we've walked over all the sockets we should have right now, we must
		     make sure to detect sockets that are removed */i++) {
			int j;
			bool stillused = 0;
			s = generatedSockets[i];
			for (ModernizedCProgram.j = 0; ModernizedCProgram.j < num; ModernizedCProgram.j++) {
				if (s == socks[ModernizedCProgram.j]) {
					stillused = /* this is still supervised */1;
					break;
				} 
			}
			if (stillused) {
				continue;
			} 
			entry = curl_sh_entry.sh_getentry(generatedSockhash, s/* if this is NULL here, the socket has been closed and notified so
			       already by Curl_multi_closed() */);
			if (entry) {
				int oldactions = generatedActions[i];
				generatedUsers--;
				if (oldactions & CURL_POLL_OUT) {
					generatedWriters--;
				} 
				if (oldactions & CURL_POLL_IN) {
					generatedReaders--;
				} 
				if (!generatedUsers) {
					if (generatedSocket_cb) {
						.UNRECOGNIZEDFUNCTIONNAME(data, s, CURL_POLL_REMOVE, generatedSocket_userp, generatedSocketp);
					} 
					ModernizedCProgram.sh_delentry(entry, generatedSockhash, s);
				} else {
						if (generatedTransfers.Curl_hash_delete((byte)/* still users, but remove this handle as a user of this socket */data, )) {
							do {
							} while (0);
						} 
				} 
			} 
		}
		.memcpy(generatedSockets, socks, num * /* for loop over numsocks */);
		.memcpy(generatedActions, actions, num * );
		data.setNumsocks(num);
		return CURLM_OK;
	}
	public static Object add_next_timeout(curltime now, Curl_multi multi, Curl_easy d) {
		Object generatedState = d.getState();
		curltime tv = generatedState.getExpiretime();
		curl_llist list = generatedState.getTimeoutlist();
		curl_llist_element e = new curl_llist_element();
		time_node node = ((Object)0/* move over the timeout list for this specific handle and remove all
		     timeouts that are now passed tense and store the next pending
		     timeout in *tv */);
		curl_llist_element generatedNext = e.getNext();
		Object generatedPtr = e.getPtr();
		curltime generatedTime = node.getTime();
		curl_llist_element generatedHead = list.getHead();
		for (e = generatedHead; e; ) {
			curl_llist_element n = generatedNext;
			timediff_t diff = new timediff_t();
			node = (time_node)generatedPtr;
			diff = generatedTime.Curl_timediff(now);
			if (diff <= 0) {
				ModernizedCProgram.Curl_llist_remove(list, e, ((Object)/* remove outdated entry */0));
			} else {
					break;
			} 
			e = n;
		}
		e = generatedHead;
		Curl_tree generatedTimetree = multi.getTimetree();
		if (!e/* clear the expire times within the handles that we remove from the
		       splay tree */) {
			tv.setTv_sec(0);
			tv.setTv_usec(0);
		} else {
				.memcpy(tv, generatedTime, );
				multi.setTimetree(generatedTimetree.Curl_splayinsert(tv, generatedState.getTimenode()));
		} 
		return CURLM_OK;
	}
	public static Object multi_addtimeout(Curl_easy data, curltime stamp,  eid) {
		curl_llist_element e = new curl_llist_element();
		time_node node = new time_node();
		curl_llist_element prev = ((Object)0);
		size_t n = new size_t();
		Object generatedState = data.getState();
		curl_llist timeoutlist = generatedState.getTimeoutlist();
		node = generatedState.getExpires()[eid];
		curltime generatedTime = node.getTime();
		.memcpy(generatedTime, stamp, );
		node.setEid(/* also marks it as in use */eid);
		n = timeoutlist.Curl_llist_count();
		Object generatedPtr = e.getPtr();
		curl_llist_element generatedNext = e.getNext();
		curl_llist_element generatedHead = timeoutlist.getHead();
		if (n) {
			for (e = generatedHead; e; e = generatedNext) {
				time_node check = (time_node)generatedPtr;
				timediff_t diff = generatedTime.Curl_timediff(generatedTime);
				if (diff > 0) {
					break;
				} 
				prev = e;
			}
		} 
		curl_llist_element generatedList = node.getList();
		ModernizedCProgram.Curl_llist_insert_next(timeoutlist, prev, node, generatedList);
		return CURLM_OK/*
		 * Curl_expire()
		 *
		 * given a number of milliseconds from now to use to set the 'act before
		 * this'-time for the transfer, to be extracted by curl_multi_timeout()
		 *
		 * The timeout will be added to a queue of timeouts if it defines a moment in
		 * time that is later than the current head of queue.
		 *
		 * Expire replaces a former timeout using the same id if already set.
		 */;
	}
	/* Mime part callbacks for stdin. */
	public static Object tool_mime_stdin_read(Byte buffer, Object size, Object nitems, Object arg) {
		tool_mime sip = (tool_mime)arg;
		 bytesleft = new ();
		(Object)/* Always 1: ignored. */size;
		Object generatedSize = sip.getSize();
		Object generatedCurpos = sip.getCurpos();
		if (generatedSize >= 0) {
			if (generatedCurpos >= generatedSize) {
				return /* At eof. */0;
			} 
			bytesleft = generatedSize - generatedCurpos;
			if (ModernizedCProgram.curlx_uztoso(nitems) > bytesleft) {
				nitems = ModernizedCProgram.curlx_sotouz(bytesleft);
			} 
		} 
		Object generatedData = sip.getData();
		GlobalConfig generatedConfig = sip.getConfig();
		if (nitems) {
			if (generatedData) {
				.memcpy(buffer, generatedData + ModernizedCProgram.curlx_sotouz(generatedCurpos), /* Return data from memory. */nitems);
			} else {
					nitems = .fread(buffer, 1, nitems, (_iob[/* Read from stdin. */0]));
					if ((((_iob[0])).get_flag() & -1024)) {
						if (generatedConfig) {
							generatedConfig.warnf("stdin: %s\n", .strerror((._errno())));
							sip.setConfig(((Object)0));
						} 
						return CURL_READFUNC_ABORT;
					} 
			} 
			generatedCurpos += ModernizedCProgram.curlx_uztoso(nitems);
		} 
		return nitems;
	}
	public static int tool_mime_stdin_seek(Object instream, Object offset, int whence) {
		tool_mime sip = (tool_mime)instream;
		Object generatedCurpos = sip.getCurpos();
		Object generatedSize = sip.getSize();
		switch (whence) {
		case 2:
				offset += generatedSize;
				break;
		case 1:
				offset += generatedCurpos;
				break;
		}
		if (offset < 0) {
			return CURL_SEEKFUNC_CANTSEEK;
		} 
		Object generatedData = sip.getData();
		Object generatedOrigin = sip.getOrigin();
		if (!generatedData) {
			if (.fseek((_iob[0]), (long)(offset + generatedOrigin), 0)) {
				return CURL_SEEKFUNC_CANTSEEK;
			} 
		} 
		sip.setCurpos(offset);
		return CURL_SEEKFUNC_OK;
	}
	public static Byte get_param_word(byte str, byte end_pos, byte endchar) {
		byte ptr = str;
		byte word_begin = /* the first non-space char is here */ptr;
		byte ptr2;
		byte escape = ((Object)0);
		if (ptr == (byte)'"') {
			++ptr;
			while (ptr) {
				if (ptr == (byte)'\\') {
					if (ptr[1] == (byte)'\\' || ptr[1] == (byte)'"') {
						if (!/* remember the first escape position */escape) {
							escape = ptr;
						} 
						ptr += /* skip escape of back-slash or double-quote */2;
						continue;
					} 
				} 
				if (ptr == (byte)'"') {
					end_pos = ptr;
					if (escape) {
						ptr = ptr2 = /* has escape, we restore the unescaped string here */escape;
						do {
							if (ptr == (byte)'\\' && (ptr[1] == (byte)'\\' || ptr[1] == (byte)'"')) {
								++ptr;
							} 
							ptr2++ = ptr++;
						} while (ptr < end_pos);
						end_pos = ptr2;
					} 
					while (ptr && ptr != (byte)';' && ptr != endchar) {
						++ptr;
					}
					str = ptr;
					return word_begin + 1;
				} 
				++ptr;
			}
			ptr = /* end quote is missing, treat it as non-quoted. */word_begin;
		} 
		while (ptr && ptr != (byte)';' && ptr != endchar) {
			++ptr;
		}
		str = end_pos = ptr;
		return word_begin;
	}
	/* Append slist item and return -1 if failed. */
	public static int slist_append(Object plist, Object data) {
		curl_slist s = plist.curl_slist_append(data);
		if (!s) {
			return -1;
		} 
		plist = s;
		return 0;
	}
	/* Read headers from a file and append to list. */
	public static int read_field_headers(OperationConfig config, Object filename, _iobuf fp, Object pheaders) {
		size_t hdrlen = 0;
		size_t pos = 0;
		bool incomment = 0;
		int lineno = 1;
		byte[] hdrbuf = new byte[/* Max. header length + 1. */999];
		GlobalConfig generatedGlobal = config.getGlobal();
		_iobuf generatedErrors = generatedGlobal.getErrors();
		Object generated_flag = (fp).get_flag();
		for (; ; ) {
			int c = .getc(fp);
			if (c == (true) || (!pos && !(ModernizedCProgram.Curl_isspace((int)((byte)c))))) {
				while (hdrlen && (ModernizedCProgram.Curl_isspace((int)((byte)hdrbuf[hdrlen - /* Strip and flush the current header. */1])))) {
					hdrlen--;
				}
				if (hdrlen) {
					hdrbuf[hdrlen] = (byte)'\0';
					if (ModernizedCProgram.slist_append(pheaders, hdrbuf)) {
						generatedErrors.curl_mfprintf("Out of memory for field headers!\n");
						return -1;
					} 
					hdrlen = 0;
				} 
			} 
			switch (c) {
			case (byte)'\r':
					continue;
			case (byte)'\n':
					pos = 0;
					incomment = 0;
					lineno++;
					continue;
			case (byte)'#':
					if (!pos) {
						incomment = 1;
					} 
					break;
			case (true):
					if ((generated_flag & -1024)) {
						generatedErrors.curl_mfprintf("Header file %s read error: %s\n", filename, .strerror((._errno())));
						return -1;
					} 
					return /* Done. */0;
			}
			pos++;
			if (!incomment) {
				if (hdrlen ==  - 1) {
					generatedGlobal.warnf("File %s line %d: header too long (truncated)\n", filename, lineno);
					c = (byte)' ';
				} 
				if (hdrlen <=  - 1) {
					hdrbuf[hdrlen++] = (byte)c/* NOTREACHED */;
				} 
			} 
		}
	}
	/* Convenience macros for null pointer check. */
	public static int formparse(OperationConfig config, Object input, tool_mime mimeroot, tool_mime mimecurrent,  literal_value) {
		byte name = ((Object)/* input MUST be a string in the format 'name=contents' and we'll
		     build a linked list with the info */0);
		byte contents = ((Object)0);
		byte contp;
		byte data;
		byte type = ((Object)0);
		byte filename = ((Object)0);
		byte encoder = ((Object)0);
		curl_slist headers = ((Object)0);
		tool_mime part = ((Object)0);
		 res = new ();
		GlobalConfig generatedGlobal = config.getGlobal();
		if (!/* Allocate the main mime structure if needed. */mimecurrent) {
			{ 
				(mimeroot) = (((Object)0).tool_mime_new_parts());
				if (!(mimeroot)) {
					generatedGlobal.warnf("out of memory!\n");
					headers.curl_slist_free_all();
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 1;
				} 
			}
			;
			mimecurrent = mimeroot;
		} 
		{ 
			(contents) = (.strdup(input));
			if (!(contents)) {
				generatedGlobal.warnf("out of memory!\n");
				headers.curl_slist_free_all();
				do {
					.free((contents));
					(contents) = ((Object)0);
				} while (0);
				return /* Make a copy we can overwrite. */2;
			} 
		}
		;
		contp = .strchr(contents, /* Scan for the end of the name. */(byte)'=');
		Object generatedType = (part).getType();
		tool_mime generatedParent = (mimecurrent).getParent();
		Object generatedSize = part.getSize();
		Object generatedData = part.getData();
		Object generatedFilename = (part).getFilename();
		Object generatedEncoder = (part).getEncoder();
		tool_mime generatedSubparts = (mimecurrent).getSubparts();
		Object generatedName = (part).getName();
		if (contp) {
			int sep = (byte)'\0';
			if (contp > contents) {
				name = contents;
			} 
			contp++ = (byte)'\0';
			if (contp == (byte)'(' && !literal_value) {
				sep = config.get_param_part(/* Starting a multipart. */(byte)'\0', contp, data, type, ((Object)0), ((Object)0), headers);
				if (sep < 0) {
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 3;
				} 
				{ 
					(part) = (mimecurrent.tool_mime_new_parts());
					if (!(part)) {
						generatedGlobal.warnf("out of memory!\n");
						headers.curl_slist_free_all();
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return 4;
					} 
				}
				;
				mimecurrent = part;
				part.setHeaders(headers);
				headers = ((Object)0);
				{ 
					if (type) {
						(generatedType) = (.strdup(type));
						if (!(generatedType)) {
							generatedGlobal.warnf("out of memory!\n");
							headers.curl_slist_free_all();
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 5;
						} 
					} 
					;
				}
				;
			}  else if (!name && !.strcmp(contp, ")") && !literal_value) {
				if (mimecurrent == /* Ending a multipart. */mimeroot) {
					generatedGlobal.warnf("no multipart to terminate!\n");
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 6;
				} 
				mimecurrent = generatedParent;
			}  else if ((byte)'@' == contp[0] && !literal_value) {
				tool_mime subparts = ((Object)/* we use the @-letter to indicate file name(s) */0);
				do {
					++contp;
					sep = config.get_param_part((byte)',', contp, data, type, filename, encoder, headers);
					if (sep < 0) {
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return 7;
					} 
					if (!/* now contp point to comma or string end.
					           If more files to come, make sure we have multiparts. */subparts) {
						if (sep != /* If there is a single file. */(byte)',') {
							subparts = mimecurrent;
						} else {
								(subparts) = (mimecurrent.tool_mime_new_parts());
								if (!(subparts)) {
									generatedGlobal.warnf("out of memory!\n");
									headers.curl_slist_free_all();
									do {
										.free((contents));
										(contents) = ((Object)0);
									} while (0);
									return 8;
								} 
						} 
						;
					} 
					{ 
						(part) = (subparts.tool_mime_new_filedata(data, 1, res));
						if (!(part)) {
							generatedGlobal.warnf("out of memory!\n");
							headers.curl_slist_free_all();
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return /* Store that file in a part. */9;
						} 
					}
					;
					part.setHeaders(headers);
					headers = ((Object)0);
					part.setConfig(generatedGlobal);
					if (res == CURLE_READ_ERROR/* An error occurred while reading stdin: if read has started,
					               issue the error now. Else, delay it until processed by
					               libcurl. */) {
						if (generatedSize > 0) {
							generatedGlobal.warnf("error while reading standard input\n");
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 10;
						} 
						do {
							.free((((Object)(generatedData))));
							(((Object)(generatedData))) = ((Object)0);
						} while (0);
						part.setData(((Object)0));
						part.setSize(-1);
						res = CURLE_OK;
					} 
					{ 
						if (filename) {
							(generatedFilename) = (.strdup(filename));
							if (!(generatedFilename)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 11;
							} 
						} 
						;
					}
					;
					{ 
						if (type) {
							(generatedType) = (.strdup(type));
							if (!(generatedType)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 12;
							} 
						} 
						;
					}
					;
					{ 
						if (encoder) {
							(generatedEncoder) = (.strdup(encoder));
							if (!(generatedEncoder)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 13;
							} 
						} 
						;
					}
					;
				} while (/* *contp could be '\0', so we just check with the delimiter *//* loop if there's another file name */sep);
				part = generatedSubparts;
			} else {
					if (contp == (byte)'<' && !literal_value) {
						++contp;
						sep = config.get_param_part((byte)'\0', contp, data, type, ((Object)0), encoder, headers);
						if (sep < 0) {
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 14;
						} 
						{ 
							(part) = (mimecurrent.tool_mime_new_filedata(data, 0, res));
							if (!(part)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 15;
							} 
						}
						;
						part.setHeaders(headers);
						headers = ((Object)0);
						part.setConfig(generatedGlobal);
						if (res == CURLE_READ_ERROR/* An error occurred while reading stdin: if read has started,
						               issue the error now. Else, delay it until processed by
						               libcurl. */) {
							if (generatedSize > 0) {
								generatedGlobal.warnf("error while reading standard input\n");
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 16;
							} 
							do {
								.free((((Object)(generatedData))));
								(((Object)(generatedData))) = ((Object)0);
							} while (0);
							part.setData(((Object)0));
							part.setSize(-1);
							res = CURLE_OK;
						} 
					} else {
							if (literal_value) {
								data = contp;
							} else {
									sep = config.get_param_part((byte)'\0', contp, data, type, filename, encoder, headers);
									if (sep < 0) {
										do {
											.free((contents));
											(contents) = ((Object)0);
										} while (0);
										return 17;
									} 
							} 
							{ 
								(part) = (mimecurrent.tool_mime_new_data(data));
								if (!(part)) {
									generatedGlobal.warnf("out of memory!\n");
									headers.curl_slist_free_all();
									do {
										.free((contents));
										(contents) = ((Object)0);
									} while (0);
									return 18;
								} 
							}
							;
							part.setHeaders(headers);
							headers = ((Object)0);
					} 
					{ 
						if (filename) {
							(generatedFilename) = (.strdup(filename));
							if (!(generatedFilename)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 19;
							} 
						} 
						;
					}
					;
					{ 
						if (type) {
							(generatedType) = (.strdup(type));
							if (!(generatedType)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 20;
							} 
						} 
						;
					}
					;
					{ 
						if (encoder) {
							(generatedEncoder) = (.strdup(encoder));
							if (!(generatedEncoder)) {
								generatedGlobal.warnf("out of memory!\n");
								headers.curl_slist_free_all();
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 21;
							} 
						} 
						;
					}
					;
					if (sep) {
						contp = (byte)sep;
						generatedGlobal.warnf("garbage at end of field specification: %s\n", contp);
					} 
			} 
			{ 
				if (name) {
					(generatedName) = (.strdup(name));
					if (!(generatedName)) {
						generatedGlobal.warnf("out of memory!\n");
						headers.curl_slist_free_all();
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return /* Set part name. */22;
					} 
				} 
				;
			}
			;
		} else {
				generatedGlobal.warnf("Illegally formatted input field!\n");
				do {
					.free((contents));
					(contents) = ((Object)0);
				} while (0);
				return 23;
		} 
		do {
			.free((contents));
			(contents) = ((Object)0);
		} while (0);
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2015, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * curlx_nonblock() set the given socket to either blocking or non-blocking
	 * mode based on the 'nonblock' boolean argument. This function is highly
	 * portable.
	 */
	/* operate on this */
	public static int curlx_nonblock(Object sockfd, int nonblock) {
		long flags = nonblock ? -1024 : /* older unix versions *//* Windows */-1024;
		return .ioctlsocket(sockfd, (-1024 | (((long) & -1024) << 16) | (((byte)'f') << 8) | (true)), flags/* Amiga *//* BeOS */);
	}
	/* TRUE or FALSE */
	/* returns success */
	/* most recent unix versions */
	public static int tool_debug_cb(Object handle, Object type, Byte data, Object size, Object userdata) {
		OperationConfig operation = userdata;
		GlobalConfig generatedGlobal = operation.getGlobal();
		GlobalConfig config = generatedGlobal;
		_iobuf generatedErrors = config.getErrors();
		FILE output = generatedErrors;
		byte text;
		timeval tv = new timeval();
		byte[] timebuf = new byte[20];
		time_t secs = new time_t();
		(Object)/* not used */handle;
		 generatedTracetime = config.getTracetime();
		timeval timeval = new timeval();
		long generatedTv_sec = tv.getTv_sec();
		Object generatedTm_hour = now.getTm_hour();
		Object generatedTm_min = now.getTm_min();
		Object generatedTm_sec = now.getTm_sec();
		long generatedTv_usec = tv.getTv_usec();
		if (generatedTracetime) {
			tm now = new tm();
			time_t epoch_offset = new time_t();
			int known_offset;
			tv = timeval.tvnow();
			if (!ModernizedCProgram.known_offset) {
				ModernizedCProgram.epoch_offset = .time(((Object)0)) - generatedTv_sec;
				ModernizedCProgram.known_offset = 1;
			} 
			secs = ModernizedCProgram.epoch_offset + generatedTv_sec;
			now = .localtime(/* not thread safe but we don't care */secs);
			ModernizedCProgram.curl_msnprintf(timebuf, , "%02d:%02d:%02d.%06ld ", generatedTm_hour, generatedTm_min, generatedTm_sec, (long)generatedTv_usec);
		} else {
				timebuf[0] = 0;
		} 
		_iobuf generatedTrace_stream = config.getTrace_stream();
		Byte generatedTrace_dump = config.getTrace_dump();
		if (!generatedTrace_stream) {
			if (!.strcmp("-", generatedTrace_dump)) {
				config.setTrace_stream((_iob[1]));
			}  else if (!.strcmp("%", generatedTrace_dump)) {
				config.setTrace_stream(generatedErrors);
			} else {
					config.setTrace_stream(.fopen(generatedTrace_dump, "wt"));
					config.setTrace_fopened(1);
			} 
		} 
		if (generatedTrace_stream) {
			output = generatedTrace_stream;
		} 
		if (!output) {
			config.warnf("Failed to create/open output");
			return 0;
		} 
		 generatedTracetype = config.getTracetype();
		 generatedIsatty = config.getIsatty();
		if (generatedTracetype == .TRACE_PLAIN/*
		     * This is the trace look that is similar to what libcurl makes on its
		     * own.
		     */) {
			byte[] s_infotype = new byte[]{"*", "<", ">", "{", "}", "{", "}"};
			bool newl = 0;
			bool traced_data = 0;
			switch (type) {
			case CURLINFO_HEADER_OUT:
					if (size > 0) {
						size_t st = 0;
						size_t i = new size_t();
						for (i = 0; i < size - 1; i++) {
							if (data[i] == /* LF */(byte)'\n') {
								if (!newl) {
									output.curl_mfprintf("%s%s ", timebuf, s_infotype[type]);
								} 
								(Object).fwrite(data + st, i - st + 1, 1, output);
								st = i + 1;
								newl = 0;
							} 
						}
						if (!newl) {
							output.curl_mfprintf("%s%s ", timebuf, s_infotype[type]);
						} 
						(Object).fwrite(data + st, i - st + 1, 1, output);
					} 
					newl = (size && (data[size - 1] != (byte)'\n')) ? 1 : 0;
					traced_data = 0;
					break;
			case CURLINFO_SSL_DATA_OUT:
					if (!traced_data/* if the data is output to a tty and we're sending this debug trace
					           to stderr or stdout, we don't display the alert about the data not
					           being shown as the data _is_ shown then just not via this
					           function */) {
						if (!generatedIsatty || ((output != (_iob[2])) && (output != (_iob[1])))) {
							if (!newl) {
								output.curl_mfprintf("%s%s ", timebuf, s_infotype[type]);
							} 
							output.curl_mfprintf("[%zu bytes data]\n", size);
							newl = 0;
							traced_data = 1;
						} 
					} 
					break;
			case CURLINFO_HEADER_IN:
					if (!newl) {
						output.curl_mfprintf("%s%s ", timebuf, s_infotype[type]);
					} 
					(Object).fwrite(data, size, 1, output);
					newl = (size && (data[size - 1] != (byte)'\n')) ? 1 : 0;
					traced_data = 0;
					break;
			case CURLINFO_DATA_IN:
			case CURLINFO_TEXT:
			case CURLINFO_SSL_DATA_IN:
			case CURLINFO_DATA_OUT:
			default:
					newl = 0;
					traced_data = 0;
					break;
			}
			return 0/* Special processing is needed for CURLINFO_HEADER_OUT blocks
			   * if they contain both headers and data (separated by CRLFCRLF).
			   * We dump the header text and then switch type to CURLINFO_DATA_OUT.
			   */;
		} 
		/* dump everything through the CRLFCRLF as a sent header */switch (/* CURL_DOES_CONVERSIONS */type) {
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_TEXT:
				output.curl_mfprintf("%s== Info: %s", timebuf, data/* FALLTHROUGH */);
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		default:
				return 0;
		}
		text.dump(timebuf, output, (byte)data, size, generatedTracetype, type);
		return 0;
	}
	public static void curl_close_cb(Object handle) {
		curl_context_t context = (curl_context_t)handle.getData();
		.free(context);
	}
	public static void add_download(Object url, int num) {
		byte[] filename = new byte[50];
		FILE file = new FILE();
		 handle = new ();
		.snprintf(filename, 50, "%d.download", num);
		file = .fopen(filename, "wb");
		if (!file) {
			.fprintf((_iob[2]), "Error opening %s\n", filename);
			return ;
		} 
		Curl_easy curl_easy = new Curl_easy();
		handle = curl_easy.curl_easy_init();
		handle.curl_easy_setopt(CURLOPT_WRITEDATA, file);
		handle.curl_easy_setopt(CURLOPT_PRIVATE, file);
		handle.curl_easy_setopt(CURLOPT_URL, url);
		ModernizedCProgram.curl_multi_add_handle(ModernizedCProgram.curl_handle, handle);
		.fprintf((_iob[2]), "Added download %s -> %s\n", url, filename);
		byte[] filename = new byte[50];
		FILE file = new FILE();
		 handle = new ();
		.snprintf(filename, 50, "%d.download", num);
		file = .fopen(filename, "wb");
		if (!file) {
			.fprintf((_iob[2]), "Error opening %s\n", filename);
			return ;
		} 
		Curl_easy curl_easy = new Curl_easy();
		handle = curl_easy.curl_easy_init();
		handle.curl_easy_setopt(CURLOPT_WRITEDATA, file);
		handle.curl_easy_setopt(CURLOPT_PRIVATE, file);
		handle.curl_easy_setopt(CURLOPT_URL, url);
		ModernizedCProgram.curl_multi_add_handle(ModernizedCProgram.curl_handle, handle);
		.fprintf((_iob[2]), "Added download %s -> %s\n", url, filename);
	}
	public static void curl_perform(Object req, int status, int events) {
		int running_handles;
		int flags = 0;
		curl_context_t context = new curl_context_t();
		if (events & UV_READABLE) {
			flags |=  CURL_CSELECT_IN;
		} 
		if (events & UV_WRITABLE) {
			flags |=  CURL_CSELECT_OUT;
		} 
		context = (curl_context_t)req.getData();
		Object generatedSockfd = context.getSockfd();
		ModernizedCProgram.curl_handle.curl_multi_socket_action(generatedSockfd, flags, running_handles);
		_GlobalInfo _GlobalInfo = new _GlobalInfo();
		_GlobalInfo.check_multi_info();
		int running_handles;
		int flags = 0;
		curl_context_t context = new curl_context_t();
		if (event & EV_READ) {
			flags |=  CURL_CSELECT_IN;
		} 
		if (event & EV_WRITE) {
			flags |=  CURL_CSELECT_OUT;
		} 
		context = (curl_context_t)arg;
		Object generatedSockfd = context.getSockfd();
		ModernizedCProgram.curl_handle.curl_multi_socket_action(generatedSockfd, flags, running_handles);
		_GlobalInfo _GlobalInfo = new _GlobalInfo();
		_GlobalInfo.check_multi_info();
	}
	public static void on_timeout(Object req) {
		int running_handles;
		ModernizedCProgram.curl_handle.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, running_handles);
		_GlobalInfo _GlobalInfo = new _GlobalInfo();
		_GlobalInfo.check_multi_info();
		int running_handles;
		ModernizedCProgram.curl_handle.curl_multi_socket_action(CURL_SOCKET_TIMEOUT, 0, running_handles);
		_GlobalInfo _GlobalInfo = new _GlobalInfo();
		_GlobalInfo.check_multi_info();
	}
	public static int start_timeout(Object multi, long timeout_ms, Object userp) {
		if (timeout_ms < 0) {
			.uv_timer_stop(ModernizedCProgram.timeout);
		} else {
				if (timeout_ms == 0) {
					timeout_ms = /* 0 means directly call socket_action, but we'll do it
					                         in a bit */1;
				} 
				.uv_timer_start(ModernizedCProgram.timeout, on_timeout, timeout_ms, 0);
		} 
		return 0;
		if (timeout_ms < 0) {
			.evtimer_del(ModernizedCProgram.timeout);
		} else {
				if (timeout_ms == 0) {
					timeout_ms = /* 0 means directly call socket_action, but we'll do it
					                         in a bit */1;
				} 
				timeval tv = new timeval();
				tv.setTimeval(timeout_ms / 1000);
				tv.setTimeval((timeout_ms % 1000) * 1000);
				.evtimer_del(ModernizedCProgram.timeout);
				.evtimer_add(ModernizedCProgram.timeout, tv);
		} 
		return 0;
	}
	public static int handle_socket(Object easy, Object s, int action, Object userp, Object socketp) {
		curl_context_t curl_context = new curl_context_t();
		int events = 0;
		curl_context_s curl_context_s = new curl_context_s();
		Object generatedPoll_handle = curl_context.getPoll_handle();
		switch (action) {
		case CURL_POLL_REMOVE:
				if (socketp) {
					.uv_poll_stop(generatedPoll_handle);
					(curl_context_t)socketp.destroy_curl_context();
					ModernizedCProgram.curl_handle.curl_multi_assign(s, ((Object)0));
				} 
				break;
		case CURL_POLL_IN:
		case CURL_POLL_OUT:
		case CURL_POLL_INOUT:
				curl_context = socketp ? (curl_context_t)socketp : curl_context_s.create_curl_context(s);
				ModernizedCProgram.curl_handle.curl_multi_assign(s, (Object)curl_context);
				if (action != CURL_POLL_IN) {
					events |=  UV_WRITABLE;
				} 
				if (action != CURL_POLL_OUT) {
					events |=  UV_READABLE;
				} 
				.uv_poll_start(generatedPoll_handle, events, ModernizedCProgram.curl_perform);
				break;
		default:
				.abort();
		}
		return 0;
		curl_context_t curl_context = new curl_context_t();
		int events = 0;
		curl_context_s curl_context_s = new curl_context_s();
		Object generatedEvent = curl_context.getEvent();
		Object generatedSockfd = curl_context.getSockfd();
		switch (action) {
		case CURL_POLL_IN:
		case CURL_POLL_REMOVE:
				if (socketp) {
					.event_del(generatedEvent);
					(curl_context_t)socketp.destroy_curl_context();
					ModernizedCProgram.curl_handle.curl_multi_assign(s, ((Object)0));
				} 
				break;
		case CURL_POLL_INOUT:
				curl_context = socketp ? (curl_context_t)socketp : curl_context_s.create_curl_context(s);
				ModernizedCProgram.curl_handle.curl_multi_assign(s, (Object)curl_context);
				if (action != CURL_POLL_IN) {
					events |=  EV_WRITE;
				} 
				if (action != CURL_POLL_OUT) {
					events |=  EV_READ;
				} 
				events |=  EV_PERSIST;
				.event_del(generatedEvent);
				.event_assign(generatedEvent, ModernizedCProgram.base, generatedSockfd, events, ModernizedCProgram.curl_perform, curl_context);
				.event_add(generatedEvent, ((Object)0));
				break;
		case CURL_POLL_OUT:
		default:
				.abort();
		}
		return 0;
	}
	public static Byte Curl_checkProxyheaders(Object conn, Object thisheader) {
		curl_slist head = new curl_slist();
		size_t thislen = .strlen(thisheader);
		Curl_easy data = conn.getData();
		Object generatedCurl_slist = head.getCurl_slist();
		Object generatedSet = data.getSet();
		for (head = (conn.getBits().getProxy() && generatedSet.getSep_headers()) ? generatedSet.getProxyheaders() : generatedSet.getHeaders(); head; head = generatedCurl_slist) {
			if (ModernizedCProgram.Curl_strncasecompare(generatedCurl_slist, thisheader, thislen) && ((((generatedCurl_slist[thislen]) == (byte)':') || ((generatedCurl_slist[thislen]) == (byte)';')))) {
				return generatedCurl_slist;
			} 
		}
		return ((Object)0/* disabled */);
	}
	/*
	 * Strip off leading and trailing whitespace from the value in the
	 * given HTTP header line and return a strdupped copy. Returns NULL in
	 * case of allocation failure. Returns an empty string if the header value
	 * consists entirely of whitespace.
	 */
	public static Byte Curl_copy_header_value(Object header) {
		byte start;
		byte end;
		byte value;
		size_t len = new size_t();
		while (header && (header != /* Find the end of the header name */(byte)':')) {
			++header;
		}
		if (header) {
			++/* Skip over colon */header;
		} 
		start = /* Find the first non-space letter */header;
		while (start && (ModernizedCProgram.Curl_isspace((int)((byte)start)))) {
			start++;
		}
		end = .strchr(start, /* data is in the host encoding so
		     use '\r' and '\n' instead of 0x0d and 0x0a */(byte)'\r');
		if (!end) {
			end = .strchr(start, (byte)'\n');
		} 
		if (!end) {
			end = .strchr(start, (byte)'\0');
		} 
		if (!end) {
			return ((Object)0);
		} 
		while ((end > start) && (ModernizedCProgram.Curl_isspace((int)((byte)/* skip all trailing space letters */end)))) {
			end--;
		}
		len = end - start + /* get length of the type */1;
		value = .Curl_cmalloc(len + 1);
		if (!value) {
			return ((Object)0);
		} 
		.memcpy(value, start, len);
		value[len] = /* zero terminate */0;
		return value/*
		 * http_output_basic() sets up an Authorization: header (or the proxy version)
		 * for HTTP Basic authentication.
		 *
		 * Returns CURLcode.
		 *//*
		 * http_output_basic() sets up an Authorization: header (or the proxy version)
		 * for HTTP Basic authentication.
		 *
		 * Returns CURLcode.
		 */;
	}
	public static Object output_auth_headers(connectdata conn, auth authstatus, Object request, Object path,  proxy) {
		byte auth = ((Object)0);
		 result = CURLE_OK;
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		long generatedPicked = authstatus.getPicked();
		ConnectBits generatedBits = conn.getBits();
		Object generatedProxy_user_passwd = generatedBits.getProxy_user_passwd();
		Object generatedUser_passwd = generatedBits.getUser_passwd();
		if (generatedPicked == CURLAUTH_NTLM) {
			auth = "NTLM";
			result = conn.Curl_output_ntlm(proxy);
			if (result) {
				return result;
			} 
		}  else if (generatedPicked == CURLAUTH_DIGEST) {
			auth = "Digest";
			result = conn.Curl_output_digest(proxy, (byte)request, (byte)path);
			if (result) {
				return result;
			} 
		}  else if (generatedPicked == CURLAUTH_BASIC) {
			if ((proxy && generatedProxy_user_passwd && !ModernizedCProgram.Curl_checkProxyheaders(conn, "Proxy-authorization")) || (!proxy && generatedUser_passwd && !ModernizedCProgram.Curl_checkheaders(conn, "Authorization"))) {
				auth = "Basic";
				result = conn.http_output_basic(proxy);
				if (result) {
					return result;
				} 
			} 
			authstatus.setDone(/* NOTE: this function should set 'done' TRUE, as the other auth
			       functions work that way */1);
		} 
		Byte generatedOauth_bearer = conn.getOauth_bearer();
		if (generatedPicked == CURLAUTH_BEARER) {
			if ((!proxy && generatedOauth_bearer && !ModernizedCProgram.Curl_checkheaders(conn, "Authorization:"))) {
				auth = "Bearer";
				result = conn.http_output_bearer();
				if (result) {
					return result;
				} 
			} 
			authstatus.setDone(/* NOTE: this function should set 'done' TRUE, as the other auth
			       functions work that way */1);
		} 
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		Byte generatedUser = generatedHttp_proxy.getUser();
		Object generatedDone = authstatus.getDone();
		if (auth) {
			data.Curl_infof("%s auth using %s with user '%s'\n", proxy ? "Proxy" : "Server", auth, proxy ? (generatedUser ? generatedUser : "") : (generatedUser ? generatedUser : ""));
			authstatus.setMultipass((!generatedDone) ? 1 : 0);
		} else {
				authstatus.setMultipass(0);
		} 
		return CURLE_OK/**
		 * Curl_http_output_auth() setups the authentication headers for the
		 * host/proxy and the correct authentication
		 * method. conn->data->state.authdone is set to TRUE when authentication is
		 * done.
		 *
		 * @param conn all information about the current connection
		 * @param request pointer to the request keyword
		 * @param path pointer to the requested path; should include query part
		 * @param proxytunnel boolean if this is the request setting up a "proxy
		 * tunnel"
		 *
		 * @returns CURLcode
		 */;
	}
	public static Object readmoredata(Byte buffer, Object size, Object nitems, Object userp) {
		connectdata conn = (connectdata)userp;
		Curl_easy generatedData = conn.getData();
		Object generatedReq = generatedData.getReq();
		HTTP http = generatedReq.getProtop();
		size_t fullsize = size * nitems;
		Object generatedPostsize = http.getPostsize();
		if (!generatedPostsize) {
			return /* nothing to return */0;
		} 
		 generatedSending = http.getSending();
		generatedReq.setForbidchunk((generatedSending == .HTTPSEND_REQUEST) ? 1 : /* make sure that a HTTP request is never sent away chunked! */0);
		Object generatedPostdata = http.getPostdata();
		back generatedBackup = http.getBackup();
		Object generatedFread_func = generatedBackup.getFread_func();
		Object generatedState = generatedData.getState();
		Object generatedFread_in = generatedBackup.getFread_in();
		if (generatedPostsize <= ()fullsize) {
			.memcpy(buffer, generatedPostdata, (size_t)generatedPostsize);
			fullsize = (size_t)generatedPostsize;
			if (generatedPostsize) {
				http.setPostdata(generatedPostdata);
				http.setPostsize(generatedPostsize);
				generatedState.setFread_func(generatedFread_func);
				generatedState.setIn(generatedFread_in);
				generatedSending++;
				generatedBackup.setPostsize(0);
			} else {
					http.setPostsize(0);
			} 
			return fullsize;
		} 
		.memcpy(buffer, generatedPostdata, fullsize);
		generatedPostdata += fullsize;
		generatedPostsize -= fullsize;
		return fullsize/* ------------------------------------------------------------------------- *//* add_buffer functions */;
	}
	public static Object Curl_add_buffer_send(Curl_send_buffer inp, connectdata conn, Object bytes_written, Object included_body_bytes, int socketindex) {
		/* how much of the buffer contains body data */ssize_t amount = new ssize_t();
		 result = new ();
		byte ptr;
		size_t size = new size_t();
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Object generatedReq = data.getReq();
		HTTP http = generatedReq.getProtop();
		size_t sendsize = new size_t();
		 sockfd = new ();
		size_t headersize = new size_t();
		Curl_send_buffer in = inp;
		do {
		} while (0);
		Object generatedSock = conn.getSock();
		sockfd = generatedSock[socketindex/* The looping below is required since we use non-blocking sockets, but due
		     to the circumstances we will just loop and try again and again etc */];
		Byte generatedBuffer = in.getBuffer();
		ptr = generatedBuffer;
		Object generatedSize_used = in.getSize_used();
		size = generatedSize_used;
		headersize = size - /* the initial part that isn't body
		                                              is header */included_body_bytes;
		do {
		} while (0);
		result = ();
		if (/* Curl_convert_to_network calls failf if unsuccessful */result) {
			/* conversion failed, free memory and return to the caller */inp.Curl_add_buffer_free();
			return result;
		} 
		Object generatedHandler = conn.getHandler();
		proxy_info generatedHttp_proxy = conn.getHttp_proxy();
		Object generatedProxytype = generatedHttp_proxy.getProxytype();
		int generatedHttpversion = conn.getHttpversion();
		Object generatedState = data.getState();
		if ((generatedHandler.getFlags() & (1 << 0) || generatedProxytype == CURLPROXY_HTTPS) && generatedHttpversion != 20/* We never send more than CURL_MAX_WRITE_SIZE bytes in one single chunk
		       when we speak HTTPS, as if only a fraction of it is sent now, this data
		       needs to fit into the normal read-callback buffer later on and that
		       buffer is using this size.
		    */) {
			sendsize = ((size) < (CURL_MAX_WRITE_SIZE) ? (size) : (CURL_MAX_WRITE_SIZE/* OpenSSL is very picky and we must send the SAME buffer pointer to the
			       library when we attempt to re-send this buffer. Sending the same data
			       is not enough, we must use the exact same address. For this reason, we
			       must copy the data to the uploadbuffer first, since that is the buffer
			       we will be using if this send is retried later.
			    */));
			result = data.Curl_get_upload_buffer();
			if (result) {
				/* malloc failed, free memory and return to the caller */in.Curl_add_buffer_free();
				return result;
			} 
			.memcpy(generatedState.getUlbuf(), ptr, sendsize);
			ptr = generatedState.getUlbuf();
		} else {
				sendsize = size;
		} 
		result = conn.Curl_write(sockfd, ptr, sendsize, amount);
		Object generatedSet = data.getSet();
		back generatedBackup = http.getBackup();
		Object generatedPostdata = http.getPostdata();
		Object generatedPostsize = http.getPostsize();
		if (!result/*
		     * Note that we may not send the entire chunk at once, and we have a set
		     * number of data bytes at the end of the big buffer (out of which we may
		     * only send away a part).
		     */) {
			size_t headlen = (size_t)amount > headersize ? headersize : (size_t)/* how much of the header that was sent */amount;
			size_t bodylen = amount - headlen;
			if (generatedSet.getVerbose()) {
				data.Curl_debug(CURLINFO_HEADER_OUT, ptr, /* this data _may_ contain binary stuff */headlen);
				if (bodylen/* there was body data sent beyond the initial header part, pass that
				           on to the debug callback too */) {
					data.Curl_debug(CURLINFO_DATA_OUT, ptr + headlen, bodylen);
				} 
			} 
			bytes_written += (long)/* 'amount' can never be a very large value here so typecasting it so a
			       signed 31 bit value should not cause problems even if ssize_t is
			       64bit */amount;
			if (http/* if we sent a piece of the body here, up the byte counter for it
			         accordingly */) {
				generatedReq.getWritebytecount() += bodylen;
				data.Curl_pgrsSetUploadCounter(generatedReq.getWritebytecount());
				if ((size_t)amount != size/* The whole request could not be sent in one system call. We must
				           queue it up and send it later when we get the chance. We must not
				           loop here and wait until it might work again. */) {
					size -= amount;
					ptr = generatedBuffer + amount;
					generatedBackup.setFread_func(generatedState.getFread_func());
					generatedBackup.setFread_in(generatedState.getIn());
					generatedBackup.setPostdata(generatedPostdata);
					generatedBackup.setPostsize(generatedPostsize);
					generatedState.setFread_func(()/* set the new pointers for the request-sending */readmoredata);
					generatedState.setIn((Object)conn);
					http.setPostdata(ptr);
					http.setPostsize(()size);
					http.setSend_buffer(in);
					http.setSending(.HTTPSEND_REQUEST);
					return CURLE_OK;
				} 
				http.setSending(.HTTPSEND_BODY/* the full buffer was sent, clean up and return */);
			} else {
					if ((size_t)amount != size/* We have no continue-send mechanism now, fail. This can only happen
					           when this function is used from the CONNECT sending function. We
					           currently (stupidly) assume that the whole request is always sent
					           away in the first single chunk.
					
					           This needs FIXing.
					        */) {
						return CURLE_SEND_ERROR;
					} 
			} 
		} 
		in.Curl_add_buffer_free();
		return result;
	}
	/*
	 * Curl_compareheader()
	 *
	 * Returns TRUE if 'headerline' contains the 'header' with given 'content'.
	 * Pass headers WITH the colon.
	 */
	/* line to check */
	public static  Curl_compareheader(Object headerline, Object header, Object content) {
		size_t hlen = .strlen(header);
		size_t clen = new size_t();
		size_t len = new size_t();
		byte start;
		byte end;
		if (!ModernizedCProgram.Curl_strncasecompare(headerline, header, hlen)) {
			return /* doesn't start with header */0;
		} 
		start = headerline[/* pass the header */hlen];
		while (start && (ModernizedCProgram.Curl_isspace((int)((byte)/* pass all white spaces */start)))) {
			start++;
		}
		end = .strchr(start, /* find the end of the header line *//* lines end with CRLF */(byte)'\r');
		if (!end) {
			end = .strchr(start, /* in case there's a non-standard compliant line here */(byte)'\n');
			if (!end) {
				end = .strchr(start, /* hm, there's no line ending here, use the zero byte! */(byte)'\0');
			} 
		} 
		len = end - /* length of the content part of the input line */start;
		clen = .strlen(/* length of the word to find */content);
		for (; len >= clen; ) {
			if (ModernizedCProgram.Curl_strncasecompare(start, content, clen)) {
				return /* match! */1;
			} 
		}
		return /* no match */0/*
		 * Curl_http_connect() performs HTTP stuff to do at connect-time, called from
		 * the generic Curl_connect().
		 */;
	}
	/* header keyword _with_ colon */
	/* content string to find */
	/* RFC2616, section 4.2 says: "Each header field consists of a name followed
	   * by a colon (":") and the field value. Field names are case-insensitive.
	   * The field value MAY be preceded by any amount of LWS, though a single SP
	   * is preferred." */
	public static  use_http_1_1plus(Object data, Object conn) {
		if ((data.getState().getHttpversion() == 10) || (conn.getHttpversion() == 10)) {
			return 0;
		} 
		if ((data.getSet().getHttpversion() == CURL_HTTP_VERSION_1_0) && (conn.getHttpversion() <= 10)) {
			return 0;
		} 
		return ((data.getSet().getHttpversion() == CURL_HTTP_VERSION_NONE) || (data.getSet().getHttpversion() >= CURL_HTTP_VERSION_1_1));
	}
	public static Object get_http_string(Object data, Object conn) {
		if (ModernizedCProgram.use_http_1_1plus(data, conn)) {
			return "1.1";
		} 
		return "1.0";
	}
	/* check and possibly add an Expect: header */
	public static Object expect100(Curl_easy data, connectdata conn, Curl_send_buffer req_buffer) {
		 result = CURLE_OK;
		Object generatedState = data.getState();
		generatedState.setExpect100header(/* default to false unless it is set
		                                          to TRUE below */0);
		int generatedHttpversion = conn.getHttpversion();
		if (ModernizedCProgram.use_http_1_1plus(data, conn) && (generatedHttpversion < 20/* if not doing HTTP 1.0 or version 2, or disabled explicitly, we add an
		       Expect: 100-continue to the headers which actually speeds up post
		       operations (as there is one packet coming back from the web server) */)) {
			byte ptr = ModernizedCProgram.Curl_checkheaders(conn, "Expect");
			if (ptr) {
				generatedState.setExpect100header(ModernizedCProgram.Curl_compareheader(ptr, "Expect:", "100-continue"));
			} else {
					result = req_buffer.Curl_add_bufferf("Expect: 100-continue\r\n");
					if (!result) {
						generatedState.setExpect100header(1);
					} 
			} 
		} 
		return result;
	}
	/* used to compile the provided trailers into one buffer
	   will return an error code if one of the headers is
	   not formatted correctly */
	public static Object Curl_http_compile_trailers(curl_slist trailers, Curl_send_buffer buffer, Curl_easy handle) {
		byte ptr = ((Object)0);
		 result = CURLE_OK;
		byte endofline_native = ((Object)0);
		byte endofline_network = ((Object)0);
		Object generatedSet = handle.getSet();
		if ((generatedSet.getCrlf())) {
			endofline_native = /* \n will become \r\n later on */"\n";
			endofline_network = "\x0a";
		} else {
				endofline_native = "\r\n";
				endofline_network = "\x0d\x0a";
		} 
		Object generatedCurl_slist = trailers.getCurl_slist();
		while (trailers) {
			ptr = .strchr(generatedCurl_slist, /* only add correctly formatted trailers */(byte)':');
			if (ptr && (ptr + 1) == (byte)' ') {
				result = buffer.Curl_add_bufferf("%s%s", generatedCurl_slist, endofline_native);
				if (result) {
					return result;
				} 
			} else {
					handle.Curl_infof("Malformatted trailing header ! Skipping trailer.");
			} 
			trailers = generatedCurl_slist;
		}
		result = buffer.Curl_add_buffer(endofline_network, .strlen(endofline_network));
		return result;
	}
	public static Object Curl_add_custom_headers(connectdata conn,  is_connect, Curl_send_buffer req_buffer) {
		byte ptr;
		curl_slist[] h = new curl_slist();
		curl_slist headers = new curl_slist();
		int numlists = /* by default */1;
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		int i;
		proxy_use proxy;
		ConnectBits generatedBits = conn.getBits();
		Object generatedHttpproxy = generatedBits.getHttpproxy();
		Object generatedTunnel_proxy = generatedBits.getTunnel_proxy();
		if (is_connect) {
			proxy_use.proxy = proxy_use.HEADER_CONNECT;
		} else {
				proxy_use.proxy = generatedHttpproxy && !generatedTunnel_proxy ? proxy_use.HEADER_PROXY : proxy_use.HEADER_SERVER;
		} 
		Object generatedSet = data.getSet();
		switch (proxy_use.proxy) {
		case proxy_use.HEADER_CONNECT:
				if (generatedSet.getSep_headers()) {
					h[0] = generatedSet.getProxyheaders();
				} else {
						h[0] = generatedSet.getHeaders();
				} 
				break;
		case proxy_use.HEADER_SERVER:
				h[0] = generatedSet.getHeaders();
				break;
		case proxy_use.HEADER_PROXY:
				h[0] = generatedSet.getHeaders();
				if (generatedSet.getSep_headers()) {
					h[1] = generatedSet.getProxyheaders();
					numlists++;
				} 
				break;
		}
		Object generatedCurl_slist = headers.getCurl_slist();
		dynamically_allocated_data generatedAllocptr = conn.getAllocptr();
		Byte generatedHost = generatedAllocptr.getHost();
		Object generatedAuthneg = generatedBits.getAuthneg();
		Byte generatedTe = generatedAllocptr.getTe();
		int generatedHttpversion = conn.getHttpversion();
		Object generatedState = data.getState();
		for (i = 0; i < numlists; /* loop through one or two lists */i++) {
			headers = h[i];
			while (headers) {
				byte semicolonp = ((Object)0);
				ptr = .strchr(generatedCurl_slist, (byte)':');
				if (!ptr) {
					byte optr;
					ptr = .strchr(generatedCurl_slist, /* no colon, semicolon? */(byte)';');
					if (ptr) {
						optr = ptr;
						/* pass the semicolon */ptr++;
						while (ptr && (ModernizedCProgram.Curl_isspace((int)((byte)ptr)))) {
							ptr++;
						}
						if (ptr) {
							optr = ((Object)/* this may be used for something else in the future */0);
						} else {
								if ((--ptr) == (byte)';') {
									semicolonp = .Curl_cstrdup(generatedCurl_slist);
									if (!semicolonp) {
										req_buffer.Curl_add_buffer_free();
										return CURLE_OUT_OF_MEMORY;
									} 
									semicolonp[ptr - generatedCurl_slist] = /* put a colon where the semicolon is */(byte)':';
									optr = semicolonp[ptr - generatedCurl_slist];
								} 
						} 
						ptr = optr;
					} 
				} 
				if (ptr/* we require a colon for this to be a true header */) {
					/* pass the colon */ptr++;
					while (ptr && (ModernizedCProgram.Curl_isspace((int)((byte)ptr)))) {
						ptr++;
					}
					if (ptr || semicolonp) {
						 result = /* only send this if the contents was non-blank or done special */CURLE_OK;
						byte compare = semicolonp ? semicolonp : generatedCurl_slist;
						if (generatedHost && ModernizedCProgram.curl_strnequal("Host:", compare, .strlen("Host:"))) {
							;
						}  else if (generatedSet.getHttpreq() == .HTTPREQ_POST_FORM && ModernizedCProgram.curl_strnequal("Content-Type:", compare, .strlen(/* this header (extended by formdata.c) is sent later */"Content-Type:"))) {
							;
						}  else if (generatedSet.getHttpreq() == .HTTPREQ_POST_MIME && ModernizedCProgram.curl_strnequal("Content-Type:", compare, .strlen(/* this header is sent later */"Content-Type:"))) {
							;
						}  else if (generatedAuthneg && ModernizedCProgram.curl_strnequal("Content-Length:", compare, .strlen("Content-Length:"))) {
							;
						}  else if (generatedTe && ModernizedCProgram.curl_strnequal("Connection:", compare, .strlen("Connection:"))) {
							;
						}  else if ((generatedHttpversion >= 20) && ModernizedCProgram.curl_strnequal("Transfer-Encoding:", compare, .strlen("Transfer-Encoding:"/* HTTP/2 doesn't support chunked requests */))) {
							;
						}  else if ((ModernizedCProgram.curl_strnequal("Authorization:", compare, .strlen("Authorization:")) || ModernizedCProgram.curl_strnequal("Cookie:", compare, .strlen("Cookie:"/* be careful of sending this potentially sensitive header to
						                     other hosts */))) && (generatedState.getThis_is_a_follow() && generatedState.getFirst_host() && !generatedSet.getAllow_auth_to_other_hosts() && !ModernizedCProgram.Curl_strcasecompare(generatedState.getFirst_host(), generatedHost.getName()))) {
							;
						} else {
								ModernizedCProgram.result = req_buffer.Curl_add_bufferf("%s\r\n", compare);
						} 
						if (semicolonp) {
							.Curl_cfree(semicolonp);
						} 
						if (ModernizedCProgram.result) {
							return ModernizedCProgram.result;
						} 
					} 
				} 
				headers = generatedCurl_slist;
			}
		}
		return CURLE_OK;
	}
	/* not a status line */
	/* Check a string for a prefix. Check no more than 'len' bytes */
	public static  checkprefixmax(Object prefix, Object buffer, Object len) {
		size_t ch = ((.strlen(prefix)) < (len) ? (.strlen(prefix)) : (len));
		return ModernizedCProgram.curl_strnequal(prefix, buffer, ch/*
		 * checkhttpprefix()
		 *
		 * Returns TRUE if member of the list matches prefix of string
		 */);
	}
	public static  checkprotoprefix(Curl_easy data, connectdata conn, Object s, Object len) {
		Object generatedHandler = conn.getHandler();
		if (generatedHandler.getProtocol() & CURLPROTO_RTSP) {
			return data.checkrtspprefix(s, len);
		} 
		return data.checkhttpprefix(s, /* CURL_DISABLE_RTSP */len/*
		 * header_append() copies a chunk of data to the end of the already received
		 * header. We make sure that the full string fit in the allocated header
		 * buffer, or else we enlarge it.
		 */);
	}
	public static Object header_append(Curl_easy data, SingleRequest k, Object length) {
		Object generatedHbuflen = k.getHbuflen();
		size_t newsize = generatedHbuflen + /* length is at most the size of a full read buffer, for which the upper
		     bound is CURL_MAX_READ_SIZE. There is thus no chance of overflow in this
		     calculation. */length;
		if (newsize > CURL_MAX_HTTP_HEADER/* The reason to have a max limit for this is to avoid the risk of a bad
		       server feeding libcurl with a never-ending header that will cause
		       reallocs infinitely */) {
			data.Curl_failf("Rejected %zu bytes header (max is %d)!", newsize, CURL_MAX_HTTP_HEADER);
			return CURLE_OUT_OF_MEMORY;
		} 
		Object generatedState = data.getState();
		byte generatedHbufp = k.getHbufp();
		if (newsize >= generatedState.getHeadersize()) {
			byte newbuff;
			size_t hbufp_index = new size_t();
			newsize = (((generatedHbuflen + length) * 3 / 2) > (generatedState.getHeadersize() * 2) ? ((generatedHbuflen + length) * 3 / 2) : (generatedState.getHeadersize() * 2));
			hbufp_index = generatedHbufp - generatedState.getHeaderbuff();
			newbuff = .Curl_crealloc(generatedState.getHeaderbuff(), newsize);
			if (!newbuff) {
				data.Curl_failf("Failed to alloc memory for big header!");
				return CURLE_OUT_OF_MEMORY;
			} 
			generatedState.setHeadersize(newsize);
			generatedState.setHeaderbuff(newbuff);
			k.setHbufp(generatedState.getHeaderbuff() + hbufp_index);
		} 
		Byte generatedStr_start = k.getStr_start();
		.memcpy(generatedHbufp, generatedStr_start, length);
		generatedHbufp += length;
		generatedHbuflen += length;
		generatedHbufp = 0;
		return CURLE_OK;
	}
	public static Object Curl_http_readwrite_headers(Curl_easy data, connectdata conn, Object nread,  stop_reading) {
		 result = new ();
		Object generatedReq = data.getReq();
		SingleRequest k = generatedReq;
		ssize_t onread = nread;
		byte generatedStr = k.getStr();
		byte ostr = generatedStr;
		Byte generatedStr_start = k.getStr_start();
		Byte generatedEnd_ptr = k.getEnd_ptr();
		int generatedHeaderline = k.getHeaderline();
		Object generatedState = data.getState();
		Object generatedHbuflen = k.getHbuflen();
		Object generatedSet = data.getSet();
		byte generatedHbufp = k.getHbufp();
		byte generatedP = k.getP();
		int generatedHttpcode = k.getHttpcode();
		expect100 generatedExp100 = k.getExp100();
		int generatedKeepon = k.getKeepon();
		upgrade101 generatedUpgr101 = k.getUpgr101();
		Object generatedSize = k.getSize();
		Object generatedChunk = k.getChunk();
		ConnectBits generatedBits = conn.getBits();
		Object generatedClose = generatedBits.getClose();
		int generatedHttpversion = conn.getHttpversion();
		Object generatedHandler = conn.getHandler();
		 generatedHttp_ntlm_state = conn.getHttp_ntlm_state();
		 generatedProxy_ntlm_state = conn.getProxy_ntlm_state();
		Object generatedInfo = data.getInfo();
		Object generatedAuthneg = generatedBits.getAuthneg();
		Object generatedRewindaftersend = generatedBits.getRewindaftersend();
		Object generatedUpload_done = k.getUpload_done();
		Object generatedHeader = k.getHeader();
		Object generatedMaxdownload = k.getMaxdownload();
		connectbundle generatedBundle = conn.getBundle();
		int generatedRtspversion = conn.getRtspversion();
		Object generatedUser_passwd = generatedBits.getUser_passwd();
		Object generatedProxy_user_passwd = generatedBits.getProxy_user_passwd();
		Object generatedHttp_bodyless = k.getHttp_bodyless();
		Object generatedHttpproxy = generatedBits.getHttpproxy();
		Object generatedOffset = k.getOffset();
		Object generatedCookies = data.getCookies();
		dynamically_allocated_data generatedAllocptr = conn.getAllocptr();
		Byte generatedCookiehost = generatedAllocptr.getCookiehost();
		hostname generatedHost = conn.getHost();
		Byte generatedName = generatedHost.getName();
		Cookie cookie = new Cookie();
		Object generatedTimeofdoc = k.getTimeofdoc();
		/* header line within buffer loop */do {
			size_t rest_length = new size_t();
			size_t full_length = new size_t();
			int writetype;
			k.setStr_start(generatedStr);
			k.setEnd_ptr(.memchr(generatedStr_start, -1024, /* data is in network encoding so use 0x0a instead of '\n' */nread));
			if (!generatedEnd_ptr) {
				result = ModernizedCProgram.header_append(data, k, nread);
				if (result) {
					return result;
				} 
				if (!generatedHeaderline) {
					statusline st = ModernizedCProgram.checkprotoprefix(data, conn, generatedState.getHeaderbuff(), generatedHbuflen);
					if (st == .STATUS_BAD) {
						k.setHeader(/* this is not the beginning of a protocol first header line */0);
						k.setBadheader(.HEADER_ALLBAD);
						conn.Curl_conncontrol(2);
						if (!generatedSet.getHttp09_allowed()) {
							data.Curl_failf("Received HTTP/0.9 when not allowed\n");
							return CURLE_UNSUPPORTED_PROTOCOL;
						} 
						break;
					} 
				} 
				break;
			} 
			rest_length = (generatedEnd_ptr - generatedStr) + /* decrease the size of the remaining (supposed) header line */1;
			nread -= (ssize_t)rest_length;
			k.setStr(generatedEnd_ptr + /* move past new line */1);
			full_length = generatedStr - generatedStr_start;
			result = ModernizedCProgram.header_append(data, k, full_length);
			if (result) {
				return result;
			} 
			k.setEnd_ptr(generatedHbufp);
			k.setP(generatedState.getHeaderbuff());
			if (!generatedHeaderline) {
				statusline st = ModernizedCProgram.checkprotoprefix(data, conn, generatedState.getHeaderbuff(), generatedHbuflen);
				if (st == .STATUS_BAD) {
					conn.Curl_conncontrol(2);
					if (!generatedSet.getHttp09_allowed()) {
						data.Curl_failf("Received HTTP/0.9 when not allowed\n");
						return CURLE_UNSUPPORTED_PROTOCOL;
					} 
					k.setHeader(0);
					if (nread) {
						k.setBadheader(/* since there's more, this is a partial bad header */.HEADER_PARTHEADER);
					} else {
							k.setBadheader(/* this was all we read so it's all a bad header */.HEADER_ALLBAD);
							nread = onread;
							k.setStr(ostr);
							return CURLE_OK;
					} 
					break;
				} 
			} 
			if ((-1024 == generatedP) || (-1024 == generatedP)) {
				size_t headerlen = new size_t();
				if ((byte)'\r' == generatedP) {
					generatedP++;
				} 
				if ((byte)'\n' == generatedP) {
					generatedP++;
				} 
				if (100 <= generatedHttpcode && 199 >= generatedHttpcode) {
					switch (generatedHttpcode) {
					case 100/*
					           * We have made a HTTP PUT or POST and this is 1.1-lingo
					           * that tells us that the server is OK with this and ready
					           * to receive the data.
					           * However, we'll get more headers now so we must get
					           * back into the header-parsing state!
					           */:
							k.setHeader(1);
							k.setHeaderline(/* restart the header line counter */0);
							if (generatedExp100 > /* if we did wait for this do enable write now! */expect100.EXP100_SEND_DATA) {
								k.setExp100(expect100.EXP100_SEND_DATA);
								generatedKeepon |=  (1 << 1);
								data.Curl_expire_done(.EXPIRE_100_TIMEOUT);
							} 
							break;
					case 101:
							if (generatedUpgr101 == /* Switching Protocols */upgrade101.UPGR101_REQUESTED) {
								data.Curl_infof(/* Switching to HTTP/2 */"Received 101\n");
								k.setUpgr101(upgrade101.UPGR101_RECEIVED);
								k.setHeader(/* we'll get more headers (HTTP/2 response) */1);
								k.setHeaderline(/* restart the header line counter */0);
								result = /* switch to http2 now. The bytes after response headers
								               are also processed here, otherwise they are lost. */CURLE_UNSUPPORTED_PROTOCOL;
								if (result) {
									return result;
								} 
								nread = 0;
							} else {
									k.setHeader(/* Switching to another protocol (e.g. WebSocket) *//* no more header to parse! */0);
							} 
							break;
					default:
							k.setHeader(1);
							k.setHeaderline(/* restart the header line counter */0);
							break;
					}
				} else {
						k.setHeader(/* no more header to parse! */0);
						if ((generatedSize == -1) && !generatedChunk && !generatedClose && (generatedHttpversion == 11) && !(generatedHandler.getProtocol() & CURLPROTO_RTSP) && generatedSet.getHttpreq() != .HTTPREQ_HEAD/* On HTTP 1.1, when connection is not to get closed, but no
						             Content-Length nor Transfer-Encoding chunked have been
						             received, according to RFC2616 section 4.4 point 5, we
						             assume that the server will close the connection to
						             signal the end of the document. */) {
							data.Curl_infof("no chunk, no close, no size. Assume close to signal end\n");
							conn.Curl_conncontrol(2);
						} 
				} 
				if (generatedClose && (((generatedHttpcode == 401) && (generatedHttp_ntlm_state == .NTLMSTATE_TYPE2)) || ((generatedHttpcode == 407) && (generatedProxy_ntlm_state == .NTLMSTATE_TYPE2)))) {
					data.Curl_infof("Connection closure while negotiating auth (HTTP 1.0?)\n");
					generatedState.setAuthproblem(1);
				} 
				if (/*
				       * When all the headers have been parsed, see if we should give
				       * up and return an error.
				       */conn.http_should_fail()) {
					data.Curl_failf("The requested URL returned error: %d", generatedHttpcode);
					return CURLE_HTTP_RETURNED_ERROR;
				} 
				writetype = (1 << /* now, only output this if the header AND body are requested:
				       */1);
				if (generatedSet.getInclude_header()) {
					writetype |=  (1 << 0);
				} 
				headerlen = generatedP - generatedState.getHeaderbuff();
				result = conn.Curl_client_write(writetype, generatedState.getHeaderbuff(), headerlen);
				if (result) {
					return result;
				} 
				generatedInfo.getHeader_size() += (long)headerlen;
				generatedReq.getHeaderbytecount() += (long)headerlen;
				generatedReq.setDeductheadercount((100 <= generatedHttpcode && 199 >= generatedHttpcode) ? generatedReq.getHeaderbytecount() : 0/* Curl_http_auth_act() checks what authentication methods
				       * that are available and decides which one (if any) to
				       * use. It will set 'newurl' if an auth method was picked. */);
				result = conn.Curl_http_auth_act();
				if (result) {
					return result;
				} 
				if (generatedHttpcode >= 300) {
					if ((!generatedAuthneg) && !generatedClose && !generatedRewindaftersend) {
						switch (generatedSet.getHttpreq()) {
						case .HTTPREQ_PUT:
						case .HTTPREQ_POST:
						case .HTTPREQ_POST_FORM:
						case .HTTPREQ_POST_MIME/* We got an error response. If this happened before the whole
						             * request body has been sent we stop sending and mark the
						             * connection for closure after we've read the entire response.
						             */:
								data.Curl_expire_done(.EXPIRE_100_TIMEOUT);
								if (!generatedUpload_done) {
									if (generatedSet.getHttp_keep_sending_on_error()) {
										data.Curl_infof("HTTP error before end of send, keep sending\n");
										if (generatedExp100 > expect100.EXP100_SEND_DATA) {
											k.setExp100(expect100.EXP100_SEND_DATA);
											generatedKeepon |=  (1 << 1);
										} 
									} else {
											data.Curl_infof("HTTP error before end of send, stop sending\n");
											conn.Curl_conncontrol(2);
											result = ModernizedCProgram.Curl_done_sending(conn, k);
											if (result) {
												return result;
											} 
											k.setUpload_done(1);
											if (generatedState.getExpect100header()) {
												k.setExp100(expect100.EXP100_FAILED);
											} 
									} 
								} 
								break;
						default:
								break;
						}
					} 
					if (generatedRewindaftersend) {
						data.Curl_infof("Keep sending data to get tossed away!\n");
						generatedKeepon |=  (1 << 1);
					} 
				} 
				if (!generatedHeader) {
					if (generatedSet.getOpt_no_body()) {
						stop_reading = 1;
					}  else if ((generatedHandler.getProtocol() & CURLPROTO_RTSP) && (generatedSet.getRtspreq() == .RTSPREQ_DESCRIBE) && (generatedSize <= -1/* Respect section 4.4 of rfc2326: If the Content-Length header is
					             absent, a length 0 must be assumed.  It will prevent libcurl from
					             hanging on DESCRIBE request that got refused for whatever
					             reason */)) {
						stop_reading = 1/* If we know the expected size of this document, we set the
						             maximum download size to the size of the expected
						             document or else, we won't know when to stop reading!
						
						             Note that we set the download maximum even if we read a
						             "Connection: close" header, to make sure that
						             "Content-Length: 0" still prevents us from attempting to
						             read the (missing) response-body.
						          */;
					} else {
							if (generatedChunk) {
								k.setMaxdownload(k.setSize(-1));
							} 
					} 
					if (-1 != generatedSize) {
						data.Curl_pgrsSetDownloadSize(generatedSize);
						k.setMaxdownload(generatedSize);
					} 
					if (0 == generatedMaxdownload) {
						stop_reading = 1;
					} 
					if (stop_reading) {
						generatedKeepon &=  ~(1 << /* we make sure that this socket isn't read more now */0);
					} 
					if (generatedSet.getVerbose()) {
						data.Curl_debug(CURLINFO_HEADER_IN, generatedStr_start, headerlen);
					} 
					break;
				} 
				k.setHbufp(generatedState.getHeaderbuff());
				k.setHbuflen(0);
				continue;
			} 
			if (!generatedHeaderline++) {
				int httpversion_major;
				int rtspversion_major;
				int nc = 0/* "HTTP/major.minor 123" *//* We can't really convert this yet because we
				         don't know if it's the 1st header line or the body.
				         So we do a partial conversion into a scratch area,
				         leaving the data at k->p as-is.
				      */;
				if (generatedHandler.getProtocol() & (CURLPROTO_HTTP | /* Curl_convert_from_network calls failf if unsuccessful *//* no conversion needed, just use k->p *//* CURL_DOES_CONVERSIONS */CURLPROTO_HTTPS/*
				         * https://tools.ietf.org/html/rfc7230#section-3.1.2
				         *
				         * The response code is always a three-digit number in HTTP as the spec
				         * says. We try to allow any number here, but we cannot make
				         * guarantees on future behaviors since it isn't within the protocol.
				         */)) {
					byte separator;
					byte[] twoorthree = new byte[2];
					nc = .sscanf(generatedP, " HTTP/%1d.%1d%c%3d", httpversion_major, generatedHttpversion, separator, generatedHttpcode);
					if (nc == 1 && httpversion_major >= 2 && 2 == .sscanf(generatedP, " HTTP/%1[23] %d", twoorthree, generatedHttpcode)) {
						conn.setHttpversion(0);
						nc = 4;
						separator = (byte)' ';
					} 
					if ((nc == 4) && ((byte)' ' == separator)) {
						generatedHttpversion += 10 * httpversion_major;
						if (generatedUpgr101 == upgrade101.UPGR101_RECEIVED) {
							if (generatedHttpversion != /* supposedly upgraded to http2 now */20) {
								data.Curl_infof("Lying server, not serving HTTP/2\n");
							} 
						} 
						if (generatedHttpversion < 20) {
							generatedBundle.setMultiuse(-1);
							data.Curl_infof("Mark bundle as not supporting multiuse\n");
						} 
					}  else if (!nc/* this is the real world, not a Nirvana
					             NCSA 1.5.x returns this crap when asked for HTTP/1.1
					          */) {
						nc = .sscanf(generatedP, " HTTP %3d", generatedHttpcode);
						conn.setHttpversion(10/* If user has set option HTTP200ALIASES,
						             compare header line against list of aliases
						          */);
						if (!nc) {
							if (data.checkhttpprefix(generatedP, generatedHbuflen) == .STATUS_DONE) {
								nc = 1;
								k.setHttpcode(200);
								conn.setHttpversion(10);
							} 
						} 
					} else {
							data.Curl_failf("Unsupported HTTP version in response");
							return CURLE_UNSUPPORTED_PROTOCOL;
					} 
				}  else if (generatedHandler.getProtocol() & CURLPROTO_RTSP) {
					byte separator;
					nc = .sscanf(generatedP, " RTSP/%1d.%1d%c%3d", rtspversion_major, generatedRtspversion, separator, generatedHttpcode);
					if ((nc == 4) && ((byte)' ' == separator)) {
						generatedRtspversion += 10 * rtspversion_major;
						conn.setHttpversion(/* For us, RTSP acts like HTTP 1.1 */11);
					} else {
							nc = 0;
					} 
				} 
				if (nc) {
					generatedInfo.setHttpcode(generatedHttpcode);
					generatedInfo.setHttpversion(generatedHttpversion);
					if (!generatedHttpversion || generatedHttpversion > generatedHttpversion) {
						generatedState.setHttpversion(generatedHttpversion);
					} 
					if (generatedState.getResume_from() && generatedSet.getHttpreq() == .HTTPREQ_GET && generatedHttpcode == 416/* "Requested Range Not Satisfiable", just proceed and
					             pretend this is no error */) {
						k.setIgnorebody(/* Avoid appending error msg to good data. */1);
					}  else if (generatedSet.getHttp_fail_on_error() && (generatedHttpcode >= 400) && ((generatedHttpcode != 401) || !generatedUser_passwd) && ((generatedHttpcode != 407) || !generatedProxy_user_passwd)) {
						/* serious error, go home! */data.print_http_error();
						return CURLE_HTTP_RETURNED_ERROR;
					} 
					if (generatedHttpversion == 10/* Default action for HTTP/1.0 must be to close, unless
					             we get one of those fancy headers that tell us the
					             server keeps it open for us! */) {
						data.Curl_infof("HTTP 1.0, assume close after body\n");
						conn.Curl_conncontrol(1);
					}  else if (generatedHttpversion == 20 || (generatedUpgr101 == upgrade101.UPGR101_REQUESTED && generatedHttpcode == 101)) {
						do {
						} while (0);
						generatedBundle.setMultiuse(/* HTTP/2 cannot blacklist multiplexing since it is a core
						             functionality of the protocol */2);
					}  else if (generatedHttpversion >= 11 && !generatedClose) {
						do {
						} while (/* If HTTP version is >= 1.1 and connection is persistent */0);
					} 
					k.setHttp_bodyless(generatedHttpcode >= 100 && generatedHttpcode < 200);
					switch (generatedHttpcode) {
					case 304/* (quote from RFC2616, section 10.3.5): The 304 response
					           * MUST NOT contain a message-body, and thus is always
					           * terminated by the first empty line after the header
					           * fields.  */:
							if (generatedSet.getTimecondition()) {
								generatedInfo.setTimecond(1);
							} 
					case /* FALLTHROUGH */204/* (quote from RFC2616, section 10.2.5): The server has
					           * fulfilled the request but does not need to return an
					           * entity-body ... The 204 response MUST NOT include a
					           * message-body, and thus is always terminated by the first
					           * empty line after the header fields. */:
							k.setSize(0);
							k.setMaxdownload(0);
							k.setHttp_bodyless(1);
							break;
					default:
							break;
					}
				} else {
						k.setHeader(/* this is not a header line */0);
						break;
				} 
			} 
			result = ();
			if (/* Curl_convert_from_network calls failf if unsuccessful */result) {
				return result;
			} 
			if (!generatedHttp_bodyless && !generatedSet.getIgnorecl() && ModernizedCProgram.curl_strnequal("Content-Length:", generatedP, .strlen("Content-Length:"))) {
				 contentlength = new ();
				CURLofft offt = ModernizedCProgram.curlx_strtoofft(generatedP + 15, ((Object)0), 10, contentlength);
				if (offt == .CURL_OFFT_OK) {
					if (generatedSet.getMax_filesize() && contentlength > generatedSet.getMax_filesize()) {
						data.Curl_failf("Maximum file size exceeded");
						return CURLE_FILESIZE_EXCEEDED;
					} 
					k.setSize(contentlength);
					k.setMaxdownload(generatedSize);
					data.Curl_pgrsSetDownloadSize(generatedSize);
				}  else if (offt == .CURL_OFFT_FLOW) {
					if (generatedSet.getMax_filesize()) {
						data.Curl_failf("Maximum file size exceeded");
						return CURLE_FILESIZE_EXCEEDED;
					} 
					conn.Curl_conncontrol(2);
					data.Curl_infof("Overflow Content-Length: value!\n");
				} else {
						data.Curl_failf(/* negative or just rubbish - bad HTTP */"Invalid Content-Length: value");
						return CURLE_WEIRD_SERVER_REPLY;
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Content-Type:", generatedP, .strlen(/* check for Content-Type: header lines to get the MIME-type */"Content-Type:"))) {
				byte contenttype = ModernizedCProgram.Curl_copy_header_value(generatedP);
				if (!contenttype) {
					return CURLE_OUT_OF_MEMORY;
				} 
				if (!contenttype) {
					.Curl_cfree(/* ignore empty data */contenttype);
				} else {
						do {
							.Curl_cfree((generatedInfo.getContenttype()));
							(generatedInfo.getContenttype()) = ((Object)0);
						} while (0);
						generatedInfo.setContenttype(contenttype);
				} 
			}  else if ((generatedHttpversion == 10) && generatedHttpproxy && ModernizedCProgram.Curl_compareheader(generatedP, "Proxy-Connection:", "keep-alive"/*
			       * When a HTTP/1.0 reply comes when using a proxy, the
			       * 'Proxy-Connection: keep-alive' line tells us the
			       * connection will be kept alive for our pleasure.
			       * Default action for 1.0 is to close.
			       */)) {
				conn.Curl_conncontrol(/* don't close */0);
				data.Curl_infof("HTTP/1.0 proxy connection set to keep alive!\n");
			}  else if ((generatedHttpversion == 11) && generatedHttpproxy && ModernizedCProgram.Curl_compareheader(generatedP, "Proxy-Connection:", "close"/*
			       * We get a HTTP/1.1 response from a proxy and it says it'll
			       * close down after this transfer.
			       */)) {
				conn.Curl_conncontrol(1);
				data.Curl_infof("HTTP/1.1 proxy connection set close!\n");
			}  else if ((generatedHttpversion == 10) && ModernizedCProgram.Curl_compareheader(generatedP, "Connection:", "keep-alive"/*
			       * A HTTP/1.0 reply with the 'Connection: keep-alive' line
			       * tells us the connection will be kept alive for our
			       * pleasure.  Default action for 1.0 is to close.
			       *
			       * [RFC2068, section 19.7.1] */)) {
				conn.Curl_conncontrol(0);
				data.Curl_infof("HTTP/1.0 connection set to keep alive!\n");
			}  else if (ModernizedCProgram.Curl_compareheader(generatedP, "Connection:", "close"/*
			       * [RFC 2616, section 8.1.2.1]
			       * "Connection: close" is HTTP/1.1 language and means that
			       * the connection will close when this request has been
			       * served.
			       */)) {
				conn.Curl_conncontrol(2);
			}  else if (!generatedHttp_bodyless && ModernizedCProgram.curl_strnequal("Transfer-Encoding:", generatedP, .strlen("Transfer-Encoding:"/* One or more encodings. We check for chunked and/or a compression
			         algorithm. *//*
			       * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
			       * means that the server will send a series of "chunks". Each
			       * chunk starts with line with info (including size of the
			       * coming block) (terminated with CRLF), then a block of data
			       * with the previously mentioned size. There can be any amount
			       * of chunks, and a chunk-data set to zero signals the
			       * end-of-chunks. */))) {
				result = conn.Curl_build_unencoding_stack(generatedP + 18, 1);
				if (result) {
					return result;
				} 
			}  else if (!generatedHttp_bodyless && ModernizedCProgram.curl_strnequal("Content-Encoding:", generatedP, .strlen("Content-Encoding:")) && generatedStr[dupstring.STRING_ENCODING/*
			       * Process Content-Encoding. Look for the values: identity,
			       * gzip, deflate, compress, x-gzip and x-compress. x-gzip and
			       * x-compress are the same as gzip and compress. (Sec 3.5 RFC
			       * 2616). zlib cannot handle compress.  However, errors are
			       * handled further down when the response body is processed
			       */]) {
				result = conn.Curl_build_unencoding_stack(generatedP + 17, 0);
				if (result) {
					return result;
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Retry-After:", generatedP, .strlen("Retry-After:"))) {
				 retry_after = /* Retry-After = HTTP-date / delay-seconds *//* zero for unknown or "now" */0;
				time_t date = ModernizedCProgram.curl_getdate(generatedP[12], ((Object)0));
				if (-1 == date) {
					(Object)ModernizedCProgram.curlx_strtoofft(generatedP[12], ((Object)0), 10, /* not a date, try it as a decimal number */retry_after);
				} else {
						retry_after = date - .time(((Object)/* convert date to number of seconds into the future */0));
				} 
				generatedInfo.setRetry_after(/* store it */retry_after);
			}  else if (!generatedHttp_bodyless && ModernizedCProgram.curl_strnequal("Content-Range:", generatedP, .strlen("Content-Range:"/* Content-Range: bytes [num]-
			         Content-Range: bytes: [num]-
			         Content-Range: [num]-
			         Content-Range: [asterisk]/[total]
			
			         The second format was added since Sun's webserver
			         JavaWebServer/1.1.1 obviously sends the header this way!
			         The third added since some servers use that!
			         The forth means the requested range was unsatisfied.
			      */))) {
				byte ptr = generatedP + 14;
				while (ptr && !(ModernizedCProgram.Curl_isdigit((int)((byte)ptr))) && ptr != /* Move forward until first digit or asterisk */(byte)'*') {
					ptr++;
				}
				if ((ModernizedCProgram.Curl_isdigit((int)((byte)/* if it truly stopped on a digit */ptr)))) {
					if (!ModernizedCProgram.curlx_strtoofft(ptr, ((Object)0), 10, generatedOffset)) {
						if (generatedState.getResume_from() == generatedOffset) {
							k.setContent_range(/* we asked for a resume and we got it */1);
						} 
					} 
				} else {
						generatedState.setResume_from(/* get everything */0);
				} 
			}  else if (generatedCookies && generatedState.getCookie_engine() && ModernizedCProgram.curl_strnequal("Set-Cookie:", generatedP, .strlen("Set-Cookie:"))) {
				data.Curl_share_lock(CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
				cookie.Curl_cookie_add(data, generatedCookies, 1, 0, generatedP + 11/* If there is a custom-set Host: name, use it
				                         here, or else use real peer host name. */, generatedCookiehost ? generatedCookiehost : generatedName, generatedState.getUp().getPath(), (generatedHandler.getProtocol() & CURLPROTO_HTTPS) ? 1 : 0);
				data.Curl_share_unlock(CURL_LOCK_DATA_COOKIE);
			}  else if (!generatedHttp_bodyless && ModernizedCProgram.curl_strnequal("Last-Modified:", generatedP, .strlen("Last-Modified:")) && (generatedSet.getTimecondition() || generatedSet.getGet_filetime())) {
				time_t secs = .time(((Object)0));
				k.setTimeofdoc(ModernizedCProgram.curl_getdate(generatedP + .strlen("Last-Modified:"), secs));
				if (generatedSet.getGet_filetime()) {
					generatedInfo.setFiletime(generatedTimeofdoc);
				} 
			}  else if ((ModernizedCProgram.curl_strnequal("WWW-Authenticate:", generatedP, .strlen("WWW-Authenticate:")) && (401 == generatedHttpcode)) || (ModernizedCProgram.curl_strnequal("Proxy-authenticate:", generatedP, .strlen("Proxy-authenticate:")) && (407 == generatedHttpcode))) {
				bool proxy = (generatedHttpcode == 407) ? 1 : 0;
				byte auth = ModernizedCProgram.Curl_copy_header_value(generatedP);
				if (!auth) {
					return CURLE_OUT_OF_MEMORY;
				} 
				result = conn.Curl_http_input_auth(proxy, auth);
				.Curl_cfree(auth);
				if (result) {
					return result;
				} 
			}  else if ((generatedHttpcode >= 300 && generatedHttpcode < 400) && ModernizedCProgram.curl_strnequal("Location:", generatedP, .strlen("Location:")) && !generatedReq.getLocation()) {
				byte location = ModernizedCProgram.Curl_copy_header_value(generatedP);
				if (!location) {
					return CURLE_OUT_OF_MEMORY;
				} 
				if (!location) {
					.Curl_cfree(/* ignore empty data */location);
				} else {
						generatedReq.setLocation(location);
						if (generatedSet.getHttp_follow_location()) {
							do {
							} while (0);
							generatedReq.setNewurl(.Curl_cstrdup(generatedReq.getLocation()));
							if (!generatedReq.getNewurl()) {
								return CURLE_OUT_OF_MEMORY;
							} 
							result = /* some cases of POST and PUT etc needs to rewind the data
							             stream at this point */conn.http_perhapsrewind();
							if (result) {
								return result/* If enabled, the header is incoming and this is over HTTPS *//* allow debug builds to circumvent the HTTPS restriction */;
							} 
						} 
				} 
			}  else if (generatedHandler.getProtocol() & /* the ALPN of the current request */CURLPROTO_RTSP) {
				result = .Curl_rtsp_parseheader(conn, generatedP);
				if (result) {
					return result/*
					     * End of header-checks. Write them to the client.
					     */;
				} 
			} 
			writetype = (1 << 1);
			if (generatedSet.getInclude_header()) {
				writetype |=  (1 << 0);
			} 
			if (generatedSet.getVerbose()) {
				data.Curl_debug(CURLINFO_HEADER_IN, generatedP, (size_t)generatedHbuflen);
			} 
			result = conn.Curl_client_write(writetype, generatedP, generatedHbuflen);
			if (result) {
				return result;
			} 
			generatedInfo.getHeader_size() += (long)generatedHbuflen;
			generatedReq.getHeaderbytecount() += (long)generatedHbuflen;
			k.setHbufp(generatedState.getHeaderbuff());
			k.setHbuflen(0);
		} while (generatedStr);
		return CURLE_OK/* CURL_DISABLE_HTTP */;
	}
	public static int runawhile(long time_limit, long speed_limit, Object speed, int dec) {
		int counter = 1;
		curltime now = new curltime(1, 0);
		 result = new ();
		int finaltime;
		ModernizedCProgram.easy.curl_easy_setopt(CURLOPT_LOW_SPEED_LIMIT, speed_limit);
		ModernizedCProgram.easy.curl_easy_setopt(CURLOPT_LOW_SPEED_TIME, time_limit);
		ModernizedCProgram.easy.Curl_speedinit();
		do {
			ModernizedCProgram.easy.getProgress().setCurrent_speed(/* fake the current transfer speed */speed);
			result = ModernizedCProgram.Curl_speedcheck(ModernizedCProgram.easy, now);
			if (result) {
				break;
			} 
			now.setTv_sec(++/* step the time */counter);
			speed -= dec;
		} while (counter < 100);
		Object generatedTv_sec = now.getTv_sec();
		finaltime = (int)(generatedTv_sec - 1);
		return finaltime;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static Object glob_fixed(Byte fixed, Object len) {
		Object generatedPattern = this.getPattern();
		Object generatedSize = this.getSize();
		URLPattern pat = generatedPattern[generatedSize];
		pat.setType(.UPTSet);
		Object generatedContent = pat.getContent();
		generatedContent.getSet().setSize(1);
		generatedContent.getSet().setPtr_s(0);
		pat.setGlobindex(-1);
		generatedContent.getSet().setElements(.malloc());
		if (!generatedContent.getSet().getElements()) {
			return ;
		} 
		generatedContent.getSet().getElements()[0] = .malloc(len + 1);
		if (!generatedContent.getSet().getElements()[0]) {
			return ;
		} 
		.memcpy(generatedContent.getSet().getElements()[0], fixed, len);
		generatedContent.getSet().getElements()[0][len] = 0;
		return CURLE_OK/* multiply
		 *
		 * Multiplies and checks for overflow.
		 */;
	}
	public static int multiply(long amount, long with) {
		long sum = amount * with;
		if (!with) {
			amount = 0;
			return 0;
		} 
		if (sum / with != amount) {
			return /* didn't fit, bail out */1;
		} 
		amount = sum;
		return 0;
	}
	public static Object glob_set(byte patternp, Object posp, Long amount, int globindex) {
		/* processes a set expression with the point behind the opening '{'
		     ','-separated elements are collected until the next closing '}'
		  */URLPattern pat = new URLPattern();
		bool done = 0;
		Object generatedGlob_buffer = this.getGlob_buffer();
		byte buf = generatedGlob_buffer;
		byte pattern = patternp;
		byte opattern = pattern;
		size_t opos = posp - 1;
		Object generatedPattern = this.getPattern();
		Object generatedSize = this.getSize();
		pat = generatedPattern[generatedSize];
		pat.setType(/* patterns 0,1,2,... correspond to size=1,3,5,... */.UPTSet);
		Object generatedContent = pat.getContent();
		generatedContent.getSet().setSize(0);
		generatedContent.getSet().setPtr_s(0);
		generatedContent.getSet().setElements(((Object)0));
		pat.setGlobindex(globindex);
		while (!done) {
			switch (pattern) {
			case /* URL ended while set was still open */(byte)'\0':
					return ;
			case /* set element completed */(byte)'}':
					if (opattern == pattern) {
						return ;
					} 
					if (ModernizedCProgram.multiply(amount, generatedSize + /* add 1 to size since it'll be incremented below */1)) {
						return ;
					} 
			case /* no nested expressions at this time */(byte)'[':
					return ;
			case /* FALLTHROUGH */(byte)',':
					buf = (byte)'\0';
					if (generatedContent.getSet().getElements()) {
						byte new_arr = .realloc(generatedContent.getSet().getElements(), (generatedSize + 1) * );
						if (!new_arr) {
							return ;
						} 
						generatedContent.getSet().setElements(new_arr);
					} else {
							generatedContent.getSet().setElements(.malloc());
					} 
					if (!generatedContent.getSet().getElements()) {
						return ;
					} 
					generatedContent.getSet().getElements()[generatedSize] = .strdup(generatedGlob_buffer);
					if (!generatedContent.getSet().getElements()[generatedSize]) {
						return ;
					} 
					++generatedSize;
					if (pattern == (byte)'}') {
						/* pass the closing brace */pattern++;
						done = 1;
						continue;
					} 
					buf = generatedGlob_buffer;
					++pattern;
					++(posp);
					break;
			case /* illegal closing bracket */(byte)']':
					return ;
			case (byte)'{':
			case /* escaped character, skip '\' */(byte)'\\':
					if (pattern[1]) {
						++pattern;
						++(posp);
					} 
			default:
					buf++ = /* copy character to set element */pattern++;
					++(posp);
			}
		}
		patternp = /* return with the new position */pattern;
		return CURLE_OK;
	}
	public static Object glob_range(byte patternp, Object posp, Long amount, int globindex) {
		URLPattern pat = new URLPattern();
		int rc;
		byte pattern = patternp;
		byte c;
		Object generatedPattern = this.getPattern();
		Object generatedSize = this.getSize();
		pat = generatedPattern[generatedSize];
		pat.setGlobindex(globindex);
		Object generatedContent = pat.getContent();
		patternp = pattern;
		return CURLE_OK;
	}
	/* processes a range expression with the point behind the opening '['
	     - char range: e.g. "a-z]", "B-Q]"
	     - num range: e.g. "0-9]", "17-2000]"
	     - num range with leading zeros: e.g. "001-999]"
	     expression is checked for well-formedness and collected until the next ']'
	  */
	public static  peek_ipv6(Object str, Object skip) {
		size_t i = 0;
		size_t colons = 0;
		if (str[i++] != (byte)'[') {
			return 0;
		} 
		for (; ; ) {
			byte c = str[i++];
			if ((ModernizedCProgram.Curl_isalnum((int)((byte)c))) || c == (byte)'.' || c == (byte)'%'/* ok */) {
			}  else if (c == (byte)':') {
				colons++;
			}  else if (c == (byte)']') {
				skip = i;
				return colons >= 2 ? 1 : 0;
			} else {
					return 0;
			} 
		}
	}
	/*
	   * Scan for a potential IPv6 literal.
	   * - Valid globs contain a hyphen and <= 1 colon.
	   * - IPv6 literals contain no hyphens and >= 2 colons.
	   */
	public static Object glob_parse(byte pattern, Object pos, long amount) {
		 res = /* processes a literal string component of a URL
		     special characters '{' and '[' branch to set/range processing functions
		   */CURLE_OK;
		int globindex = /* count "actual" globs */0;
		amount = 1;
		Object generatedGlob_buffer = this.getGlob_buffer();
		Object generatedSize = this.getSize();
		while (pattern && !res) {
			byte buf = generatedGlob_buffer;
			size_t sublen = 0;
			while (pattern && pattern != (byte)'{') {
				if (pattern == (byte)'[') {
					size_t skip = /* skip over IPv6 literals and [] */0;
					if (!ModernizedCProgram.peek_ipv6(pattern, ModernizedCProgram.skip) && (pattern[1] == (byte)']')) {
						ModernizedCProgram.skip = 2;
					} 
					if (ModernizedCProgram.skip) {
						.memcpy(ModernizedCProgram.buf, pattern, ModernizedCProgram.skip);
						ModernizedCProgram.buf += ModernizedCProgram.skip;
						pattern += ModernizedCProgram.skip;
						sublen += ModernizedCProgram.skip;
						continue;
					} 
					break;
				} 
				if (pattern == (byte)'}' || pattern == (byte)']') {
					return ;
				} 
				if (pattern == /* only allow \ to escape known "special letters" */(byte)'\\' && ((pattern + 1) == (byte)'{' || (pattern + 1) == (byte)'[' || (pattern + 1) == (byte)'}' || (pattern + 1) == (byte)']')) {
					++/* escape character, skip '\' */pattern;
					++pos;
				} 
				ModernizedCProgram.buf++ = /* copy character to literal */pattern++;
				++pos;
				sublen++;
			}
			if (sublen) {
				ModernizedCProgram.buf = /* we got a literal string, add it as a single-item list */(byte)'\0';
				res = glob.glob_fixed(generatedGlob_buffer, sublen);
			} else {
					switch (pattern) {
					case (byte)'{':
							/* process set pattern */pattern++;
							pos++;
							res = glob.glob_set(pattern, pos, amount, globindex++);
							break;
					case /* done  */(byte)'\0':
							break;
					case (byte)'[':
							/* process range pattern */pattern++;
							pos++;
							res = glob.glob_range(pattern, pos, amount, globindex++);
							break;
					}
			} 
			if (++generatedSize >= 100) {
				return ;
			} 
		}
		return res;
	}
	public static Object glob_url( glob, Byte url, long urlnum, _iobuf error) {
		URLGlob glob_expand = new URLGlob();
		long amount = 0;
		byte glob_buffer;
		 res = new ();
		glob = ((Object)0);
		glob_buffer = .malloc(.strlen(url) + 1);
		if (!glob_buffer) {
			return CURLE_OUT_OF_MEMORY;
		} 
		glob_buffer[0] = 0;
		glob_expand = .calloc(1, );
		if (!glob_expand) {
			do {
				.free((glob_buffer));
				(glob_buffer) = ((Object)0);
			} while (0);
			return CURLE_OUT_OF_MEMORY;
		} 
		glob_expand.setUrllen(.strlen(url));
		glob_expand.setGlob_buffer(glob_buffer);
		res = glob_expand.glob_parse(url, 1, amount);
		Object generatedError = glob_expand.getError();
		Object generatedPos = glob_expand.getPos();
		if (!res) {
			urlnum = amount;
		} else {
				if (error && generatedError) {
					byte[] text = new byte[512];
					byte t;
					if (generatedPos) {
						ModernizedCProgram.curl_msnprintf(text, , "%s in URL position %zu:\n%s\n%*s^", generatedError, generatedPos, url, generatedPos - 1, " ");
						t = text;
					} else {
							t = generatedError;
					} 
					error.curl_mfprintf("curl: (%d) %s\n", res, /* send error description to the error-stream */t);
				} 
				/* it failed, we cleanup */glob_expand.glob_cleanup();
				urlnum = 1;
				return res;
		} 
		glob = glob_expand;
		return CURLE_OK;
	}
	/*
	   * We can deal with any-size, just make a buffer with the same length
	   * as the specified URL!
	   */
	public static void glob_cleanup() {
		size_t i = new size_t();
		int elem;
		if (!glob) {
			return ;
		} 
		Object generatedSize = this.getSize();
		Object generatedPattern = this.getPattern();
		for (i = 0; i < generatedSize; i++) {
			if ((generatedPattern[i].getType() == .UPTSet) && (generatedPattern[i].getContent().getSet().getElements())) {
				for (elem = generatedSize - 1; elem >= 0; --elem) {
					do {
						.free((generatedPattern[i].getContent().getSet().getElements()[elem]));
						(generatedPattern[i].getContent().getSet().getElements()[elem]) = ((Object)0);
					} while (0);
				}
				do {
					.free((generatedPattern[i].getContent().getSet().getElements()));
					(generatedPattern[i].getContent().getSet().getElements()) = ((Object)0);
				} while (0);
			} 
		}
		Object generatedGlob_buffer = this.getGlob_buffer();
		do {
			.free((generatedGlob_buffer));
			(generatedGlob_buffer) = ((Object)0);
		} while (0);
		do {
			.free((glob));
			(glob) = ((Object)0);
		} while (0);
	}
	public static Object glob_next_url(byte globbed) {
		URLPattern pat = new URLPattern();
		size_t i = new size_t();
		size_t len = new size_t();
		Object generatedUrllen = this.getUrllen();
		size_t buflen = generatedUrllen + 1;
		Object generatedGlob_buffer = this.getGlob_buffer();
		byte buf = generatedGlob_buffer;
		globbed = ((Object)0);
		Object generatedBeenhere = this.getBeenhere();
		Object generatedSize = this.getSize();
		Object generatedPattern = this.getPattern();
		Object generatedContent = pat.getContent();
		Object generatedType = pat.getType();
		if (!generatedBeenhere) {
			this.setBeenhere(1);
		} else {
				bool carry = 1;
				for (i = 0; carry && (i < generatedSize); /* implement a counter over the index ranges of all patterns, starting
				       with the rightmost pattern */i++) {
					carry = 0;
					pat = generatedPattern[generatedSize - 1 - i];
					switch (generatedType) {
					case .UPTSet:
							if ((generatedContent.getSet().getElements()) && (++generatedContent.getSet().getPtr_s() == generatedSize)) {
								generatedContent.getSet().setPtr_s(0);
								carry = 1;
							} 
							break;
					case .UPTNumRange:
							generatedContent.getNumRange().getPtr_n() += generatedContent.getNumRange().getStep();
							if (generatedContent.getNumRange().getPtr_n() > generatedContent.getNumRange().getMax_n()) {
								generatedContent.getNumRange().setPtr_n(generatedContent.getNumRange().getMin_n());
								carry = 1;
							} 
							break;
					case .UPTCharRange:
							generatedContent.getCharRange().setPtr_c((byte)(generatedContent.getCharRange().getStep() + (int)((byte)generatedContent.getCharRange().getPtr_c())));
							if (generatedContent.getCharRange().getPtr_c() > generatedContent.getCharRange().getMax_c()) {
								generatedContent.getCharRange().setPtr_c(generatedContent.getCharRange().getMin_c());
								carry = 1;
							} 
							break;
					default:
							ModernizedCProgram.curl_mprintf("internal error: invalid pattern type (%d)\n", (int)generatedType);
							return CURLE_FAILED_INIT;
					}
				}
				if (/* first pattern ptr has run into overflow, done! */carry) {
					return CURLE_OK;
				} 
		} 
		for (i = 0; i < generatedSize; ++i) {
			pat = generatedPattern[i];
			switch (generatedType) {
			case .UPTNumRange:
					ModernizedCProgram.curl_msnprintf(buf, buflen, "%0*lu", generatedContent.getNumRange().getPadlength(), generatedContent.getNumRange().getPtr_n());
					len = .strlen(buf);
					buf += len;
					buflen -= len;
					break;
			case .UPTCharRange:
					if (buflen) {
						buf++ = generatedContent.getCharRange().getPtr_c();
						buf = (byte)'\0';
						buflen--;
					} 
					break;
			case .UPTSet:
					if (generatedContent.getSet().getElements()) {
						ModernizedCProgram.curl_msnprintf(buf, buflen, "%s", generatedContent.getSet().getElements()[generatedContent.getSet().getPtr_s()]);
						len = .strlen(buf);
						buf += len;
						buflen -= len;
					} 
					break;
			default:
					ModernizedCProgram.curl_mprintf("internal error: invalid pattern type (%d)\n", (int)generatedType);
					return CURLE_FAILED_INIT;
			}
		}
		globbed = .strdup(generatedGlob_buffer);
		if (!globbed) {
			return CURLE_OUT_OF_MEMORY;
		} 
		return CURLE_OK;
	}
	public static Object glob_match_url(byte result, byte filename) {
		byte target;
		size_t allocsize = new size_t();
		byte[] numbuf = new byte[18];
		byte appendthis = (byte)"";
		size_t appendlen = 0;
		size_t stringlen = 0;
		result = ((Object)0/* We cannot use the glob_buffer for storage here since the filename may
		   * be longer than the URL we use. We allocate a good start size, then
		   * we need to realloc in case of need.
		   */);
		allocsize = .strlen(filename) + /* make it at least one byte to store the
		                                       trailing zero */1;
		target = .malloc(allocsize);
		if (!target) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Object generatedSize = this.getSize();
		Object generatedPattern = this.getPattern();
		Object generatedContent = pat.getContent();
		Object generatedType = pat.getType();
		while (filename) {
			if (filename == (byte)'#' && (ModernizedCProgram.Curl_isdigit((int)((byte)filename[1])))) {
				byte ptr = filename;
				long num = .strtoul(filename[1], filename, 10);
				URLPattern pat = ((Object)0);
				if (num < generatedSize) {
					long i;
					/* make it zero based */num--;
					for (i = 0; i < generatedSize; /* find the correct glob entry */i++) {
						if (generatedPattern[i].getGlobindex() == (int)num) {
							pat = generatedPattern[i];
							break;
						} 
					}
				} 
				if (pat) {
					switch (generatedType) {
					case .UPTCharRange:
							numbuf[0] = generatedContent.getCharRange().getPtr_c();
							numbuf[1] = 0;
							appendthis = numbuf;
							appendlen = 1;
							break;
					case .UPTSet:
							if (generatedContent.getSet().getElements()) {
								appendthis = generatedContent.getSet().getElements()[generatedContent.getSet().getPtr_s()];
								appendlen = .strlen(generatedContent.getSet().getElements()[generatedContent.getSet().getPtr_s()]);
							} 
							break;
					case .UPTNumRange:
							ModernizedCProgram.curl_msnprintf(numbuf, , "%0*lu", generatedContent.getNumRange().getPadlength(), generatedContent.getNumRange().getPtr_n());
							appendthis = numbuf;
							appendlen = .strlen(numbuf);
							break;
					default:
							(_iob[2]).curl_mfprintf("internal error: invalid pattern type (%d)\n", (int)generatedType);
							do {
								.free((target));
								(target) = ((Object)0);
							} while (0);
							return CURLE_FAILED_INIT;
					}
				} else {
						filename = /* #[num] out of range, use the #[num] in the output */ptr;
						appendthis = filename++;
						appendlen = 1;
				} 
			} else {
					appendthis = filename++;
					appendlen = 1;
			} 
			if (appendlen + stringlen >= allocsize) {
				byte newstr;
				allocsize = (appendlen + stringlen) * 2;
				newstr = .realloc(target, allocsize + 1);
				if (!newstr) {
					do {
						.free((target));
						(target) = ((Object)0);
					} while (0);
					return CURLE_OUT_OF_MEMORY;
				} 
				target = newstr;
			} 
			.memcpy(target[stringlen], appendthis, appendlen);
			stringlen += appendlen;
		}
		target[stringlen] = (byte)'\0';
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, target, ((1 << 1) | (1 << 2)));
			do {
				.free((target));
				(target) = ((Object)0);
			} while (0);
			if (sc) {
				return CURLE_URL_MALFORMAT;
			} 
			target = sanitized;
		}
		result = /* MSDOS || WIN32 */target;
		return CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/*
	** callback for CURLOPT_READFUNCTION
	*/
	public static Object tool_read_cb(Object buffer, Object sz, Object nmemb, Object userdata) {
		ssize_t rc = new ssize_t();
		InStruct in = userdata;
		int generatedFd = in.getFd();
		rc = ModernizedCProgram.curlx_read(generatedFd, buffer, sz * nmemb);
		OperationConfig generatedConfig = in.getConfig();
		if (rc < 0) {
			if ((._errno()) == 11) {
				(._errno()) = 0;
				generatedConfig.setOperationConfig(1);
				return CURL_READFUNC_PAUSE;
			} 
			rc = /* since size_t is unsigned we can't return negative values fine */0;
		} 
		generatedConfig.setOperationConfig(0);
		return (size_t)rc;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_read16_le()
	 *
	 * This function converts a 16-bit integer from the little endian format, as
	 * used in the incoming package to whatever endian format we're using
	 * natively.
	 *
	 * Parameters:
	 *
	 * buf      [in]     - A pointer to a 2 byte buffer.
	 *
	 * Returns the integer.
	 */
	public static int Curl_read16_le(Object buf) {
		return (int)(((int)buf[0]) | ((int)buf[1] << 8/*
		 * Curl_read32_le()
		 *
		 * This function converts a 32-bit integer from the little endian format, as
		 * used in the incoming package to whatever endian format we're using
		 * natively.
		 *
		 * Parameters:
		 *
		 * buf      [in]     - A pointer to a 4 byte buffer.
		 *
		 * Returns the integer.
		 */));
	}
	public static int Curl_read32_le(Object buf) {
		return ((int)buf[0]) | ((int)buf[1] << 8) | ((int)buf[2] << 16) | ((int)buf[3] << 24/*
		 * Curl_read16_be()
		 *
		 * This function converts a 16-bit integer from the big endian format, as
		 * used in the incoming package to whatever endian format we're using
		 * natively.
		 *
		 * Parameters:
		 *
		 * buf      [in]     - A pointer to a 2 byte buffer.
		 *
		 * Returns the integer.
		 */);
	}
	public static int Curl_read16_be(Object buf) {
		return (int)(((int)buf[0] << 8) | ((int)buf[1/*
		 * write32_le()
		 *
		 * This function converts a 32-bit integer from the native endian format,
		 * to little endian format ready for sending down the wire.
		 *
		 * Parameters:
		 *
		 * value    [in]     - The 32-bit integer value.
		 * buffer   [in]     - A pointer to the output buffer.
		 */]));
	}
	public static void write32_le(Object value, Byte buffer) {
		buffer[0] = (byte)(value & -1024);
		buffer[1] = (byte)((value & -1024) >> 8);
		buffer[2] = (byte)((value & -1024) >> 16);
		buffer[3] = (byte)((value & -1024) >> 24/*
		 * Curl_write64_le()
		 *
		 * This function converts a 64-bit integer from the native endian format,
		 * to little endian format ready for sending down the wire.
		 *
		 * Parameters:
		 *
		 * value    [in]     - The 64-bit integer value.
		 * buffer   [in]     - A pointer to the output buffer.
		 */);
	}
	public static void Curl_write64_le(Object value, Byte buffer) {
		ModernizedCProgram.write32_le((int)value, buffer);
		ModernizedCProgram.write32_le((int)(value >> 32), buffer + 4/* CURL_SIZEOF_CURL_OFF_T > 4 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * get_line() makes sure to only return complete whole lines that fit in 'len'
	 * bytes and end with a newline.
	 */
	public static Byte Curl_get_line(Byte buf, int len) {
		bool partial = 0;
		while (1) {
			byte b = .fgets(buf, len, ModernizedCProgram.input);
			if (b) {
				size_t rlen = .strlen(b);
				if (rlen && (b[rlen - 1] == (byte)'\n')) {
					if (partial) {
						partial = 0;
						continue;
					} 
					return b;
				} 
				partial = /* read a partial, discard the next piece that ends with newline */1;
			} else {
					break;
			} 
		}
		return ((Object)0);
	}
	public static Object ioctl_callback(Object handle, int cmd, Object clientp) {
		(Object)clientp;
		if (cmd == CURLIOCMD_RESTARTREAD) {
			ModernizedCProgram.curl_mprintf("APPLICATION: received a CURLIOCMD_RESTARTREAD request\n");
			ModernizedCProgram.curl_mprintf("APPLICATION: ** REWINDING! **\n");
			ModernizedCProgram.current_offset = 0;
			return CURLIOE_OK;
		} 
		(Object)handle;
		return CURLIOE_UNKNOWNCMD;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Checks a single file's size and mtime from an FTP server.
	 * </DESC>
	 */
	public static Object throw_away(Object ptr, Object size, Object nmemb, Object data) {
		(Object)ptr;
		(Object)data/* we are not interested in the headers itself,
		     so we only return the size we would have saved ... */;
		return (size_t)(size * nmemb);
	}
	public static void test_curl_llist_dtor(Object key, Object value) {
		(Object)/* used by the llist API, does nothing here */key;
		(Object)value;
	}
	public static void libtest_debug_dump(Object timebuf, Object text, Object ptr, Object size, int nohex) {
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (nohex) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		stream.curl_mfprintf("%s%s, %zu bytes (0x%zx)\n", timebuf, text, size, size);
		for (i = 0; i < size; i += width) {
			stream.curl_mfprintf("%04zx: ", i);
			if (!nohex) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						stream.curl_mfprintf("%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if (/* check for 0D0A; if found, skip past and start a new line of output */nohex && (i + c + 1 < size) && (ptr[i + c] == -1024) && (ptr[i + c + 1] == -1024)) {
					i += (c + 2 - width);
					break;
				} 
				stream.curl_mfprintf("%c", ((ptr[i + c] >= -1024) && (ptr[i + c] < -1024)) ? ptr[i + c] : (byte)'.');
				if (/* check again for 0D0A, to avoid an extra \n if it's at width */nohex && (i + c + 2 < size) && (ptr[i + c + 1] == -1024) && (ptr[i + c + 2] == -1024)) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
	}
	public static int libtest_debug_cb(Object handle, Object type, Byte data, Object size, Object userp) {
		libtest_trace_cfg trace_cfg = userp;
		byte text;
		timeval tv = new timeval();
		byte[] timebuf = new byte[20];
		byte timestr;
		time_t secs = new time_t();
		(Object)handle;
		timebuf[0] = (byte)'\0';
		timestr = timebuf[0];
		int generatedTracetime = trace_cfg.getTracetime();
		timeval timeval = new timeval();
		long generatedTv_sec = tv.getTv_sec();
		Object generatedTm_hour = now.getTm_hour();
		Object generatedTm_min = now.getTm_min();
		Object generatedTm_sec = now.getTm_sec();
		long generatedTv_usec = tv.getTv_usec();
		if (generatedTracetime) {
			tm now = new tm();
			tv = timeval.tutil_tvnow();
			if (!ModernizedCProgram.known_offset) {
				ModernizedCProgram.epoch_offset = .time(((Object)0)) - generatedTv_sec;
				ModernizedCProgram.known_offset = 1;
			} 
			secs = ModernizedCProgram.epoch_offset + generatedTv_sec;
			now = .localtime(/* not thread safe but we don't care */secs);
			ModernizedCProgram.curl_msnprintf(timebuf, , "%02d:%02d:%02d.%06ld ", generatedTm_hour, generatedTm_min, generatedTm_sec, (long)generatedTv_usec);
		} 
		switch (type) {
		case CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		case CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case CURLINFO_TEXT:
				(_iob[2]).curl_mfprintf("%s== Info: %s", timestr, (byte)data/* FALLTHROUGH */);
		case CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		default:
				return 0;
		}
		int generatedNohex = trace_cfg.getNohex();
		(_iob[2]).libtest_debug_dump(timebuf, text, data, size, generatedNohex);
		return 0;
	}
	public static Object write_it(Byte buff, Object size, Object nmemb, Object cb_data) {
		callback_data data = cb_data;
		size_t written = 0;
		_iobuf generatedOutput = data.getOutput();
		if (generatedOutput) {
			written = .fwrite(buff, size, nmemb, generatedOutput);
		} else {
				written = .fwrite(buff, size, nmemb, (_iob[/* listing output */1]));
		} 
		return written;
	}
	public static Object SyncTime_CURL_WriteOutput(Object ptr, Object size, Object nmemb, Object stream) {
		.fwrite(ptr, size, nmemb, stream);
		return (nmemb * size);
	}
	public static Object SyncTime_CURL_WriteHeader(Object ptr, Object size, Object nmemb, Object stream) {
		byte[] TmpStr1 = new byte[26];
		byte[] TmpStr2 = new byte[26];
		(Object)stream;
		if (ModernizedCProgram.ShowAllHeader == 1) {
			.fprintf((_iob[2]), "%s", (byte)(ptr));
		} 
		if (.strncmp((byte)(ptr), "Date:", 5) == 0) {
			if (ModernizedCProgram.ShowAllHeader == 0) {
				.fprintf((_iob[2]), "HTTP Server. %s", (byte)(ptr));
			} 
			if (ModernizedCProgram.AutoSyncTime == 1) {
				TmpStr1 = 0;
				TmpStr2 = 0;
				if (.strlen((byte)(ptr)) > /* Can prevent buffer overflow to
				                                         TmpStr1 & 2? */50) {
					ModernizedCProgram.AutoSyncTime = 0;
				} else {
						int RetVal = .sscanf((byte)(ptr), "Date: %s %hu %s %hu %hu:%hu:%hu", TmpStr1, ModernizedCProgram.SYSTime.getWDay(), TmpStr2, ModernizedCProgram.SYSTime.getWYear(), ModernizedCProgram.SYSTime.getWHour(), ModernizedCProgram.SYSTime.getWMinute(), ModernizedCProgram.SYSTime.getWSecond());
						if (RetVal == 7) {
							int i;
							ModernizedCProgram.SYSTime.setWMilliseconds(/* adjust to midpoint, 0.5 sec */500);
							for (i = 0; i < 12; i++) {
								if (.strcmp(ModernizedCProgram.MthStr[i], TmpStr2) == 0) {
									ModernizedCProgram.SYSTime.setWMonth(i + 1);
									break;
								} 
							}
							ModernizedCProgram.AutoSyncTime = /* Computer clock will be adjusted */3;
						} else {
								ModernizedCProgram.AutoSyncTime = /* Error in sscanf() fields conversion */0;
						} 
				} 
			} 
		} 
		if (.strncmp((byte)(ptr), "X-Cache: HIT", 12) == 0) {
			.fprintf((_iob[2]), "ERROR: HTTP Server data is cached. Server Date is no longer valid.\n");
			ModernizedCProgram.AutoSyncTime = 0;
		} 
		return (nmemb * size);
	}
	public static void SyncTime_CURL_Init(Object curl, Byte proxy_port, Byte proxy_user_password) {
		if (.strlen(proxy_port) > 0) {
			curl.curl_easy_setopt(CURLOPT_PROXY, proxy_port);
		} 
		if (.strlen(proxy_user_password) > 0) {
			curl.curl_easy_setopt(CURLOPT_PROXYUSERPWD, proxy_user_password);
		} 
		curl.curl_easy_setopt(CURLOPT_USERAGENT, "synctime/1.0");
		curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, SyncTime_CURL_WriteOutput);
		curl.curl_easy_setopt(CURLOPT_HEADERFUNCTION, SyncTime_CURL_WriteHeader);
	}
	public static int SyncTime_CURL_Fetch(Object curl, Byte URL_Str, Byte OutFileName, int HttpGetBody) {
		FILE outfile = new FILE();
		 res = new ();
		outfile = ((Object)0);
		if (HttpGetBody == 0) {
			curl.curl_easy_setopt(CURLOPT_NOBODY, -1024);
		} else {
				outfile = .fopen(OutFileName, "wb");
				curl.curl_easy_setopt(CURLOPT_WRITEDATA, outfile);
		} 
		curl.curl_easy_setopt(CURLOPT_URL, URL_Str);
		res = curl.curl_easy_perform();
		if (outfile != ((Object)0)) {
			.fclose(outfile);
		} 
		return /* (CURLE_OK) */res;
	}
	public static void showUsage() {
		.fprintf((_iob[2]), "SYNCTIME: Synchronising computer clock with time server using HTTP protocol.\n");
		.fprintf((_iob[2]), "Usage   : SYNCTIME [Option]\n");
		.fprintf((_iob[2]), "Options :\n");
		.fprintf((_iob[2]), " --server=WEBSERVER        Use this time server instead of default.\n");
		.fprintf((_iob[2]), " --showall                 Show all HTTP header.\n");
		.fprintf((_iob[2]), " --synctime                Synchronising computer clock with time server.\n");
		.fprintf((_iob[2]), " --proxy-user=USER[:PASS]  Set proxy username and password.\n");
		.fprintf((_iob[2]), " --proxy=HOST[:PORT]       Use HTTP proxy on given port.\n");
		.fprintf((_iob[2]), " --help                    Print this help.\n");
		.fprintf((_iob[2]), "\n");
		return ;
	}
	public static int conf_init() {
		int i;
		Object generatedHttp_proxy = this.getHttp_proxy();
		generatedHttp_proxy = 0;
		Object generatedProxy_user = this.getProxy_user();
		for (i = 0; i < 256 + 1; i++) {
			generatedProxy_user[i] = /* Clean up password from memory */0;
		}
		Object generatedTimeserver = this.getTimeserver();
		generatedTimeserver = 0;
		return 1;
	}
	public static void pop3_get_message(Byte buffer, byte outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 2) {
			len -= /* Find the start of the message */2;
			for (message = buffer + 2; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change POP3 state!
		 */;
	}
	/*
	 * POP3 protocol handler.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC2195 CRAM-MD5 authentication
	 *
	 ***************************************************************************/
	/* The last #include files should be: */
	/*
	 * Curl_auth_decode_cram_md5_message()
	 *
	 * This is used to decode an already encoded CRAM-MD5 challenge message.
	 *
	 * Parameters:
	 *
	 * chlg64  [in]     - The base64 encoded challenge message.
	 * outptr  [in/out] - The address where a pointer to newly allocated memory
	 *                    holding the result will be stored upon completion.
	 * outlen  [out]    - The length of the output message.
	 *
	 * Returns CURLE_OK on success.
	 */
	public static Object Curl_auth_decode_cram_md5_message(Object chlg64, byte outptr, Object outlen) {
		 result = CURLE_OK;
		size_t chlg64len = .strlen(chlg64);
		outptr = ((Object)0);
		outlen = 0;
		if (chlg64len && chlg64 != /* Decode the challenge if necessary */(byte)'=') {
			result = ModernizedCProgram.Curl_base64_decode(chlg64, (byte)outptr, outlen);
		} 
		return result/*
		 * Curl_auth_create_cram_md5_message()
		 *
		 * This is used to generate an already encoded CRAM-MD5 response message ready
		 * for sending to the recipient.
		 *
		 * Parameters:
		 *
		 * data    [in]     - The session handle.
		 * chlg    [in]     - The challenge.
		 * userp   [in]     - The user name.
		 * passwdp [in]     - The user's password.
		 * outptr  [in/out] - The address where a pointer to newly allocated memory
		 *                    holding the result will be stored upon completion.
		 * outlen  [out]    - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC2831 DIGEST-MD5 authentication
	 * RFC7616 DIGEST-SHA256, DIGEST-SHA512-256 authentication
	 *
	 ***************************************************************************/
	/* included for Curl_convert_... prototypes */
	/* The last #include files should be: */
	/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
	   It converts digest text to ASCII so the MD5 will be correct for
	   what ultimately goes over the network.
	*/
	/* !USE_WINDOWS_SSPI */
	public static  Curl_auth_digest_get_pair(Object str, byte value, byte content, Object endptr) {
		int c;
		bool starts_with_quote = 0;
		bool escape = 0;
		for (c = DIGEST_MAX_VALUE_LENGTH - 1; (str && (str != (byte)'=') && c--); ) {
			value++ = str++;
		}
		value = 0;
		if ((byte)'=' != str++) {
			return /* eek, no match */0;
		} 
		if ((byte)'\"' == str) {
			/* This starts with a quote so it must end with one as well! */str++;
			starts_with_quote = 1;
		} 
		for (c = DIGEST_MAX_CONTENT_LENGTH - 1; str && c--; str++) {
			switch (str) {
			case (byte)'\r':
			case (byte)'\n':
					c = /* end of string */0;
					continue;
			case (byte)',':
					if (!starts_with_quote/* This signals the end of the content if we didn't get a starting
					           quote and then we do "sloppy" parsing */) {
						c = /* the end */0;
						continue;
					} 
					break;
			case (byte)'\\':
					if (!escape) {
						escape = /* possibly the start of an escaped quote */1;
						content++ = /* Even though this is an escape character, we still
						                              store it as-is in the target buffer */(byte)'\\';
						continue;
					} 
					break;
			case (byte)'\"':
					if (!escape && starts_with_quote) {
						c = /* end of string */0;
						continue;
					} 
					break;
			}
			escape = 0;
			content++ = str;
		}
		content = 0;
		endptr = str;
		return 1;
	}
	/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
	/* 16 bytes */
	public static void auth_digest_md5_to_ascii(Byte source, Byte dest) {
		int i;
		for (i = 0; i < 16; i++) {
			ModernizedCProgram.curl_msnprintf((byte)dest[i * 2], 3, "%02x", source[i]);
		}
	}
	/* 33 bytes */
	/* Convert sha256 chunk to RFC7616 -suitable ascii string*/
	/* 32 bytes */
	public static void auth_digest_sha256_to_ascii(Byte source, Byte dest) {
		int i;
		for (i = 0; i < 32; i++) {
			ModernizedCProgram.curl_msnprintf((byte)dest[i * 2], 3, "%02x", source[i]);
		}
	}
	/* 65 bytes */
	/* Perform quoted-string escaping as described in RFC2616 and its errata */
	public static Byte auth_digest_string_quoted(Object source) {
		byte dest;
		byte s = source;
		size_t n = /* null terminator */1;
		while (/* Calculate size needed */s) {
			++n;
			if (s == (byte)'"' || s == (byte)'\\') {
				++n;
			} 
			++s;
		}
		dest = .Curl_cmalloc(n);
		if (dest) {
			byte d = dest;
			s = source;
			while (s) {
				if (s == (byte)'"' || s == (byte)'\\') {
					d++ = (byte)'\\';
				} 
				d++ = s++;
			}
			d = 0;
		} 
		return dest/* Retrieves the value for a corresponding key from the challenge string
		 * returns TRUE if the key could be found, FALSE if it does not exists
		 */;
	}
	public static  auth_digest_get_key_value(Object chlg, Object key, Byte value, Object max_val_len, byte end_char) {
		byte find_pos;
		size_t i = new size_t();
		find_pos = .strstr(chlg, key);
		if (!find_pos) {
			return 0;
		} 
		find_pos += .strlen(key);
		for (i = 0; find_pos && find_pos != end_char && i < max_val_len - 1; ++i) {
			value[i] = find_pos++;
		}
		value[i] = (byte)'\0';
		return 1;
	}
	public static Object auth_digest_get_qop_values(Object options, int value) {
		byte tmp;
		byte token;
		byte tok_buf = ((Object)0);
		value = /* Initialise the output */0;
		tmp = .Curl_cstrdup(/* Tokenise the list of qop values. Use a temporary clone of the buffer since
		     strtok_r() ruins it. */options);
		if (!tmp) {
			return CURLE_OUT_OF_MEMORY;
		} 
		token = ModernizedCProgram.Curl_strtok_r(tmp, ",", tok_buf);
		while (token != ((Object)0)) {
			if (ModernizedCProgram.Curl_strcasecompare(token, "auth")) {
				value |=  (1 << 0);
			}  else if (ModernizedCProgram.Curl_strcasecompare(token, "auth-int")) {
				value |=  (1 << 1);
			}  else if (ModernizedCProgram.Curl_strcasecompare(token, "auth-conf")) {
				value |=  (1 << 2);
			} 
			token = ModernizedCProgram.Curl_strtok_r(((Object)0), ",", tok_buf);
		}
		.Curl_cfree(tmp);
		return CURLE_OK/*
		 * auth_decode_digest_md5_message()
		 *
		 * This is used internally to decode an already encoded DIGEST-MD5 challenge
		 * message into the separate attributes.
		 *
		 * Parameters:
		 *
		 * chlg64  [in]     - The base64 encoded challenge message.
		 * nonce   [in/out] - The buffer where the nonce will be stored.
		 * nlen    [in]     - The length of the nonce buffer.
		 * realm   [in/out] - The buffer where the realm will be stored.
		 * rlen    [in]     - The length of the realm buffer.
		 * alg     [in/out] - The buffer where the algorithm will be stored.
		 * alen    [in]     - The length of the algorithm buffer.
		 * qop     [in/out] - The buffer where the qop-options will be stored.
		 * qlen    [in]     - The length of the qop buffer.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static Object auth_decode_digest_md5_message(Object chlg64, Byte nonce, Object nlen, Byte realm, Object rlen, Byte alg, Object alen, Byte qop, Object qlen) {
		 result = CURLE_OK;
		byte chlg = ((Object)0);
		size_t chlglen = 0;
		size_t chlg64len = .strlen(chlg64);
		if (chlg64len && chlg64 != /* Decode the base-64 encoded challenge message */(byte)'=') {
			result = ModernizedCProgram.Curl_base64_decode(chlg64, chlg, chlglen);
			if (result) {
				return result;
			} 
		} 
		if (!/* Ensure we have a valid challenge message */chlg) {
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		if (!ModernizedCProgram.auth_digest_get_key_value((byte)chlg, "nonce=\"", nonce, /* Retrieve nonce string from the challenge */nlen, (byte)'\"')) {
			.Curl_cfree(chlg);
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		if (!ModernizedCProgram.auth_digest_get_key_value((byte)chlg, "realm=\"", realm, /* Retrieve realm string from the challenge */rlen, (byte)'\"')) {
			.strcpy(realm, /* Challenge does not have a realm, set empty string [RFC2831] page 6 */"");
		} 
		if (!ModernizedCProgram.auth_digest_get_key_value((byte)chlg, "algorithm=", alg, alen, /* Retrieve algorithm string from the challenge */(byte)',')) {
			.Curl_cfree(chlg);
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		if (!ModernizedCProgram.auth_digest_get_key_value((byte)chlg, "qop=\"", qop, qlen, /* Retrieve qop-options string from the challenge */(byte)'\"')) {
			.Curl_cfree(chlg);
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		.Curl_cfree(chlg);
		return CURLE_OK/*
		 * Curl_auth_is_digest_supported()
		 *
		 * This is used to evaluate if DIGEST is supported.
		 *
		 * Parameters: None
		 *
		 * Returns TRUE as DIGEST as handled by libcurl.
		 */;
	}
	public static  Curl_auth_is_digest_supported() {
		return 1/*
		 * Curl_auth_create_digest_md5_message()
		 *
		 * This is used to generate an already encoded DIGEST-MD5 response message
		 * ready for sending to the recipient.
		 *
		 * Parameters:
		 *
		 * data    [in]     - The session handle.
		 * chlg64  [in]     - The base64 encoded challenge message.
		 * userp   [in]     - The user name.
		 * passwdp [in]     - The user's password.
		 * service [in]     - The service type such as http, smtp, pop or imap.
		 * outptr  [in/out] - The address where a pointer to newly allocated memory
		 *                    holding the result will be stored upon completion.
		 * outlen  [out]    - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static Object _Curl_auth_create_digest_http_message(Curl_easy data, Object userp, Object passwdp, Object request, Object uripath, digestdata digest, byte outptr, Object outlen, Object convert_to_ascii, Object hash) {
		 result = new ();
		byte[] hashbuf = new byte[/* 32 bytes/256 bits */32];
		byte[] request_digest = new byte[65];
		byte hashthis;
		byte[] ha1 = new byte[/* 64 digits and 1 zero byte */65];
		byte[] ha2 = new byte[/* 64 digits and 1 zero byte */65];
		byte[] userh = new byte[65];
		byte cnonce = ((Object)0);
		size_t cnonce_sz = 0;
		byte userp_quoted;
		byte response = ((Object)0);
		byte tmp = ((Object)0);
		int generatedNc = digest.getNc();
		if (!generatedNc) {
			digest.setNc(1);
		} 
		Byte generatedCnonce = digest.getCnonce();
		if (!generatedCnonce) {
			byte[] cnoncebuf = new byte[33];
			result = ModernizedCProgram.Curl_rand_hex(data, (byte)cnoncebuf, );
			if (result) {
				return result;
			} 
			result = data.Curl_base64_encode(cnoncebuf, .strlen(cnoncebuf), cnonce, cnonce_sz);
			if (result) {
				return result;
			} 
			digest.setCnonce(cnonce);
		} 
		Object generatedUserhash = digest.getUserhash();
		Byte generatedRealm = digest.getRealm();
		if (generatedUserhash) {
			hashthis = (byte)ModernizedCProgram.curl_maprintf("%s:%s", userp, generatedRealm);
			if (!hashthis) {
				return CURLE_OUT_OF_MEMORY;
			} 
			result = ();
			if (result) {
				.Curl_cfree(hashthis);
				return result;
			} 
			;
			.hash(hashbuf, hashthis);
			.Curl_cfree(hashthis);
			.convert_to_ascii(hashbuf, (byte)userh/*
			    If the algorithm is "MD5" or unspecified (which then defaults to MD5):
			
			      A1 = unq(username-value) ":" unq(realm-value) ":" passwd
			
			    If the algorithm is "MD5-sess" then:
			
			      A1 = H(unq(username-value) ":" unq(realm-value) ":" passwd) ":"
			           unq(nonce-value) ":" unq(cnonce-value)
			  */);
		} 
		hashthis = (byte)ModernizedCProgram.curl_maprintf("%s:%s:%s", generatedUserhash ? userh : userp, generatedRealm, passwdp);
		if (!hashthis) {
			return CURLE_OUT_OF_MEMORY;
		} 
		result = ();
		if (result) {
			.Curl_cfree(hashthis);
			return /* convert on non-ASCII machines */result;
		} 
		;
		.hash(hashbuf, hashthis);
		.Curl_cfree(hashthis);
		.convert_to_ascii(hashbuf, ha1);
		int generatedAlgo = digest.getAlgo();
		Byte generatedNonce = digest.getNonce();
		if (generatedAlgo == CURLDIGESTALGO_MD5SESS || generatedAlgo == CURLDIGESTALGO_SHA256SESS || generatedAlgo == CURLDIGESTALGO_SHA512_256SESS) {
			tmp = ModernizedCProgram.curl_maprintf("%s:%s:%s", ha1, generatedNonce, generatedCnonce);
			if (!tmp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			result = ();
			if (result) {
				.Curl_cfree(tmp);
				return /* Convert on non-ASCII machines */result;
			} 
			;
			.hash(hashbuf, (byte)tmp);
			.Curl_cfree(tmp);
			.convert_to_ascii(hashbuf, ha1/*
			    If the "qop" directive's value is "auth" or is unspecified, then A2 is:
			
			      A2 = Method ":" digest-uri-value
			
			    If the "qop" value is "auth-int", then A2 is:
			
			      A2 = Method ":" digest-uri-value ":" H(entity-body)
			
			    (The "Method" value is the HTTP request method as specified in section
			    5.1.1 of RFC 2616)
			  */);
		} 
		hashthis = (byte)ModernizedCProgram.curl_maprintf("%s:%s", request, uripath);
		if (!hashthis) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Byte generatedQop = digest.getQop();
		if (generatedQop && ModernizedCProgram.Curl_strcasecompare(generatedQop, "auth-int")) {
			byte[] hashed = new byte[/* We don't support auth-int for PUT or POST */65];
			byte hashthis2;
			.hash(hashbuf, (byte)"");
			.convert_to_ascii(hashbuf, (byte)hashed);
			hashthis2 = (byte)ModernizedCProgram.curl_maprintf("%s:%s", hashthis, hashed);
			.Curl_cfree(hashthis);
			hashthis = hashthis2;
		} 
		if (!hashthis) {
			return CURLE_OUT_OF_MEMORY;
		} 
		result = ();
		if (result) {
			.Curl_cfree(hashthis);
			return /* convert on non-ASCII machines */result;
		} 
		;
		.hash(hashbuf, hashthis);
		.Curl_cfree(hashthis);
		.convert_to_ascii(hashbuf, ha2);
		if (generatedQop) {
			hashthis = (byte)ModernizedCProgram.curl_maprintf("%s:%s:%08x:%s:%s:%s", ha1, generatedNonce, generatedNc, generatedCnonce, generatedQop, ha2);
		} else {
				hashthis = (byte)ModernizedCProgram.curl_maprintf("%s:%s:%s", ha1, generatedNonce, ha2);
		} 
		if (!hashthis) {
			return CURLE_OUT_OF_MEMORY;
		} 
		result = ();
		if (result) {
			.Curl_cfree(hashthis);
			return /* convert on non-ASCII machines */result;
		} 
		;
		.hash(hashbuf, hashthis);
		.Curl_cfree(hashthis);
		.convert_to_ascii(hashbuf, request_digest/* For test case 64 (snooped from a Mozilla 1.3a request)
		
		     Authorization: Digest username="testuser", realm="testrealm", \
		     nonce="1053604145", uri="/64", response="c55f7f30d83d774a3d2dcacf725abaca"
		
		     Digest parameters are all quoted strings.  Username which is provided by
		     the user will need double quotes and backslashes within it escaped.  For
		     the other fields, this shouldn't be an issue.  realm, nonce, and opaque
		     are copied as is from the server, escapes and all.  cnonce is generated
		     with web-safe characters.  uri is already percent encoded.  nc is 8 hex
		     characters.  algorithm and qop with standard values only contain web-safe
		     characters.
		  */);
		userp_quoted = ModernizedCProgram.auth_digest_string_quoted(generatedUserhash ? userh : userp);
		if (!userp_quoted) {
			return CURLE_OUT_OF_MEMORY;
		} 
		if (generatedQop) {
			response = ModernizedCProgram.curl_maprintf("username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", cnonce=\"%s\", nc=%08x, qop=%s, response=\"%s\"", userp_quoted, generatedRealm, generatedNonce, uripath, generatedCnonce, generatedNc, generatedQop, request_digest);
			if (ModernizedCProgram.Curl_strcasecompare(generatedQop, "auth")) {
				generatedNc++;
			} 
		} else {
				response = ModernizedCProgram.curl_maprintf("username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"", userp_quoted, generatedRealm, generatedNonce, uripath, request_digest);
		} 
		.Curl_cfree(userp_quoted);
		if (!response) {
			return CURLE_OUT_OF_MEMORY;
		} 
		Byte generatedOpaque = digest.getOpaque();
		if (generatedOpaque) {
			tmp = ModernizedCProgram.curl_maprintf("%s, opaque=\"%s\"", response, generatedOpaque);
			.Curl_cfree(response);
			if (!tmp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			response = tmp;
		} 
		Byte generatedAlgorithm = digest.getAlgorithm();
		if (generatedAlgorithm) {
			tmp = ModernizedCProgram.curl_maprintf("%s, algorithm=\"%s\"", response, generatedAlgorithm);
			.Curl_cfree(response);
			if (!tmp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			response = tmp;
		} 
		if (generatedUserhash) {
			tmp = ModernizedCProgram.curl_maprintf("%s, userhash=true", /* Append the userhash */response);
			.Curl_cfree(response);
			if (!tmp) {
				return CURLE_OUT_OF_MEMORY;
			} 
			response = tmp;
		} 
		outptr = /* Return the output */response;
		outlen = .strlen(response);
		return CURLE_OK/*
		 * Curl_auth_create_digest_http_message()
		 *
		 * This is used to generate a HTTP DIGEST response message ready for sending
		 * to the recipient.
		 *
		 * Parameters:
		 *
		 * data    [in]     - The session handle.
		 * userp   [in]     - The user name.
		 * passwdp [in]     - The user's password.
		 * request [in]     - The HTTP request.
		 * uripath [in]     - The path of the HTTP uri.
		 * digest  [in/out] - The digest data struct being used and modified.
		 * outptr  [in/out] - The address where a pointer to newly allocated memory
		 *                    holding the result will be stored upon completion.
		 * outlen  [out]    - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static Object Curl_auth_create_digest_http_message(Curl_easy data, Object userp, Object passwdp, Object request, Object uripath, digestdata digest, Byte outptr, Object outlen) {
		int generatedAlgo = digest.getAlgo();
		switch (generatedAlgo) {
		case CURLDIGESTALGO_SHA512_256:
		case CURLDIGESTALGO_MD5:
		case CURLDIGESTALGO_SHA256:
		case CURLDIGESTALGO_MD5SESS:
				return ModernizedCProgram._Curl_auth_create_digest_http_message(data, userp, passwdp, request, uripath, digest, outptr, outlen, auth_digest_md5_to_ascii, ModernizedCProgram.Curl_md5it);
		case CURLDIGESTALGO_SHA256SESS:
		case CURLDIGESTALGO_SHA512_256SESS:
				return ModernizedCProgram._Curl_auth_create_digest_http_message(data, userp, passwdp, request, uripath, digest, outptr, outlen, auth_digest_sha256_to_ascii, ModernizedCProgram.Curl_sha256it);
		default:
				return CURLE_UNSUPPORTED_PROTOCOL/*
				 * Curl_auth_digest_cleanup()
				 *
				 * This is used to clean up the digest specific data.
				 *
				 * Parameters:
				 *
				 * digest    [in/out] - The digest data struct being cleaned up.
				 *
				 */;
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Byte Curl_strtok_r(byte ptr, Object sep, byte end) {
		if (!ptr) {
			ptr = /* we got NULL input so then we get our last position instead */end;
		} 
		while (ptr && .strchr(sep, /* pass all letters that are including in the separator string */ptr)) {
			++ptr;
		}
		if (ptr) {
			byte start = /* so this is where the next piece of string starts */ptr;
			end = start + /* set the end pointer to the first byte after the start */1;
			while (end && !.strchr(sep, /* scan through the string to find where it ends, it ends on a
			       null byte or a character that exists in the separator string */end)) {
				++end;
			}
			if (end) {
				end = /* the end is not a null byte *//* zero terminate it! */(byte)'\0';
				++/* advance the last pointer to beyond the null byte */end;
			} 
			return /* return the position where the string starts */start;
		} 
		return ((Object)/* we ended up on a null byte, there are no more strings to find! */0/* this was only compiled if strtok_r wasn't present */);
	}
	public static long dprintf_DollarString(byte input, byte end) {
		int number = 0;
		while ((ModernizedCProgram.Curl_isdigit((int)((byte)input)))) {
			number *= 10;
			number += input - (byte)'0';
			input++;
		}
		if (number && ((byte)'$' == input++)) {
			end = input;
			return number;
		} 
		return 0;
	}
	public static  dprintf_IsQualifierNoDollar(Object fmt) {
		if (!.strncmp(fmt, "I32", 3) || !.strncmp(fmt, "I64", 3)) {
			return 1;
		} 
		switch (fmt) {
		case (byte)'#':
		case (byte)'.':
		case (byte)'L':
		case (byte)'z':
		case (byte)'I':
				return 1;
		case (byte)'5':
		case (byte)'4':
		case (byte)'9':
		case (byte)'+':
		case (byte)'h':
		case (byte)' ':
		case (byte)'2':
		case (byte)'l':
		case (byte)'6':
		case (byte)'-':
		case (byte)'8':
		case (byte)'O':
		case (byte)'7':
		case (byte)'0':
		case (byte)'1':
		case (byte)'q':
		case (byte)'*':
		case (byte)'3':
		default:
				return 0/******************************************************************
				 *
				 * Pass 1:
				 * Create an index with the type of each parameter entry and its
				 * value (may vary in size)
				 *
				 * Returns zero on success.
				 *
				 ******************************************************************/;
		}
	}
	public static int dprintf_Pass1(Object format, byte endpos, Object arglist) {
		byte fmt = (byte)format;
		int param_num = 0;
		long this_param;
		long width;
		long precision;
		int flags;
		long max_param = 0;
		long i;
		while (fmt) {
			if (fmt++ == (byte)'%') {
				if (fmt == (byte)'%') {
					fmt++;
					continue;
				} 
				flags = .FLAGS_NEW;
				/* Handle the positional case (N$) */param_num++;
				this_param = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
				if (0 == this_param) {
					this_param = /* we got no positional, get the next counter */param_num;
				} 
				if (this_param > max_param) {
					max_param = this_param/*
					       * The parameter with number 'i' should be used. Next, we need
					       * to get SIZE and TYPE of the parameter. Add the information
					       * to our array.
					       */;
				} 
				width = 0;
				precision = 0;
				while (ModernizedCProgram.dprintf_IsQualifierNoDollar(/* Handle the flags */fmt)) {
					if (!.strncmp(fmt, "I32", 3)) {
						flags |=  .FLAGS_LONG;
						fmt += 3;
					}  else if (!.strncmp(fmt, "I64", 3)) {
						flags |=  .FLAGS_LONGLONG;
						fmt += 3;
					} else {
							switch (fmt++) {
							case /* Special case */(byte)'*':
									flags |=  .FLAGS_WIDTHPARAM;
									param_num++;
									i = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
									if (i) {
										width = i;
									} else {
											width = param_num;
									} 
									if (width > max_param) {
										max_param = width;
									} 
									break;
							case (byte)'-':
									flags |=  .FLAGS_LEFT;
									flags &=  ~.FLAGS_PAD_NIL;
									break;
							case (byte)'q':
									flags |=  .FLAGS_LONGLONG;
									break;
							case (byte)'h':
									flags |=  .FLAGS_SHORT;
									break;
							case (byte)'6':
							case (byte)'7':
							case (byte)'L':
									flags |=  .FLAGS_LONGDOUBLE;
									break;
							case (byte)'9':
									flags |=  .FLAGS_WIDTH;
									width = .strtol(fmt - 1, fmt, 10);
									break;
							case (byte)' ':
									flags |=  .FLAGS_SPACE;
									break;
							case (byte)'I':
									flags |=  .FLAGS_LONGLONG;
									break;
							case (byte)'l':
									if (flags & .FLAGS_LONG) {
										flags |=  .FLAGS_LONGLONG;
									} else {
											flags |=  .FLAGS_LONG;
									} 
									break;
							case (byte)'5':
							case (byte)'1':
							case (byte)'+':
									flags |=  .FLAGS_SHOWSIGN;
									break;
							case (byte)'z'/* the code below generates a warning if -Wunreachable-code is
							             used */:
									flags |=  .FLAGS_LONG;
									break;
							case (byte)'0':
									if (!(flags & .FLAGS_LEFT)) {
										flags |=  .FLAGS_PAD_NIL;
									} 
							case (byte)'3':
							case (byte)'2':
							case /* FALLTHROUGH */(byte)'4':
							case (byte)'.':
									if ((byte)'*' == fmt/* The precision is picked from a specified parameter */) {
										flags |=  .FLAGS_PRECPARAM;
										fmt++;
										param_num++;
										i = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
										if (i) {
											precision = i;
										} else {
												precision = param_num;
										} 
										if (precision > max_param) {
											max_param = precision;
										} 
									} else {
											flags |=  .FLAGS_PREC;
											precision = .strtol(fmt, fmt, 10);
									} 
									break;
							case (byte)'O':
									flags |=  .FLAGS_LONGLONG;
									break;
							case (byte)'#':
									flags |=  .FLAGS_ALT;
									break;
							case (byte)'8':
							default:
									break;
							}
					} 
				}
				i = this_param - /* Handle the specifier */1;
				if ((i < 0) || (i >= 128)) {
					return /* out of allowed range */1;
				} 
				switch (fmt) {
				case /* FALLTHROUGH */(byte)'s':
						vto[i].setType(.FORMAT_STRING);
						break;
				case (byte)'S':
						flags |=  .FLAGS_ALT;
				case (byte)'p':
						vto[i].setType(.FORMAT_PTR);
						break;
				case (byte)'X':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_HEX | .FLAGS_UPPER | .FLAGS_UNSIGNED;
						break;
				case (byte)'g':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATG;
						break;
				case (byte)'e':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATE;
						break;
				case (byte)'E':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATE | .FLAGS_UPPER;
						break;
				case (byte)'n':
						vto[i].setType(.FORMAT_INTPTR);
						break;
				case (byte)'o':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_OCTAL;
						break;
				case (byte)'f':
						vto[i].setType(.FORMAT_DOUBLE);
						break;
				case (byte)'G':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATG | .FLAGS_UPPER;
						break;
				case (byte)'x':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_HEX | .FLAGS_UNSIGNED;
						break;
				case (byte)'c':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_CHAR;
						break;
				case (byte)'u':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_UNSIGNED;
						break;
				case (byte)'d':
				case (byte)'i':
						vto[i].setType(.FORMAT_INT);
						break;
				default:
						vto[i].setType(.FORMAT_UNKNOWN);
						break;
				}
				vto[i].setFlags(flags);
				vto[i].setWidth(width);
				vto[i].setPrecision(precision);
				if (flags & .FLAGS_WIDTHPARAM/* we have the width specified from a parameter, so we make that
				           parameter's info setup properly */) {
					long k = width - 1;
					vto[i].setWidth(k);
					vto[k].setType(.FORMAT_WIDTH);
					vto[k].setFlags(.FLAGS_NEW);
					vto[k].setWidth(/* can't use width or precision of width! */0);
					vto[k].setPrecision(0);
				} 
				if (flags & .FLAGS_PRECPARAM/* we have the precision specified from a parameter, so we make that
				           parameter's info setup properly */) {
					long k = precision - 1;
					vto[i].setPrecision(k);
					vto[k].setType(.FORMAT_WIDTH);
					vto[k].setFlags(.FLAGS_NEW);
					vto[k].setWidth(/* can't use width or precision of width! */0);
					vto[k].setPrecision(0);
				} 
				endpos++ = fmt + /* end of this sequence */1;
			} 
		}
		for (i = 0; i < max_param; /* Read the arg list parameters into our data list */i/* Width/precision arguments must be read before the main argument
		       they are attached to */++) {
			if (vto[i].getFlags() & .FLAGS_WIDTHPARAM) {
				vto[vto[i].getWidth()].getData().getNum().setAs_signed((long)(int)arglist);
			} 
			if (vto[i].getFlags() & .FLAGS_PRECPARAM) {
				vto[vto[i].getPrecision()].getData().getNum().setAs_signed((long)(int)arglist);
			} 
			switch (vto[i].getType()) {
			case .FORMAT_INT:
					if ((vto[i].getFlags() & .FLAGS_LONGLONG) && (vto[i].getFlags() & .FLAGS_UNSIGNED)) {
						vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
					}  else if (vto[i].getFlags() & .FLAGS_LONGLONG) {
						vto[i].getData().getNum().setAs_signed((long)(int)arglist);
					} else {
							if ((vto[i].getFlags() & .FLAGS_LONG) && (vto[i].getFlags() & .FLAGS_UNSIGNED)) {
								vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
							}  else if (vto[i].getFlags() & .FLAGS_LONG) {
								vto[i].getData().getNum().setAs_signed((long)(int)arglist);
							}  else if (vto[i].getFlags() & .FLAGS_UNSIGNED) {
								vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
							} else {
									vto[i].getData().getNum().setAs_signed((long)(int)arglist);
							} 
					} 
					break;
			case .FORMAT_UNKNOWN:
			case .FORMAT_PTR:
					vto[i].getData().setPtr((int)arglist);
					break;
			case .FORMAT_DOUBLE:
					vto[i].getData().setDnum((int)arglist);
					break;
			case .FORMAT_INTPTR:
			case .FORMAT_WIDTH/* Argument has been read. Silently convert it into an integer
			       * for later use
			       */:
					vto[i].setType(.FORMAT_INT);
					break;
			case .FORMAT_STRING:
					vto[i].getData().setStr((int)arglist);
					break;
			default:
					break;
			}
		}
		return 0;
	}
	public static int dprintf_formatf(Object data, Object stream, Object format, Object ap_save) {
		byte digits = /* %-formatted string *//* list of parameters *//* Base-36 digits for numbers.  */ModernizedCProgram.lower_digits;
		/* Pointer into the format string.  */byte f;
		int done = /* Number of characters written.  */0;
		/* current parameter to read */long param;
		long param_num = /* parameter counter */0;
		va_stack_t[] vto = new va_stack_t();
		byte[] endpos = new byte[128];
		byte end;
		byte[] work = new byte[326];
		va_stack_t p = new va_stack_t();
		/* 'workend' points to the final buffer byte position, but with an extra
		     byte as margin to avoid the (false?) warning Coverity gives us
		     otherwise */
		byte workend = work[ - 2];
		if (vto.dprintf_Pass1(format, endpos, /* Do the actual %-code parsing */ap_save)) {
			return -1;
		} 
		end = endpos[/* the initial end-position from the list dprintf_Pass1()
		                       created for us */0];
		f = (byte)format;
		Object generatedFlags = p.getFlags();
		Object generatedWidth = p.getWidth();
		Object generatedPrecision = p.getPrecision();
		Object generatedData = p.getData();
		return done;
	}
	/* untouched by format(), just sent to the stream() function in
	                 the second argument */
	/* function pointer called for each output character */
	/* fputc() look-alike */
	public static int addbyter(int output) {
		nsprintf infop = (nsprintf)ModernizedCProgram.data;
		byte outc = (byte)output;
		Object generatedLength = infop.getLength();
		Object generatedMax = infop.getMax();
		byte generatedBuffer = infop.getBuffer();
		if (generatedLength < generatedMax) {
			generatedBuffer[0] = /* only do this if we haven't reached max length yet *//* store */outc;
			generatedBuffer++;
			generatedLength++;
			return /* fputc() returns like this on success */outc;
		} 
		return -1;
	}
	public static int curl_mvsnprintf(Byte buffer, Object maxlength, Object format, Object ap_save) {
		int retcode;
		nsprintf info = new nsprintf();
		info.setBuffer(buffer);
		info.setLength(0);
		info.setMax(maxlength);
		retcode = ModernizedCProgram.dprintf_formatf(info, addbyter, format, ap_save);
		Object generatedMax = info.getMax();
		Object generatedLength = info.getLength();
		byte generatedBuffer = info.getBuffer();
		if ((retcode != -1) && generatedMax) {
			if (generatedMax == generatedLength) {
				generatedBuffer[-1] = /* we're at maximum, scrap the last letter */0;
			} else {
					generatedBuffer[0] = 0;
			} 
		} 
		return retcode;
	}
	public static int curl_msnprintf(Byte buffer, Object maxlength, Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.curl_mvsnprintf(buffer, maxlength, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	/* fputc() look-alike */
	public static int alloc_addbyter(int output) {
		asprintf infop = (asprintf)ModernizedCProgram.data;
		byte outc = (byte)output;
		Byte generatedBuffer = infop.getBuffer();
		Object generatedLen = infop.getLen();
		Object generatedAlloc = infop.getAlloc();
		if (!generatedBuffer) {
			infop.setBuffer(.Curl_cmalloc(32));
			if (!generatedBuffer) {
				infop.setFail(1);
				return -/* fail */1;
			} 
			infop.setAlloc(32);
			infop.setLen(0);
		}  else if (generatedLen + 1 >= generatedAlloc) {
			byte newptr = ((Object)0);
			size_t newsize = generatedAlloc * 2;
			if (newsize > generatedAlloc) {
				newptr = .Curl_crealloc(generatedBuffer, newsize);
			} 
			if (!newptr) {
				infop.setFail(1);
				return -/* fail */1;
			} 
			infop.setBuffer(newptr);
			infop.setAlloc(newsize);
		} 
		generatedBuffer[generatedLen] = outc;
		generatedLen++;
		return /* fputc() returns like this on success */outc;
	}
	public static Byte curl_maprintf(Object format) {
		/* argument pointer */va_list ap_save = new va_list();
		int retcode;
		asprintf info = new asprintf();
		info.setBuffer(((Object)0));
		info.setLen(0);
		info.setAlloc(0);
		info.setFail(0);
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(info, alloc_addbyter, format, ap_save);
		.__builtin_va_end(ap_save);
		int generatedFail = info.getFail();
		Object generatedAlloc = info.getAlloc();
		Byte generatedBuffer = info.getBuffer();
		if ((-1 == retcode) || generatedFail) {
			if (generatedAlloc) {
				.Curl_cfree(generatedBuffer);
			} 
			return ((Object)0);
		} 
		Object generatedLen = info.getLen();
		if (generatedAlloc) {
			generatedBuffer[generatedLen] = /* we terminate this with a zero byte */0;
			return generatedBuffer;
		} 
		return .Curl_cstrdup("");
	}
	public static Byte curl_mvaprintf(Object format, Object ap_save) {
		int retcode;
		asprintf info = new asprintf();
		info.setBuffer(((Object)0));
		info.setLen(0);
		info.setAlloc(0);
		info.setFail(0);
		retcode = ModernizedCProgram.dprintf_formatf(info, alloc_addbyter, format, ap_save);
		int generatedFail = info.getFail();
		Object generatedAlloc = info.getAlloc();
		Byte generatedBuffer = info.getBuffer();
		if ((-1 == retcode) || generatedFail) {
			if (generatedAlloc) {
				.Curl_cfree(generatedBuffer);
			} 
			return ((Object)0);
		} 
		Object generatedLen = info.getLen();
		if (generatedAlloc) {
			generatedBuffer[generatedLen] = /* we terminate this with a zero byte */0;
			return generatedBuffer;
		} 
		return .Curl_cstrdup("");
	}
	public static int storebuffer(int output) {
		byte buffer = (byte)ModernizedCProgram.data;
		byte outc = (byte)output;
		buffer = outc;
		(buffer)++;
		return /* act like fputc() ! */outc;
	}
	public static int curl_msprintf(byte buffer, Object format) {
		/* argument pointer */va_list ap_save = new va_list();
		int retcode;
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(buffer, storebuffer, format, ap_save);
		.__builtin_va_end(ap_save);
		buffer = /* we terminate this with a zero byte */0;
		return retcode;
	}
	public static int curl_mprintf(Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf((_iob[1]), fputc, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	public static int curl_mfprintf(Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(whereto, fputc, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	public static int curl_mvsprintf(byte buffer, Object format, Object ap_save) {
		int retcode;
		retcode = ModernizedCProgram.dprintf_formatf(buffer, storebuffer, format, ap_save);
		buffer = /* we terminate this with a zero byte */0;
		return retcode;
	}
	public static int curl_mvprintf(Object format, Object ap_save) {
		return ModernizedCProgram.dprintf_formatf((_iob[1]), fputc, format, ap_save);
	}
	public static int curl_mvfprintf(Object format, Object ap_save) {
		return ModernizedCProgram.dprintf_formatf(whereto, fputc, format, ap_save);
	}
	public static int getrpacketevent(Object packet) {
		return (int)((packet.getData()[0] << 8) | packet.getData()[1]);
	}
	public static int getrpacketblock(Object packet) {
		return (int)((packet.getData()[2] << 8) | packet.getData()[3]);
	}
	public static Object Curl_strnlen(Object string, Object maxlen) {
		byte end = .memchr(string, (byte)'\0', maxlen);
		return end ? (size_t)(end - string) : maxlen;
	}
	public static Object tftp_option_get(Object buf, Object len, Object option, Object value) {
		size_t loc = new size_t();
		loc = ModernizedCProgram.Curl_strnlen(buf, len);
		/* NULL term */loc++;
		if (loc >= len) {
			return ((Object)0);
		} 
		option = buf;
		loc += ModernizedCProgram.Curl_strnlen(buf + loc, len - loc);
		/* NULL term */loc++;
		if (loc > len) {
			return ((Object)0);
		} 
		value = buf[.strlen(option) + 1];
		return buf[loc];
	}
	public static Object tftp_translate_code( error) {
		 result = CURLE_OK;
		if (error != .TFTP_ERR_NONE) {
			switch (error) {
			case .TFTP_ERR_TIMEOUT:
					result = CURLE_OPERATION_TIMEDOUT;
					break;
			case .TFTP_ERR_NOSUCHUSER:
					result = CURLE_TFTP_NOSUCHUSER;
					break;
			case .TFTP_ERR_PERM:
					result = CURLE_TFTP_PERM;
					break;
			case .TFTP_ERR_DISKFULL:
					result = CURLE_REMOTE_DISK_FULL;
					break;
			case .TFTP_ERR_ILLEGAL:
					result = CURLE_TFTP_ILLEGAL;
					break;
			case .TFTP_ERR_UNDEF:
			case .TFTP_ERR_EXISTS:
					result = CURLE_REMOTE_FILE_EXISTS;
					break;
			case .TFTP_ERR_UNKNOWNID:
					result = CURLE_TFTP_UNKNOWNID;
					break;
			case .TFTP_ERR_NORESPONSE:
					result = CURLE_COULDNT_CONNECT;
					break;
			case .TFTP_ERR_NOTFOUND:
					result = CURLE_TFTP_NOTFOUND;
					break;
			default:
					result = CURLE_ABORTED_BY_CALLBACK;
					break;
			}
		} else {
				result = CURLE_OK;
		} 
		return result/**********************************************************
		 *
		 * tftp_state_machine
		 *
		 * The tftp state machine event dispatcher
		 *
		 **********************************************************/;
	}
	/*
	 * TFTP protocol handler.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/*
	** Helper functions that are used from more than one source file.
	*/
	public static Object param2text(int res) {
		ParameterError error = (ParameterError)res;
		switch (error) {
		case .PARAM_GOT_EXTRA_PARAMETER:
				return "had unsupported trailing garbage";
		case .PARAM_NO_NOT_BOOLEAN:
				return "used '--no-' for option that isn't a boolean";
		case .PARAM_BAD_USE:
				return "is badly used here";
		case .PARAM_NO_PREFIX:
				return "the given option can't be reversed with a --no- prefix";
		case .PARAM_NO_MEM:
				return "out of memory";
		case .PARAM_LIBCURL_UNSUPPORTED_PROTOCOL:
				return "a specified protocol is unsupported by libcurl";
		case .PARAM_OPTION_AMBIGUOUS:
				return "is ambiguous";
		case .PARAM_NUMBER_TOO_LARGE:
				return "too large number";
		case .PARAM_REQUIRES_PARAMETER:
				return "requires parameter";
		case .PARAM_LIBCURL_DOESNT_SUPPORT:
				return "the installed libcurl version doesn't support this";
		case .PARAM_OPTION_UNKNOWN:
				return "is unknown";
		case .PARAM_BAD_NUMERIC:
				return "expected a proper numerical parameter";
		case .PARAM_NEGATIVE_NUMERIC:
				return "expected a positive numerical parameter";
		default:
				return "unknown error";
		}
	}
	public static int ftp_pl_get_permission(Object str) {
		int permissions = 0;
		if (str[0] == /* USER */(byte)'r') {
			permissions |=  1 << 8;
		}  else if (str[0] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[1] == (byte)'w') {
			permissions |=  1 << 7;
		}  else if (str[1] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[2] == (byte)'x') {
			permissions |=  1 << 6;
		}  else if (str[2] == (byte)'s') {
			permissions |=  1 << 6;
			permissions |=  1 << 11;
		}  else if (str[2] == (byte)'S') {
			permissions |=  1 << 11;
		}  else if (str[2] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[3] == /* GROUP */(byte)'r') {
			permissions |=  1 << 5;
		}  else if (str[3] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[4] == (byte)'w') {
			permissions |=  1 << 4;
		}  else if (str[4] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[5] == (byte)'x') {
			permissions |=  1 << 3;
		}  else if (str[5] == (byte)'s') {
			permissions |=  1 << 3;
			permissions |=  1 << 10;
		}  else if (str[5] == (byte)'S') {
			permissions |=  1 << 10;
		}  else if (str[5] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[6] == /* others */(byte)'r') {
			permissions |=  1 << 2;
		}  else if (str[6] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[7] == (byte)'w') {
			permissions |=  1 << 1;
		}  else if (str[7] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[8] == (byte)'x') {
			permissions |=  1;
		}  else if (str[8] == (byte)'t') {
			permissions |=  1;
			permissions |=  1 << 9;
		}  else if (str[8] == (byte)'T') {
			permissions |=  1 << 9;
		}  else if (str[8] != (byte)'-') {
			permissions |=  -1024;
		} 
		return permissions;
	}
	public static Object ftp_pl_insert_finfo(connectdata conn, fileinfo infop) {
		 compare = new ();
		Curl_easy generatedData = conn.getData();
		Object generatedWildcard = generatedData.getWildcard();
		WildcardData wc = generatedWildcard;
		Object generatedProtdata = wc.getProtdata();
		ftp_wc ftpwc = generatedProtdata;
		curl_llist generatedFilelist = wc.getFilelist();
		curl_llist llist = generatedFilelist;
		ftp_parselist_data generatedParser = ftpwc.getParser();
		ftp_parselist_data parser = generatedParser;
		bool add = 1;
		curl_fileinfo generatedInfo = infop.getInfo();
		curl_fileinfo finfo = generatedInfo;
		Object generatedCurl_fileinfo = finfo.getCurl_fileinfo();
		byte str = generatedCurl_fileinfo;
		 generatedOffsets = parser.getOffsets();
		Object generatedFilename = generatedOffsets.getFilename();
		finfo.setCurl_fileinfo(str + generatedFilename);
		Object generatedGroup = generatedOffsets.getGroup();
		generatedCurl_fileinfo.setGroup(generatedGroup ? str + generatedGroup : ((Object)0));
		Object generatedPerm = generatedOffsets.getPerm();
		generatedCurl_fileinfo.setPerm(generatedPerm ? str + generatedPerm : ((Object)0));
		Object generatedSymlink_target = generatedOffsets.getSymlink_target();
		generatedCurl_fileinfo.setTarget(generatedSymlink_target ? str + generatedSymlink_target : ((Object)0));
		Object generatedTime = generatedOffsets.getTime();
		generatedCurl_fileinfo.setTime(str + generatedTime);
		Object generatedUser = generatedOffsets.getUser();
		generatedCurl_fileinfo.setUser(generatedUser ? str + generatedUser : ((Object)0));
		Object generatedSet = generatedData.getSet();
		compare = generatedSet.getFnmatch();
		if (!compare) {
			compare = ModernizedCProgram.Curl_fnmatch;
		} 
		generatedData.Curl_set_in_callback(/* filter pattern-corresponding filenames */.bool_true);
		Byte generatedPattern = wc.getPattern();
		if (.compare(generatedSet.getFnmatch_data(), generatedPattern, generatedCurl_fileinfo) == 0) {
			if ((generatedCurl_fileinfo == CURLFILETYPE_SYMLINK) && generatedCurl_fileinfo.getTarget() && (.strstr(generatedCurl_fileinfo.getTarget(), " -> "))) {
				add = 0;
			} 
		} else {
				add = 0;
		} 
		generatedData.Curl_set_in_callback(.bool_false);
		curl_llist_element generatedTail = llist.getTail();
		curl_llist_element generatedList = infop.getList();
		if (add) {
			ModernizedCProgram.Curl_llist_insert_next(llist, generatedTail, finfo, generatedList);
		} else {
				infop.Curl_fileinfo_cleanup();
		} 
		generatedParser.setFile_data(((Object)0));
		return CURLE_OK;
	}
	public static Object Curl_ftp_parselist(Byte buffer, Object size, Object nmemb, Object connptr) {
		size_t bufflen = size * nmemb;
		connectdata conn = (connectdata)connptr;
		Curl_easy generatedData = conn.getData();
		Object generatedWildcard = generatedData.getWildcard();
		ftp_wc ftpwc = generatedWildcard.getProtdata();
		ftp_parselist_data generatedParser = ftpwc.getParser();
		ftp_parselist_data parser = generatedParser;
		fileinfo infop = new fileinfo();
		curl_fileinfo finfo = new curl_fileinfo();
		long i = 0;
		 result = new ();
		size_t retsize = bufflen;
		Object generatedError = parser.getError();
		if (generatedError) {
			;
		} 
		 generatedOs_type = parser.getOs_type();
		if (generatedOs_type == .OS_TYPE_UNKNOWN && bufflen > 0) {
			parser.setOs_type((buffer[0] >= (byte)'0' && buffer[0] <= /* considering info about FILE response format */(byte)'9') ? .OS_TYPE_WIN_NT : .OS_TYPE_UNIX);
		} 
		fileinfo generatedFile_data = parser.getFile_data();
		fileinfo fileinfo = new fileinfo();
		curl_fileinfo generatedInfo = generatedFile_data.getInfo();
		Object generatedCurl_fileinfo = generatedInfo.getCurl_fileinfo();
		 generatedState = parser.getState();
		Object generatedUNIX = generatedState.getUNIX();
		int generatedItem_length = parser.getItem_length();
		Object generatedItem_offset = parser.getItem_offset();
		 generatedOffsets = parser.getOffsets();
		Object generatedNT = generatedState.getNT();
		while (i < /* FSM */bufflen) {
			byte c = buffer[i];
			if (!generatedFile_data) {
				parser.setFile_data(fileinfo.Curl_fileinfo_alloc());
				if (!generatedFile_data) {
					parser.setError(CURLE_OUT_OF_MEMORY);
					;
				} 
				generatedInfo.setCurl_fileinfo(.Curl_cmalloc(160));
				if (!generatedCurl_fileinfo) {
					parser.setError(CURLE_OUT_OF_MEMORY);
					;
				} 
				generatedInfo.setCurl_fileinfo(160);
				parser.setItem_offset(0);
				parser.setItem_length(0);
			} 
			infop = generatedFile_data;
			finfo = generatedInfo;
			generatedCurl_fileinfo[generatedCurl_fileinfo++] = c;
			if (generatedCurl_fileinfo >= generatedCurl_fileinfo - 1) {
				byte tmp = .Curl_crealloc(generatedCurl_fileinfo, generatedCurl_fileinfo + /* if it is important, extend buffer space for file data */160);
				if (tmp) {
					generatedCurl_fileinfo += 160;
					finfo.setCurl_fileinfo(tmp);
				} else {
						generatedFile_data.Curl_fileinfo_cleanup();
						parser.setFile_data(((Object)0));
						parser.setError(CURLE_OUT_OF_MEMORY);
						;
				} 
			} 
			switch (generatedOs_type) {
			case .OS_TYPE_UNIX:
					switch (generatedUNIX.getMain()) {
					case .PL_UNIX_PERMISSION:
							generatedItem_length++;
							if (generatedItem_length <= 9) {
								if (!.strchr("rwx-tTsS", c)) {
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
								} 
							}  else if (generatedItem_length == 10) {
								int perm;
								if (c != (byte)' ') {
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
								} 
								generatedCurl_fileinfo[10] = /* terminate permissions */0;
								perm = ModernizedCProgram.ftp_pl_get_permission(generatedCurl_fileinfo + generatedItem_offset);
								if (perm & -1024) {
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
								} 
								generatedCurl_fileinfo |=  CURLFINFOFLAG_KNOWN_PERM;
								generatedInfo.setCurl_fileinfo(perm);
								generatedOffsets.setPerm(generatedItem_offset);
								parser.setItem_length(0);
								generatedUNIX.setMain(.PL_UNIX_HLINKS);
								generatedUNIX.getSub().setHlinks(.PL_UNIX_HLINKS_PRESPACE);
							} 
							break;
					case .PL_UNIX_SYMLINK:
							switch (generatedUNIX.getSub().getSymlink()) {
							case .PL_UNIX_SYMLINK_WINDOWSEOL:
									if (c == (byte)'\n') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setSymlink_target(generatedItem_offset);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										generatedUNIX.setMain(.PL_UNIX_FILETYPE);
									} else {
											parser.setError(CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_SYMLINK_TARGET:
									generatedItem_length++;
									if (c == (byte)'\r') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_WINDOWSEOL);
									}  else if (c == (byte)'\n') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setSymlink_target(generatedItem_offset);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										generatedUNIX.setMain(.PL_UNIX_FILETYPE);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET1:
									generatedItem_length++;
									if (c == (byte)'-') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET2);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET3:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET4);
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 4] = /* now place where is symlink following */0;
										generatedOffsets.setFilename(generatedItem_offset);
										parser.setItem_length(0);
										parser.setItem_offset(0);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET2:
									generatedItem_length++;
									if (c == (byte)'>') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET3);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET4:
									if (c != (byte)'\r' && c != (byte)'\n') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_TARGET);
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
									} else {
											parser.setError(CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_SYMLINK_NAME:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET1);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							}
							break;
					case .PL_UNIX_TIME:
							switch (generatedUNIX.getSub().getTime()) {
							case .PL_UNIX_TIME_PART1:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PREPART2);
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PART3:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setTime(generatedItem_offset);
										if (generatedCurl_fileinfo == CURLFILETYPE_SYMLINK) {
											generatedUNIX.setMain(.PL_UNIX_SYMLINK);
											generatedUNIX.getSub().setSymlink(.PL_UNIX_SYMLINK_PRESPACE);
										} else {
												generatedUNIX.setMain(.PL_UNIX_FILENAME);
												generatedUNIX.getSub().setFilename(.PL_UNIX_FILENAME_PRESPACE);
										} 
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.' && c != (byte)':') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PART2:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PREPART3);
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PREPART1:
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											parser.setItem_offset(generatedCurl_fileinfo - 1);
											parser.setItem_length(1);
											generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PART1);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_TIME_PREPART2:
									generatedItem_length++;
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PART2);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_TIME_PREPART3:
									generatedItem_length++;
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PART3);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_USER:
							switch (generatedUNIX.getSub().getUser()) {
							case .PL_UNIX_USER_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedUNIX.getSub().setUser(.PL_UNIX_USER_PARSING);
									} 
									break;
							case .PL_UNIX_USER_PARSING:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setUser(generatedItem_offset);
										generatedUNIX.setMain(.PL_UNIX_GROUP);
										generatedUNIX.getSub().setGroup(.PL_UNIX_GROUP_PRESPACE);
										parser.setItem_offset(0);
										parser.setItem_length(0);
									} 
									break;
							}
							break;
					case .PL_UNIX_TOTALSIZE:
							switch (generatedUNIX.getSub().getTotal_dirsize()) {
							case .PL_UNIX_TOTALSIZE_READING:
									generatedItem_length++;
									if (c == (byte)'\r') {
										generatedItem_length--;
										generatedCurl_fileinfo--;
									}  else if (c == (byte)'\n') {
										generatedCurl_fileinfo[generatedItem_length - 1] = 0;
										if (.strncmp("total ", generatedCurl_fileinfo, 6) == 0) {
											byte endptr = generatedCurl_fileinfo + 6/* here we can deal with directory size, pass the leading white
											                 spaces and then the digits */;
											while ((ModernizedCProgram.Curl_isspace((int)((byte)endptr)))) {
												endptr++;
											}
											while ((ModernizedCProgram.Curl_isdigit((int)((byte)endptr)))) {
												endptr++;
											}
											if (endptr != 0) {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
											} 
											generatedUNIX.setMain(.PL_UNIX_FILETYPE);
											finfo.setCurl_fileinfo(0);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_TOTALSIZE_INIT:
									if (c == (byte)'t') {
										generatedUNIX.getSub().setTotal_dirsize(.PL_UNIX_TOTALSIZE_READING);
										generatedItem_length++;
									} else {
											generatedUNIX.setMain(.PL_UNIX_FILETYPE);
											finfo.setCurl_fileinfo(/* start FSM again not considering size of directory */0);
											continue;
									} 
									break;
							}
							break;
					case .PL_UNIX_SIZE:
							switch (generatedUNIX.getSub().getSize()) {
							case .PL_UNIX_SIZE_NUMBER:
									generatedItem_length++;
									if (c == (byte)' ') {
										byte p;
										 fsize = new ();
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										if (!ModernizedCProgram.curlx_strtoofft(generatedCurl_fileinfo + generatedItem_offset, p, 10, fsize)) {
											if (p[0] == (byte)'\0' && fsize != .CURL_OFF_T_C(-1024) && fsize != (-.CURL_OFF_T_C(-1024) - .CURL_OFF_T_C(1))) {
												generatedCurl_fileinfo |=  CURLFINFOFLAG_KNOWN_SIZE;
												generatedInfo.setCurl_fileinfo(fsize);
											} 
											parser.setItem_length(0);
											parser.setItem_offset(0);
											generatedUNIX.setMain(.PL_UNIX_TIME);
											generatedUNIX.getSub().setTime(.PL_UNIX_TIME_PREPART1);
										} 
									}  else if (!(ModernizedCProgram.Curl_isdigit((int)((byte)c)))) {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_SIZE_PRESPACE:
									if (c != (byte)' ') {
										if (c >= (byte)'0' && c <= (byte)'9') {
											parser.setItem_offset(generatedCurl_fileinfo - 1);
											parser.setItem_length(1);
											generatedUNIX.getSub().setSize(.PL_UNIX_SIZE_NUMBER);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_GROUP:
							switch (generatedUNIX.getSub().getGroup()) {
							case .PL_UNIX_GROUP_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedUNIX.getSub().setGroup(.PL_UNIX_GROUP_NAME);
									} 
									break;
							case .PL_UNIX_GROUP_NAME:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setGroup(generatedItem_offset);
										generatedUNIX.setMain(.PL_UNIX_SIZE);
										generatedUNIX.getSub().setSize(.PL_UNIX_SIZE_PRESPACE);
										parser.setItem_offset(0);
										parser.setItem_length(0);
									} 
									break;
							}
							break;
					case .PL_UNIX_HLINKS:
							switch (generatedUNIX.getSub().getHlinks()) {
							case .PL_UNIX_HLINKS_NUMBER:
									generatedItem_length++;
									if (c == (byte)' ') {
										byte p;
										long hlinks;
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										hlinks = .strtol(generatedCurl_fileinfo + generatedItem_offset, p, 10);
										if (p[0] == (byte)'\0' && hlinks != LONG_MAX && hlinks != LONG_MIN) {
											generatedCurl_fileinfo |=  CURLFINFOFLAG_KNOWN_HLINKCOUNT;
											generatedInfo.setCurl_fileinfo(hlinks);
										} 
										parser.setItem_length(0);
										parser.setItem_offset(0);
										generatedUNIX.setMain(.PL_UNIX_USER);
										generatedUNIX.getSub().setUser(.PL_UNIX_USER_PRESPACE);
									}  else if (c < (byte)'0' || c > (byte)'9') {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_HLINKS_PRESPACE:
									if (c != (byte)' ') {
										if (c >= (byte)'0' && c <= (byte)'9') {
											parser.setItem_offset(generatedCurl_fileinfo - 1);
											parser.setItem_length(1);
											generatedUNIX.getSub().setHlinks(.PL_UNIX_HLINKS_NUMBER);
										} else {
												parser.setError(CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_FILETYPE:
							switch (c) {
							case (byte)'d':
									finfo.setCurl_fileinfo(CURLFILETYPE_DIRECTORY);
									break;
							case (byte)'b':
									finfo.setCurl_fileinfo(CURLFILETYPE_DEVICE_BLOCK);
									break;
							case (byte)'-':
									finfo.setCurl_fileinfo(CURLFILETYPE_FILE);
									break;
							case (byte)'c':
									finfo.setCurl_fileinfo(CURLFILETYPE_DEVICE_CHAR);
									break;
							case (byte)'l':
									finfo.setCurl_fileinfo(CURLFILETYPE_SYMLINK);
									break;
							case (byte)'D':
									finfo.setCurl_fileinfo(CURLFILETYPE_DOOR);
									break;
							case (byte)'s':
									finfo.setCurl_fileinfo(CURLFILETYPE_SOCKET);
									break;
							case (byte)'p':
									finfo.setCurl_fileinfo(CURLFILETYPE_NAMEDPIPE);
									break;
							default:
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
							}
							generatedUNIX.setMain(.PL_UNIX_PERMISSION);
							parser.setItem_length(0);
							parser.setItem_offset(1);
							break;
					case .PL_UNIX_FILENAME:
							switch (generatedUNIX.getSub().getFilename()) {
							case .PL_UNIX_FILENAME_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedUNIX.getSub().setFilename(.PL_UNIX_FILENAME_NAME);
									} 
									break;
							case .PL_UNIX_FILENAME_WINDOWSEOL:
									if (c == (byte)'\n') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setFilename(generatedItem_offset);
										generatedUNIX.setMain(.PL_UNIX_FILETYPE);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
									} else {
											parser.setError(CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_FILENAME_NAME:
									generatedItem_length++;
									if (c == (byte)'\r') {
										generatedUNIX.getSub().setFilename(.PL_UNIX_FILENAME_WINDOWSEOL);
									}  else if (c == (byte)'\n') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedOffsets.setFilename(generatedItem_offset);
										generatedUNIX.setMain(.PL_UNIX_FILETYPE);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
									} 
									break;
							}
							break;
					}
					break;
			case .OS_TYPE_WIN_NT:
					switch (generatedNT.getMain()) {
					case .PL_WINNT_DATE:
							generatedItem_length++;
							if (generatedItem_length < 9) {
								if (!.strchr("0123456789-", /* only simple control */c)) {
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
								} 
							}  else if (generatedItem_length == 9) {
								if (c == (byte)' ') {
									generatedNT.setMain(.PL_WINNT_TIME);
									generatedNT.getSub().setTime(.PL_WINNT_TIME_PRESPACE);
								} else {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
								} 
							} else {
									parser.setError(CURLE_FTP_BAD_FILE_LIST);
									;
							} 
							break;
					case .PL_WINNT_FILENAME:
							switch (generatedNT.getSub().getFilename()) {
							case .PL_WINNT_FILENAME_WINEOL:
									if (c == (byte)'\n') {
										generatedOffsets.setFilename(generatedItem_offset);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										generatedNT.setMain(.PL_WINNT_DATE);
										generatedNT.getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} else {
											parser.setError(CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_WINNT_FILENAME_CONTENT:
									generatedItem_length++;
									if (c == (byte)'\r') {
										generatedNT.getSub().setFilename(.PL_WINNT_FILENAME_WINEOL);
										generatedCurl_fileinfo[generatedCurl_fileinfo - 1] = 0;
									}  else if (c == (byte)'\n') {
										generatedOffsets.setFilename(generatedItem_offset);
										generatedCurl_fileinfo[generatedCurl_fileinfo - 1] = 0;
										generatedOffsets.setFilename(generatedItem_offset);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										generatedNT.setMain(.PL_WINNT_DATE);
										generatedNT.getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} 
									break;
							case .PL_WINNT_FILENAME_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedNT.getSub().setFilename(.PL_WINNT_FILENAME_CONTENT);
									} 
									break;
							}
							break;
					case .PL_WINNT_DIRORSIZE:
							switch (generatedNT.getSub().getDirorsize()) {
							case .PL_WINNT_DIRORSIZE_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(generatedCurl_fileinfo - 1);
										parser.setItem_length(1);
										generatedNT.getSub().setDirorsize(.PL_WINNT_DIRORSIZE_CONTENT);
									} 
									break;
							case .PL_WINNT_DIRORSIZE_CONTENT:
									generatedItem_length++;
									if (c == (byte)' ') {
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										if (.strcmp("<DIR>", generatedCurl_fileinfo + generatedItem_offset) == 0) {
											finfo.setCurl_fileinfo(CURLFILETYPE_DIRECTORY);
											finfo.setCurl_fileinfo(0);
										} else {
												byte endptr;
												if (ModernizedCProgram.curlx_strtoofft(generatedCurl_fileinfo + generatedItem_offset, endptr, 10, generatedCurl_fileinfo)) {
													parser.setError(CURLE_FTP_BAD_FILE_LIST);
													;
												} 
												generatedInfo.setCurl_fileinfo(/* correct file type */CURLFILETYPE_FILE);
										} 
										generatedCurl_fileinfo |=  CURLFINFOFLAG_KNOWN_SIZE;
										parser.setItem_length(0);
										generatedNT.setMain(.PL_WINNT_FILENAME);
										generatedNT.getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} 
									break;
							}
							break;
					case .PL_WINNT_TIME:
							generatedItem_length++;
							switch (generatedNT.getSub().getTime()) {
							case .PL_WINNT_TIME_PRESPACE:
									if (!(ModernizedCProgram.Curl_isspace((int)((byte)c)))) {
										generatedNT.getSub().setTime(.PL_WINNT_TIME_TIME);
									} 
									break;
							case .PL_WINNT_TIME_TIME:
									if (c == (byte)' ') {
										generatedOffsets.setTime(generatedItem_offset);
										generatedCurl_fileinfo[generatedItem_offset + generatedItem_length - 1] = 0;
										generatedNT.setMain(.PL_WINNT_DIRORSIZE);
										generatedNT.getSub().setDirorsize(.PL_WINNT_DIRORSIZE_PRESPACE);
										parser.setItem_length(0);
									}  else if (!.strchr("APM0123456789:", c)) {
										parser.setError(CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							}
							break;
					}
					break;
			default:
					retsize = bufflen + 1;
					;
			}
			i++;
		}
		return retsize;
		return retsize/* CURL_DISABLE_FTP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static Object Curl_setstropt(byte charp, Object s) {
		do {
			.Curl_cfree((charp));
			(charp) = ((Object)0);
		} while (0);
		if (s) {
			byte str = .Curl_cstrdup(s);
			if (str) {
				size_t len = .strlen(str);
				if (len > 8000000) {
					.Curl_cfree(str);
					return CURLE_BAD_FUNCTION_ARGUMENT;
				} 
			} 
			if (!str) {
				return CURLE_OUT_OF_MEMORY;
			} 
			charp = str;
		} 
		return CURLE_OK;
	}
	/* Release the previous storage at `charp' and replace by a dynamic storage
	     copy of `s'. Return CURLE_OK or CURLE_OUT_OF_MEMORY. */
	public static Object setstropt_userpwd(Byte option, byte userp, byte passwdp) {
		 result = CURLE_OK;
		byte user = ((Object)0);
		byte passwd = ((Object)0);
		if (/* Parse the login details if specified. It not then we treat NULL as a hint
		     to clear the existing data */option) {
			result = ModernizedCProgram.Curl_parse_login_details(option, .strlen(option), (userp ? user : ((Object)0)), (passwdp ? passwd : ((Object)0)), ((Object)0));
		} 
		if (!result) {
			if (/* Store the username part of option if required */userp) {
				if (!user && option && option[0] == (byte)':') {
					user = .Curl_cstrdup(/* Allocate an empty string instead of returning NULL as user name */"");
					if (!user) {
						result = CURLE_OUT_OF_MEMORY;
					} 
				} 
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				userp = user;
			} 
			if (/* Store the password part of option if required */passwdp) {
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwdp = passwd;
			} 
		} 
		return result;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Download a given URL into a local file named page.out.
	 * </DESC>
	 */
	public static Object write_data(Object ptr, Object size, Object nmemb, Object stream) {
		size_t written = .fwrite(ptr, size, nmemb, (FILE)stream);
		return written;
		size_t written = .fwrite(ptr, size, nmemb, (FILE)stream);
		return written;
		size_t written = .fwrite(ptr, size, nmemb, (FILE)stream);
		return written;
	}
	public static void fake_t_startsingle_time(Curl_easy data, curltime fake_now, int seconds_offset) {
		data.Curl_pgrsTime(.TIMER_STARTSINGLE);
		Object generatedTv_sec = fake_now.getTv_sec();
		Object generatedProgress = data.getProgress();
		generatedProgress.getT_startsingle().setTv_sec(generatedTv_sec + seconds_offset);
		int generatedTv_usec = fake_now.getTv_usec();
		generatedProgress.getT_startsingle().setTv_usec(generatedTv_usec);
	}
	public static  usec_matches_seconds(Object time_usec, int expected_seconds) {
		int time_sec = (int)(time_usec / ModernizedCProgram.usec_magnitude);
		bool same = (time_sec == expected_seconds);
		(_iob[2]).curl_mfprintf("is %d us same as %d seconds? %s\n", (int)time_usec, expected_seconds, same ? "Yes" : "No");
		return same;
	}
	public static Object decodeQuantum(Byte dest, Object src) {
		size_t padding = 0;
		byte s;
		byte p;
		long i;
		long x = 0;
		for (; i < 4; ) {
			if (s == (byte)'=') {
				x = (x << 6);
				padding++;
			} else {
					long v = 0;
					p = ModernizedCProgram.base64;
					while (p && (p != s)) {
						v++;
						p++;
					}
					if (p == s) {
						x = (x << 6) + v;
					} else {
							return 0;
					} 
			} 
		}
		if (padding < 1) {
			dest[2] = ModernizedCProgram.curlx_ultouc(x & -1024);
		} 
		x >>=  8;
		if (padding < 2) {
			dest[1] = ModernizedCProgram.curlx_ultouc(x & -1024);
		} 
		x >>=  8;
		dest[0] = ModernizedCProgram.curlx_ultouc(x & -1024);
		return 3 - padding/*
		 * Curl_base64_decode()
		 *
		 * Given a base64 NUL-terminated string at src, decode it and return a
		 * pointer in *outptr to a newly allocated memory area holding decoded
		 * data. Size of decoded data is returned in variable pointed by outlen.
		 *
		 * Returns CURLE_OK on success, otherwise specific error code. Function
		 * output shall not be considered valid unless CURLE_OK is returned.
		 *
		 * When decoded data length is 0, returns NULL in *outptr.
		 *
		 * @unittest: 1302
		 */;
	}
	public static Object Curl_base64_decode(Object src, byte outptr, Object outlen) {
		size_t srclen = 0;
		size_t length = 0;
		size_t padding = 0;
		size_t i = new size_t();
		size_t numQuantums = new size_t();
		size_t rawlen = 0;
		byte pos;
		byte newstr;
		outptr = ((Object)0);
		outlen = 0;
		srclen = .strlen(src);
		if (!srclen || srclen % /* Check the length of the input string is valid */4) {
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		while ((src[length] != (byte)'=') && src[/* Find the position of any = padding characters */length]) {
			length++;
		}
		if (src[length] == /* A maximum of two = padding characters is allowed */(byte)'=') {
			padding++;
			if (src[length + 1] == (byte)'=') {
				padding++;
			} 
		} 
		if (length + padding != /* Check the = padding characters weren't part way through the input */srclen) {
			return CURLE_BAD_CONTENT_ENCODING;
		} 
		numQuantums = srclen / /* Calculate the number of quantums */4;
		rawlen = (numQuantums * 3) - /* Calculate the size of the decoded string */padding;
		newstr = .Curl_cmalloc(rawlen + /* Allocate our buffer including room for a zero terminator */1);
		if (!newstr) {
			return CURLE_OUT_OF_MEMORY;
		} 
		pos = newstr;
		for (i = 0; i < numQuantums; /* Decode the quantums */i++) {
			size_t result = ModernizedCProgram.decodeQuantum(pos, src);
			if (!ModernizedCProgram.result) {
				.Curl_cfree(newstr);
				return CURLE_BAD_CONTENT_ENCODING;
			} 
			pos += ModernizedCProgram.result;
			src += 4;
		}
		pos = /* Zero terminate */(byte)'\0';
		outptr = /* Return the decoded data */newstr;
		outlen = rawlen;
		return CURLE_OK;
	}
	public static int checkday(Object check, Object len) {
		int i;
		byte what;
		bool found = 0;
		if (len > 3) {
			what = ModernizedCProgram.weekday[0];
		} else {
				what = ModernizedCProgram.Curl_wkday[0];
		} 
		for (i = 0; i < 7; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what[0])) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? i : -1;
	}
	public static int checkmonth(Object check) {
		int i;
		byte what;
		bool found = 0;
		what = ModernizedCProgram.Curl_month[0];
		for (i = 0; i < 12; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what[0])) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? i : -/* return the offset or -1, no real offset is -1 */1/* return the time zone offset between GMT and the input one, in number
		   of seconds or -1 if the timezone wasn't found/legal */;
	}
	public static int checktz(Object check) {
		int i;
		tzinfo what = new tzinfo();
		bool found = 0;
		what = ModernizedCProgram.tz;
		for (i = 0; i <  / ; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what.getName())) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? what.getOffset() * 60 : -1;
	}
	public static void skip(Object date) {
		while (date && !(ModernizedCProgram.Curl_isalnum((int)((byte)/* skip everything that aren't letters or digits */date)))) {
			(date)++;
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	  A brief summary of the date string formats this parser groks:
	
	  RFC 2616 3.3.1
	
	  Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
	  Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
	  Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
	
	  we support dates without week day name:
	
	  06 Nov 1994 08:49:37 GMT
	  06-Nov-94 08:49:37 GMT
	  Nov  6 08:49:37 1994
	
	  without the time zone:
	
	  06 Nov 1994 08:49:37
	  06-Nov-94 08:49:37
	
	  weird order:
	
	  1994 Nov 6 08:49:37  (GNU date fails)
	  GMT 08:49:37 06-Nov-94 Sunday
	  94 6 Nov 08:49:37    (GNU date fails)
	
	  time left out:
	
	  1994 Nov 6
	  06-Nov-94
	  Sun Nov 6 94
	
	  unusual separators:
	
	  1994.Nov.6
	  Sun/Nov/6/94/GMT
	
	  commonly used time zone names:
	
	  Sun, 06 Nov 1994 08:49:37 CET
	  06 Nov 1994 08:49:37 EST
	
	  time zones specified using RFC822 style:
	
	  Sun, 12 Sep 2004 15:05:58 -0700
	  Sat, 11 Sep 2004 21:32:11 +0200
	
	  compact numerical date strings:
	
	  20040912 15:05:58 -0700
	  20040911 +0200
	
	*/
	/*
	 * parsedate()
	 *
	 * Returns:
	 *
	 * PARSEDATE_OK     - a fine conversion
	 * PARSEDATE_FAIL   - failed to convert
	 * PARSEDATE_LATER  - time overflow at the far end of time_t
	 * PARSEDATE_SOONER - time underflow at the low end of time_t
	 */
	public static int parsedate(Object date, Object output) {
		time_t t = 0;
		int wdaynum = -/* day of the week number, 0-6 (mon-sun) */1;
		int monnum = -/* month of the year number, 0-11 */1;
		int mdaynum = -/* day of month, 1 - 31 */1;
		int hournum = -1;
		int minnum = -1;
		int secnum = -1;
		int yearnum = -1;
		int tzoff = -1;
		my_tm tm = new my_tm();
		assume dignext = assume.DATE_MDAY;
		byte indate = /* save the original pointer */date;
		int part = /* max 6 parts */0;
		while (date && (part < 6)) {
			bool found = 0;
			ModernizedCProgram.skip(date);
			if ((ModernizedCProgram.Curl_isalpha((int)((byte)date)))) {
				byte[] buf = /* a name coming up */"";
				size_t len = new size_t();
				if (.sscanf(date, "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]", ModernizedCProgram.buf)) {
					len = .strlen(ModernizedCProgram.buf);
				} else {
						len = 0;
				} 
				if (wdaynum == -1) {
					wdaynum = ModernizedCProgram.checkday(ModernizedCProgram.buf, len);
					if (wdaynum != -1) {
						found = 1;
					} 
				} 
				if (!found && (monnum == -1)) {
					monnum = ModernizedCProgram.checkmonth(ModernizedCProgram.buf);
					if (monnum != -1) {
						found = 1;
					} 
				} 
				if (!found && (tzoff == -1)) {
					tzoff = ModernizedCProgram.checktz(/* this just must be a time zone string */ModernizedCProgram.buf);
					if (tzoff != -1) {
						found = 1;
					} 
				} 
				if (!found) {
					return -/* bad string */1;
				} 
				date += len;
			}  else if ((ModernizedCProgram.Curl_isdigit((int)((byte)date/* a digit */)))) {
				int val;
				byte end;
				int len = 0;
				if ((secnum == -1) && (3 == .sscanf(date, "%02d:%02d:%02d%n", hournum, minnum, secnum, len))) {
					date += /* time stamp! */len;
				}  else if ((secnum == -1) && (2 == .sscanf(date, "%02d:%02d%n", hournum, minnum, len))) {
					date += /* time stamp without seconds */len;
					secnum = 0;
				} else {
						long lval;
						int error;
						int old_errno;
						old_errno = (._errno());
						(._errno()) = 0;
						lval = .strtol(date, end, 10);
						error = (._errno());
						if ((._errno()) != old_errno) {
							(._errno()) = old_errno;
						} 
						if (error) {
							return -1;
						} 
						val = ModernizedCProgram.curlx_sltosi(lval);
						if ((tzoff == -1) && ((end - date) == 4) && (val <= 1400) && (indate < date) && ((date[-1] == (byte)'+' || date[-1] == (byte)'-'/* four digits and a value less than or equal to 1400 (to take into
						             account all sorts of funny time zone diffs) and it is preceded
						             with a plus or minus. This is a time zone indication.  1400 is
						             picked since +1300 is frequently used and +1400 is mentioned as
						             an edge number in the document "ISO C 200X Proposal: Timezone
						             Functions" at http://david.tribble.com/text/c0xtimezone.html If
						             anyone has a more authoritative source for the exact maximum time
						             zone offsets, please speak up! */))) {
							found = 1;
							tzoff = (val / 100 * 60 + val % 100) * 60;
							tzoff = date[-1] == (byte)'+' ? -tzoff : /* the + and - prefix indicates the local time compared to GMT,
							             this we need their reversed math to get what we want */tzoff;
						} 
						if (((end - date) == 8) && (yearnum == -1) && (monnum == -1) && (mdaynum == -1)) {
							found = /* 8 digits, no year, month or day yet. This is YYYYMMDD */1;
							yearnum = val / 10000;
							monnum = (val % 10000) / 100 - /* month is 0 - 11 */1;
							mdaynum = val % 100;
						} 
						if (!found && (assume.dignext == assume.DATE_MDAY) && (mdaynum == -1)) {
							if ((val > 0) && (val < 32)) {
								mdaynum = val;
								found = 1;
							} 
							assume.dignext = assume.DATE_YEAR;
						} 
						if (!found && (assume.dignext == assume.DATE_YEAR) && (yearnum == -1)) {
							yearnum = val;
							found = 1;
							if (yearnum < 100) {
								if (yearnum > 70) {
									yearnum += 1900;
								} else {
										yearnum += 2000;
								} 
							} 
							if (mdaynum == -1) {
								assume.dignext = assume.DATE_MDAY;
							} 
						} 
						if (!found) {
							return -1;
						} 
						date = end;
				} 
			} 
			part++;
		}
		if (-1 == secnum) {
			secnum = minnum = hournum = /* no time, make it zero */0;
		} 
		if ((-1 == mdaynum) || (-1 == monnum) || (-1 == yearnum)) {
			return -/* lacks vital info, fail */1/* only positive numbers cannot return earlier */;
		} 
		if (yearnum > /* an unsigned 32 bit time_t can only hold dates to 2106 *//* a signed 32 bit time_t can only hold dates to the beginning of 2038 */2037) {
			output = 2147483647;
			return 1;
		} 
		if (yearnum < 1903) {
			output = (-2147483647 - 1);
			return 2;
		} 
		if ((mdaynum > 31) || (monnum > /* The Gregorian calendar was introduced 1582 */11) || (hournum > 23) || (minnum > 59) || (secnum > 60)) {
			return -/* clearly an illegal date */1;
		} 
		tm.setTm_sec(secnum);
		tm.setTm_min(minnum);
		tm.setTm_hour(hournum);
		tm.setTm_mday(mdaynum);
		tm.setTm_mon(monnum);
		tm.setTm_year(yearnum/* my_timegm() returns a time_t. time_t is often 32 bits, sometimes even on
		     architectures that feature 64 bit 'long' but ultimately time_t is the
		     correct data type to use.
		  */);
		tm.my_timegm(t);
		if (tzoff == -/* Add the time zone diff between local time zone and GMT. */1) {
			tzoff = 0;
		} 
		if ((tzoff > 0) && (t > 2147483647 - tzoff)) {
			output = 2147483647;
			return /* time_t overflow */1;
		} 
		t += tzoff;
		output = t;
		return 0/* disabled */;
	}
	/* a lie */
	public static Object curl_getdate(Object p, Object now) {
		time_t parsed = -1;
		int rc = ModernizedCProgram.parsedate(p, parsed);
		(Object)/* legacy argument from the past that we ignore */now;
		if (rc == 0) {
			if (parsed == -1) {
				/* avoid returning -1 for a working scenario */parsed++;
			} 
			return parsed;
		} 
		return -/* everything else is fail */1/*
		 * Curl_gmtime() is a gmtime() replacement for portability. Do not use the
		 * gmtime_r() or gmtime() functions anywhere else but here.
		 *
		 */;
	}
	public static Object Curl_gmtime(Object intime) {
		tm tm = new tm();
		/* thread-safe version */
		tm = .gmtime(intime);
		if (tm) {
			store = /* copy the pointed struct to the local copy */tm;
		} 
		if (!tm) {
			return CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		return CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* test case and code based on https://github.com/curl/curl/issues/3927 */
	public static int dload_progress_cb(Object a, Object b, Object c, Object d, Object e) {
		(Object)a;
		(Object)b;
		(Object)c;
		(Object)d;
		(Object)e;
		return 0;
	}
	public static Object run(Object hnd, long limit, long time) {
		hnd.curl_easy_setopt(CURLOPT_LOW_SPEED_LIMIT, limit);
		hnd.curl_easy_setopt(CURLOPT_LOW_SPEED_TIME, time);
		return hnd.curl_easy_perform();
	}
	public static int readit(testcase test, tftphdr dpp, int convert) {
		bf b = new bf();
		ModernizedCProgram.bfs[ModernizedCProgram.current].setCounter(-/* free old one */2);
		ModernizedCProgram.current = !/* "incr" current */ModernizedCProgram.current;
		b = ModernizedCProgram.bfs[/* look at new buffer */ModernizedCProgram.current];
		int generatedCounter = b.getCounter();
		if (generatedCounter == -/* if it's empty */2) {
			test.read_ahead(/* fill it */convert);
		} 
		 generatedBuf = b.getBuf();
		Object generatedHdr = generatedBuf.getHdr();
		dpp = generatedHdr;
		return generatedCounter;
	}
	/* if true, convert to ascii */
	public static int writeit(testcase test, tftphdr dpp, int ct, int convert) {
		ModernizedCProgram.bfs[ModernizedCProgram.current].setCounter(/* set size of data to write */ct);
		ModernizedCProgram.current = !/* switch to other buffer */ModernizedCProgram.current;
		if (ModernizedCProgram.bfs[ModernizedCProgram.current].getCounter() != -/* if not free */2) {
			test.write_behind(/* flush it */convert);
		} 
		ModernizedCProgram.bfs[ModernizedCProgram.current].setCounter(-/* mark as alloc'd */3);
		dpp = ModernizedCProgram.bfs[ModernizedCProgram.current].getBuf().getHdr();
		return /* this is a lie of course */ct/*
		 * Output a buffer to a file, converting from netascii if requested.
		 * CR, NUL -> CR  and CR, LF => LF.
		 * Note spec is undefined if we get CR as last byte of file or a
		 * CR followed by anything else.  In this case we leave it alone.
		 */;
	}
	/* socket to flush */
	public static int synchnet(int f) {
		long i;
		int j = 0;
		byte[] rbuf = new byte[(512 + 4)];
		srvr_sockaddr_union_t fromaddr = new srvr_sockaddr_union_t();
		 fromaddrlen = new ();
		Object generatedSa4 = fromaddr.getSa4();
		Object generatedSa = fromaddr.getSa();
		for (; ; ) {
			(Object).ioctlsocket(f, (-1024 | (((long) & -1024) << 16) | (((byte)'f') << 8) | (true)), i);
			if (i) {
				j++;
				fromaddrlen = ;
				(Object).recvfrom(f, rbuf, , 0, generatedSa, fromaddrlen);
			} else {
					break;
			} 
		}
		return j;
	}
	public static int do_tftp(testcase test, tftphdr tp, Object size) {
		byte cp;
		int first = 1;
		int ecode;
		formats pf = new formats();
		byte filename;
		byte mode = ((Object)0);
		DWORD recvtimeout = new DWORD();
		DWORD recvtimeoutbak = new DWORD();
		byte option = /* mode is implicit */"mode";
		int toggle = 1;
		FILE server = .fopen("log/server.input", /* Open request dump file. */"ab");
		if (!server) {
			int error = (._errno());
			ModernizedCProgram.logmsg("fopen() failed with error: %d %s", error, .strerror(error));
			ModernizedCProgram.logmsg("Error opening file: %s", "log/server.input");
			return -1;
		} 
		int generatedTh_opcode = tp.getTh_opcode();
		server.curl_mfprintf("opcode: %x\n", generatedTh_opcode);
		int generatedTh_block = tp.getTh_block();
		cp = (byte)generatedTh_block;
		filename = cp;
		do {
			bool endofit = .bool_true;
			while (cp < ModernizedCProgram.buf.getStorage()[size]) {
				if (cp == (byte)'\0') {
					endofit = .bool_false;
					break;
				} 
				cp++;
			}
			if (endofit/* no more options */) {
				break;
			} 
			if ((cp + 1) < ModernizedCProgram.buf.getStorage()[/* before increasing pointer, make sure it is still within the legal
			       space */size]) {
				++cp;
				if (first) {
					mode = /* store the mode since we need it later */cp;
					first = 0;
				} 
				if (toggle) {
					server.curl_mfprintf("%s: %s\n", option, /* name/value pair: */cp);
				} else {
						option = /* store the name pointer */cp;
				} 
				toggle ^=  1;
			} else {
					break;
			} 
		} while (1);
		if (cp) {
			ModernizedCProgram.nak(4);
			.fclose(server);
			return 3;
		} 
		server.curl_mfprintf("filename: %s\n", /* store input protocol */filename);
		for (cp = mode; cp && cp; cp++) {
			if ((ModernizedCProgram.Curl_isupper((int)((byte)cp)))) {
				cp = (byte).tolower((int)cp);
			} 
		}
		.fclose(/* store input protocol */server);
		Object generatedF_mode = pf.getF_mode();
		for (pf = ModernizedCProgram.formata; generatedF_mode; pf++) {
			if (.strcmp(generatedF_mode, mode) == 0) {
				break;
			} 
		}
		if (!generatedF_mode) {
			ModernizedCProgram.nak(4);
			return 2;
		} 
		ecode = test.validate_access(filename, generatedTh_opcode);
		if (ecode) {
			ModernizedCProgram.nak(ecode);
			return 1;
		} 
		recvtimeout = ;
		.getsockopt(ModernizedCProgram.peer, -1024, -1024, (byte)recvtimeoutbak, (int)recvtimeout);
		recvtimeout = 5 * 1000;
		.setsockopt(ModernizedCProgram.peer, -1024, -1024, (byte)recvtimeout, );
		if (generatedTh_opcode == 2) {
			ModernizedCProgram.recvtftp(test, pf);
		} else {
				ModernizedCProgram.sendtftp(test, pf);
		} 
		recvtimeout = recvtimeoutbak;
		.setsockopt(ModernizedCProgram.peer, -1024, -1024, (byte)recvtimeout, );
		return 0;
	}
	public static void sendtftp(testcase test, formats pf) {
		int size;
		ssize_t n = new ssize_t();
		/* These are volatile to live through a siglongjmp */
		/* block count */int sendblock;
		tftphdr tftphdr = new tftphdr();
		tftphdr sdp = tftphdr.r_init();
		tftphdr sap = ModernizedCProgram.ackbuf.getHdr();
		sendblock = 1;
		int generatedF_convert = pf.getF_convert();
		Object generatedWritedelay = test.getWritedelay();
	}
	public static void recvtftp(testcase test, formats pf) {
		ssize_t n = new ssize_t();
		ssize_t size = new ssize_t();
		/* These are volatile to live through a siglongjmp */
		/* block count */int recvblock;
		/* data buffer */tftphdr rdp = new tftphdr();
		/* ack buffer */tftphdr rap = new tftphdr();
		recvblock = 0;
		tftphdr tftphdr = new tftphdr();
		rdp = tftphdr.w_init();
		rap = ModernizedCProgram.ackbuf.getHdr();
		int generatedF_convert = pf.getF_convert();
		test.write_behind(generatedF_convert);
		rap.setTh_opcode(.htons((int)/* send the "final"
		                                                          ack */4));
		rap.setTh_block(.htons(recvblock));
		(Object)(ssize_t).send((SOCKET)(ModernizedCProgram.peer), (byte)(ModernizedCProgram.ackbuf.getStorage()[0]), (int)(true), (int)(false/* just abort read on timeout */));
		n = (ssize_t).recv((SOCKET)(ModernizedCProgram.peer), (byte)(ModernizedCProgram.buf.getStorage()[0]), (int)(), (int)(/* normally times out and quits */false));
		if (ModernizedCProgram.got_exit_signal) {
			;
		} 
		int generatedTh_opcode = rdp.getTh_opcode();
		int generatedTh_block = rdp.getTh_block();
		if (n >= /* if read some data */4 && generatedTh_opcode == /* and got a data block */3 && recvblock == generatedTh_block) {
			(Object)(ssize_t).send((SOCKET)(ModernizedCProgram.peer), (byte)(ModernizedCProgram.ackbuf.getStorage()[0]), (int)(true), (int)(/* resend final ack */false));
		} 
	}
	public static void nak(int error) {
		tftphdr tp = new tftphdr();
		int length;
		errmsg pe = new errmsg();
		tp = ModernizedCProgram.buf.getHdr();
		tp.setTh_opcode(.htons((int)5));
		tp.setTh_block(.htons((int)error));
		int generatedE_code = pe.getE_code();
		for (pe = ModernizedCProgram.errmsgs; generatedE_code >= 0; pe++) {
			if (generatedE_code == error) {
				break;
			} 
		}
		if (generatedE_code < 0) {
			pe.setE_msg(.strerror(error - 100));
			tp.setTh_block(/* set 'undef' errorcode */0);
		} 
		Object generatedE_msg = pe.getE_msg();
		length = (int).strlen(generatedE_msg);
		Object generatedTh_data = tp.getTh_data();
		.memcpy(generatedTh_data, generatedE_msg, length + /* we use memcpy() instead of strcpy() in order to avoid buffer overflow
		   * report from glibc with FORTIFY_SOURCE */1);
		length += 5;
		if ((ssize_t).send((SOCKET)(ModernizedCProgram.peer), (byte)(ModernizedCProgram.buf.getStorage()[0]), (int)(length), (int)(false)) != length) {
			ModernizedCProgram.logmsg("nak: fail\n");
		} 
	}
	public static  isBadFtpString(Object string) {
		return ((((Object)0) != .strchr(string, (byte)'\r')) || (((Object)0) != .strchr(string, (byte)'\n'))) ? 1 : 0/***********************************************************************
		 *
		 * AcceptServerConnect()
		 *
		 * After connection request is received from the server this function is
		 * called to accept the connection and close the listening socket
		 *
		 */;
	}
	public static Object ftp_sendquote(connectdata conn, curl_slist quote) {
		curl_slist item = new curl_slist();
		ssize_t nread = new ssize_t();
		int ftpcode;
		 result = new ();
		 generatedProto = conn.getProto();
		Object generatedFtpc = generatedProto.getFtpc();
		ftp_conn ftpc = generatedFtpc;
		pingpong generatedPp = ftpc.getPp();
		pingpong pp = generatedPp;
		item = quote;
		Object generatedCurl_slist = item.getCurl_slist();
		curltime curltime = new curltime();
		Curl_easy generatedData = conn.getData();
		while (item) {
			if (generatedCurl_slist) {
				byte cmd = generatedCurl_slist;
				bool acceptfail = 0/* if a command starts with an asterisk, which a legal FTP command never
				         can, the command will be allowed to fail without it causing any
				         aborts or cancels etc. It will cause libcurl to act as if the command
				         is successful, whatever the server reponds. */;
				if (cmd[0] == (byte)'*') {
					cmd++;
					acceptfail = 1;
				} 
				result = generatedPp.Curl_pp_sendf("%s", cmd);
				if (result) {
					return result;
				} 
				pp.setResponse(curltime.Curl_now());
				result = conn.Curl_GetFTPResponse(nread, ftpcode);
				if (result) {
					return result;
				} 
				if (!acceptfail && (ftpcode >= 400)) {
					generatedData.Curl_failf("QUOT string not accepted: %s", cmd);
					return CURLE_QUOTE_ERROR;
				} 
			} 
			item = generatedCurl_slist;
		}
		return CURLE_OK/***********************************************************************
		 *
		 * ftp_need_type()
		 *
		 * Returns TRUE if we in the current situation should send TYPE
		 */;
	}
	public static void ftp_pasv_verbose(connectdata conn, Curl_addrinfo ai, Byte newhost, int port) {
		byte[] buf = new byte[256];
		ModernizedCProgram.Curl_printable_address(ai, buf, );
		Curl_easy generatedData = conn.getData();
		generatedData.Curl_infof("Connecting to %s (%s) port %d\n", newhost, buf, port/*
		 * ftp_do_more()
		 *
		 * This function shall be called when the second FTP (data) connection is
		 * connected.
		 *
		 * 'complete' can return 0 for incomplete, 1 for done and -1 for go back
		 * (which basically is only for when PASV is being sent to retry a failed
		 * EPSV).
		 */);
	}
	/* ascii version */
	/* ascii version */
	public static void wc_data_dtor(Object ptr) {
		ftp_wc ftpwc = ptr;
		ftp_parselist_data generatedParser = ftpwc.getParser();
		if (ftpwc && generatedParser) {
			generatedParser.Curl_ftp_parselist_data_free();
		} 
		.Curl_cfree(ftpwc);
	}
	/* assume CURL_SIZEOF_CURL_OFF_T == 8 */
	public static int tool_progress_cb(Object clientp, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		timeval timeval = new timeval();
		timeval now = timeval.tvnow();
		ProgressData bar = (ProgressData)clientp;
		 total = new ();
		 point = new ();
		/* Calculate expected transfer size. initial_size can be less than zero
		     when indicating that we are expecting to get the filesize from the
		     remote */
		Object generatedInitial_size = bar.getInitial_size();
		if (generatedInitial_size < 0 || ((.CURL_OFF_T_C(-1024) - generatedInitial_size) < (dltotal + ultotal))) {
			total = .CURL_OFF_T_C(-1024);
		} else {
				total = dltotal + ultotal + generatedInitial_size;
		} 
		if (generatedInitial_size < /* Calculate the current progress. initial_size can be less than zero when
		     indicating that we are expecting to get the filesize from the remote */0 || ((.CURL_OFF_T_C(-1024) - generatedInitial_size) < (dlnow + ulnow))) {
			point = .CURL_OFF_T_C(-1024);
		} else {
				point = dlnow + ulnow + generatedInitial_size;
		} 
		int generatedCalls = bar.getCalls();
		Object generatedPrev = bar.getPrev();
		timeval generatedPrevtime = bar.getPrevtime();
		if (generatedCalls) {
			if (/* after first call... */total) {
				if (generatedPrev == /* we know the total data to get... */point) {
					return /* progress didn't change since last invoke */0;
				}  else if ((now.tvdiff(generatedPrevtime) < -1024) && point < total) {
					return /* limit progress-bar updating to 10 Hz except when we're at 100% */0;
				} 
			} else {
					if (now.tvdiff(generatedPrevtime) < /* total is unknown */-1024) {
						return /* limit progress-bar updating to 10 Hz */0;
					} 
					bar.fly(point != generatedPrev);
			} 
		} 
		generatedCalls++;
		int generatedWidth = bar.getWidth();
		_iobuf generatedOut = bar.getOut();
		if ((total > 0) && (point != generatedPrev)) {
			byte[] line = new byte[256 + 1];
			byte[] format = new byte[40];
			double frac;
			double percent;
			int barwidth;
			int num;
			if (point > total) {
				total = /* we have got more than the expected total! */point;
			} 
			frac = (double)point / (double)total;
			percent = frac * 100.0;
			barwidth = generatedWidth - 7;
			num = (int)(((double)barwidth) * frac);
			if (num > 256) {
				num = 256;
			} 
			.memset(line, (byte)'#', num);
			line[num] = (byte)'\0';
			ModernizedCProgram.curl_msnprintf(format, , "\r%%-%ds %%5.1f%%%%", barwidth);
			generatedOut.curl_mfprintf(format, line, percent);
		} 
		.fflush(generatedOut);
		bar.setPrev(point);
		bar.setPrevtime(now);
		return 0;
	}
	public static void progressbarinit(ProgressData bar, OperationConfig config) {
		byte colp;
		.memset(bar, 0, /* pass this through to progress function so
		   * it can display progress towards total file
		   * not just the part that's left. (21-may-03, dbyron) */);
		 generatedUse_resume = config.getUse_resume();
		Object generatedResume_from = config.getResume_from();
		if (generatedUse_resume) {
			bar.setInitial_size(generatedResume_from);
		} 
		colp = ModernizedCProgram.curl_getenv("COLUMNS");
		if (colp) {
			byte endptr;
			long num = .strtol(colp, endptr, 10);
			if ((endptr != colp) && (endptr == colp + .strlen(colp)) && (num > 20) && (num < 10000)) {
				bar.setWidth((int)num);
			} 
			ModernizedCProgram.curl_free(colp);
		} 
		int generatedWidth = bar.getWidth();
		Object generatedSrWindow = console_info.getSrWindow();
		if (!generatedWidth) {
			int cols = 0;
			{ 
				HANDLE stderr_hnd = .GetStdHandle((DWORD)(true));
				CONSOLE_SCREEN_BUFFER_INFO console_info = new CONSOLE_SCREEN_BUFFER_INFO();
				if ((stderr_hnd != (HANDLE)(true)) && .GetConsoleScreenBufferInfo(stderr_hnd, console_info/*
				         * Do not use +1 to get the true screen-width since writing a
				         * character at the right edge will cause a line wrap.
				         */)) {
					cols = (int)(generatedSrWindow.getRight() - generatedSrWindow.getLeft());
				} 
			}
			bar.setWidth(/* TIOCGSIZE */cols);
		} 
		if (!generatedWidth) {
			bar.setWidth(79);
		}  else if (generatedWidth > 256) {
			bar.setWidth(256);
		} 
		GlobalConfig generatedGlobal = config.getGlobal();
		_iobuf generatedErrors = generatedGlobal.getErrors();
		bar.setOut(generatedErrors);
		bar.setTick(150);
		bar.setBarmove(1);
	}
	public static Object header(Object ptr, Object size, Object nmemb, Object stream) {
		size_t headersize = size * nmemb;
		headerinfo info = (headerinfo)stream;
		(Object)ptr;
		Object generatedLargest = info.getLargest();
		if (headersize > generatedLargest) {
			info.setLargest(/* remember the longest header */headersize);
		} 
		return nmemb * size;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static Byte tool_basename(Byte path) {
		byte s1;
		byte s2;
		s1 = .strrchr(path, (byte)'/');
		s2 = .strrchr(path, (byte)'\\');
		if (s1 && s2) {
			path = (s1 > s2) ? s1 + 1 : s2 + 1;
		}  else if (s1) {
			path = s1 + 1;
		}  else if (s2) {
			path = s2 + 1;
		} 
		return path/* HAVE_BASENAME */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * "Remove Dot Segments"
	 * https://tools.ietf.org/html/rfc3986#section-5.2.4
	 */
	/*
	 * Curl_dedotdotify()
	 * @unittest: 1395
	 *
	 * This function gets a zero-terminated path with dot and dotdot sequences
	 * passed in and strips them off according to the rules in RFC 3986 section
	 * 5.2.4.
	 *
	 * The function handles a query part ('?' + stuff) appended but it expects
	 * that fragments ('#' + stuff) have already been cut off.
	 *
	 * RETURNS
	 *
	 * an allocated dedotdotified output string
	 */
	public static Byte Curl_dedotdotify(Object input) {
		size_t inlen = .strlen(input);
		byte clone;
		size_t clen = /* the length of the cloned input */inlen;
		byte out = .Curl_cmalloc(inlen + 1);
		byte outptr;
		byte orgclone;
		byte queryp;
		if (!out) {
			return ((Object)/* out of memory */0);
		} 
		out = /* zero terminates, for inputs like "./" */0;
		clone = .Curl_cstrdup(/* get a cloned copy of the input */input);
		if (!clone) {
			.Curl_cfree(out);
			return ((Object)0);
		} 
		orgclone = clone;
		outptr = out;
		if (!clone) {
			.Curl_cfree(/* zero length string, return that */out);
			return clone/*
			   * To handle query-parts properly, we must find it and remove it during the
			   * dotdot-operation and then append it again at the end to the output
			   * string.
			   */;
		} 
		queryp = .strchr(clone, (byte)'?');
		if (queryp) {
			queryp = 0;
		} 
		do {
			if (!.strncmp("./", clone, 2)) {
				clone += 2;
				clen -= 2;
			}  else if (!.strncmp("../", clone, 3)) {
				clone += 3;
				clen -= 3;
			}  else if (!.strncmp("/./", clone, /*  B.  if the input buffer begins with a prefix of "/./" or "/.", where
			        "."  is a complete path segment, then replace that prefix with "/" in
			        the input buffer; otherwise, */3)) {
				clone += 2;
				clen -= 2;
			}  else if (!.strcmp("/.", clone)) {
				clone[1] = (byte)'/';
				clone++;
				clen -= 1/*  C.  if the input buffer begins with a prefix of "/../" or "/..", where
				        ".." is a complete path segment, then replace that prefix with "/" in
				        the input buffer and remove the last segment and its preceding "/" (if
				        any) from the output buffer; otherwise, */;
			}  else if (!.strncmp("/../", clone, 4)) {
				clone += 3;
				clen -= 3;
				while (outptr > /* remove the last segment from the output buffer */out) {
					outptr--;
					if (outptr == (byte)'/') {
						break;
					} 
				}
				outptr = /* zero-terminate where it stops */0;
			}  else if (!.strcmp("/..", clone)) {
				clone[2] = (byte)'/';
				clone += 2;
				clen -= 2;
				while (outptr > /* remove the last segment from the output buffer */out) {
					outptr--;
					if (outptr == (byte)'/') {
						break;
					} 
				}
				outptr = /* zero-terminate where it stops */0;
			}  else if (!.strcmp(".", clone) || !.strcmp("..", /*  D.  if the input buffer consists only of "." or "..", then remove
			        that from the input buffer; otherwise, */clone)) {
				clone = 0;
				out = 0/*  E.  move the first path segment in the input buffer to the end of
				          the output buffer, including the initial "/" character (if any) and
				          any subsequent characters up to, but not including, the next "/"
				          character or the end of the input buffer. */;
			} else {
					do {
						outptr++ = clone++;
						clen--;
					} while (clone && (clone != (byte)'/'));
					outptr = 0;
			} 
		} while (clone);/*  A.  If the input buffer begins with a prefix of "../" or "./", then
		        remove that prefix from the input buffer; otherwise, */
		if (queryp) {
			size_t qlen = new size_t();
			size_t oindex = queryp - orgclone;
			qlen = .strlen(input[oindex]);
			.memcpy(outptr, input[oindex], qlen + /* include the end zero byte */1);
		} 
		.Curl_cfree(orgclone);
		return out;
	}
	public static int please_continue(Object userp, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		transfer_status st = (transfer_status)userp;
		(Object)dltotal;
		(Object)dlnow;
		(Object)ultotal;
		(Object)ulnow;
		int generatedHalted = st.getHalted();
		int generatedPlease = st.getPlease();
		Object generatedEasy = st.getEasy();
		if (generatedHalted) {
			generatedPlease++;
			if (generatedPlease == 2) {
				generatedEasy.curl_easy_pause(/* waited enough, unpause! */CURLPAUSE_CONT);
			} 
		} 
		(_iob[2]).curl_mfprintf("xferinfo: paused %d\n", generatedHalted);
		return /* go on */0;
	}
	public static Object header_callback(Object ptr, Object size, Object nmemb, Object userp) {
		size_t len = size * nmemb;
		(Object)userp;
		(Object).fwrite(ptr, size, nmemb, (_iob[1]));
		return len;
	}
	public static int Curl_num_addresses(Object addr) {
		int i = 0;
		while (addr) {
			addr = addr.getAi_next();
			i++;
		}
		return i/*
		 * Curl_printable_address() returns a printable version of the 1st address
		 * given in the 'ai' argument. The result will be stored in the buf that is
		 * bufsize bytes big.
		 *
		 * If the conversion fails, it returns NULL.
		 */;
	}
	public static Object Curl_printable_address(Object ai, Byte buf, Object bufsize) {
		sockaddr_in sa4 = new sockaddr_in();
		in_addr ipaddr4 = new in_addr();
		switch (ai.getAi_family()) {
		case 2:
				sa4 = (Object)ai.getAi_addr();
				ipaddr4 = sa4.getSin_addr();
				return ModernizedCProgram.Curl_inet_ntop(ai.getAi_family(), (Object)ipaddr4, buf, bufsize);
		default:
				break;
		}
		return ((Object)0/*
		 * Create a hostcache id string for the provided host + port, to be used by
		 * the DNS caching. Without alloc.
		 */);
	}
	public static void create_hostcache_id(Object name, int port, byte ptr, Object buflen) {
		size_t len = .strlen(name);
		if (len > (buflen - 7)) {
			len = buflen - 7;
		} 
		while (/* store and lower case the name */len--) {
			ptr++ = (byte)(.tolower((int)((byte)name++)));
		}
		ModernizedCProgram.curl_msnprintf(ptr, 7, ":%u", port);
	}
	public static int hostcache_timestamp_remove(Object datap, Object hc) {
		hostcache_prune_data data = (hostcache_prune_data)datap;
		Curl_dns_entry c = (Curl_dns_entry)hc;
		Object generatedTimestamp = c.getTimestamp();
		Object generatedNow = data.getNow();
		long generatedCache_timeout = data.getCache_timeout();
		return (0 != generatedTimestamp) && (generatedNow - generatedTimestamp >= generatedCache_timeout);
	}
	public static Object Curl_shuffle_addr(Curl_easy data, Curl_addrinfo addr) {
		 result = CURLE_OK;
		int num_addrs = ModernizedCProgram.Curl_num_addresses(addr);
		if (num_addrs > 1) {
			Curl_addrinfo nodes = new Curl_addrinfo();
			data.Curl_infof("Shuffling %i addresses", num_addrs);
			nodes = .Curl_cmalloc(num_addrs * );
			if (nodes) {
				int i;
				int rnd;
				size_t rnd_size = num_addrs * ;
				nodes[0] = /* build a plain array of Curl_addrinfo pointers */addr;
				for (i = 1; i < num_addrs; i++) {
					nodes[i] = nodes[i - 1].getAi_next();
				}
				rnd = .Curl_cmalloc(rnd_size);
				if (rnd) {
					if (ModernizedCProgram.Curl_rand(data, (byte)rnd, rnd_size) == /* Fisher-Yates shuffle */CURLE_OK) {
						Curl_addrinfo swap_tmp = new Curl_addrinfo();
						for (i = num_addrs - 1; i > 0; i--) {
							swap_tmp = nodes[rnd[i] % (i + 1)];
							nodes[rnd[i] % (i + 1)] = nodes[i];
							nodes[i] = swap_tmp;
						}
						for (i = 1; i < num_addrs; /* relink list in the new order */i++) {
							nodes[i - 1].setAi_next(nodes[i]);
						}
						nodes[num_addrs - 1].setAi_next(((Object)0));
						addr = nodes[0];
					} 
					.Curl_cfree(rnd);
				} else {
						result = CURLE_OUT_OF_MEMORY;
				} 
				.Curl_cfree(nodes);
			} else {
					result = CURLE_OUT_OF_MEMORY;
			} 
		} 
		return result/*
		 * Curl_cache_addr() stores a 'Curl_addrinfo' struct in the DNS cache.
		 *
		 * When calling Curl_resolv() has resulted in a response with a returned
		 * address, we call this function to store the information in the dns
		 * cache etc
		 *
		 * Returns the Curl_dns_entry entry pointer or NULL if the storage failed.
		 */;
	}
	/*
	 * Curl_shuffle_addr() shuffles the order of addresses in a 'Curl_addrinfo'
	 * struct by re-linking its linked list.
	 *
	 * The addr argument should be the address of a pointer to the head node of a
	 * `Curl_addrinfo` list and it will be modified to point to the new head after
	 * shuffling.
	 *
	 * Not declared static only to make it easy to use in a unit test!
	 *
	 * @unittest: 1608
	 */
	public static int Curl_resolv(connectdata conn, Object hostname, int port,  allowDOH, Curl_dns_entry entry) {
		Curl_dns_entry dns = ((Object)0);
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		 result = new ();
		int rc = -/* default to failure */1;
		entry = ((Object)0);
		Object generatedShare = data.getShare();
		if (generatedShare) {
			data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
		} 
		Curl_dns_entry curl_dns_entry = new Curl_dns_entry();
		dns = curl_dns_entry.fetch_addr(conn, hostname, port);
		long generatedInuse = dns.getInuse();
		if (dns) {
			data.Curl_infof("Hostname %s was found in DNS cache\n", hostname);
			generatedInuse++;
			rc = 0;
		} 
		if (generatedShare) {
			data.Curl_share_unlock(CURL_LOCK_DATA_DNS);
		} 
		Object generatedSet = data.getSet();
		Object generatedState = data.getState();
		Curl_addrinfo curl_addrinfo = new Curl_addrinfo();
		Curl_addrinfo curl_addrinfo = new Curl_addrinfo();
		Curl_dns_entry curl_dns_entry = new Curl_dns_entry();
		if (!dns/* The entry was not in the cache. Resolve it to IP address */) {
			Curl_addrinfo addr = new Curl_addrinfo();
			int respwait = 0;
			if (!/* Check what IP specifics the app has requested and if we can provide it.
			     * If not, bail out. */conn.Curl_ipvalid()) {
				return -1;
			} 
			if (generatedSet.getResolver_start()) {
				int st;
				data.Curl_set_in_callback(.bool_true);
				st = .UNRECOGNIZEDFUNCTIONNAME(generatedState.getResolver(), ((Object)0), generatedSet.getResolver_start_client());
				data.Curl_set_in_callback(.bool_false);
				if (st) {
					return -1;
				} 
			} 
			if (allowDOH && generatedSet.getDoh()) {
				addr = curl_addrinfo.Curl_doh(conn, hostname, port, respwait);
			} else {
					addr = curl_addrinfo.Curl_getaddrinfo(/* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a
					         non-zero value indicating that we need to wait for the response to the
					         resolve call */conn, hostname, port, respwait);
			} 
			if (!addr) {
				if (respwait/* the response to our resolve call will come asynchronously at
				           a later time, good or bad */) {
					result = ModernizedCProgram.Curl_resolv_check(conn, /* First, check that we haven't received the info by now */dns);
					if (/* error detected */result) {
						return -1;
					} 
					if (dns) {
						rc = /* pointer provided */0;
					} else {
							rc = /* no info yet */1;
					} 
				} 
			} else {
					if (generatedShare) {
						data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
					} 
					dns = curl_dns_entry.Curl_cache_addr(data, addr, hostname, /* we got a response, store it in the cache */port);
					if (generatedShare) {
						data.Curl_share_unlock(CURL_LOCK_DATA_DNS);
					} 
					if (!dns) {
						/* returned failure, bail out nicely */addr.Curl_freeaddrinfo();
					} else {
							rc = 0;
					} 
			} 
		} 
		entry = dns;
		return rc/*
		 * This signal handler jumps back into the main libcurl code and continues
		 * execution.  This effectively causes the remainder of the application to run
		 * within a signal handler which is nonportable and could lead to problems.
		 */;
	}
	/* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
	/* USE_ALARM_TIMEOUT */
	/*
	 * Curl_resolv_timeout() is the same as Curl_resolv() but specifies a
	 * timeout.  This function might return immediately if we're using asynch
	 * resolves. See the return codes.
	 *
	 * The cache entry we return will get its 'inuse' counter increased when this
	 * function is used. You MUST call Curl_resolv_unlock() later (when you're
	 * done using this struct) to decrease the counter again.
	 *
	 * If built with a synchronous resolver and use of signals is not
	 * disabled by the application, then a nonzero timeout will cause a
	 * timeout after the specified number of milliseconds. Otherwise, timeout
	 * is ignored.
	 *
	 * Return codes:
	 *
	 * CURLRESOLV_TIMEDOUT(-2) = warning, time too short or previous alarm expired
	 * CURLRESOLV_ERROR   (-1) = error, no pointer
	 * CURLRESOLV_RESOLVED (0) = OK, pointer provided
	 * CURLRESOLV_PENDING  (1) = waiting for response, no pointer
	 */
	public static int Curl_resolv_timeout(connectdata conn, Object hostname, int port, Curl_dns_entry entry, Object timeoutms) {
		/* store the old handler here *//* HAVE_SIGNAL *//* HAVE_SIGACTION *//* USE_ALARM_TIMEOUT */int rc;
		entry = ((Object)0);
		if (timeoutms < 0) {
			return -/* got an already expired timeout */2/* Ignore the timeout when signals are disabled *//* USE_ALARM_TIMEOUT defined, but no timeout actually requested */;
		} 
		/* The alarm() function only provides integer second resolution, so if
		       we want to wait less than one second we must bail out already now. *//* This allows us to time-out from the name resolver, as the timeout
		     will generate a signal and we will siglongjmp() from that here.
		     This technique has problems (see alarmfunc).
		     This should be the last thing we do before calling Curl_resolv(),
		     as otherwise we'd have to worry about variables that get modified
		     before we invoke Curl_resolv() (and thus use "volatile"). *//* this is coming from a siglongjmp() after an alarm signal */
		/*************************************************************
		     * Set signal handler to catch SIGALRM
		     * Store the old value to be able to set it back later!
		     *************************************************************//* yes, we have a copy *//* HPUX doesn't have SA_RESTART but defaults to that behaviour! *//* now set the new struct *//* HAVE_SIGACTION *//* no sigaction(), revert to the much lamer signal() *//* HAVE_SIGACTION *//*************************************************************
		     * Set signal handler to catch SIGALRM
		     * Store the old value to be able to set it back later!
		     *************************************************************//* yes, we have a copy *//* HPUX doesn't have SA_RESTART but defaults to that behaviour! *//* now set the new struct *//* HAVE_SIGACTION *//* no sigaction(), revert to the much lamer signal() *//* HAVE_SIGACTION */(Object)/* alarm() makes a signal get sent when the timeout fires off, and that
		       will abort system calls *//* timeoutms not used with an async resolver */timeoutms/* USE_ALARM_TIMEOUT */;
		rc = ModernizedCProgram.Curl_resolv(conn, hostname, port, 1, /* Perform the actual name resolution. This might be interrupted by an
		   * alarm if it takes too long.
		   */entry/* deactivate a possibly active alarm before uninstalling the handler */)/* we got a struct as it looked before, now put that one back nice
		       and clean *//* put it back *//* restore the previous SIGALRM handler *//* HAVE_SIGACTION *//* switch back the alarm() to either zero or to what it was before minus
		     the time we spent until now! */;/* we got a struct as it looked before, now put that one back nice
		       and clean *//* put it back *//* restore the previous SIGALRM handler *//* HAVE_SIGACTION *//* switch back the alarm() to either zero or to what it was before minus
		     the time we spent until now! */
		/* there was an alarm() set before us, now put it back *//* the alarm period is counted in even number of seconds */return /* if the alarm time-left reached zero or turned "negative" (counted
		         with unsigned values), we should fire off a SIGALRM here, but we
		         won't, and zero would be to switch it off so we never set it to
		         less than 1! *//* USE_ALARM_TIMEOUT */rc/*
		 * Curl_resolv_unlock() unlocks the given cached DNS entry. When this has been
		 * made, the struct may be destroyed due to pruning. It is important that only
		 * one unlock is made for each Curl_resolv() call.
		 *
		 * May be called with 'data' == NULL for global cache.
		 */;
	}
	public static void Curl_resolv_unlock(Curl_easy data, Curl_dns_entry dns) {
		Object generatedShare = data.getShare();
		if (data && generatedShare) {
			data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
		} 
		ModernizedCProgram.freednsentry(dns);
		if (data && generatedShare) {
			data.Curl_share_unlock(CURL_LOCK_DATA_DNS/*
			 * File-internal: release cache dns entry reference, free if inuse drops to 0
			 */);
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* alarm-based timeouts can only be used with all the dependencies satisfied */
	/* max FQDN + colon + port number + zero */
	/*
	 * hostip.c explained
	 * ==================
	 *
	 * The main COMPILE-TIME DEFINES to keep in mind when reading the host*.c
	 * source file are these:
	 *
	 * CURLRES_IPV6 - this host has getaddrinfo() and family, and thus we use
	 * that. The host may not be able to resolve IPv6, but we don't really have to
	 * take that into account. Hosts that aren't IPv6-enabled have CURLRES_IPV4
	 * defined.
	 *
	 * CURLRES_ARES - is defined if libcurl is built to use c-ares for
	 * asynchronous name resolves. This can be Windows or *nix.
	 *
	 * CURLRES_THREADED - is defined if libcurl is built to run under (native)
	 * Windows, and then the name resolve will be done in a new thread, and the
	 * supported API will be the same as for ares-builds.
	 *
	 * If any of the two previous are defined, CURLRES_ASYNCH is defined too. If
	 * libcurl is not built to use an asynchronous resolver, CURLRES_SYNCH is
	 * defined.
	 *
	 * The host*.c sources files are split up like this:
	 *
	 * hostip.c   - method-independent resolver functions and utility functions
	 * hostasyn.c - functions for asynchronous name resolves
	 * hostsyn.c  - functions for synchronous name resolves
	 * hostip4.c  - IPv4 specific functions
	 * hostip6.c  - IPv6 specific functions
	 *
	 * The two asynchronous name resolver backends are implemented in:
	 * asyn-ares.c   - functions for ares-using name resolves
	 * asyn-thread.c - functions for threaded name resolves
	
	 * The hostip.h is the united header file for all this. It defines the
	 * CURLRES_* defines based on the config*.h and curl_setup.h defines.
	 */
	public static void freednsentry(Object freethis) {
		Curl_dns_entry dns = (Curl_dns_entry)freethis;
		do {
		} while (0);
		long generatedInuse = dns.getInuse();
		generatedInuse--;
		Curl_addrinfo generatedAddr = dns.getAddr();
		if (generatedInuse == 0) {
			generatedAddr.Curl_freeaddrinfo();
			.Curl_cfree(dns);
		} 
	}
	/*
	 * Return # of addresses in a Curl_addrinfo struct
	 */
	public static void Curl_hostcache_clean(Curl_easy data, curl_hash hash) {
		Object generatedShare = data.getShare();
		if (data && generatedShare) {
			data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
		} 
		hash.Curl_hash_clean();
		if (data && generatedShare) {
			data.Curl_share_unlock(CURL_LOCK_DATA_DNS);
		} 
	}
	public static Object Curl_resolv_check(connectdata conn, Curl_dns_entry dns) {
		Curl_easy generatedData = conn.getData();
		Object generatedSet = generatedData.getSet();
		if (generatedSet.getDoh()) {
			return ModernizedCProgram.Curl_doh_is_resolved(conn, dns);
		} 
		return ModernizedCProgram.Curl_resolver_is_resolved(conn, dns);
	}
	public static void sighandler(int dummy) {
		ModernizedCProgram.pending_interrupt = 1;
	}
	public static Object grow_buffer(Object contents, Object sz, Object nmemb, Object ctx) {
		size_t realsize = sz * nmemb;
		memory mem = (memory)ctx;
		Object generatedBuf = mem.getBuf();
		Object generatedSize = mem.getSize();
		byte ptr = .realloc(generatedBuf, generatedSize + realsize);
		if (!ptr) {
			.printf(/* out of memory */"not enough memory (realloc returned NULL)\n");
			return 0;
		} 
		mem.setBuf(ptr);
		.memcpy((generatedBuf[generatedSize]), contents, realsize);
		generatedSize += realsize;
		return realsize;
	}
	public static Object make_handle(Byte url) {
		Curl_easy curl_easy = new Curl_easy();
		 handle = curl_easy.curl_easy_init();
		handle.curl_easy_setopt(CURLOPT_HTTP_VERSION, /* Important: use HTTP2 over HTTPS */CURL_HTTP_VERSION_2TLS);
		handle.curl_easy_setopt(CURLOPT_URL, url);
		memory mem = .malloc(/* buffer body */);
		mem.setSize(0);
		mem.setBuf(.malloc(1));
		handle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, grow_buffer);
		handle.curl_easy_setopt(CURLOPT_WRITEDATA, mem);
		handle.curl_easy_setopt(CURLOPT_PRIVATE, mem);
		handle.curl_easy_setopt(CURLOPT_ACCEPT_ENCODING, /* For completeness */"");
		handle.curl_easy_setopt(CURLOPT_TIMEOUT, -1024);
		handle.curl_easy_setopt(CURLOPT_FOLLOWLOCATION, -1024);
		handle.curl_easy_setopt(CURLOPT_MAXREDIRS, -1024);
		handle.curl_easy_setopt(CURLOPT_CONNECTTIMEOUT, -1024);
		handle.curl_easy_setopt(CURLOPT_COOKIEFILE, "");
		handle.curl_easy_setopt(CURLOPT_FILETIME, -1024);
		handle.curl_easy_setopt(CURLOPT_USERAGENT, "mini crawler");
		handle.curl_easy_setopt(CURLOPT_HTTPAUTH, CURLAUTH_ANY);
		handle.curl_easy_setopt(CURLOPT_UNRESTRICTED_AUTH, -1024);
		handle.curl_easy_setopt(CURLOPT_PROXYAUTH, CURLAUTH_ANY);
		handle.curl_easy_setopt(CURLOPT_EXPECT_100_TIMEOUT_MS, -1024);
		return handle;
	}
	/* HREF finder implemented in libxml2 but could be any HTML parser */
	public static Object follow_links(Object multi_handle, Byte url) {
		int opts = HTML_PARSE_NOBLANKS | HTML_PARSE_NOERROR | HTML_PARSE_NOWARNING | HTML_PARSE_NONET;
		Object generatedBuf = this.getBuf();
		Object generatedSize = this.getSize();
		 doc = .htmlReadMemory(generatedBuf, generatedSize, url, ((Object)0), opts);
		if (!doc) {
			return 0;
		} 
		 xpath = ()"//a/@href";
		 context = .xmlXPathNewContext(doc);
		 result = .xmlXPathEvalExpression(xpath, context);
		.xmlXPathFreeContext(context);
		if (!result) {
			return 0;
		} 
		 nodeset = result.getNodesetval();
		if (.xmlXPathNodeSetIsEmpty(nodeset)) {
			.xmlXPathFreeObject(result);
			return 0;
		} 
		size_t count = 0;
		for (int i = 0;
		 i < nodeset.getNodeNr(); i++) {
			double r = .rand();
			int x = r * nodeset.getNodeNr() / -1024;
			 node = nodeset.getNodeTab()[x].getXmlChildrenNode();
			 href = .xmlNodeListGetString(doc, node, 1);
			if (ModernizedCProgram.follow_relative_links) {
				 orig = href;
				href = .xmlBuildURI(href, ()url);
				.xmlFree(orig);
			} 
			byte link = (byte)href;
			if (!link || .strlen(link) < 20) {
				continue;
			} 
			if (!.strncmp(link, "http://", 7) || !.strncmp(link, "https://", 8)) {
				ModernizedCProgram.curl_multi_add_handle(multi_handle, ModernizedCProgram.make_handle(link));
				if (count++ == ModernizedCProgram.max_link_per_page) {
					break;
				} 
			} 
			.xmlFree(link);
		}
		.xmlXPathFreeObject(result);
		return count;
	}
	public static int is_html(Byte ctype) {
		return ctype != ((Object)0) && .strlen(ctype) > 10 && .strstr(ctype, "text/html");
	}
	public static int test_unsigned_short_formatting() {
		int i;
		int j;
		int num_ushort_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("65535");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("65280");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("255");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("61440");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("3840");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("240");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("15");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("49152");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("3072");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("192");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("12");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("1");
		i++;
		ModernizedCProgram.us_test[i].setNum(-1024);
		ModernizedCProgram.us_test[i].setExpected("0");
		num_ushort_tests = i;
		for (i = 1; i <= num_ushort_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.us_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.us_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.us_test[i].getResult(), "%hu", ModernizedCProgram.us_test[i].getNum());
			if (.memcmp(ModernizedCProgram.us_test[i].getResult(), ModernizedCProgram.us_test[i].getExpected(), .strlen(ModernizedCProgram.us_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("unsigned short test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.us_test[i].getExpected(), ModernizedCProgram.us_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() unsigned short tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() unsigned short tests Failed!\n");
		} 
		return failed;
	}
	public static int test_signed_short_formatting() {
		int i;
		int j;
		int num_sshort_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("32767");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("32766");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("32765");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("32512");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("2032");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("127");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("28672");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("1792");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("112");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("7");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("20480");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("1280");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("80");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("5");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("1");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024);
		ModernizedCProgram.ss_test[i].setExpected("0");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-32768");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-32767");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-32766");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-32513");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-2033");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-128");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-28673");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-1793");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-113");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-8");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-20481");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-1281");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-81");
		i++;
		ModernizedCProgram.ss_test[i].setNum(--1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-6");
		i++;
		ModernizedCProgram.ss_test[i].setNum(-1024 - 1);
		ModernizedCProgram.ss_test[i].setExpected("-1");
		num_sshort_tests = i;
		for (i = 1; i <= num_sshort_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.ss_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.ss_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.ss_test[i].getResult(), "%hd", ModernizedCProgram.ss_test[i].getNum());
			if (.memcmp(ModernizedCProgram.ss_test[i].getResult(), ModernizedCProgram.ss_test[i].getExpected(), .strlen(ModernizedCProgram.ss_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("signed short test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.ss_test[i].getExpected(), ModernizedCProgram.ss_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() signed short tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() signed short tests Failed!\n");
		} 
		return failed;
	}
	public static int test_unsigned_int_formatting() {
		int i;
		int j;
		int num_uint_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("4294967295");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("4294901760");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("65535");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("4278190080");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("16711680");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("65280");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("255");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("4026531840");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("251658240");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("15728640");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("983040");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("61440");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("3840");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("240");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("15");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("3221225472");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("201326592");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("12582912");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("786432");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("49152");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("3072");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("192");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("12");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("1");
		i++;
		ModernizedCProgram.ui_test[i].setNum(-1024);
		ModernizedCProgram.ui_test[i].setExpected("0");
		num_uint_tests = i/* !checksrc! disable LONGLINE all */;
		for (i = 1; i <= num_uint_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.ui_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.ui_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.ui_test[i].getResult(), "%u", ModernizedCProgram.ui_test[i].getNum());
			if (.memcmp(ModernizedCProgram.ui_test[i].getResult(), ModernizedCProgram.ui_test[i].getExpected(), .strlen(ModernizedCProgram.ui_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("unsigned int test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.ui_test[i].getExpected(), ModernizedCProgram.ui_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() unsigned int tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() unsigned int tests Failed!\n");
		} 
		return failed;
	}
	public static int test_signed_int_formatting() {
		int i;
		int j;
		int num_sint_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("2147483647");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("2147483646");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("2147483645");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("2147418112");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("32767");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("2130706432");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("8323072");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("32512");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("127");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("1879048192");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("117440512");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("7340032");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("458752");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("28672");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("1792");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("112");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("7");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("1342177280");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("83886080");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("5242880");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("327680");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("20480");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("1280");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("80");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("5");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("1");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024);
		ModernizedCProgram.si_test[i].setExpected("0");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-2147483648");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-2147483647");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-2147483646");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-2147418113");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-32768");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-2130706433");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-8323073");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-32513");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-128");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-1879048193");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-117440513");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-7340033");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-458753");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-28673");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-1793");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-113");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-8");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-1342177281");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-83886081");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-5242881");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-327681");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-20481");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-1281");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-81");
		i++;
		ModernizedCProgram.si_test[i].setNum(--1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-6");
		i++;
		ModernizedCProgram.si_test[i].setNum(-1024 - 1);
		ModernizedCProgram.si_test[i].setExpected("-1");
		num_sint_tests = i;
		for (i = 1; i <= num_sint_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.si_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.si_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.si_test[i].getResult(), "%d", ModernizedCProgram.si_test[i].getNum());
			if (.memcmp(ModernizedCProgram.si_test[i].getResult(), ModernizedCProgram.si_test[i].getExpected(), .strlen(ModernizedCProgram.si_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("signed int test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.si_test[i].getExpected(), ModernizedCProgram.si_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() signed int tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() signed int tests Failed!\n");
		} 
		return failed;
	}
	public static int test_unsigned_long_formatting() {
		int i;
		int j;
		int num_ulong_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("4294967295");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("4294901760");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("65535");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("4278190080");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("16711680");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("65280");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("255");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("4026531840");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("251658240");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("15728640");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("983040");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("61440");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("3840");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("240");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("15");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("3221225472");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("201326592");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("12582912");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("786432");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("49152");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("3072");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("192");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("12");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("1");
		i++;
		ModernizedCProgram.ul_test[i].setNum(-1024);
		ModernizedCProgram.ul_test[i].setExpected("0");
		num_ulong_tests = i;
		for (i = 1; i <= num_ulong_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.ul_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.ul_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.ul_test[i].getResult(), "%lu", ModernizedCProgram.ul_test[i].getNum());
			if (.memcmp(ModernizedCProgram.ul_test[i].getResult(), ModernizedCProgram.ul_test[i].getExpected(), .strlen(ModernizedCProgram.ul_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("unsigned long test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.ul_test[i].getExpected(), ModernizedCProgram.ul_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() unsigned long tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() unsigned long tests Failed!\n");
		} 
		return failed;
	}
	public static int test_signed_long_formatting() {
		int i;
		int j;
		int num_slong_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("2147483647");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("2147483646");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("2147483645");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("2147418112");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("32767");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("2130706432");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("8323072");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("32512");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("127");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("1879048192");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("117440512");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("7340032");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("458752");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("28672");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("1792");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("112");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("7");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("1342177280");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("83886080");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("5242880");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("327680");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("20480");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("1280");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("80");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("5");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("1");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024);
		ModernizedCProgram.sl_test[i].setExpected("0");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-2147483648");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-2147483647");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-2147483646");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-2147418113");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-32768");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-2130706433");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-8323073");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-32513");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-128");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-1879048193");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-117440513");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-7340033");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-458753");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-28673");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-1793");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-113");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-8");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-1342177281");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-83886081");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-5242881");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-327681");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-20481");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-1281");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-81");
		i++;
		ModernizedCProgram.sl_test[i].setNum(--1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-6");
		i++;
		ModernizedCProgram.sl_test[i].setNum(-1024 - -1024);
		ModernizedCProgram.sl_test[i].setExpected("-1");
		num_slong_tests = i;
		for (i = 1; i <= num_slong_tests; i++) {
			for (j = 0; j < 256; j++) {
				ModernizedCProgram.sl_test[i].getResult()[j] = (byte)'X';
			}
			ModernizedCProgram.sl_test[i].getResult()[256 - 1] = (byte)'\0';
			(Object)ModernizedCProgram.curl_msprintf(ModernizedCProgram.sl_test[i].getResult(), "%ld", ModernizedCProgram.sl_test[i].getNum());
			if (.memcmp(ModernizedCProgram.sl_test[i].getResult(), ModernizedCProgram.sl_test[i].getExpected(), .strlen(ModernizedCProgram.sl_test[i].getExpected()))) {
				ModernizedCProgram.curl_mprintf("signed long test #%.2d: Failed (Expected: %s Got: %s)\n", i, ModernizedCProgram.sl_test[i].getExpected(), ModernizedCProgram.sl_test[i].getResult());
				failed++;
			} 
		}
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() signed long tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() signed long tests Failed!\n");
		} 
		return failed;
	}
	public static int test_curl_off_t_formatting() {
		int i;
		int j;
		int num_cofft_tests = 0;
		int failed = 0;
		i = 1;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9223372036854775807");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9223372036854775806");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9223372036854775805");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9223372032559808512");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("2147483647");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9223090561878065152");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("140733193388032");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("2147418112");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("32767");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("9151314442816847872");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("35747322042253312");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("139637976727552");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("545460846592");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("2130706432");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("8323072");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("32512");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("127");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("8070450532247928832");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("504403158265495552");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("31525197391593472");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("1970324836974592");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("123145302310912");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("7696581394432");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("481036337152");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("30064771072");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("1879048192");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("117440512");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("7340032");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("458752");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("28672");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("1792");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("112");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("7");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("1");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL;
		ModernizedCProgram.co_test[i].setExpected("0");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9223372036854775808");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9223372036854775807");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9223372036854775806");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9223372032559808513");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-2147483648");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9223090561878065153");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-140733193388033");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-2147418113");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-32768");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-9151314442816847873");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-35747322042253313");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-139637976727553");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-545460846593");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-2130706433");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-8323073");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-32513");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-128");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-8070450532247928833");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-504403158265495553");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-31525197391593473");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-1970324836974593");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-123145302310913");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-7696581394433");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-481036337153");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-30064771073");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-1879048193");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-117440513");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-7340033");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-458753");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-28673");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-1793");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-113");
		i++;
		ModernizedCProgram.co_test[i].setNum(--1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-8");
		i++;
		ModernizedCProgram.co_test[i].setNum(-1024);
		LL - 1;
		LL;
		ModernizedCProgram.co_test[i].setExpected("-1");
		num_cofft_tests = i;
		if (!failed) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() curl_off_t tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() curl_off_t tests Failed!\n");
		} 
		return failed;
	}
	public static int _string_check(int linenumber, Byte buf, Object buf2) {
		if (.strcmp(buf, buf2)) {
			ModernizedCProgram.curl_mprintf(/* they shouldn't differ */"sprintf line %d failed:\nwe      '%s'\nsystem: '%s'\n", linenumber, buf, buf2);
			return 1;
		} 
		return 0;
	}
	public static int _strlen_check(int linenumber, Byte buf, Object len) {
		size_t buflen = .strlen(buf);
		if (len != buflen) {
			ModernizedCProgram.curl_mprintf(/* they shouldn't differ */"sprintf strlen:%d failed:\nwe '%zu'\nsystem: '%zu'\n", linenumber, buflen, len);
			return 1;
		} 
		return 0;
	}
	/*
	 * The output strings in this test need to have been verified with a system
	 * sprintf() before used here.
	 */
	public static int test_string_formatting() {
		int errors = 0;
		byte[] buf = new byte[256];
		ModernizedCProgram.curl_msnprintf(buf, , "%0*d%s", 2, 9, "foo");
		errors += ModernizedCProgram._string_check(1417, buf, "09foo");
		ModernizedCProgram.curl_msnprintf(buf, , "%*.*s", 5, 2, "foo");
		errors += ModernizedCProgram._string_check(1420, buf, "   fo");
		ModernizedCProgram.curl_msnprintf(buf, , "%*.*s", 2, 5, "foo");
		errors += ModernizedCProgram._string_check(1423, buf, "foo");
		ModernizedCProgram.curl_msnprintf(buf, , "%*.*s", 0, 10, "foo");
		errors += ModernizedCProgram._string_check(1426, buf, "foo");
		ModernizedCProgram.curl_msnprintf(buf, , "%-10s", "foo");
		errors += ModernizedCProgram._string_check(1429, buf, "foo       ");
		ModernizedCProgram.curl_msnprintf(buf, , "%10s", "foo");
		errors += ModernizedCProgram._string_check(1432, buf, "       foo");
		ModernizedCProgram.curl_msnprintf(buf, , "%*.*s", -10, -10, "foo");
		errors += ModernizedCProgram._string_check(1435, buf, "foo       ");
		if (!errors) {
			ModernizedCProgram.curl_mprintf("All curl_mprintf() strings tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("Some curl_mprintf() string tests Failed!\n");
		} 
		return errors;
	}
	public static int test_weird_arguments() {
		int errors = 0;
		byte[] buf = new byte[256];
		int rc;
		rc = ModernizedCProgram.curl_msnprintf(buf, , /* 10 */"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d"/* 10 1 *//* 10 2 *//* 10 3 *//* 10 4 *//* 10 5 *//* 10 6 */, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 7 *//* 10 8 *//* 10 9 *//* 10 10 *//* 10 11 *//* 8 *//* 10 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 1 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 2 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 3 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 4 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 5 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 6 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 7 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 8 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 9 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 10 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 11 */9, 0, 1, 2, 3, 4, 5, 6, /* 8 */7);
		if (rc != 128) {
			ModernizedCProgram.curl_mprintf("curl_mprintf() returned %d and not 128!\n", rc);
			errors++;
		} 
		errors += ModernizedCProgram._string_check(1500, buf, "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567"/* 10 *//* 10 1 *//* 10 2 *//* 10 3 *//* 10 4 *//* 10 5 *//* 10 6 *//* 10 7 */);
		buf[0] = /* 10 8 *//* 10 9 *//* 10 10*//* 10 11 *//* 8 *//* MAX_PARAMETERS is 128, try more! */0;
		rc = ModernizedCProgram.curl_msnprintf(buf, , /* 10 */"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d"/* 10 1 *//* 10 2 *//* 10 3 *//* 10 4 *//* 10 5 *//* 10 6 */, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 7 *//* 10 8 *//* 10 9 *//* 10 10 *//* 10 11 *//* 9 *//* 10 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 1 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 2 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 3 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 4 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 5 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 6 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 7 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 8 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 9 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 10 */9, 0, 1, 2, 3, 4, 5, 6, 7, 8, /* 10 11 */9, 0, 1, 2, 3, 4, 5, 6, 7, /* 9 */8);
		if (rc != -1) {
			ModernizedCProgram.curl_mprintf("curl_mprintf() returned %d and not -1!\n", rc);
			errors++;
		} 
		errors += ModernizedCProgram._string_check(1538, buf, "");
		if (errors) {
			ModernizedCProgram.curl_mprintf("Some curl_mprintf() weird arguments tests failed!\n");
		} 
		return errors/* DBL_MAX value from Linux */;
	}
	/* !checksrc! disable PLUSNOSPACE 1 */
	public static int test_float_formatting() {
		int errors = 0;
		byte[] buf = new byte[/* larger than max float size */512];
		ModernizedCProgram.curl_msnprintf(buf, , "%f", 9.0);
		errors += ModernizedCProgram._string_check(1555, buf, "9.000000");
		ModernizedCProgram.curl_msnprintf(buf, , "%.1f", 9.1);
		errors += ModernizedCProgram._string_check(1558, buf, "9.1");
		ModernizedCProgram.curl_msnprintf(buf, , "%.2f", 9.1);
		errors += ModernizedCProgram._string_check(1561, buf, "9.10");
		ModernizedCProgram.curl_msnprintf(buf, , "%.0f", 9.1);
		errors += ModernizedCProgram._string_check(1564, buf, "9");
		ModernizedCProgram.curl_msnprintf(buf, , "%0f", 9.1);
		errors += ModernizedCProgram._string_check(1567, buf, "9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%10f", 9.1);
		errors += ModernizedCProgram._string_check(1570, buf, "  9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%10.3f", 9.1);
		errors += ModernizedCProgram._string_check(1573, buf, "     9.100");
		ModernizedCProgram.curl_msnprintf(buf, , "%-10.3f", 9.1);
		errors += ModernizedCProgram._string_check(1576, buf, "9.100     ");
		ModernizedCProgram.curl_msnprintf(buf, , "%-10.3f", 9.123456);
		errors += ModernizedCProgram._string_check(1579, buf, "9.123     ");
		ModernizedCProgram.curl_msnprintf(buf, , "%.-2f", 9.1);
		errors += ModernizedCProgram._string_check(1582, buf, "9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", 10, 9.1);
		errors += ModernizedCProgram._string_check(1585, buf, "  9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", 3, 9.1);
		errors += ModernizedCProgram._string_check(1588, buf, "9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", 6, 9.2987654);
		errors += ModernizedCProgram._string_check(1591, buf, "9.298765");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", 6, 9.298765);
		errors += ModernizedCProgram._string_check(1594, buf, "9.298765");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", 6, 9.29876);
		errors += ModernizedCProgram._string_check(1597, buf, "9.298760");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 6, 9.2987654);
		errors += ModernizedCProgram._string_check(1600, buf, "9.298765");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 5, 9.2987654);
		errors += ModernizedCProgram._string_check(1602, buf, "9.29877");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 4, 9.2987654);
		errors += ModernizedCProgram._string_check(1604, buf, "9.2988");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 3, 9.2987654);
		errors += ModernizedCProgram._string_check(1606, buf, "9.299");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 2, 9.2987654);
		errors += ModernizedCProgram._string_check(1608, buf, "9.30");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 1, 9.2987654);
		errors += ModernizedCProgram._string_check(1610, buf, "9.3");
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", 0, 9.2987654);
		errors += ModernizedCProgram._string_check(1612, buf, "9"/* very large precisions easily turn into system specific outputs so we only
		     check the output buffer length here as we know the internal limit */);
		ModernizedCProgram.curl_msnprintf(buf, , "%.*f", (1 << 30), 9.2987654);
		errors += ModernizedCProgram._strlen_check(1618, buf, 325);
		ModernizedCProgram.curl_msnprintf(buf, , "%10000.10000f", 9.2987654);
		errors += ModernizedCProgram._strlen_check(1621, buf, 325);
		ModernizedCProgram.curl_msnprintf(buf, , "%240.10000f", 1.2345678912345679E26);
		errors += ModernizedCProgram._strlen_check(1625, buf, 325);
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", (-2147483647 - 1), /* check negative when used signed */9.1);
		errors += ModernizedCProgram._string_check(1629, buf, "9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%*f", (1 << 30), /* curl_msnprintf() limits a single float output to 325 bytes maximum
		     width */9.1);
		errors += ModernizedCProgram._string_check(1634, buf, "                                                                                                                                                                                                                                                                                                                             9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%100000f", 9.1);
		errors += ModernizedCProgram._string_check(1636, buf, "                                                                                                                                                                                                                                                                                                                             9.100000");
		ModernizedCProgram.curl_msnprintf(buf, , "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1639, buf, 317);
		ModernizedCProgram.curl_msnprintf(buf, 2, "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1642, buf, 1);
		ModernizedCProgram.curl_msnprintf(buf, 3, "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1644, buf, 2);
		ModernizedCProgram.curl_msnprintf(buf, 4, "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1646, buf, 3);
		ModernizedCProgram.curl_msnprintf(buf, 5, "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1648, buf, 4);
		ModernizedCProgram.curl_msnprintf(buf, 6, "%f", -1.7976931348623157E308);
		errors += ModernizedCProgram._strlen_check(1650, buf, 5);
		if (!errors) {
			ModernizedCProgram.curl_mprintf("All float strings tests OK!\n");
		} else {
				ModernizedCProgram.curl_mprintf("test_float_formatting Failed!\n");
		} 
		return errors/* !checksrc! enable LONGLINE */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* check rate limits within this many recent milliseconds, at minimum. */
	/* Provide a string that is 2 + 1 + 2 + 1 + 2 = 8 letters long (plus the zero
	   byte) */
	/* Provide a string that is 2 + 1 + 2 + 1 + 2 = 8 letters long (plus the zero
	   byte) */
	public static void time2str(Byte r, Object seconds) {
		 h = new ();
		if (seconds <= 0) {
			.strcpy(r, "--:--:--");
			return ;
		} 
		h = seconds / .CURL_OFF_T_C(3600);
		 h = new ();
		if (seconds <= 0) {
			.strcpy(r, "--:--:--");
			return ;
		} 
		h = seconds / .CURL_OFF_T_C(3600);
	}
	/* The point of this function would be to return a string of the input data,
	   but never longer than 5 columns (+ one zero byte).
	   Add suffix k, M, G when suitable... */
	public static Byte max5data(Object bytes, Byte max5) {
		return max5/*
		
		   New proposed interface, 9th of February 2000:
		
		   pgrsStartNow() - sets start time
		   pgrsSetDownloadSize(x) - known expected download size
		   pgrsSetUploadSize(x) - known expected upload size
		   pgrsSetDownloadCounter() - amount of data currently downloaded
		   pgrsSetUploadCounter() - amount of data currently uploaded
		   pgrsUpdate() - show progress
		   pgrsDone() - transfer complete
		
		*/;
		return max5;
	}
	public static void Curl_ratelimit(Curl_easy data, curltime now) {
		Object generatedSet = data.getSet();
		Object generatedProgress = data.getProgress();
		if (generatedSet.getMax_recv_speed() > /* don't set a new stamp unless the time since last update is long enough */0) {
			if (now.Curl_timediff(generatedProgress.getDl_limit_start()) >= 3000) {
				generatedProgress.setDl_limit_start(now);
				generatedProgress.setDl_limit_size(generatedProgress.getDownloaded());
			} 
		} 
		if (generatedSet.getMax_send_speed() > 0) {
			if (now.Curl_timediff(generatedProgress.getUl_limit_start()) >= 3000) {
				generatedProgress.setUl_limit_start(now);
				generatedProgress.setUl_limit_size(generatedProgress.getUploaded());
			} 
		} 
	}
	/* returns TRUE if it's time to show the progress meter */
	public static  progress_calc(connectdata conn, curltime now) {
		 timespent = new ();
		/* milliseconds */ timespent_ms = new ();
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Object generatedProgress = data.getProgress();
		 dl = generatedProgress.getDownloaded();
		 ul = generatedProgress.getUploaded();
		bool timetoshow = 0;
		generatedProgress.setTimespent(now.Curl_timediff_us(generatedProgress.getStart()));
		timespent = ()generatedProgress.getTimespent() / /* seconds */1000000;
		timespent_ms = ()generatedProgress.getTimespent() / /* ms */1000;
		if (dl < .CURL_OFF_T_C(-1024) / /* The average download speed this far */1000) {
			generatedProgress.setDlspeed((dl * 1000 / (timespent_ms > 0 ? timespent_ms : 1)));
		} else {
				generatedProgress.setDlspeed((dl / (timespent > 0 ? timespent : 1)));
		} 
		if (ul < .CURL_OFF_T_C(-1024) / /* The average upload speed this far */1000) {
			generatedProgress.setUlspeed((ul * 1000 / (timespent_ms > 0 ? timespent_ms : 1)));
		} else {
				generatedProgress.setUlspeed((ul / (timespent > 0 ? timespent : 1)));
		} 
		Object generatedTv_sec = now.getTv_sec();
		if (generatedProgress.getLastshow() != generatedTv_sec) {
			int countindex;
			int nowindex = generatedProgress.getSpeeder_c() % (5 + 1);
			generatedProgress.setLastshow(generatedTv_sec);
			timetoshow = 1;
			generatedProgress.getSpeeder()[/* Let's do the "current speed" thing, with the dl + ul speeds
			       combined. Store the speed at entry 'nowindex'. */nowindex] = generatedProgress.getDownloaded() + generatedProgress.getUploaded();
			generatedProgress.getSpeeder_time()[nowindex] = /* remember the exact time for this moment */now;
			generatedProgress.getSpeeder_c()++;
			countindex = ((generatedProgress.getSpeeder_c() >= (5 + 1)) ? (5 + 1) : generatedProgress.getSpeeder_c()) - 1;
			if (/* first of all, we don't do this if there's no counted seconds yet */countindex) {
				int checkindex;
				timediff_t span_ms = new timediff_t();
				checkindex = (generatedProgress.getSpeeder_c() >= (5 + 1)) ? generatedProgress.getSpeeder_c() % (5 + 1) : 0;
				span_ms = now.Curl_timediff(generatedProgress.getSpeeder_time()[/* Figure out the exact time for the time span */checkindex]);
				if (0 == span_ms) {
					span_ms = /* at least one millisecond MUST have passed */1;
				} 
				{ 
					 amount = generatedProgress.getSpeeder()[/* Calculate the average speed the last 'span_ms' milliseconds */nowindex] - generatedProgress.getSpeeder()[checkindex];
					if (amount > .CURL_OFF_T_C(/* 0xffffffff/1000 */4294967/* the 'amount' value is bigger than would fit in 32 bits if
					             multiplied with 1000, so we use the double math for this */)) {
						generatedProgress.setCurrent_speed(.UNRECOGNIZEDFUNCTIONNAME((double)amount / ((double)span_ms / 1000.0)));
					} else {
							generatedProgress.setCurrent_speed(amount * .CURL_OFF_T_C(1000) / /* the 'amount' value is small enough to fit within 32 bits even
							             when multiplied with 1000 */span_ms);
					} 
				}
			} else {
					generatedProgress.setCurrent_speed(generatedProgress.getUlspeed() + generatedProgress.getDlspeed());
			} 
		} 
		return /* Calculations end */timetoshow;
	}
	public static int xferinfo_cb(Object clientp, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		per_transfer per = clientp;
		per.setDltotal(dltotal);
		per.setDlnow(dlnow);
		per.setUltotal(ultotal);
		per.setUlnow(ulnow);
		return 0;
	}
	/* We can not translate it, so return the original string */
	/* VMS translate path is actually not needed on the current 64 bit */
	/* VMS platforms, so instead of figuring out the pointer settings */
	/* Change it to a noop */
	public static Byte vms_getenv(Object envvar) {
		byte result;
		byte vms_path;
		result = .decc$getenv(/* first use the DECC getenv() function */envvar);
		if (result == ((Object)0)) {
			return result;
		} 
		vms_path = result;
		result = .vms_translate_path(vms_path/* note that if you backport this to use VAX C RTL, that the VAX C RTL *//* may do a malloc(2048) for each call to getenv(), so you will need   */);
		return /* to add a free(vms_path) *//* Do not do a free() for DEC C RTL builds, which should be used for *//* VMS 5.5-2 and later, even if using GCC */result;
	}
	public static passwd vms_getpwuid(Object uid) {
		passwd my_passwd = new passwd();
		/* Hack needed to support 64 bit builds, decc_getpwnam is 32 bit only */
		byte unix_path;
		my_passwd = .decc$getpwuid(uid);
		if (my_passwd == ((Object)0)) {
			return my_passwd;
		} 
		Object generatedPasswd = my_passwd.getPasswd();
		unix_path = .vms_translate_path(generatedPasswd);
		if ((long)unix_path <= 0) {
			return /* We can not translate it, so return the original string */my_passwd;
		} 
		if (unix_path == generatedPasswd) {
			return my_passwd;
		} 
		ModernizedCProgram.vms_passwd_cache.setPasswd(generatedPasswd);
		ModernizedCProgram.vms_passwd_cache.setPasswd(generatedPasswd);
		ModernizedCProgram.vms_passwd_cache.setPasswd(generatedPasswd);
		ModernizedCProgram.vms_passwd_cache.setPasswd(unix_path);
		ModernizedCProgram.vms_passwd_cache.setPasswd(generatedPasswd);
		return ModernizedCProgram.vms_passwd_cache/* Bug - VMS OpenSSL and Kerberos universal symbols are in uppercase only *//* VMS libraries should have universal symbols in exact and uppercase */;
	}
	public static void helpf(Object fmt) {
		if (fmt) {
			va_list ap = new va_list();
			.__builtin_va_start(ap, fmt);
			.fputs("curl: ", /* prefix it */ModernizedCProgram.errors);
			ModernizedCProgram.errors.curl_mvfprintf(fmt, ap);
			.__builtin_va_end(ap);
		} 
		ModernizedCProgram.errors.curl_mfprintf("curl: try 'curl --help' or 'curl --manual' for more information\n");
	}
	public static void GUSISetupFactories() {
		.GUSIwithInetSockets();
	}
	public static void GUSISetupDevices() {
		.GUSIwithNullSockets();
	}
	public static void GUSISetupConfig() {
		GUSIConfiguration config = .CreateInstance(kNoResource);
		.UNRECOGNIZEDFUNCTIONNAME((byte)'TEXT', (byte)'CWIE');
		.UNRECOGNIZEDFUNCTIONNAME( /  - 1, /**************** BEGIN GUSI CONFIGURATION ****************************
		 *
		 * GUSI Configuration section generated by GUSI Configurator
		 * last modified: Mon Oct 29 15:41:51 2001
		 *
		 * This section will be overwritten by the next run of Configurator.
		 *//* Declarations of Socket Factories *//* Configure Socket Factories *//* Declarations of File Devices *//* Configure File Devices *//**************** END GUSI CONFIGURATION *************************/sSuffices);
	}
	public static int checkparts(Object u, Object in, Object wanted, int getflags) {
		int i;
		 rc = new ();
		byte[] buf = new byte[256];
		byte bufp = buf[0];
		size_t len = ;
		part[] parts = new part[]{new part(CURLUPART_SCHEME, "scheme"), new part(CURLUPART_USER, "user"), new part(CURLUPART_PASSWORD, "password"), new part(CURLUPART_OPTIONS, "options"), new part(CURLUPART_HOST, "host"), new part(CURLUPART_PORT, "port"), new part(CURLUPART_PATH, "path"), new part(CURLUPART_QUERY, "query"), new part(CURLUPART_FRAGMENT, "fragment"), new part(0, ((Object)0))};
		buf[0] = 0;
		for (i = 0; parts[i].getName(); i++) {
			byte p = ((Object)0);
			size_t n = new size_t();
			rc = .curl_url_get(u, parts[i].getPart(), p, getflags);
			if (!rc && p) {
				ModernizedCProgram.curl_msnprintf(bufp, len, "%s%s", buf[0] ? " | " : "", p);
			} else {
					ModernizedCProgram.curl_msnprintf(bufp, len, "%s[%d]", buf[0] ? " | " : "", (int)rc);
			} 
			n = .strlen(bufp);
			bufp += n;
			len -= n;
			ModernizedCProgram.curl_free(p);
		}
		if (.strcmp(buf, wanted)) {
			(_iob[2]).curl_mfprintf("in: %s\nwanted: %s\ngot:    %s\n", in, wanted, buf);
			return 1;
		} 
		return 0;
	}
	public static int checkurl(Object url, Object out) {
		if (.strcmp(out, url)) {
			(_iob[2]).curl_mfprintf("Wanted: %s\nGot   : %s\n", out, url);
			return 1;
		} 
		return 0;
	}
	public static Object part2id(Byte part) {
		if (!.strcmp("url", part)) {
			return CURLUPART_URL;
		} 
		if (!.strcmp("scheme", part)) {
			return CURLUPART_SCHEME;
		} 
		if (!.strcmp("user", part)) {
			return CURLUPART_USER;
		} 
		if (!.strcmp("password", part)) {
			return CURLUPART_PASSWORD;
		} 
		if (!.strcmp("options", part)) {
			return CURLUPART_OPTIONS;
		} 
		if (!.strcmp("host", part)) {
			return CURLUPART_HOST;
		} 
		if (!.strcmp("port", part)) {
			return CURLUPART_PORT;
		} 
		if (!.strcmp("path", part)) {
			return CURLUPART_PATH;
		} 
		if (!.strcmp("query", part)) {
			return CURLUPART_QUERY;
		} 
		if (!.strcmp("fragment", part)) {
			return CURLUPART_FRAGMENT;
		} 
		if (!.strcmp("zoneid", part)) {
			return CURLUPART_ZONEID;
		} 
		return /* bad input => bad output */9999;
	}
	public static Object updateurl(Object u, Object cmd, int setflags) {
		byte p = cmd;
		 uc = new ();
		while (/* make sure the last command ends with a comma too! */p) {
			byte e = .strchr(p, (byte)',');
			if (e) {
				size_t n = e - p;
				byte[] buf = new byte[80];
				byte[] part = new byte[80];
				byte[] value = new byte[80];
				.memcpy(ModernizedCProgram.buf, p, n);
				ModernizedCProgram.buf[n] = 0;
				if (2 == .sscanf(ModernizedCProgram.buf, "%79[^=]=%79[^,]", part, value)) {
					 what = ModernizedCProgram.part2id(part/* for debugging this */);
					if (what > CURLUPART_ZONEID) {
						(_iob[2]).curl_mfprintf("UNKNOWN part '%s'\n", part);
					} 
					if (!.strcmp("NULL", value)) {
						uc = .curl_url_set(u, what, ((Object)0), setflags);
					}  else if (!.strcmp("\"\"", value)) {
						uc = .curl_url_set(u, what, "", setflags);
					} else {
							uc = .curl_url_set(u, what, value, setflags);
					} 
					if (uc) {
						return uc;
					} 
				} 
				p = e + 1;
				continue;
			} 
			break;
		}
		return CURLUE_OK;
	}
	public static int set_url() {
		int i;
		int error = 0;
		for (i = 0; ModernizedCProgram.set_url_list[i].getIn() && !error; i++) {
			 rc = new ();
			 urlp = .curl_url();
			if (!urlp) {
				break;
			} 
			rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.set_url_list[i].getIn(), ModernizedCProgram.set_url_list[i].getUrlflags());
			if (!rc) {
				rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.set_url_list[i].getSet(), ModernizedCProgram.set_url_list[i].getSetflags());
				if (rc) {
					(_iob[2]).curl_mfprintf("%s:%d Set URL %s returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 709, ModernizedCProgram.set_url_list[i].getSet(), (int)rc);
					error++;
				} else {
						byte url = ((Object)0);
						rc = .curl_url_get(urlp, CURLUPART_URL, url, 0);
						if (rc) {
							(_iob[2]).curl_mfprintf("%s:%d Get URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 718, (int)rc);
							error++;
						} else {
								if (ModernizedCProgram.checkurl(url, ModernizedCProgram.set_url_list[i].getOut())) {
									error++;
								} 
						} 
						ModernizedCProgram.curl_free(url);
				} 
			}  else if (rc != ModernizedCProgram.set_url_list[i].getUcode()) {
				(_iob[2]).curl_mfprintf("Set URL\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.set_url_list[i].getIn(), (int)rc, ModernizedCProgram.set_url_list[i].getUcode());
				error++;
			} 
			.curl_url_cleanup(urlp);
		}
		return error;
	}
	public static int set_parts() {
		int i;
		int error = 0;
		for (i = 0; ModernizedCProgram.set_parts_list[i].getSet() && !error; i++) {
			 rc = new ();
			 urlp = .curl_url();
			if (!urlp) {
				error++;
				break;
			} 
			if (ModernizedCProgram.set_parts_list[i].getIn()) {
				rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.set_parts_list[i].getIn(), ModernizedCProgram.set_parts_list[i].getUrlflags());
			} else {
					rc = CURLUE_OK;
			} 
			if (!rc) {
				byte url = ((Object)0);
				 uc = ModernizedCProgram.updateurl(urlp, ModernizedCProgram.set_parts_list[i].getSet(), ModernizedCProgram.set_parts_list[i].getSetflags());
				if (uc != ModernizedCProgram.set_parts_list[i].getPcode()) {
					(_iob[2]).curl_mfprintf("updateurl\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.set_parts_list[i].getSet(), (int)uc, ModernizedCProgram.set_parts_list[i].getPcode());
					error++;
				} 
				rc = .curl_url_get(urlp, CURLUPART_URL, url, 0);
				if (rc) {
					(_iob[2]).curl_mfprintf("%s:%d Get URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 771, (int)rc);
					error++;
				}  else if (ModernizedCProgram.checkurl(url, ModernizedCProgram.set_parts_list[i].getOut())) {
					error++;
				} 
				ModernizedCProgram.curl_free(url);
			}  else if (rc != ModernizedCProgram.set_parts_list[i].getUcode()) {
				(_iob[2]).curl_mfprintf("Set parts\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.set_parts_list[i].getIn(), (int)rc, ModernizedCProgram.set_parts_list[i].getUcode());
				error++;
			} 
			.curl_url_cleanup(urlp);
		}
		return error;
	}
	public static int get_url() {
		int i;
		int error = 0;
		for (i = 0; ModernizedCProgram.get_url_list[i].getIn() && !error; i++) {
			 rc = new ();
			 urlp = .curl_url();
			if (!urlp) {
				error++;
				break;
			} 
			rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.get_url_list[i].getIn(), ModernizedCProgram.get_url_list[i].getUrlflags());
			if (!rc) {
				byte url = ((Object)0);
				rc = .curl_url_get(urlp, CURLUPART_URL, url, ModernizedCProgram.get_url_list[i].getGetflags());
				if (rc) {
					(_iob[2]).curl_mfprintf("%s:%d returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 808, (int)rc);
					error++;
				} else {
						if (ModernizedCProgram.checkurl(url, ModernizedCProgram.get_url_list[i].getOut())) {
							error++;
						} 
				} 
				ModernizedCProgram.curl_free(url);
			}  else if (rc != ModernizedCProgram.get_url_list[i].getUcode()) {
				(_iob[2]).curl_mfprintf("Get URL\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.get_url_list[i].getIn(), (int)rc, ModernizedCProgram.get_url_list[i].getUcode());
				error++;
			} 
			.curl_url_cleanup(urlp);
		}
		return error;
	}
	public static int get_parts() {
		int i;
		int error = 0;
		for (i = 0; ModernizedCProgram.get_parts_list[i].getIn() && !error; i++) {
			 rc = new ();
			 urlp = .curl_url();
			if (!urlp) {
				error++;
				break;
			} 
			rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.get_parts_list[i].getIn(), ModernizedCProgram.get_parts_list[i].getUrlflags());
			if (rc != ModernizedCProgram.get_parts_list[i].getUcode()) {
				(_iob[2]).curl_mfprintf("Get parts\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.get_parts_list[i].getIn(), (int)rc, ModernizedCProgram.get_parts_list[i].getUcode());
				error++;
			}  else if (ModernizedCProgram.get_parts_list[i].getUcode()) {
			}  else if (ModernizedCProgram.checkparts(urlp, ModernizedCProgram.get_parts_list[i].getIn(), ModernizedCProgram.get_parts_list[i].getOut(), ModernizedCProgram.get_parts_list[i].getGetflags())) {
				error++;
			} 
			.curl_url_cleanup(urlp);
		}
		return error;
	}
	public static int append() {
		int i;
		int error = 0;
		for (i = 0; ModernizedCProgram.append_list[i].getIn() && !error; i++) {
			 rc = new ();
			 urlp = .curl_url();
			if (!urlp) {
				error++;
				break;
			} 
			rc = .curl_url_set(urlp, CURLUPART_URL, ModernizedCProgram.append_list[i].getIn(), ModernizedCProgram.append_list[i].getUrlflags());
			if (rc) {
				error++;
			} else {
					rc = .curl_url_set(urlp, CURLUPART_QUERY, ModernizedCProgram.append_list[i].getQ(), ModernizedCProgram.append_list[i].getQflags() | CURLU_APPENDQUERY);
			} 
			if (error) {
				;
			}  else if (rc != ModernizedCProgram.append_list[i].getUcode()) {
				(_iob[2]).curl_mfprintf("Append\nin: %s\nreturned %d (expected %d)\n", ModernizedCProgram.append_list[i].getIn(), (int)rc, ModernizedCProgram.append_list[i].getUcode());
				error++;
			}  else if (ModernizedCProgram.append_list[i].getUcode()) {
			} else {
					byte url;
					rc = .curl_url_get(urlp, CURLUPART_URL, url, 0);
					if (rc) {
						(_iob[2]).curl_mfprintf("%s:%d Get URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 911, (int)rc);
						error++;
					} else {
							if (ModernizedCProgram.checkurl(url, ModernizedCProgram.append_list[i].getOut())) {
								error++;
							} 
							ModernizedCProgram.curl_free(url);
					} 
			} 
			.curl_url_cleanup(urlp);
		}
		return error;
	}
	public static int scopeid() {
		 u = .curl_url();
		int error = 0;
		 rc = new ();
		byte url;
		rc = .curl_url_set(u, CURLUPART_URL, "https://[fe80::20c:29ff:fe9c:409b%25eth0]/hello.html", 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_set returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 937, (int)rc);
			error++;
		} 
		rc = .curl_url_get(u, CURLUPART_HOST, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_HOST returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 944, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_set(u, CURLUPART_HOST, "[::1]", 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_set CURLUPART_HOST returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 955, (int)rc);
			error++;
		} 
		rc = .curl_url_get(u, CURLUPART_URL, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 962, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_set(u, CURLUPART_HOST, "example.com", 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_set CURLUPART_HOST returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 973, (int)rc);
			error++;
		} 
		rc = .curl_url_get(u, CURLUPART_URL, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 980, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_set(u, CURLUPART_HOST, "[fe80::20c:29ff:fe9c:409b%25eth0]", 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_set CURLUPART_HOST returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 992, (int)rc);
			error++;
		} 
		rc = .curl_url_get(u, CURLUPART_URL, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 999, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_get(u, CURLUPART_HOST, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_HOST returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 1010, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_get(u, CURLUPART_ZONEID, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_ZONEID returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 1021, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		rc = .curl_url_set(u, CURLUPART_ZONEID, "clown", 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_set CURLUPART_ZONEID returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 1032, (int)rc);
			error++;
		} 
		rc = .curl_url_get(u, CURLUPART_URL, url, 0);
		if (rc != CURLUE_OK) {
			(_iob[2]).curl_mfprintf("%s:%d curl_url_get CURLUPART_URL returned %d\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\lib1560.c", 1039, (int)rc);
			error++;
		} else {
				ModernizedCProgram.curl_mprintf("we got %s\n", url);
				ModernizedCProgram.curl_free(url);
		} 
		.curl_url_cleanup(u);
		return error;
	}
	public static void SignalHandler(int signo) {
		if (signo == 2) {
			ModernizedCProgram.g_should_exit_ = 1;
		} 
	}
	public static int closecb(Object clientp, Object item) {
		(Object)clientp;
		.printf("libcurl wants to close %d now\n", (int)item);
		return 0;
	}
	public static int cyclic_add() {
		Curl_easy curl_easy = new Curl_easy();
		 easy = curl_easy.curl_easy_init();
		 mime = easy.curl_mime_init();
		 part = ModernizedCProgram.curl_mime_addpart(mime);
		 a1 = ModernizedCProgram.curl_mime_subparts(part, mime);
		if (a1 == CURLE_BAD_FUNCTION_ARGUMENT) {
			 submime = easy.curl_mime_init();
			 subpart = ModernizedCProgram.curl_mime_addpart(submime);
			ModernizedCProgram.curl_mime_subparts(part, submime);
			a1 = ModernizedCProgram.curl_mime_subparts(subpart, mime);
		} 
		ModernizedCProgram.curl_mime_free(mime);
		easy.curl_easy_cleanup();
		if (a1 != CURLE_BAD_FUNCTION_ARGUMENT) {
			return /* that should have failed */1;
		} 
		return 0;
	}
	/* Take all the fun out of simply looking up a logical name */
	public static int sys_trnlnm(Object logname, Byte value, int value_len) {
		long attr = LNM$M_CASE_BLIND;
		dsc$descriptor_s name_dsc = new dsc$descriptor_s();
		int status;
		int result;
		itmlst_3[] itlst = new itmlst_3();
		itlst[0].setBuflen(value_len);
		itlst[0].setItmcode(LNM$_STRING);
		itlst[0].setBufadr(value);
		itlst[0].setRetlen(result);
		itlst[1].setBuflen(0);
		itlst[1].setItmcode(0);
		name_dsc.setDsc$descriptor_s(.strlen(logname));
		name_dsc.setDsc$descriptor_s((byte)logname);
		name_dsc.setDsc$descriptor_s(DSC$K_DTYPE_T);
		name_dsc.setDsc$descriptor_s(DSC$K_CLASS_S);
		status = .SYS$TRNLNM(attr, table_dsc, name_dsc, 0, itlst);
		if (.$VMS_STATUS_SUCCESS(status)) {
			value[result] = /* Null terminate and return the string *//*--------------------------------------*/(byte)'\0';
		} 
		return status;
	}
	/* How to simply create a logical name */
	public static int sys_crelnm(Object logname, Object value) {
		int ret_val;
		byte proc_table = "LNM$PROCESS_TABLE";
		dsc$descriptor_s proc_table_dsc = new dsc$descriptor_s();
		dsc$descriptor_s logname_dsc = new dsc$descriptor_s();
		itmlst_3[] item_list = new itmlst_3();
		proc_table_dsc.setDsc$descriptor_s((byte)proc_table);
		proc_table_dsc.setDsc$descriptor_s(.strlen(proc_table));
		proc_table_dsc.setDsc$descriptor_s(DSC$K_DTYPE_T);
		proc_table_dsc.setDsc$descriptor_s(DSC$K_CLASS_S);
		logname_dsc.setDsc$descriptor_s((byte)logname);
		logname_dsc.setDsc$descriptor_s(.strlen(logname));
		logname_dsc.setDsc$descriptor_s(DSC$K_DTYPE_T);
		logname_dsc.setDsc$descriptor_s(DSC$K_CLASS_S);
		item_list[0].setBuflen(.strlen(value));
		item_list[0].setItmcode(LNM$_STRING);
		item_list[0].setBufadr((byte)value);
		item_list[0].setRetlen(((Object)0));
		item_list[1].setBuflen(0);
		item_list[1].setItmcode(0);
		ret_val = .SYS$CRELNM(((Object)0), proc_table_dsc, logname_dsc, ((Object)0), item_list);
		return ret_val/* Start of DECC RTL Feature handling *//*
		** Sets default value for a feature
		*/;
	}
	public static void set_feature_default(Object name, int value) {
		int index;
		index = .decc$feature_get_index(name);
		if (index > 0) {
			.decc$feature_set_value(index, 0, value);
		} 
	}
	public static void set_features() {
		int status;
		byte[] unix_shell_name = new byte[255];
		int use_unix_settings = 1;
		status = ModernizedCProgram.sys_trnlnm("GNV$UNIX_SHELL", unix_shell_name,  - 1);
		if (!.$VMS_STATUS_SUCCESS(status)) {
			use_unix_settings = 0;
		} 
		ModernizedCProgram.set_feature_default("DECC$ACL_ACCESS_CHECK", /* ACCESS should check ACLs or it is lying. */TRUE);
		ModernizedCProgram.set_feature_default("DECC$ARGV_PARSE_STYLE", /* We always want the new parse style */TRUE);
		ModernizedCProgram.set_feature_default("DECC$DISABLE_POSIX_ROOT", /* Unless we are in POSIX compliant mode, we want the old POSIX root
		     * enabled.
		     */0);
		ModernizedCProgram.set_feature_default("DECC$EFS_CHARSET", /* EFS charset, means UTF-8 support *//* VTF-7 support is controlled by a feature setting called UTF8 */TRUE);
		ModernizedCProgram.set_feature_default("DECC$EFS_CASE_PRESERVE", TRUE);
		ModernizedCProgram.set_feature_default("DECC$EFS_FILE_TIMESTAMPS", /* Support timestamps when available */TRUE);
		ModernizedCProgram.set_feature_default("DECC$ENABLE_GETENV_CACHE", /* Cache environment variables - performance improvements */TRUE/* Start out with new file attribute inheritance */);
		ModernizedCProgram.set_feature_default("DECC$EXEC_FILEATTR_INHERITANCE", 2);
		ModernizedCProgram.set_feature_default("DECC$READDIR_DROPDOTNOTYPE", /* Don't display trailing dot after files without type */TRUE);
		ModernizedCProgram.set_feature_default("DECC$STDIO_CTX_EOL", /* For standard output channels buffer output until terminator *//* Gets rid of output logs with single character lines in them. */TRUE);
		ModernizedCProgram.set_feature_default("DECC$RENAME_NO_INHERIT", /* Fix mv aa.bb aa  */TRUE);
		if (use_unix_settings) {
			ModernizedCProgram.set_feature_default("DECC$ALLOW_REMOVE_OPEN_FILES", /* POSIX requires that open files be able to be removed */TRUE);
			ModernizedCProgram.set_feature_default("DECC$FILENAME_UNIX_ONLY", /* Default to outputting Unix filenames in VMS routines */TRUE/* FILENAME_UNIX_ONLY Implicitly sets */);
			ModernizedCProgram.set_feature_default("DECC$FILE_PERMISSION_UNIX", /* decc$disable_to_vms_logname_translation */TRUE);
			ModernizedCProgram.set_feature_default("DECC$FILE_SHARING", TRUE);
			ModernizedCProgram.set_feature_default("DECC$FILE_OWNER_UNIX", TRUE);
			ModernizedCProgram.set_feature_default("DECC$POSIX_SEEK_STREAM_FILE", TRUE);
		} else {
				ModernizedCProgram.set_feature_default("DECC$FILENAME_UNIX_REPORT", TRUE);
		} 
		ModernizedCProgram.set_feature_default("DECC$GLOB_UNIX_STYLE", /* When reporting Unix filenames, glob the same way */TRUE);
		ModernizedCProgram.set_feature_default("DECC$FILENAME_UNIX_NO_VERSION", /* The VMS version numbers on Unix filenames is incompatible with most *//* ported packages. */TRUE);
		ModernizedCProgram.set_feature_default("DECC$UNIX_PATH_BEFORE_LOGNAME", /* The VMS version numbers on Unix filenames is incompatible with most *//* ported packages. */TRUE);
		ModernizedCProgram.set_feature_default("DECC$STRTOL_ERANGE", /* Set strtol to proper behavior */TRUE/* Commented here to prevent future bugs:  A program or user should *//* never ever enable DECC$POSIX_STYLE_UID. *//* It will probably break all code that accesses UIDs *//*  do_not_set_default ("DECC$POSIX_STYLE_UID", TRUE); *//* Some boilerplate to force this to be a proper LIB$INITIALIZE section */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object getfiletime(Object filename) {
		 result = -1/* Windows stat() may attempt to adjust the unix GMT file time by a daylight
		   saving time offset and since it's GMT that is bad behavior. When we have
		   access to a 64-bit type we can bypass stat and get the times directly. */;
		HANDLE hfile = new HANDLE();
		hfile = .CreateFileA(filename, -1024, (-1024 | -1024 | -1024), ((Object)0), 3, 0, ((Object)0));
		Object generatedDwLowDateTime = ft.getDwLowDateTime();
		Object generatedDwHighDateTime = ft.getDwHighDateTime();
		if (hfile != (HANDLE)(true)) {
			FILETIME ft = new FILETIME();
			if (.GetFileTime(hfile, ((Object)0), ((Object)0), ft)) {
				 converted = ()generatedDwLowDateTime | (()generatedDwHighDateTime) << 32;
				if (converted < .CURL_OFF_T_C(-1024)) {
					.fprintf(error_stream, "Failed to get filetime: underflow\n");
				} else {
						result = (converted - .CURL_OFF_T_C(-1024)) / 10000000;
				} 
			} else {
					.fprintf(error_stream, "Failed to get filetime: GetFileTime failed: GetLastError %u\n", (int).GetLastError());
			} 
			.CloseHandle(hfile);
		}  else if (.GetLastError() != -1024) {
			.fprintf(error_stream, "Failed to get filetime: CreateFile failed: GetLastError %u\n", (int).GetLastError());
		} 
		return result;
	}
	public static void setfiletime(Object filetime, Object filename) {
	}
	/* Clean up all source code if we run out of memory */
	public static void easysrc_free() {
		ModernizedCProgram.easysrc_decl.slist_wc_free_all();
		ModernizedCProgram.easysrc_decl = ((Object)0);
		ModernizedCProgram.easysrc_data.slist_wc_free_all();
		ModernizedCProgram.easysrc_data = ((Object)0);
		ModernizedCProgram.easysrc_code.slist_wc_free_all();
		ModernizedCProgram.easysrc_code = ((Object)0);
		ModernizedCProgram.easysrc_toohard.slist_wc_free_all();
		ModernizedCProgram.easysrc_toohard = ((Object)0);
		ModernizedCProgram.easysrc_clean.slist_wc_free_all();
		ModernizedCProgram.easysrc_clean = ((Object)0);
	}
	public static Object easysrc_init() {
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add("hnd = curl_easy_init();"));
			if (ret) {
				return ret;
			} 
		} while (0);
		return CURLE_OK;
	}
	public static Object easysrc_perform() {
		Object generatedCurl_slist = ptr.getCurl_slist();
		if (/* Note any setopt calls which we could not convert */ModernizedCProgram.easysrc_toohard) {
			int i;
			curl_slist ptr = new curl_slist();
			byte c;
			do {
				 ret = (ModernizedCProgram.easysrc_code.easysrc_add(""));
				if (ret) {
					return ret;
				} 
			} while (0);
			for (i = 0; ((c = ModernizedCProgram.srchard[i]) != ((Object)0)); /* Preamble comment */i++) {
				do {
					 ret = (ModernizedCProgram.easysrc_code.easysrc_add(c));
					if (ret) {
						return ret;
					} 
				} while (0);
			}
			if (/* Each unconverted option */ModernizedCProgram.easysrc_toohard) {
				for (ptr = ModernizedCProgram.easysrc_toohard.getFirst(); ptr; ptr = generatedCurl_slist) {
					do {
						 ret = (ModernizedCProgram.easysrc_code.easysrc_add(generatedCurl_slist));
						if (ret) {
							return ret;
						} 
					} while (0);
				}
			} 
			do {
				 ret = (ModernizedCProgram.easysrc_code.easysrc_add(""));
				if (ret) {
					return ret;
				} 
			} while (0);
			do {
				 ret = (ModernizedCProgram.easysrc_code.easysrc_add("*/"));
				if (ret) {
					return ret;
				} 
			} while (0);
			ModernizedCProgram.easysrc_toohard.slist_wc_free_all();
			ModernizedCProgram.easysrc_toohard = ((Object)0);
		} 
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add(""));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add("ret = curl_easy_perform(hnd);"));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add(""));
			if (ret) {
				return ret;
			} 
		} while (0);
		return CURLE_OK;
	}
	public static Object easysrc_cleanup() {
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add("curl_easy_cleanup(hnd);"));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			 ret = (ModernizedCProgram.easysrc_code.easysrc_add("hnd = NULL;"));
			if (ret) {
				return ret;
			} 
		} while (0);
		return CURLE_OK;
	}
	/* CURLOPT_CLOSESOCKETFUNCTION */
	public static int close_socket(Object clientp, Object item) {
		.fprintf(stdout, "\nclose_socket : %d", item);
		iterator it = .UNRECOGNIZEDFUNCTIONNAME(item);
		if (it != .UNRECOGNIZEDFUNCTIONNAME()) {
			;
			.UNRECOGNIZEDFUNCTIONNAME(it);
		} 
		return 0;
	}
	public static Object get_libcurl_info() {
		Object[] possibly_built_in = new Object[]{{"dict", CURLPROTO_DICT}, {"file", CURLPROTO_FILE}, {"ftp", CURLPROTO_FTP}, {"ftps", CURLPROTO_FTPS}, {"gopher", CURLPROTO_GOPHER}, {"http", CURLPROTO_HTTP}, {"https", CURLPROTO_HTTPS}, {"imap", CURLPROTO_IMAP}, {"imaps", CURLPROTO_IMAPS}, {"ldap", CURLPROTO_LDAP}, {"ldaps", CURLPROTO_LDAPS}, {"pop3", CURLPROTO_POP3}, {"pop3s", CURLPROTO_POP3S}, {"rtmp", CURLPROTO_RTMP}, {"rtsp", CURLPROTO_RTSP}, {"scp", CURLPROTO_SCP}, {"sftp", CURLPROTO_SFTP}, {"smb", CURLPROTO_SMB}, {"smbs", CURLPROTO_SMBS}, {"smtp", CURLPROTO_SMTP}, {"smtps", CURLPROTO_SMTPS}, {"telnet", CURLPROTO_TELNET}, {"tftp", CURLPROTO_TFTP}, {((Object)0), 0}};
		byte proto;
		ModernizedCProgram.curlinfo = ModernizedCProgram.curl_version_info(/* Pointer to libcurl's run-time version information */CURLVERSION_NOW);
		if (!ModernizedCProgram.curlinfo) {
			return CURLE_FAILED_INIT;
		} 
		ModernizedCProgram.built_in_protos = /* Build CURLPROTO_* bit pattern with libcurl's built-in protocols */0;
		if (ModernizedCProgram.curlinfo.getProtocols()) {
			for (proto = ModernizedCProgram.curlinfo.getProtocols(); proto; proto++) {
				proto_name_pattern p = new proto_name_pattern();
				for (p = possibly_built_in; p.getProto_name(); p++) {
					if (ModernizedCProgram.curl_strequal(proto, p.getProto_name())) {
						ModernizedCProgram.built_in_protos |=  p.getProto_pattern();
						break;
					} 
				}
			}
		} 
		return CURLE_OK;
	}
	/*
	 * Copyright (c) 2011, Jim Hollinger
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 *   * Redistributions of source code must retain the above copyright
	 *     notice, this list of conditions and the following disclaimer.
	 *   * Redistributions in binary form must reproduce the above copyright
	 *     notice, this list of conditions and the following disclaimer in the
	 *     documentation and/or other materials provided with the distribution.
	 *   * Neither the name of Jim Hollinger nor the names of its contributors
	 *     may be used to endorse or promote products derived from this
	 *     software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */
	/* <DESC>
	 * A basic RTSP transfer
	 * </DESC>
	 */
	/* _getch() */
	/* error handling macros */
	/* send RTSP OPTIONS request */
	public static void rtsp_options(Object curl, Object uri) {
		 res = CURLE_OK;
		.printf("\nRTSP: OPTIONS %s\n", uri);
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (uri));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_STREAM_URI", "uri", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), ((long)CURL_RTSPREQ_OPTIONS));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_REQUEST", "(long)CURL_RTSPREQ_OPTIONS", res);
		} 
		;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform(%s) failed: %d\n", "curl", res);
		} 
		;
	}
	/* send RTSP DESCRIBE request and write sdp response to a file */
	public static void rtsp_describe(Object curl, Object uri, Object sdp_filename) {
		 res = CURLE_OK;
		FILE sdp_fp = .fopen(sdp_filename, "wb");
		.printf("\nRTSP: DESCRIBE %s\n", uri);
		if (sdp_fp == ((Object)0)) {
			.fprintf((_iob[2]), "Could not open '%s' for writing\n", sdp_filename);
			sdp_fp = (_iob[1]);
		} else {
				.printf("Writing SDP to '%s'\n", sdp_filename);
		} 
		res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), (sdp_fp));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_WRITEDATA", "sdp_fp", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), ((long)CURL_RTSPREQ_DESCRIBE));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_REQUEST", "(long)CURL_RTSPREQ_DESCRIBE", res);
		} 
		;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform(%s) failed: %d\n", "curl", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_WRITEDATA), ((_iob[1])));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_WRITEDATA", "stdout", res);
		} 
		;
		if (sdp_fp != (_iob[1])) {
			.fclose(sdp_fp);
		} 
	}
	/* send RTSP SETUP request */
	public static void rtsp_setup(Object curl, Object uri, Object transport) {
		 res = CURLE_OK;
		.printf("\nRTSP: SETUP %s\n", uri);
		.printf("      TRANSPORT %s\n", transport);
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (uri));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_STREAM_URI", "uri", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_TRANSPORT), (transport));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_TRANSPORT", "transport", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), ((long)CURL_RTSPREQ_SETUP));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_REQUEST", "(long)CURL_RTSPREQ_SETUP", res);
		} 
		;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform(%s) failed: %d\n", "curl", res);
		} 
		;
	}
	/* send RTSP PLAY request */
	public static void rtsp_play(Object curl, Object uri, Object range) {
		 res = CURLE_OK;
		.printf("\nRTSP: PLAY %s\n", uri);
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_STREAM_URI), (uri));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_STREAM_URI", "uri", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RANGE), (range));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RANGE", "range", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), ((long)CURL_RTSPREQ_PLAY));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_REQUEST", "(long)CURL_RTSPREQ_PLAY", res);
		} 
		;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform(%s) failed: %d\n", "curl", res);
		} 
		;
		res = (curl).curl_easy_setopt((CURLOPT_RANGE), (((Object)0)));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RANGE", "NULL", /* switch off using range again */res);
		} 
		;
	}
	/* send RTSP TEARDOWN request */
	public static void rtsp_teardown(Object curl, Object uri) {
		 res = CURLE_OK;
		.printf("\nRTSP: TEARDOWN %s\n", uri);
		res = (curl).curl_easy_setopt((CURLOPT_RTSP_REQUEST), ((long)CURL_RTSPREQ_TEARDOWN));
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_setopt(%s, %s, %s) failed: %d\n", "curl", "CURLOPT_RTSP_REQUEST", "(long)CURL_RTSPREQ_TEARDOWN", res);
		} 
		;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			.fprintf((_iob[2]), "curl_easy_perform(%s) failed: %d\n", "curl", res);
		} 
		;
	}
	/* convert url into an sdp filename */
	public static void get_sdp_filename(Object url, Byte sdp_filename, Object namelen) {
		byte s = .strrchr(url, (byte)'/');
		.strcpy(sdp_filename, "video.sdp");
		if (s != ((Object)0)) {
			s++;
			if (s[0] != (byte)'\0') {
				.snprintf(sdp_filename, namelen, "%s.sdp", s);
			} 
		} 
	}
	/* scan sdp file for media control attribute */
	public static void get_media_control_attribute(Object sdp_filename, Byte control) {
		int max_len = 256;
		byte s = .malloc(max_len);
		FILE sdp_fp = .fopen(sdp_filename, "rb");
		control[0] = (byte)'\0';
		if (sdp_fp != ((Object)0)) {
			while (.fgets(s, max_len - 2, sdp_fp) != ((Object)0)) {
				.sscanf(s, " a = control: %s", control);
			}
			.fclose(sdp_fp);
		} 
		.free(s);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * This is a simple example showing how a program on a non-ASCII platform
	 * would invoke callbacks to do its own codeset conversions instead of
	 * using the built-in iconv functions in libcurl.
	 * </DESC>
	 */
	/*
	
	   The IBM-1047 EBCDIC codeset is used for this example but the code
	   would be similar for other non-ASCII codesets.
	
	   Three callback functions are created below:
	        my_conv_from_ascii_to_ebcdic,
	        my_conv_from_ebcdic_to_ascii, and
	        my_conv_from_utf8_to_ebcdic
	
	   The "platform_xxx" calls represent platform-specific conversion routines.
	
	 */
	public static Object my_conv_from_ascii_to_ebcdic(Byte buffer, Object length) {
		byte tempptrin;
		byte tempptrout;
		size_t bytes = length;
		int rc;
		tempptrin = tempptrout = buffer;
		rc = .platform_a2e(tempptrin, bytes, tempptrout, bytes);
		if (rc == PLATFORM_CONV_OK) {
			return CURLE_OK;
		} else {
				return CURLE_CONV_FAILED;
		} 
	}
	public static Object my_conv_from_ebcdic_to_ascii(Byte buffer, Object length) {
		byte tempptrin;
		byte tempptrout;
		size_t bytes = length;
		int rc;
		tempptrin = tempptrout = buffer;
		rc = .platform_e2a(tempptrin, bytes, tempptrout, bytes);
		if (rc == PLATFORM_CONV_OK) {
			return CURLE_OK;
		} else {
				return CURLE_CONV_FAILED;
		} 
	}
	public static Object my_conv_from_utf8_to_ebcdic(Byte buffer, Object length) {
		byte tempptrin;
		byte tempptrout;
		size_t bytes = length;
		int rc;
		tempptrin = tempptrout = buffer;
		rc = .platform_u2e(tempptrin, bytes, tempptrout, bytes);
		if (rc == PLATFORM_CONV_OK) {
			return CURLE_OK;
		} else {
				return CURLE_CONV_FAILED;
		} 
	}
	public static  sanitize_file_name(byte sanitized, Object file_name, int flags) {
		byte p;
		byte target;
		size_t len = new size_t();
		SANITIZEcode sc = new SANITIZEcode();
		size_t max_sanitized_len = new size_t();
		if (!sanitized) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		sanitized = ((Object)0);
		if (!file_name) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if ((flags & (1 << 1))) {
			if (file_name[0] == (byte)'\\' && file_name[1] == (byte)'\\') {
				max_sanitized_len = 32767 - /* UNC prefixed path \\ (eg \\?\C:\foo) */1;
			} else {
					max_sanitized_len = 260 - 1;
			} 
		} else {
				max_sanitized_len = (260 - 1 > 255) ? 255 : 260 - /* The maximum length of a filename.
				       FILENAME_MAX is often the same as PATH_MAX, in other words it is 260 and
				       does not discount the path information therefore we shouldn't use it. */1;
		} 
		len = .strlen(file_name);
		if (len > max_sanitized_len) {
			if (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(file_name, max_sanitized_len)) {
				return .SANITIZE_ERR_INVALID_PATH;
			} 
			len = max_sanitized_len;
		} 
		target = .malloc(len + 1);
		if (!target) {
			return .SANITIZE_ERR_OUT_OF_MEMORY;
		} 
		.strncpy(target, file_name, len);
		target[len] = (byte)'\0';
		if ((flags & (1 << 1)) && !.strncmp(target, "\\\\?\\", 4)) {
			p = target + /* Skip the literal path prefix \\?\ */4;
		} else {
				p = target;
		} 
		for (; p; ++/* replace control characters and other banned characters */p) {
			byte banned;
			if ((1 <= p && p <= 31) || (!(flags & ((1 << 0) | (1 << 1))) && p == (byte)':') || (!(flags & (1 << 1)) && (p == (byte)'/' || p == (byte)'\\'))) {
				p = (byte)'_';
				continue;
			} 
			for (banned = "|<>\"?*"; banned; ++banned) {
				if (p == banned) {
					p = (byte)'_';
					break;
				} 
			}
		}
		if (!(flags & (1 << 1)) && /* remove trailing spaces and periods if not allowing paths */len) {
			byte clip = ((Object)0);
			p = target[len];
			do {
				--p;
				if (p != (byte)' ' && p != (byte)'.') {
					break;
				} 
				clip = p;
			} while (p != target);
			if (clip) {
				clip = (byte)'\0';
				len = clip - target;
			} 
		} 
		if (!(flags & (1 << 2))) {
			sc = ModernizedCProgram.rename_if_reserved_dos_device_name(p, target, flags);
			.free(target);
			if (sc) {
				return sc;
			} 
			target = p;
			len = .strlen(target);
			if (len > max_sanitized_len) {
				.free(target);
				return .SANITIZE_ERR_INVALID_PATH;
			} 
		} 
		sanitized = target;
		return .SANITIZE_ERR_OK/*
		Test if truncating a path to a file will leave at least a single character in
		the filename. Filenames suffixed by an alternate data stream can't be
		truncated. This performs a dry run, nothing is modified.
		
		Good truncate_pos 9:    C:\foo\bar  =>  C:\foo\ba
		Good truncate_pos 6:    C:\foo      =>  C:\foo
		Good truncate_pos 5:    C:\foo      =>  C:\fo
		Bad* truncate_pos 5:    C:foo       =>  C:foo
		Bad truncate_pos 5:     C:\foo:ads  =>  C:\fo
		Bad truncate_pos 9:     C:\foo:ads  =>  C:\foo:ad
		Bad truncate_pos 5:     C:\foo\bar  =>  C:\fo
		Bad truncate_pos 5:     C:\foo\     =>  C:\fo
		Bad truncate_pos 7:     C:\foo\     =>  C:\foo\
		Error truncate_pos 7:   C:\foo      =>  (pos out of range)
		Bad truncate_pos 1:     C:\foo\     =>  C
		
		* C:foo is ambiguous, C could end up being a drive or file therefore something
		  like C:superlongfilename can't be truncated.
		
		Returns
		SANITIZE_ERR_OK: Good -- 'path' can be truncated
		SANITIZE_ERR_INVALID_PATH: Bad -- 'path' cannot be truncated
		!= SANITIZE_ERR_OK && != SANITIZE_ERR_INVALID_PATH: Error
		*/;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	/*
	 * Macros ALWAYS_TRUE and ALWAYS_FALSE are used to avoid compiler warnings.
	 */
	/* cannot tell if file is a device */
	/* long file names always available */
	/* DJGPP 2.0 has _use_lfn() */
	/* long file names never available */
	/* _use_lfn(f) prototype */
	public static  truncate_dryrun(Object path, Object truncate_pos) {
		size_t len = new size_t();
		if (!path) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		len = .strlen(path);
		if (truncate_pos > len) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if (!len || !truncate_pos) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		if (.strpbrk(path[truncate_pos - 1], "\\/:")) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		if (truncate_pos > /* C:\foo can be truncated but C:\foo:ads can't */1) {
			byte p = path[truncate_pos - 1];
			do {
				--p;
				if (p == (byte)':') {
					return .SANITIZE_ERR_INVALID_PATH;
				} 
			} while (p != path && p != (byte)'\\' && p != (byte)'/');
		} 
		return .SANITIZE_ERR_OK/* The functions msdosify, rename_if_dos_device_name and __crt0_glob_function
		 * were taken with modification from the DJGPP port of tar 1.12. They use
		 * algorithms originally from DJTAR.
		 *//*
		Extra sanitization MSDOS for file_name.
		
		This is a supporting function for sanitize_file_name.
		
		Warning: This is an MSDOS legacy function and was purposely written in a way
		that some path information may pass through. For example drive letter names
		(C:, D:, etc) are allowed to pass through. For sanitizing a filename use
		sanitize_file_name.
		
		Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
		Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
		*/;
	}
	/* illegal in DOS */
	/* illegal in DOS & W95 */
	/* Support for Windows 9X VFAT systems, when available. */
	/* Get past the drive letter, if any. */
	/* Dots are special: DOS doesn't allow them as the leading character,
	         and a file name cannot have more than a single dot.  We leave the
	         first non-leading dot alone, unless it comes too close to the
	         beginning of the name: we want sh.lex.c to become sh_lex.c, not
	         sh.lex-c.  */
	/* Copy "./" and "../" verbatim.  */
	/* 5 is a heuristic ad-hoc'ery */
	/* replace previous dot */
	/* .c++, .h++ etc. */
	/* libg++ etc.  */
	/* dos_name is truncated, check that truncation requirements are met,
	       specifically truncating a filename suffixed by an alternate data stream
	       or truncating the entire filename is not allowed. */
	/* MSDOS || UNITTESTS */
	/*
	Rename file_name if it's a reserved dos device name.
	
	This is a supporting function for sanitize_file_name.
	
	Warning: This is an MSDOS legacy function and was purposely written in a way
	that some path information may pass through. For example drive letter names
	(C:, D:, etc) are allowed to pass through. For sanitizing a filename use
	sanitize_file_name.
	
	Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
	Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
	*/
	public static  rename_if_reserved_dos_device_name(byte sanitized, Object file_name, int flags) {
		/* We could have a file whose name is a device on MS-DOS.  Trying to
		   * retrieve such a file would fail at best and wedge us at worst.  We need
		   * to rename such files. */byte p;
		byte base;
		byte[] fname = new byte[260];
		if (!sanitized) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		sanitized = ((Object)0);
		if (!file_name) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if ((flags & (1 << /* Ignore UNC prefixed paths, they are allowed to contain a reserved name. */1)) && file_name[0] == (byte)'\\' && file_name[1] == (byte)'\\') {
			size_t len = .strlen(file_name);
			sanitized = .malloc(len + 1);
			if (!sanitized) {
				return .SANITIZE_ERR_OUT_OF_MEMORY;
			} 
			.strncpy(sanitized, file_name, len + 1);
			return .SANITIZE_ERR_OK;
		} 
		if (.strlen(file_name) > 260 - 1 && (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(file_name, 260 - 1))) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		.strncpy(fname, file_name, 260 - 1);
		fname[260 - 1] = (byte)'\0';
		base = ModernizedCProgram.tool_basename((fname/* Rename reserved device names that are known to be accessible without \\.\
		     Examples: CON => _CON, CON.EXT => CON_EXT, CON:ADS => CON_ADS
		     https://support.microsoft.com/en-us/kb/74496
		     https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx
		     */));
		for (p = fname; p; p = (p == fname && fname != base ? base : ((Object)0))) {
			size_t p_len = new size_t();
			int x = (ModernizedCProgram.curl_strnequal(p, "CON", 3) || ModernizedCProgram.curl_strnequal(p, "PRN", 3) || ModernizedCProgram.curl_strnequal(p, "AUX", 3) || ModernizedCProgram.curl_strnequal(p, "NUL", 3)) ? 3 : (ModernizedCProgram.curl_strnequal(p, "CLOCK$", 6)) ? 6 : (ModernizedCProgram.curl_strnequal(p, "COM", 3) || ModernizedCProgram.curl_strnequal(p, "LPT", 3)) ? (((byte)'1' <= p[3] && p[3] <= (byte)'9') ? 4 : 3) : 0;
			if (!x) {
				continue;
			} 
			for (; p[x] == (byte)' '; ++x) {
				;
			}
			if (p[x] == (byte)'.') {
				p[x] = (byte)'_';
				continue;
			}  else if (p[x] == (byte)':') {
				if (!(flags & ((1 << 0) | (1 << 1)))) {
					p[x] = (byte)'_';
					continue;
				} 
				++x;
			}  else if (p[/* no match */x]) {
				continue;
			} 
			p_len = .strlen(/* p points to 'CON' or 'CON ' or 'CON:', etc */p);
			if (.strlen(fname) == 260 - /* Prepend a '_' */1) {
				--p_len;
				if (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(p, p_len)) {
					return .SANITIZE_ERR_INVALID_PATH;
				} 
				p[p_len] = (byte)'\0';
			} 
			.memmove(p + 1, p, p_len + 1);
			p[0] = (byte)'_';
			++p_len;
			if (p == /* if fname was just modified then the basename pointer must be updated */fname) {
				base = ModernizedCProgram.tool_basename((fname/* This is the legacy portion from rename_if_dos_device_name that checks for
				     reserved device names. It only works on MSDOS. On Windows XP the stat
				     check errors with EINVAL if the device name is reserved. On Windows
				     Vista/7/8 it sets mode S_IFREG (regular file or device). According to MSDN
				     stat doc the latter behavior is correct, but that doesn't help us identify
				     whether it's a reserved device name and not a regular file name. */));
			} 
		}
		sanitized = .strdup(fname);
		return (sanitized ? .SANITIZE_ERR_OK : .SANITIZE_ERR_OUT_OF_MEMORY/*
		 * Disable program default argument globbing. We do it on our own.
		 */);
	}
	/* !UNITTESTS (static declarations used if no unit tests) */
	/*
	Sanitize a file or path name.
	
	All banned characters are replaced by underscores, for example:
	f?*foo => f__foo
	f:foo::$DATA => f_foo__$DATA
	f:\foo:bar => f__foo_bar
	f:\foo:bar => f:\foo:bar   (flag SANITIZE_ALLOW_PATH)
	
	This function was implemented according to the guidelines in 'Naming Files,
	Paths, and Namespaces' section 'Naming Conventions'.
	https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx
	
	Flags
	-----
	SANITIZE_ALLOW_COLONS:     Allow colons.
	Without this flag colons are sanitized.
	
	SANITIZE_ALLOW_PATH:       Allow path separators and colons.
	Without this flag path separators and colons are sanitized.
	
	SANITIZE_ALLOW_RESERVED:   Allow reserved device names.
	Without this flag a reserved device name is renamed (COM1 => _COM1) unless it's
	in a UNC prefixed path.
	
	SANITIZE_ALLOW_TRUNCATE:   Allow truncating a long filename.
	Without this flag if the sanitized filename or path will be too long an error
	occurs. With this flag the filename --and not any other parts of the path-- may
	be truncated to at least a single character. A filename followed by an
	alternate data stream (ADS) cannot be truncated in any case.
	
	Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
	Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
	*/
	public static long chunk_bgn(Object finfo, Object ptr, int remains) {
		chunk_data_t ch_d = ptr;
		ch_d.setRemains(remains);
		ModernizedCProgram.curl_mprintf("=============================================================\n");
		ModernizedCProgram.curl_mprintf("Remains:      %d\n", remains);
		ModernizedCProgram.curl_mprintf("Filename:     %s\n", finfo.getFilename());
		if (finfo.getStrings().getPerm()) {
			ModernizedCProgram.curl_mprintf("Permissions:  %s", finfo.getStrings().getPerm());
			if (finfo.getFlags() & CURLFINFOFLAG_KNOWN_PERM) {
				ModernizedCProgram.curl_mprintf(" (parsed => %o)", finfo.getPerm());
			} 
			ModernizedCProgram.curl_mprintf("\n");
		} 
		ModernizedCProgram.curl_mprintf("Size:         %ldB\n", (long)finfo.getSize());
		if (finfo.getStrings().getUser()) {
			ModernizedCProgram.curl_mprintf("User:         %s\n", finfo.getStrings().getUser());
		} 
		if (finfo.getStrings().getGroup()) {
			ModernizedCProgram.curl_mprintf("Group:        %s\n", finfo.getStrings().getGroup());
		} 
		if (finfo.getStrings().getTime()) {
			ModernizedCProgram.curl_mprintf("Time:         %s\n", finfo.getStrings().getTime());
		} 
		ModernizedCProgram.curl_mprintf("Filetype:     ");
		switch (finfo.getFiletype()) {
		case CURLFILETYPE_FILE:
				ModernizedCProgram.curl_mprintf("regular file\n");
				break;
		case CURLFILETYPE_DIRECTORY:
				ModernizedCProgram.curl_mprintf("directory\n");
				break;
		case CURLFILETYPE_SYMLINK:
				ModernizedCProgram.curl_mprintf("symlink\n");
				ModernizedCProgram.curl_mprintf("Target:       %s\n", finfo.getStrings().getTarget());
				break;
		default:
				ModernizedCProgram.curl_mprintf("other type\n");
				break;
		}
		if (finfo.getFiletype() == CURLFILETYPE_FILE) {
			ch_d.setPrint_content(1);
			ModernizedCProgram.curl_mprintf("Content:\n-------------------------------------------------------------\n");
		} 
		if (.strcmp(finfo.getFilename(), "someothertext.txt") == 0) {
			ModernizedCProgram.curl_mprintf("# THIS CONTENT WAS SKIPPED IN CHUNK_BGN CALLBACK #\n");
			return CURL_CHUNK_BGN_FUNC_SKIP;
		} 
		return CURL_CHUNK_BGN_FUNC_OK;
	}
	public static long chunk_end(Object ptr) {
		chunk_data_t ch_d = ptr;
		Object generatedPrint_content = ch_d.getPrint_content();
		if (generatedPrint_content) {
			ch_d.setPrint_content(0);
			ModernizedCProgram.curl_mprintf("-------------------------------------------------------------\n");
		} 
		Object generatedRemains = ch_d.getRemains();
		if (generatedRemains == 1) {
			ModernizedCProgram.curl_mprintf("=============================================================\n");
		} 
		return CURL_CHUNK_END_FUNC_OK;
	}
	public static int perform_and_check_connections(Object curl, Object description, long expected_connections) {
		 res = new ();
		long connections = 0;
		res = curl.curl_easy_perform();
		if (res != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_easy_perform() failed\n");
			return 126;
		} 
		res = curl.curl_easy_getinfo(CURLINFO_NUM_CONNECTS, connections);
		if (res != CURLE_OK) {
			(_iob[2]).curl_mfprintf("curl_easy_getinfo() failed\n");
			return 126;
		} 
		(_iob[2]).curl_mfprintf("%s: expected: %ld connections; actual: %ld connections\n", description, expected_connections, connections);
		if (connections != expected_connections) {
			return 119;
		} 
		return 120;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static Byte GetEnv(Object variable, byte do_expand) {
		byte env = ((Object)0);
		byte[] buf1 = new byte[1024];
		byte[] buf2 = new byte[1024];
		DWORD rc = new DWORD();
		/* Don't use getenv(); it doesn't find variable added after program was
		   * started. Don't accept truncated results (i.e. rc >= sizeof(buf1)).  */
		rc = .GetEnvironmentVariableA(variable, buf1, );
		if (rc > 0 && rc < ) {
			env = buf1;
			variable = buf1;
		} 
		if (do_expand && .strchr(variable, (byte)'%')) {
			rc = .ExpandEnvironmentStringsA(variable, buf2, );
			if (rc > 0 && rc <  && !.strchr(buf2, /* no vars still unexpanded */(byte)'%')) {
				env = buf2;
			} 
		} 
		return (env && env[0]) ? .strdup(env) : ((Object)/* no length control */0);
		byte[] env = new byte[4096];
		byte temp = .getenv(variable);
		env[0] = (byte)'\0';
		if (temp != ((Object)0)) {
			.ExpandEnvironmentStringsA(temp, env, );
		} 
		return (env[0] != (byte)'\0') ? .Curl_cstrdup(env) : ((Object)0);
	}
	/* return the home directory of the current user as an allocated string */
	public static Byte homedir() {
		byte home;
		home = ModernizedCProgram.GetEnv("CURL_HOME", 0);
		if (home) {
			return home;
		} 
		home = ModernizedCProgram.GetEnv("HOME", 0);
		if (home) {
			return home;
		} 
		home = ModernizedCProgram.GetEnv("APPDATA", /* PWD-stuff */1);
		if (!home) {
			home = ModernizedCProgram.GetEnv("%USERPROFILE%\\Application Data", /* Normally only
			                                                               on Win-2K/XP */1);
		} 
		return /* WIN32 */home;
	}
	public static int Curl_wait_ms(int timeout_ms) {
		int r = 0;
		if (!timeout_ms) {
			return 0;
		} 
		if (timeout_ms < 0) {
			(.WSASetLastError((int)(true)));
			return -1;
		} 
		.Sleep(timeout_ms)/* HAVE_POLL_FINE */;/* HAVE_POLL_FINE */
		if (/* Simulate a "call timed out" case *//* USE_WINSOCK */r) {
			r = -1;
		} 
		return r/*
		 * Wait for read or write events on a set of file descriptors. It uses poll()
		 * when a fine poll() is available, in order to avoid limits with FD_SETSIZE,
		 * otherwise select() is used.  An error is returned if select() is being used
		 * and a file descriptor is too large for FD_SETSIZE.
		 *
		 * A negative timeout value makes this function wait indefinitely,
		 * unless no valid file descriptor is given, when this happens the
		 * negative timeout is ignored and the function times out immediately.
		 *
		 * Return values:
		 *   -1 = system call error or fd >= FD_SETSIZE
		 *    0 = timeout
		 *    [bitmask] = action as described below
		 *
		 * CURL_CSELECT_IN - first socket is readable
		 * CURL_CSELECT_IN2 - second socket is readable
		 * CURL_CSELECT_OUT - write socket is writable
		 * CURL_CSELECT_ERR - an error condition occurred
		 */;
	}
	/* two sockets to read from */
	public static int Curl_socket_check(Object readfd0, Object readfd1, Object writefd, Object timeout_ms) {
		timeval pending_tv = new timeval();
		timeval ptimeout = new timeval();
		fd_set fds_read = new fd_set();
		fd_set fds_write = new fd_set();
		fd_set fds_err = new fd_set();
		 maxfd = new ();
		curltime initial_tv = new curltime(0, 0);
		int pending_ms = 0;
		int r;
		int ret;
		/* wrap-around precaution */
		if ((readfd0 == CURL_SOCKET_BAD) && (readfd1 == CURL_SOCKET_BAD) && (writefd == CURL_SOCKET_BAD)) {
			r = ModernizedCProgram.Curl_wait_ms((int)/* no sockets, just wait */timeout_ms);
			return r/* Avoid initial timestamp, avoid Curl_now() call, when elapsed
			     time in this function does not need to be measured. This happens
			     when function is called with a zero timeout or a negative timeout
			     value indicating a blocking call should be performed. */;
		} 
		curltime curltime = new curltime();
		if (timeout_ms > 0) {
			pending_ms = (int)timeout_ms;
			initial_tv = curltime.Curl_now();
		} 
		/* Simulate a "call timed out" case *//* Simulate a "call timed out" case */(((fd_set)(fds_err)).setFd_count(/* HAVE_POLL_FINE */0));
		maxfd = (ModernizedCProgram.curl_socket_t) - 1;
		(((fd_set)(fds_read)).setFd_count(0));
		if (readfd0 != CURL_SOCKET_BAD) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
					if (((fd_set)(fds_read)).getFd_array()[__i] == (readfd0)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_read)).getFd_count()) {
					if (((fd_set)(fds_read)).getFd_count() < 64) {
						((fd_set)(fds_read)).getFd_array()[__i] = (readfd0);
						((fd_set)(fds_read)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (readfd0)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (readfd0);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			maxfd = readfd0;
		} 
		if (readfd1 != CURL_SOCKET_BAD) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
					if (((fd_set)(fds_read)).getFd_array()[__i] == (readfd1)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_read)).getFd_count()) {
					if (((fd_set)(fds_read)).getFd_count() < 64) {
						((fd_set)(fds_read)).getFd_array()[__i] = (readfd1);
						((fd_set)(fds_read)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (readfd1)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (readfd1);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			if (readfd1 > maxfd) {
				maxfd = readfd1;
			} 
		} 
		(((fd_set)(fds_write)).setFd_count(0));
		if (writefd != CURL_SOCKET_BAD) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_write)).getFd_count(); __i++) {
					if (((fd_set)(fds_write)).getFd_array()[__i] == (writefd)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_write)).getFd_count()) {
					if (((fd_set)(fds_write)).getFd_count() < 64) {
						((fd_set)(fds_write)).getFd_array()[__i] = (writefd);
						((fd_set)(fds_write)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (writefd)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (writefd);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			if (writefd > maxfd) {
				maxfd = writefd;
			} 
		} 
		ptimeout = (timeout_ms < 0) ? ((Object)0) : pending_tv;
		Object generatedFd_count = fds_read.getFd_count();
		do {
			int error;
			if (timeout_ms > 0) {
				pending_tv.setTv_sec(pending_ms / 1000);
				pending_tv.setTv_usec((pending_ms % 1000) * 1000);
			}  else if (!timeout_ms) {
				pending_tv.setTv_sec(0);
				pending_tv.setTv_usec(0/* WinSock select() must not be called with an fd_set that contains zero
				       fd flags, or it will return WSAEINVAL.  But, it also can't be called
				       with no fd_sets at all!  From the documentation:
				
				         Any two of the parameters, readfds, writefds, or exceptfds, can be
				         given as null. At least one must be non-null, and any non-null
				         descriptor set must contain at least one handle to a socket.
				
				       We know that we have at least one bit set in at least two fd_sets in
				       this case, but we may have no bits set in either fds_read or fd_write,
				       so check for that and handle it.  Luckily, with WinSock, we can _also_
				       ask how many bits are set on an fd_set.
				
				       It is unclear why WinSock doesn't just handle this for us instead of
				       calling this an error.
				
				       Note also that WinSock ignores the first argument, so we don't worry
				       about the fact that maxfd is computed incorrectly with WinSock (since
				       curl_socket_t is unsigned in such cases and thus -1 is the largest
				       value).
				    */);
			} 
			r = .select((int)maxfd + 1, generatedFd_count ? fds_read : ((Object)0), generatedFd_count ? fds_write : ((Object)0), fds_err, ptimeout);
			if (r != -1) {
				break;
			} 
			error = ((int).WSAGetLastError());
			if (error && (ModernizedCProgram.Curl_ack_eintr || error != -1024)) {
				break;
			} 
			if (timeout_ms > 0) {
				pending_ms = (int)(timeout_ms - (int)curltime.Curl_now().Curl_timediff(initial_tv));
				if (pending_ms <= 0) {
					r = /* Simulate a "call timed out" case */0;
					break;
				} 
			} 
		} while (r == -1);
		if (r < 0) {
			return -1;
		} 
		if (r == 0) {
			return 0;
		} 
		ret = 0;
		if (readfd0 != CURL_SOCKET_BAD) {
			if (.__WSAFDIsSet((SOCKET)(readfd0), (fd_set)(fds_read))) {
				ret |=  CURL_CSELECT_IN;
			} 
			if (.__WSAFDIsSet((SOCKET)(readfd0), (fd_set)(fds_err))) {
				ret |=  CURL_CSELECT_ERR;
			} 
		} 
		if (readfd1 != CURL_SOCKET_BAD) {
			if (.__WSAFDIsSet((SOCKET)(readfd1), (fd_set)(fds_read))) {
				ret |=  (CURL_CSELECT_ERR << 1);
			} 
			if (.__WSAFDIsSet((SOCKET)(readfd1), (fd_set)(fds_err))) {
				ret |=  CURL_CSELECT_ERR;
			} 
		} 
		if (writefd != CURL_SOCKET_BAD) {
			if (.__WSAFDIsSet((SOCKET)(writefd), (fd_set)(fds_write))) {
				ret |=  CURL_CSELECT_OUT;
			} 
			if (.__WSAFDIsSet((SOCKET)(writefd), (fd_set)(fds_err))) {
				ret |=  CURL_CSELECT_ERR;
			} 
		} 
		return ret/* HAVE_POLL_FINE *//*
		 * This is a wrapper around poll().  If poll() does not exist, then
		 * select() is used instead.  An error is returned if select() is
		 * being used and a file descriptor is too large for FD_SETSIZE.
		 * A negative timeout value makes this function wait indefinitely,
		 * unless no valid file descriptor is given, when this happens the
		 * negative timeout is ignored and the function times out immediately.
		 *
		 * Return values:
		 *   -1 = system call error or fd >= FD_SETSIZE
		 *    0 = timeout
		 *    N = number of structures with non zero revent fields
		 */;
	}
	/* socket to write to */
	/* milliseconds to wait */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_gethostname() is a wrapper around gethostname() which allows
	 * overriding the host name that the function would normally return.
	 * This capability is used by the test suite to verify exact matching
	 * of NTLM authentication, which exercises libcurl's MD4 and DES code
	 * as well as by the SMTP module when a hostname is not provided.
	 *
	 * For libcurl debug enabled builds host name overriding takes place
	 * when environment variable CURL_GETHOSTNAME is set, using the value
	 * held by the variable to override returned host name.
	 *
	 * Note: The function always returns the un-qualified hostname rather
	 * than being provider dependent.
	 *
	 * For libcurl shared library release builds the test suite preloads
	 * another shared library named libhostname using the LD_PRELOAD
	 * mechanism which intercepts, and might override, the gethostname()
	 * function call. In this case a given platform must support the
	 * LD_PRELOAD mechanism and additionally have environment variable
	 * CURL_GETHOSTNAME set in order to override the returned host name.
	 *
	 * For libcurl static library release builds no overriding takes place.
	 */
	public static int Curl_gethostname(Byte name, int namelen) {
		int err;
		byte dot;
		/* Override host name when environment variable CURL_GETHOSTNAME is set */
		name[0] = /* DEBUGBUILD *//* The call to system's gethostname() might get intercepted by the
		     libhostname library when libcurl is built as a non-debug shared
		     library when running the test suite. */(byte)'\0';
		err = ModernizedCProgram.gethostname(name, namelen);
		name[namelen - 1] = (byte)'\0';
		if (err) {
			return err;
		} 
		dot = .strchr(name, /* Truncate domain, leave only machine name */(byte)'.');
		if (dot) {
			dot = (byte)'\0';
		} 
		return 0;
	}
	/* Allow compilation and return failure when unavailable */
	/* Allow compilation and return failure when unavailable */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* OUR_MAX_SEEK_L has 'long' data type, OUR_MAX_SEEK_O has 'curl_off_t,
	   both represent the same value. Maximum offset used here when we lseek
	   using a 'long' data type offset */
	/*
	** callback for CURLOPT_SEEKFUNCTION
	**
	** Notice that this is not supposed to return the resulting offset. This
	** shall only return CURL_SEEKFUNC_* return codes.
	*/
	public static int tool_seek_cb(Object userdata, Object offset, int whence) {
		InStruct in = userdata/* The offset check following here is only interesting if curl_off_t is
		     larger than off_t and we are not using the WIN32 large file support
		     macros that provide the support to do 64bit seeks correctly *//* Some precaution code to work around problems with different data sizes
		       to allow seeking >32bit even if off_t is 32bit. Should be very rare and
		       is really valid on weirdo-systems. */;
		/* this code path doesn't support other types */
		int generatedFd = in.getFd();
		/* couldn't rewind to beginning */if ((long)-1 == ._lseeki64(generatedFd, offset, /* couldn't seek forwards the desired amount */whence/* couldn't rewind, the reason is in errno but errno is just not portable
		       enough and we don't actually care that much why we failed. We'll let
		       libcurl know that it may try other means if it wants to. */)) {
			return CURL_SEEKFUNC_CANTSEEK;
		} 
		return CURL_SEEKFUNC_OK/* 64-bit lseek-like function unavailable */;
	}
	/* 64-bit lseek-like function unavailable */
	/* 64-bit lseek-like function unavailable */
	/*
	 * Truncate a file handle at a 64-bit position 'where'.
	 */
	public static int tool_ftruncate64(int fd, Object where) {
		intptr_t handle = ._get_osfhandle(fd);
		if (._lseeki64(fd, where, 0) < 0) {
			return -1;
		} 
		if (!.SetEndOfFile((HANDLE)handle)) {
			return -1;
		} 
		return 0/* WIN32  && ! __MINGW64__ */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NOTE:
	 *
	 * In the ISO C standard (IEEE Std 1003.1), there is a strtoimax() function we
	 * could use in case strtoll() doesn't exist...  See
	 * https://www.opengroup.org/onlinepubs/009695399/functions/strtoimax.html
	 */
	/* Range tests can be used for alphanum decoding if characters are consecutive,
	   like in ASCII. Else an array is scanned. Determine this condition now. */
	/**
	 * Custom version of the strtooff function.  This extracts a curl_off_t
	 * value from the given input string and returns it.
	 */
	/* Skip leading whitespace. */
	/* Handle the sign, if any. */
	/* We had nothing but perhaps some whitespace -- there was no number. */
	/* Handle special beginnings, if present and allowed. */
	/* Matching strtol, if the base is 0 and it doesn't look like
	   * the number is octal or hex, we assume it's base 10.
	   */
	/* Loop handling digits. */
	/* We've overflowed. */
	/* Fix the sign. */
	/**
	 * Returns the value of c in the given base, or -1 if c cannot
	 * be interpreted properly in that base (i.e., is out of range,
	 * is a null, etc.).
	 *
	 * @param c     the character to interpret according to base
	 * @param base  the base in which to interpret c
	 *
	 * @return  the value of c in base, or -1 if c isn't in range
	 */
	/* Lowercase. */
	/* Only present if we need strtoll, but don't have it. */
	/*
	 * Parse a *positive* up to 64 bit number written in ascii.
	 */
	public static  curlx_strtoofft(Object str, byte endp, int base, Object num) {
		byte end;
		 number = new ();
		(._errno()) = 0;
		num = /* clear by default */0;
		while (str && (ModernizedCProgram.Curl_isspace((int)((byte)str)))) {
			str++;
		}
		if ((byte)'-' == str) {
			if (endp) {
				endp = (byte)/* didn't actually move */str;
			} 
			return /* nothing parsed */.CURL_OFFT_INVAL;
		} 
		number = .strtoll(str, end, base);
		if (endp) {
			endp = end;
		} 
		if ((._errno()) == 34) {
			return /* overflow/underflow */.CURL_OFFT_FLOW;
		}  else if (str == end) {
			return /* nothing parsed */.CURL_OFFT_INVAL;
		} 
		num = number;
		return .CURL_OFFT_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * we force our own host name, in order to make some tests machine independent
	 */
	public static int gethostname(Byte name, int namelen) {
		byte force_hostname = .getenv("CURL_GETHOSTNAME");
		if (force_hostname) {
			.strncpy(name, force_hostname, namelen);
			name[namelen - 1] = (byte)'\0';
			return 0;
		} 
		return -/* LD_PRELOAD used, but no hostname set, we'll just return a failure */1;
	}
	public static Object callback(Byte ptr, Object size, Object nmemb, Object data) {
		ssize_t idx = (()data) - ModernizedCProgram.easy;
		 sock = new ();
		long longdata;
		 code = new ();
		size_t failure = (size && nmemb) ? 0 : 1;
		(Object)ptr;
		ModernizedCProgram.counter[idx] += (int)(size * nmemb);
		code = ModernizedCProgram.easy[idx].curl_easy_getinfo(CURLINFO_LASTSOCKET, /* Get socket being used for this easy handle, otherwise CURL_SOCKET_BAD */longdata);
		if (CURLE_OK != code) {
			(_iob[2]).curl_mfprintf("%s:%d curl_easy_getinfo() failed, with code %d (%s)\n", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\libntlmconnect.c", 55, (int)code, ModernizedCProgram.curl_easy_strerror(code));
			ModernizedCProgram.res = 126;
			return failure;
		} 
		if (longdata == --1024) {
			sock = CURL_SOCKET_BAD;
		} else {
				sock = ()longdata;
		} 
		if (sock != CURL_SOCKET_BAD) {
			if (ModernizedCProgram.sockets[idx] == /* Track relationship between this easy handle and the socket. */CURL_SOCKET_BAD) {
				ModernizedCProgram.sockets[idx] = /* An easy handle without previous socket, record the socket. */sock;
			}  else if (sock != ModernizedCProgram.sockets[idx/* An easy handle with a socket different to previously
			         tracked one, log and fail right away. Known bug #37. */]) {
				(_iob[2]).curl_mfprintf("Handle %d started on socket %d and moved to %d\n", ModernizedCProgram.curlx_sztosi(idx), (int)ModernizedCProgram.sockets[idx], (int)sock);
				ModernizedCProgram.res = 126;
				return failure;
			} 
		} 
		return size * nmemb;
	}
	public static int debugf_cb(Object handle, Object type, Byte buf, Object size, Object userptr) {
		(Object)handle;
		(Object)type;
		(Object)userptr;
		.memset(ModernizedCProgram.result, (byte)'\0', );
		.memcpy(ModernizedCProgram.result, buf, size);
		return 0;
	}
	/*
	 * This debugf callback is simply dumping the string into the static buffer
	 * for the unit test to inspect. Since we know that we're only dealing with
	 * text we can afford the luxury of skipping the type check here.
	 */
	/*
	 * read-wrapper to support reading from stdin on Windows.
	 */
	public static Object read_wincon(int fd, Object buf, Object count) {
		HANDLE handle = ((Object)0);
		DWORD mode = new DWORD();
		DWORD rcount = 0;
		BOOL success = new BOOL();
		if (fd == (((_iob[0])).get_file())) {
			handle = .GetStdHandle((DWORD)(true));
		} else {
				return ModernizedCProgram.curlx_read(fd, buf, count);
		} 
		if (.GetConsoleMode(handle, mode)) {
			success = .ReadConsoleA(handle, buf, ModernizedCProgram.curlx_uztoul(count), rcount, ((Object)0));
		} else {
				success = .ReadFile(handle, buf, ModernizedCProgram.curlx_uztoul(count), rcount, ((Object)0));
		} 
		if (success) {
			return rcount;
		} 
		(._errno()) = .GetLastError();
		return -1;
	}
	/*
	 * write-wrapper to support writing to stdout and stderr on Windows.
	 */
	public static Object write_wincon(int fd, Object buf, Object count) {
		HANDLE handle = ((Object)0);
		DWORD mode = new DWORD();
		DWORD wcount = 0;
		BOOL success = new BOOL();
		if (fd == (((_iob[1])).get_file())) {
			handle = .GetStdHandle((DWORD)(true));
		}  else if (fd == (((_iob[2])).get_file())) {
			handle = .GetStdHandle((DWORD)(true));
		} else {
				return ModernizedCProgram.curlx_write(fd, buf, count);
		} 
		if (.GetConsoleMode(handle, mode)) {
			success = .WriteConsoleA(handle, buf, ModernizedCProgram.curlx_uztoul(count), wcount, ((Object)0));
		} else {
				success = .WriteFile(handle, buf, ModernizedCProgram.curlx_uztoul(count), wcount, ((Object)0));
		} 
		if (success) {
			return wcount;
		} 
		(._errno()) = .GetLastError();
		return -1/*
		 * fullread is a wrapper around the read() function. This will repeat the call
		 * to read() until it actually has read the complete number of bytes indicated
		 * in nbytes or it fails with a condition that cannot be handled with a simple
		 * retry of the read call.
		 */;
	}
	public static Object fullread(int filedes, Object buffer, Object nbytes) {
		int error;
		ssize_t nread = 0;
		do {
			ssize_t rc = ModernizedCProgram.read_wincon(filedes, (byte)buffer + nread, nbytes - nread);
			if (ModernizedCProgram.got_exit_signal) {
				ModernizedCProgram.logmsg("signalled to die");
				return -1;
			} 
			if (rc < 0) {
				error = (._errno());
				if ((error == 4) || (error == 11)) {
					continue;
				} 
				ModernizedCProgram.logmsg("reading from file descriptor: %d,", filedes);
				ModernizedCProgram.logmsg("unrecoverable read() failure: (%d) %s", error, .strerror(error));
				return -1;
			} 
			if (rc == 0) {
				ModernizedCProgram.logmsg("got 0 reading from stdin");
				return 0;
			} 
			nread += rc;
		} while ((size_t)nread < nbytes);
		if (ModernizedCProgram.verbose) {
			ModernizedCProgram.logmsg("read %zd bytes", nread);
		} 
		return nread/*
		 * fullwrite is a wrapper around the write() function. This will repeat the
		 * call to write() until it actually has written the complete number of bytes
		 * indicated in nbytes or it fails with a condition that cannot be handled
		 * with a simple retry of the write call.
		 */;
	}
	public static Object fullwrite(int filedes, Object buffer, Object nbytes) {
		int error;
		ssize_t nwrite = 0;
		do {
			ssize_t wc = ModernizedCProgram.write_wincon(filedes, (byte)buffer + nwrite, nbytes - nwrite);
			if (ModernizedCProgram.got_exit_signal) {
				ModernizedCProgram.logmsg("signalled to die");
				return -1;
			} 
			if (wc < 0) {
				error = (._errno());
				if ((error == 4) || (error == 11)) {
					continue;
				} 
				ModernizedCProgram.logmsg("writing to file descriptor: %d,", filedes);
				ModernizedCProgram.logmsg("unrecoverable write() failure: (%d) %s", error, .strerror(error));
				return -1;
			} 
			if (wc == 0) {
				ModernizedCProgram.logmsg("put 0 writing to stdout");
				return 0;
			} 
			nwrite += wc;
		} while ((size_t)nwrite < nbytes);
		if (ModernizedCProgram.verbose) {
			ModernizedCProgram.logmsg("wrote %zd bytes", nwrite);
		} 
		return nwrite/*
		 * read_stdin tries to read from stdin nbytes into the given buffer. This is a
		 * blocking function that will only return TRUE when nbytes have actually been
		 * read or FALSE when an unrecoverable error has been detected. Failure of this
		 * function is an indication that the sockfilt process should terminate.
		 */;
	}
	public static  read_stdin(Object buffer, Object nbytes) {
		ssize_t nread = ModernizedCProgram.fullread((((_iob[0])).get_file()), buffer, nbytes);
		if (nread != (ssize_t)nbytes) {
			ModernizedCProgram.logmsg("exiting...");
			return 0;
		} 
		return 1/*
		 * write_stdout tries to write to stdio nbytes from the given buffer. This is a
		 * blocking function that will only return TRUE when nbytes have actually been
		 * written or FALSE when an unrecoverable error has been detected. Failure of
		 * this function is an indication that the sockfilt process should terminate.
		 */;
	}
	public static  write_stdout(Object buffer, Object nbytes) {
		ssize_t nwrite = ModernizedCProgram.fullwrite((((_iob[1])).get_file()), buffer, nbytes);
		if (nwrite != (ssize_t)nbytes) {
			ModernizedCProgram.logmsg("exiting...");
			return 0;
		} 
		return 1;
	}
	public static void lograw(Byte buffer, Object len) {
		byte[] data = new byte[120];
		ssize_t i = new ssize_t();
		byte ptr = buffer;
		byte optr = data;
		ssize_t width = 0;
		int left = ;
		for (i = 0; i < len; i++) {
			switch (ptr[i]) {
			case (byte)'\r':
					ModernizedCProgram.curl_msnprintf(optr, left, "\\r");
					width += 2;
					optr += 2;
					left -= 2;
					break;
			case (byte)'\n':
					ModernizedCProgram.curl_msnprintf(optr, left, "\\n");
					width += 2;
					optr += 2;
					left -= 2;
					break;
			default:
					ModernizedCProgram.curl_msnprintf(optr, left, "%c", ((ModernizedCProgram.Curl_isgraph((int)((byte)ptr[i]))) || ptr[i] == -1024) ? ptr[i] : (byte)'.');
					width++;
					optr++;
					left--;
					break;
			}
			if (width > 60) {
				ModernizedCProgram.logmsg("'%s'", data);
				width = 0;
				optr = data;
				left = ;
			} 
		}
		if (width) {
			ModernizedCProgram.logmsg("'%s'", data/*
			 * WinSock select() does not support standard file descriptors,
			 * it can only check SOCKETs. The following function is an attempt
			 * to re-create a select() function with support for other handle types.
			 *
			 * select() function with support for WINSOCK2 sockets and all
			 * other handle types supported by WaitForMultipleObjectsEx() as
			 * well as disk files, anonymous and names pipes, and character input.
			 *
			 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms687028.aspx
			 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms741572.aspx
			 */);
		} 
	}
	public static Object select_ws_wait_thread(Object lpParameter) {
		select_ws_wait_data data = new select_ws_wait_data();
		HANDLE handle = new HANDLE();
		HANDLE[] handles = new HANDLE();
		INPUT_RECORD inputrecord = new INPUT_RECORD();
		LARGE_INTEGER size = new LARGE_INTEGER();
		LARGE_INTEGER pos = new LARGE_INTEGER();
		DWORD type = new DWORD();
		DWORD length = new DWORD();
		data = (select_ws_wait_data)/* retrieve handles from internal structure */lpParameter;
		Object generatedHandle = data.getHandle();
		Object generatedEvent = data.getEvent();
		if (data) {
			handle = generatedHandle;
			handles[0] = generatedEvent;
			handles[1] = handle;
			.free(data);
		} else {
				return (DWORD)-1;
		} 
		type = .GetFileType(/* retrieve the type of file to wait on */handle);
		Object generatedLowPart = size.getLowPart();
		Object generatedHighPart = pos.getHighPart();
		Object generatedQuadPart = size.getQuadPart();
		Object generatedEventType = inputrecord.getEventType();
		switch (type) {
		case 3/* The handle represents an anonymous or named pipe, this means:
		        * - WaitForMultipleObjectsEx will always be signalled for it.
		        * - peek into the pipe and retrieve the amount of data available.
		        *
		        * Approach: Loop till either the internal event is signalled
		        *           or there is data in the pipe available for reading.
		        */:
				while (.WaitForMultipleObjectsEx(1, handles, 0, 0, 0) == -1024) {
					length = /* peek into the pipe and retrieve the amount of data available */0;
					if (.PeekNamedPipe(handle, ((Object)0), 0, ((Object)0), length, ((Object)0))) {
						if (length == /* if there is no data available, sleep and continue waiting */0) {
							.SleepEx(0, 0);
							continue;
						} 
					} else {
							if (.GetLastError() == /* if the pipe has been closed, sleep and continue waiting */-1024) {
								.SleepEx(0, 0);
								continue;
							} 
					} 
					break;
				}
				break;
		case 1/* The handle represents a file on disk, this means:
		        * - WaitForMultipleObjectsEx will always be signalled for it.
		        * - comparison of current position in file and total size of
		        *   the file can be used to check if we reached the end yet.
		        *
		        * Approach: Loop till either the internal event is signalled
		        *           or if the end of the file has already been reached.
		        */:
				while (.WaitForMultipleObjectsEx(1, handles, 0, 0, 0) == -1024) {
					length = /* get total size of file */0;
					size.setQuadPart(0);
					size.setLowPart(.GetFileSize(handle, length));
					if ((generatedLowPart != -1024) || (.GetLastError() == -1024)) {
						size.setHighPart(length);
						pos.setQuadPart(/* get the current position within the file */0);
						pos.setLowPart(.SetFilePointer(handle, 0, generatedHighPart, 1));
						if ((generatedLowPart != ((DWORD)-1)) || (.GetLastError() == -1024)) {
							if (generatedQuadPart == generatedQuadPart) {
								.SleepEx(0, /* sleep and continue waiting */0);
								continue;
							} 
						} 
					} 
					break;
				}
				break;
		case 2/* The handle represents a character input, this means:
		        * - WaitForMultipleObjectsEx will be signalled on any kind of input,
		        *   including mouse and window size events we do not care about.
		        *
		        * Approach: Loop till either the internal event is signalled
		        *           or we get signalled for an actual key-event.
		        */:
				while (.WaitForMultipleObjectsEx(2, handles, 0, -1024, 0) == 0 + 1) {
					length = /* check if this is an actual console handle */0;
					if (.GetConsoleMode(handle, length)) {
						length = /* retrieve an event from the console buffer */0;
						if (.PeekConsoleInputA(handle, inputrecord, 1, length)) {
							if (length == 1 && generatedEventType != /* check if the event is not an actual key-event */1) {
								.ReadConsoleInputA(handle, inputrecord, 1, /* purge the non-key-event and continue waiting */length);
								continue;
							} 
						} 
					} 
					break;
				}
				break;
		default:
				.WaitForMultipleObjectsEx(2, handles, 0, -1024, /* The handle has an unknown type, try to wait on it */0);
				break;
		}
		return 0;
	}
	public static Object select_ws_wait(Object handle, Object event) {
		select_ws_wait_data data = new select_ws_wait_data();
		HANDLE thread = ((Object)0);
		data = .malloc(/* allocate internal waiting data structure */);
		if (data) {
			data.setHandle(handle);
			data.setEvent(event);
			thread = .CreateThread(((Object)0), /* launch waiting thread */0, select_ws_wait_thread, data, 0, ((Object)0));
			if (!/* free data if thread failed to launch */thread) {
				.free(data);
			} 
		} 
		return thread;
	}
	public static int select_ws(int nfds, fd_set readfds, fd_set writefds, fd_set exceptfds, timeval timeout) {
		DWORD milliseconds = new DWORD();
		DWORD wait = new DWORD();
		DWORD idx = new DWORD();
		WSANETWORKEVENTS wsanetevents = new WSANETWORKEVENTS();
		select_ws_data data = new select_ws_data();
		HANDLE handle = new HANDLE();
		HANDLE handles = new HANDLE();
		HANDLE wsaevent = new HANDLE();
		int error;
		int fds;
		HANDLE waitevent = ((Object)0);
		DWORD nfd = 0;
		DWORD thd = 0;
		DWORD wsa = 0;
		int ret = 0;
		if (nfds < /* check if the input value is valid */0) {
			(._errno()) = 22;
			return -1;
		} 
		long generatedTv_sec = timeout.getTv_sec();
		long generatedTv_usec = timeout.getTv_usec();
		if (!/* check if we got descriptors, sleep in case we got none */nfds) {
			.Sleep((generatedTv_sec * 1000) + (DWORD)(((double)generatedTv_usec) / 1000.0));
			return 0;
		} 
		waitevent = .CreateEventA(((Object)0), 1, 0, ((Object)/* create internal event to signal waiting threads */0));
		if (!waitevent) {
			(._errno()) = 12;
			return -1;
		} 
		data = .calloc(nfds, /* allocate internal array for the internal data */);
		if (data == ((Object)0)) {
			.CloseHandle(waitevent);
			(._errno()) = 12;
			return -1;
		} 
		handles = .calloc(nfds, /* allocate internal array for the internal event handles */);
		if (handles == ((Object)0)) {
			.CloseHandle(waitevent);
			.free(data);
			(._errno()) = 12;
			return -1;
		} 
		for (fds = 0; fds < nfds; /* loop over the handles in the input descriptor sets */fds++) {
			long networkevents = 0;
			handles[nfd] = 0;
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(readfds))) {
				networkevents |=  (1 << 0) | (1 << 3) | (1 << 5);
			} 
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(writefds))) {
				networkevents |=  (1 << 1) | (1 << 4);
			} 
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(exceptfds))) {
				networkevents |=  (1 << 2) | (1 << 5);
			} 
			if (/* only wait for events for which we actually care */networkevents) {
				data[nfd].setFd(ModernizedCProgram.curlx_sitosk(fds));
				if (fds == (((_iob[0])).get_file())) {
					handle = .GetStdHandle((DWORD)(true));
					handle = ModernizedCProgram.select_ws_wait(handle, waitevent);
					handles[nfd] = handle;
					data[thd].setThread(handle);
					thd++;
				}  else if (fds == (((_iob[1])).get_file())) {
					handles[nfd] = .GetStdHandle((DWORD)(true));
				}  else if (fds == (((_iob[2])).get_file())) {
					handles[nfd] = .GetStdHandle((DWORD)(true));
				} else {
						wsaevent = .WSACreateEvent();
						if (wsaevent != ((HANDLE)((Object)0))) {
							error = .WSAEventSelect(fds, wsaevent, networkevents);
							if (error != (true)) {
								handle = (HANDLE)wsaevent;
								handles[nfd] = handle;
								data[wsa].setWsasock(ModernizedCProgram.curlx_sitosk(fds));
								data[wsa].setWsaevent(wsaevent);
								wsa++;
							} else {
									 socket = ModernizedCProgram.curlx_sitosk(fds);
									.WSACloseEvent(wsaevent);
									handle = (HANDLE)socket;
									handle = ModernizedCProgram.select_ws_wait(handle, waitevent);
									handles[nfd] = handle;
									data[thd].setThread(handle);
									thd++;
							} 
						} 
				} 
				nfd++;
			} 
		}
		if (/* convert struct timeval to milliseconds */timeout) {
			milliseconds = ((generatedTv_sec * 1000) + (generatedTv_usec / 1000));
		} else {
				milliseconds = -1024;
		} 
		wait = .WaitForMultipleObjectsEx(nfd, handles, 0, milliseconds, /* wait for one of the internal handles to trigger */0);
		.SetEvent(/* signal the event handle for the waiting threads */waitevent);
		Object generatedLNetworkEvents = wsanetevents.getLNetworkEvents();
		for (idx = 0; idx < nfd; /* loop over the internal handles returned in the descriptors */idx++) {
			 sock = data[idx].getFd();
			handle = handles[idx];
			fds = ModernizedCProgram.curlx_sktosi(sock);
			if (wait != ((DWORD)-1024) && (wait - 0) <= /* check if the current internal handle was triggered */idx && .WaitForSingleObjectEx(handle, 0, 0) == 0) {
				if (fds == (((_iob[0])).get_file())) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(writefds)).getFd_count(); __i++) {
							if (((fd_set)(writefds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(writefds)).getFd_count() - 1) {
									((fd_set)(writefds)).getFd_array()[__i] = ((fd_set)(writefds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(writefds)).getFd_count()--;
								break;
							} 
						}
					} while (/* stdin is never ready for write or exceptional */0);
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(exceptfds)).getFd_count(); __i++) {
							if (((fd_set)(exceptfds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(exceptfds)).getFd_count() - 1) {
									((fd_set)(exceptfds)).getFd_array()[__i] = ((fd_set)(exceptfds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(exceptfds)).getFd_count()--;
								break;
							} 
						}
					} while (0);
				}  else if (fds == (((_iob[1])).get_file()) || fds == (((_iob[2])).get_file())) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(readfds)).getFd_count(); __i++) {
							if (((fd_set)(readfds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(readfds)).getFd_count() - 1) {
									((fd_set)(readfds)).getFd_array()[__i] = ((fd_set)(readfds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(readfds)).getFd_count()--;
								break;
							} 
						}
					} while (/* stdout and stderr are never ready for read or exceptional */0);
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(exceptfds)).getFd_count(); __i++) {
							if (((fd_set)(exceptfds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(exceptfds)).getFd_count() - 1) {
									((fd_set)(exceptfds)).getFd_array()[__i] = ((fd_set)(exceptfds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(exceptfds)).getFd_count()--;
								break;
							} 
						}
					} while (0);
				} else {
						wsanetevents.setLNetworkEvents(/* try to handle the event with the WINSOCK2 functions */0);
						error = .WSAEnumNetworkEvents(fds, handle, wsanetevents);
						if (error != (true)) {
							if (!(generatedLNetworkEvents & ((1 << 0) | (1 << 3) | (1 << /* remove from descriptor set if not ready for read/accept/close */5)))) {
								do {
									u_int __i = new u_int();
									for (__i = 0; __i < ((fd_set)(readfds)).getFd_count(); __i++) {
										if (((fd_set)(readfds)).getFd_array()[__i] == (sock)) {
											while (__i < ((fd_set)(readfds)).getFd_count() - 1) {
												((fd_set)(readfds)).getFd_array()[__i] = ((fd_set)(readfds)).getFd_array()[__i + 1];
												__i++;
											}
											((fd_set)(readfds)).getFd_count()--;
											break;
										} 
									}
								} while (0);
							} 
							if (!(generatedLNetworkEvents & ((1 << 1) | (1 << /* remove from descriptor set if not ready for write/connect */4)))) {
								do {
									u_int __i = new u_int();
									for (__i = 0; __i < ((fd_set)(writefds)).getFd_count(); __i++) {
										if (((fd_set)(writefds)).getFd_array()[__i] == (sock)) {
											while (__i < ((fd_set)(writefds)).getFd_count() - 1) {
												((fd_set)(writefds)).getFd_array()[__i] = ((fd_set)(writefds)).getFd_array()[__i + 1];
												__i++;
											}
											((fd_set)(writefds)).getFd_count()--;
											break;
										} 
									}
								} while (0/* HACK:
								           * use exceptfds together with readfds to signal
								           * that the connection was closed by the client.
								           *
								           * Reason: FD_CLOSE is only signaled once, sometimes
								           * at the same time as FD_READ with data being available.
								           * This means that recv/sread is not reliable to detect
								           * that the connection is closed.
								           */);
							} 
							if (!(generatedLNetworkEvents & ((1 << 2) | (1 << /* remove from descriptor set if not exceptional */5)))) {
								do {
									u_int __i = new u_int();
									for (__i = 0; __i < ((fd_set)(exceptfds)).getFd_count(); __i++) {
										if (((fd_set)(exceptfds)).getFd_array()[__i] == (sock)) {
											while (__i < ((fd_set)(exceptfds)).getFd_count() - 1) {
												((fd_set)(exceptfds)).getFd_array()[__i] = ((fd_set)(exceptfds)).getFd_array()[__i + 1];
												__i++;
											}
											((fd_set)(exceptfds)).getFd_count()--;
											break;
										} 
									}
								} while (0);
							} 
						} 
				} 
				if (.__WSAFDIsSet((SOCKET)(sock), (fd_set)(readfds)) || .__WSAFDIsSet((SOCKET)(sock), (fd_set)(/* check if the event has not been filtered using specific tests */writefds)) || .__WSAFDIsSet((SOCKET)(sock), (fd_set)(exceptfds))) {
					ret++;
				} 
			} else {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(readfds)).getFd_count(); __i++) {
							if (((fd_set)(readfds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(readfds)).getFd_count() - 1) {
									((fd_set)(readfds)).getFd_array()[__i] = ((fd_set)(readfds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(readfds)).getFd_count()--;
								break;
							} 
						}
					} while (/* remove from all descriptor sets since this handle did not trigger */0);
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(writefds)).getFd_count(); __i++) {
							if (((fd_set)(writefds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(writefds)).getFd_count() - 1) {
									((fd_set)(writefds)).getFd_array()[__i] = ((fd_set)(writefds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(writefds)).getFd_count()--;
								break;
							} 
						}
					} while (0);
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(exceptfds)).getFd_count(); __i++) {
							if (((fd_set)(exceptfds)).getFd_array()[__i] == (sock)) {
								while (__i < ((fd_set)(exceptfds)).getFd_count() - 1) {
									((fd_set)(exceptfds)).getFd_array()[__i] = ((fd_set)(exceptfds)).getFd_array()[__i + 1];
									__i++;
								}
								((fd_set)(exceptfds)).getFd_count()--;
								break;
							} 
						}
					} while (0);
			} 
		}
		for (fds = 0; fds < nfds; fds++) {
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(readfds))) {
				ModernizedCProgram.logmsg("select_ws: %d is readable", fds);
			} 
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(writefds))) {
				ModernizedCProgram.logmsg("select_ws: %d is writable", fds);
			} 
			if (.__WSAFDIsSet((SOCKET)(fds), (fd_set)(exceptfds))) {
				ModernizedCProgram.logmsg("select_ws: %d is excepted", fds);
			} 
		}
		for (idx = 0; idx < wsa; idx++) {
			.WSAEventSelect(data[idx].getWsasock(), ((Object)0), 0);
			.WSACloseEvent(data[idx].getWsaevent());
		}
		for (idx = 0; idx < thd; idx++) {
			.WaitForSingleObject(data[idx].getThread(), -1024);
			.CloseHandle(data[idx].getThread());
		}
		.CloseHandle(waitevent);
		.free(handles);
		.free(data);
		return ret/* USE_WINSOCK *//*
		  sockfdp is a pointer to an established stream or CURL_SOCKET_BAD
		
		  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
		  accept()
		*/;
	}
	public static  juggle(Object sockfdp, Object listenfd, sockmode mode) {
		timeval timeout = new timeval();
		fd_set fds_read = new fd_set();
		fd_set fds_write = new fd_set();
		fd_set fds_err = new fd_set();
		 sockfd = CURL_SOCKET_BAD;
		int maxfd = -99;
		ssize_t rc = new ssize_t();
		int error = 0;
		byte[] buffer = new byte[/* 'buffer' is this excessively large only to be able to support things like
		    test 1003 which tests exceedingly large server response lines */17010];
		byte[] data = new byte[16];
		if (ModernizedCProgram.got_exit_signal) {
			ModernizedCProgram.logmsg("signalled to die, exiting...");
			return 0/* As a last resort, quit if sockfilt process becomes orphan. Just in case
			     parent ftpserver process has died without killing its sockfilt children */;
		} 
		timeout.setTv_sec(120);
		timeout.setTv_usec(0);
		(((fd_set)(fds_read)).setFd_count(0));
		(((fd_set)(fds_write)).setFd_count(0));
		(((fd_set)(fds_err)).setFd_count(0));
		do {
			u_int __i = new u_int();
			for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
				if (((fd_set)(fds_read)).getFd_array()[__i] == (.UNRECOGNIZEDFUNCTIONNAME(((_iob[0])).get_file()))) {
					break;
				} 
			}
			if (__i == ((fd_set)(fds_read)).getFd_count()) {
				if (((fd_set)(fds_read)).getFd_count() < 64) {
					((fd_set)(fds_read)).getFd_array()[__i] = (.UNRECOGNIZEDFUNCTIONNAME(((_iob[0])).get_file()));
					((fd_set)(fds_read)).getFd_count()++;
				} 
			} 
		} while (0);
		switch (mode) {
		case sockmode.PASSIVE_CONNECT:
				sockfd = sockfdp;
				if (CURL_SOCKET_BAD == sockfd) {
					ModernizedCProgram.logmsg("socket is -1! on %s:%d", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Curl\\src\\sockfilt.c", /* eeek, we are supposedly connected and then this cannot be -1 ! */969);
					maxfd = /* stdin */0;
				} else {
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
								if (((fd_set)(fds_read)).getFd_array()[__i] == (sockfd)) {
									break;
								} 
							}
							if (__i == ((fd_set)(fds_read)).getFd_count()) {
								if (((fd_set)(fds_read)).getFd_count() < 64) {
									((fd_set)(fds_read)).getFd_array()[__i] = (sockfd);
									((fd_set)(fds_read)).getFd_count()++;
								} 
							} 
						} while (/* there's always a socket to wait for */0);
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
								if (((fd_set)(fds_err)).getFd_array()[__i] == (sockfd)) {
									break;
								} 
							}
							if (__i == ((fd_set)(fds_err)).getFd_count()) {
								if (((fd_set)(fds_err)).getFd_count() < 64) {
									((fd_set)(fds_err)).getFd_array()[__i] = (sockfd);
									((fd_set)(fds_err)).getFd_count()++;
								} 
							} 
						} while (0);
						maxfd = (int)sockfd;
				} 
				break;
		case sockmode.ACTIVE:
				sockfd = sockfdp;
				if (CURL_SOCKET_BAD != /* sockfd turns CURL_SOCKET_BAD when our connection has been closed */sockfd) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
							if (((fd_set)(fds_read)).getFd_array()[__i] == (sockfd)) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_read)).getFd_count()) {
							if (((fd_set)(fds_read)).getFd_count() < 64) {
								((fd_set)(fds_read)).getFd_array()[__i] = (sockfd);
								((fd_set)(fds_read)).getFd_count()++;
							} 
						} 
					} while (0);
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
							if (((fd_set)(fds_err)).getFd_array()[__i] == (sockfd)) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_err)).getFd_count()) {
							if (((fd_set)(fds_err)).getFd_count() < 64) {
								((fd_set)(fds_err)).getFd_array()[__i] = (sockfd);
								((fd_set)(fds_err)).getFd_count()++;
							} 
						} 
					} while (0);
					maxfd = (int)sockfd;
				} else {
						ModernizedCProgram.logmsg("No socket to read on");
						maxfd = 0;
				} 
				break;
		case sockmode.PASSIVE_LISTEN:
				sockfd = /* server mode */listenfd;
				do {
					u_int __i = new u_int();
					for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
						if (((fd_set)(fds_read)).getFd_array()[__i] == (sockfd)) {
							break;
						} 
					}
					if (__i == ((fd_set)(fds_read)).getFd_count()) {
						if (((fd_set)(fds_read)).getFd_count() < 64) {
							((fd_set)(fds_read)).getFd_array()[__i] = (sockfd);
							((fd_set)(fds_read)).getFd_count()++;
						} 
					} 
				} while (/* there's always a socket to wait for */0);
				maxfd = (int)sockfd;
				break;
		case sockmode.ACTIVE_DISCONNECT:
				ModernizedCProgram.logmsg("disconnected, no socket to read on");
				maxfd = 0;
				sockfd = CURL_SOCKET_BAD;
				break;
		}
		do {
			rc = ModernizedCProgram.select_ws(maxfd + 1, fds_read, fds_write, fds_err, /* select() blocking behavior call on blocking descriptors please */timeout);
			if (ModernizedCProgram.got_exit_signal) {
				ModernizedCProgram.logmsg("signalled to die, exiting...");
				return 0;
			} 
		} while ((rc == -1) && ((error = (._errno())) == 4));
		if (rc < 0) {
			ModernizedCProgram.logmsg("select() failed with error: (%d) %s", error, .strerror(error));
			return 0;
		} 
		if (rc == 0) {
			return /* timeout */1;
		} 
		if (.__WSAFDIsSet((SOCKET)((((_iob[0])).get_file())), (fd_set)(fds_read))) {
			ssize_t buffer_len = new ssize_t();
			if (!ModernizedCProgram.read_stdin(buffer, 5)) {
				return 0;
			} 
			ModernizedCProgram.logmsg("Received %c%c%c%c (on stdin)", buffer[0], buffer[1], buffer[2], buffer[3]);
			if (!.memcmp("PING", buffer, 4)) {
				if (!ModernizedCProgram.write_stdout("PONG\n", /* send reply on stdout, just proving we are alive */5)) {
					return 0;
				} 
			}  else if (!.memcmp("PORT", buffer, 4/* Question asking us what PORT number we are listening to.
			         Replies to PORT with "IPv[num]/[port]" */)) {
				ModernizedCProgram.curl_msnprintf((byte)buffer, , "%s/%hu\n", ModernizedCProgram.ipv_inuse, ModernizedCProgram.port);
				buffer_len = (ssize_t).strlen((byte)buffer);
				ModernizedCProgram.curl_msnprintf(data, , "PORT\n%04zx\n", buffer_len);
				if (!ModernizedCProgram.write_stdout(data, 10)) {
					return 0;
				} 
				if (!ModernizedCProgram.write_stdout(buffer, buffer_len)) {
					return 0;
				} 
			}  else if (!.memcmp("QUIT", buffer, 4)) {
				ModernizedCProgram.logmsg(/* just die */"quits");
				return 0;
			}  else if (!.memcmp("DATA", buffer, 4/* data IN => data OUT */)) {
				if (!ModernizedCProgram.read_stdin(buffer, 5)) {
					return 0;
				} 
				buffer[5] = (byte)'\0';
				buffer_len = (ssize_t).strtol((byte)buffer, ((Object)0), 16);
				if (buffer_len > (ssize_t)) {
					ModernizedCProgram.logmsg("ERROR: Buffer size (%zu bytes) too small for data size (%zd bytes)", , buffer_len);
					return 0;
				} 
				ModernizedCProgram.logmsg("> %zd bytes data, server => client", buffer_len);
				if (!ModernizedCProgram.read_stdin(buffer, buffer_len)) {
					return 0;
				} 
				ModernizedCProgram.lograw(buffer, buffer_len);
				if (mode == sockmode.PASSIVE_LISTEN) {
					ModernizedCProgram.logmsg("*** We are disconnected!");
					if (!ModernizedCProgram.write_stdout("DISC\n", 5)) {
						return 0;
					} 
				} else {
						ssize_t bytes_written = (ssize_t).send((SOCKET)(sockfd), (byte)(buffer), (int)(buffer_len), (int)(/* send away on the socket */false));
						if (bytes_written != buffer_len) {
							ModernizedCProgram.logmsg("Not all data was sent. Bytes to send: %zd sent: %zd", buffer_len, bytes_written);
						} 
				} 
			}  else if (!.memcmp("DISC", buffer, 4)) {
				if (!ModernizedCProgram.write_stdout("DISC\n", /* disconnect! */5)) {
					return 0;
				} 
				if (sockfd != CURL_SOCKET_BAD) {
					ModernizedCProgram.logmsg("====> Client forcibly disconnected");
					.closesocket((sockfd));
					sockfdp = CURL_SOCKET_BAD;
					if (mode == sockmode.PASSIVE_CONNECT) {
						mode = sockmode.PASSIVE_LISTEN;
					} else {
							mode = sockmode.ACTIVE_DISCONNECT;
					} 
				} else {
						ModernizedCProgram.logmsg("attempt to close already dead connection");
				} 
				return 1;
			} 
		} 
		if ((sockfd != CURL_SOCKET_BAD) && (.__WSAFDIsSet((SOCKET)(sockfd), (fd_set)(fds_read)))) {
			ssize_t nread_socket = new ssize_t();
			if (mode == sockmode.PASSIVE_LISTEN/* there's no stream set up yet, this is an indication that there's a
			         client connecting. */) {
				 newfd = .accept(sockfd, ((Object)0), ((Object)0));
				if (CURL_SOCKET_BAD == newfd) {
					error = ((int).WSAGetLastError());
					ModernizedCProgram.logmsg("accept(%d, NULL, NULL) failed with error: (%d) %s", sockfd, error, .strerror(error));
				} else {
						ModernizedCProgram.logmsg("====> Client connect");
						if (!ModernizedCProgram.write_stdout("CNCT\n", 5)) {
							return 0;
						} 
						sockfdp = /* store the new socket */newfd;
						mode = /* we have connected */sockmode.PASSIVE_CONNECT;
				} 
				return 1;
			} 
			nread_socket = (ssize_t).recv((SOCKET)(sockfd), (byte)(buffer), (int)(), (int)(/* read from socket, pass on data to stdout */false));
			if (nread_socket > 0) {
				ModernizedCProgram.curl_msnprintf(data, , "DATA\n%04zx\n", nread_socket);
				if (!ModernizedCProgram.write_stdout(data, 10)) {
					return 0;
				} 
				if (!ModernizedCProgram.write_stdout(buffer, nread_socket)) {
					return 0;
				} 
				ModernizedCProgram.logmsg("< %zd bytes data, client => server", nread_socket);
				ModernizedCProgram.lograw(buffer, nread_socket);
			} 
			if (nread_socket <= 0 || .__WSAFDIsSet((SOCKET)(sockfd), (fd_set)(fds_err))) {
				ModernizedCProgram.logmsg("====> Client disconnect");
				if (!ModernizedCProgram.write_stdout("DISC\n", 5)) {
					return 0;
				} 
				.closesocket((sockfd));
				sockfdp = CURL_SOCKET_BAD;
				if (mode == sockmode.PASSIVE_CONNECT) {
					mode = sockmode.PASSIVE_LISTEN;
				} else {
						mode = sockmode.ACTIVE_DISCONNECT;
				} 
				return 1;
			} 
		} 
		return 1;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * This is a socketpair() implementation for Windows.
	 */
	/* IPPROTO_TCP */
	/* !INADDR_LOOPBACK */
	/* !WIN32 */
	/* The last 3 #include files should be in this order */
	public static int Curl_socketpair(int domain, int type, int protocol, Object socks) {
		Object a;
		 listener = new ();
		Object generatedInaddr = a.getInaddr();
		 addrlen = ;
		int reuse = 1;
		byte[][] data = new byte[2][12];
		ssize_t dlen = new ssize_t();
		(Object)domain;
		(Object)type;
		(Object)protocol;
		listener = .socket(2, 1, 6);
		if (listener == CURL_SOCKET_BAD) {
			return -1;
		} 
		.memset(a, 0, );
		generatedInaddr.setSin_family(2);
		generatedInaddr.getSin_addr().getS_un().setS_addr(.htonl(-1024));
		generatedInaddr.setSin_port(0);
		socks[0] = socks[1] = CURL_SOCKET_BAD;
		if (.setsockopt(listener, -1024, 4, (byte)reuse, ()) == -1) {
			;
		} 
		Object generatedAddr = a.getAddr();
		if (.bind(listener, generatedAddr, ) == -1) {
			;
		} 
		if (.getsockname(listener, generatedAddr, addrlen) == -1) {
			;
		} 
		if (.listen(listener, 1) == -1) {
			;
		} 
		socks[0] = .socket(2, 1, 0);
		if (socks[0] == CURL_SOCKET_BAD) {
			;
		} 
		if (.connect(socks[0], generatedAddr, ) == -1) {
			;
		} 
		socks[1] = .accept(listener, ((Object)0), ((Object)0));
		if (socks[1] == CURL_SOCKET_BAD) {
			;
		} 
		ModernizedCProgram.curl_msnprintf(data[0], , "%p", /* verify that nothing else connected */socks);
		dlen = .strlen(data[0]);
		if ((ssize_t).send((SOCKET)(socks[0]), (byte)(data[0]), (int)(dlen), (int)(false)) != dlen) {
			;
		} 
		if ((ssize_t).recv((SOCKET)(socks[1]), (byte)(data[1]), (int)(), (int)(false)) != dlen) {
			;
		} 
		if (.memcmp(data[0], data[1], dlen)) {
			;
		} 
		.closesocket((listener));
		return 0;
		.closesocket((socks[0]));
		.closesocket((socks[1]));
		return -1/* ! HAVE_SOCKETPAIR */;
	}
	public static Object doh_strerror( code) {
		if ((code >= .DOH_OK) && (code <= .DOH_DNS_BAD_ID)) {
			return ModernizedCProgram.errors[code];
		} 
		return "bad error code";
	}
	/* @unittest 1655
	 */
	public static  doh_encode(Object host,  dnstype, byte dnsp, Object len, Object olen) {
		size_t hostlen = .strlen(/* buffer size *//* output length */host);
		byte orig = dnsp;
		byte hostp = host/* The expected output length does not depend on the number of dots within
		   * the host name. It will always be two more than the length of the host
		   * name, one for the size and one trailing null. In case there are dots,
		   * each dot adds one size but removes the need to store the dot, net zero.
		   */;
		size_t expected_len = 12 + (1 + hostlen + 1) + 4;
		if (len < expected_len) {
			return .DOH_TOO_SMALL_BUFFER;
		} 
		dnsp++ = /* 16 bit id */0;
		dnsp++ = 0;
		dnsp++ = /* |QR|   Opcode  |AA|TC|RD| Set the RD bit */-1024;
		dnsp++ = /* |RA|   Z    |   RCODE   |                */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* QDCOUNT (number of entries in the question section) */1;
		dnsp++ = (byte)'\0';
		dnsp++ = /* ANCOUNT */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* NSCOUNT */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* ARCOUNT */(byte)'\0';
		/* store a QNAME */do {
			byte dot = .strchr(hostp, (byte)'.');
			size_t labellen = new size_t();
			bool found = .bool_false;
			if (dot) {
				found = .bool_true;
				labellen = dot - hostp;
			} else {
					labellen = .strlen(hostp);
			} 
			if (labellen > 63) {
				olen = /* too long label, error out */0;
				return .DOH_DNS_BAD_LABEL;
			} 
			dnsp++ = (byte)labellen;
			.memcpy(dnsp, hostp, labellen);
			dnsp += labellen;
			hostp += labellen + 1;
			if (!found) {
				dnsp++ = /* terminating zero */0;
				break;
			} 
		} while (1);
		dnsp++ = (byte)(255 & (dnstype >> /* There are assigned TYPE codes beyond 255: use range [1..65535]  *//* upper 8 bit TYPE */8));
		dnsp++ = (byte)(255 & /* lower 8 bit TYPE */dnstype);
		dnsp++ = /* upper 8 bit CLASS */(byte)'\0';
		dnsp++ = /* IN - "the Internet" */-1024;
		olen = dnsp - orig;
		do {
		} while (/* verify that our assumption of length is valid, since
		   * this has lead to buffer overflows in this function */0);
		return .DOH_OK;
	}
	/* buffer */
	public static Object doh_write_cb(Object contents, Object size, Object nmemb, Object userp) {
		size_t realsize = size * nmemb;
		dohresponse mem = (dohresponse)userp;
		Object generatedSize = mem.getSize();
		if ((generatedSize + realsize) > 3000) {
			return /* suspiciously much for us */0;
		} 
		Byte generatedMemory = mem.getMemory();
		mem.setMemory(ModernizedCProgram.Curl_saferealloc(generatedMemory, generatedSize + realsize));
		if (!generatedMemory) {
			return /* out of memory! */0;
		} 
		.memcpy((generatedMemory[generatedSize]), contents, realsize);
		generatedSize += realsize;
		return realsize;
	}
	public static Object dohprobe(Curl_easy data, dnsprobe p,  dnstype, Object host, Object url, Object multi, curl_slist headers) {
		Curl_easy doh = ((Object)0);
		byte nurl = ((Object)0);
		 result = CURLE_OK;
		timediff_t timeout_ms = new timediff_t();
		Object generatedDohbuffer = p.getDohbuffer();
		Object generatedDohlen = p.getDohlen();
		DOHcode d = ModernizedCProgram.doh_encode(host, dnstype, generatedDohbuffer, , generatedDohlen);
		if (d) {
			data.Curl_failf("Failed to encode DOH packet [%d]\n", d);
			return CURLE_OUT_OF_MEMORY;
		} 
		p.setDnstype(dnstype);
		dohresponse generatedServerdoh = p.getServerdoh();
		generatedServerdoh.setMemory(((Object)0/* the memory will be grown as needed by realloc in the doh_write_cb
		     function */));
		generatedServerdoh.setSize(0/* Note: this is code for sending the DoH request with GET but there's still
		     no logic that actually enables this. We should either add that ability or
		     yank out the GET code. Discuss! */);
		Object generatedSet = data.getSet();
		if (generatedSet.getDoh_get()) {
			byte b64;
			size_t b64len = new size_t();
			result = data.Curl_base64url_encode((byte)generatedDohbuffer, generatedDohlen, b64, b64len);
			if (result) {
				;
			} 
			nurl = ModernizedCProgram.curl_maprintf("%s?dns=%s", url, b64);
			.Curl_cfree(b64);
			if (!nurl) {
				result = CURLE_OUT_OF_MEMORY;
				;
			} 
			url = nurl;
		} 
		timeout_ms = ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1);
		if (timeout_ms <= 0) {
			result = CURLE_OPERATION_TIMEDOUT;
			;
		} 
		result = /* Curl_open() is the internal version of curl_easy_init() */doh.Curl_open();
		if (!result/* pass in the struct pointer via a local variable to please coverity and
		       the gcc typecheck helpers */) {
			dohresponse resp = generatedServerdoh;
			do {
				result = doh.curl_easy_setopt(CURLOPT_URL, url);
				if (result) {
					;
				} 
			} while (0);
			do {
				result = doh.curl_easy_setopt(CURLOPT_WRITEFUNCTION, doh_write_cb);
				if (result) {
					;
				} 
			} while (0);
			do {
				result = doh.curl_easy_setopt(CURLOPT_WRITEDATA, resp);
				if (result) {
					;
				} 
			} while (0);
			if (!generatedSet.getDoh_get()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_POSTFIELDS, generatedDohbuffer);
					if (result) {
						;
					} 
				} while (0);
				do {
					result = doh.curl_easy_setopt(CURLOPT_POSTFIELDSIZE, (long)generatedDohlen);
					if (result) {
						;
					} 
				} while (0);
			} 
			do {
				result = doh.curl_easy_setopt(CURLOPT_HTTPHEADER, headers);
				if (result) {
					;
				} 
			} while (0);
			do {
				result = doh.curl_easy_setopt(CURLOPT_PROTOCOLS, CURLPROTO_HTTPS);
				if (result) {
					;
				} 
			} while (/* enforce HTTPS if not debug *//* enforce HTTPS if not debug */0/* in debug mode, also allow http */);
			do {
				result = doh.curl_easy_setopt(CURLOPT_TIMEOUT_MS, (long)timeout_ms);
				if (result) {
					;
				} 
			} while (0);
			if (generatedSet.getVerbose()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getNo_signal()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_NOSIGNAL, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getFalsestart()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_FALSESTART, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getPrimary().getVerifyhost()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_VERIFYHOST, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getProxy_ssl().getPrimary().getVerifyhost()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_SSL_VERIFYHOST, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getPrimary().getVerifypeer()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_VERIFYPEER, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getProxy_ssl().getPrimary().getVerifypeer()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_SSL_VERIFYPEER, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getPrimary().getVerifystatus()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_VERIFYSTATUS, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_ORIG]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_CAINFO, generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_ORIG]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_PROXY]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_CAINFO, generatedSet.getStr()[dupstring.STRING_SSL_CAFILE_PROXY]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_ORIG]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_CAPATH, generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_ORIG]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_PROXY]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_CAPATH, generatedSet.getStr()[dupstring.STRING_SSL_CAPATH_PROXY]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_ORIG]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_CRLFILE, generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_ORIG]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_PROXY]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_CRLFILE, generatedSet.getStr()[dupstring.STRING_SSL_CRLFILE_PROXY]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getCertinfo()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_CERTINFO, -1024);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_RANDOM_FILE]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_RANDOM_FILE, generatedSet.getStr()[dupstring.STRING_SSL_RANDOM_FILE]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getStr()[dupstring.STRING_SSL_EGDSOCKET]) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_EGDSOCKET, generatedSet.getStr()[dupstring.STRING_SSL_EGDSOCKET]);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getNo_revoke()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getProxy_ssl().getNo_revoke()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_PROXY_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE);
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getFsslctx()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_CTX_FUNCTION, generatedSet.getSsl().getFsslctx());
					if (result) {
						;
					} 
				} while (0);
			} 
			if (generatedSet.getSsl().getFsslctxp()) {
				do {
					result = doh.curl_easy_setopt(CURLOPT_SSL_CTX_DATA, generatedSet.getSsl().getFsslctxp());
					if (result) {
						;
					} 
				} while (0);
			} 
			generatedSet.setFmultidone(Curl_doh_done);
			generatedSet.setDohfor(/* identify for which transfer this is done */data);
			p.setEasy(doh);
			if (ModernizedCProgram.curl_multi_add_handle(multi, /* add this transfer to the multi handle */doh)) {
				;
			} 
		} else {
				;
		} 
		.Curl_cfree(nurl);
		return CURLE_OK;
		doh.Curl_close();
		return result/*
		 * Curl_doh() resolves a name using DOH. It resolves a name and returns a
		 * 'Curl_addrinfo *' with the address information.
		 */;
	}
	public static  skipqname(Byte doh, Object dohlen, int indexp) {
		byte length;
		do {
			if (dohlen < (indexp + 1)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			length = doh[indexp];
			if ((length & -1024) == -1024) {
				if (dohlen < (indexp + /* name pointer, advance over it and be done */2)) {
					return .DOH_DNS_OUT_OF_RANGE;
				} 
				indexp += 2;
				break;
			} 
			if (length & -1024) {
				return .DOH_DNS_BAD_LABEL;
			} 
			if (dohlen < (indexp + 1 + length)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			indexp += 1 + length;
		} while (length);
		return .DOH_OK;
	}
	public static int get16bit(Byte doh, int index) {
		return (int)((doh[index] << 8) | doh[index + 1]);
	}
	public static int get32bit(Byte doh, int index) {
		doh += /* make clang and gcc optimize this to bswap by incrementing
		      the pointer first. */index/* avoid undefined behaviour by casting to unsigned before shifting
		      24 bits, possibly into the sign bit. codegen is same, but
		      ub sanitizer won't be upset */;
		return ((int)doh[0] << 24) | (doh[1] << 16) | (doh[2] << 8) | doh[3];
	}
	public static void showdoh(Curl_easy data, dohentry d) {
		int i;
		int generatedTtl = d.getTtl();
		data.Curl_infof("TTL: %u seconds\n", generatedTtl);
		int generatedNumaddr = d.getNumaddr();
		Object generatedAddr = d.getAddr();
		int generatedType = a.getType();
		 generatedIp = a.getIp();
		Object generatedV4 = generatedIp.getV4();
		Object generatedV6 = generatedIp.getV6();
		for (i = 0; i < generatedNumaddr; i++) {
			dohaddr a = generatedAddr[i];
			if (generatedType == .DNS_TYPE_A) {
				data.Curl_infof("DOH A: %u.%u.%u.%u\n", generatedV4[0], generatedV4[1], generatedV4[2], generatedV4[3]);
			}  else if (generatedType == .DNS_TYPE_AAAA) {
				int j;
				byte[] buffer = new byte[128];
				byte ptr;
				size_t len = new size_t();
				ModernizedCProgram.curl_msnprintf(ModernizedCProgram.buffer, 128, "DOH AAAA: ");
				ptr = ModernizedCProgram.buffer[10];
				len = 118;
				for (ModernizedCProgram.j = 0; ModernizedCProgram.j < 16; ModernizedCProgram.j += 2) {
					size_t l = new size_t();
					ModernizedCProgram.curl_msnprintf(ptr, len, "%s%02x%02x", ModernizedCProgram.j ? ":" : "", generatedV6[ModernizedCProgram.j], generatedV6[ModernizedCProgram.j + 1]);
					l = .strlen(ptr);
					len -= l;
					ptr += l;
				}
				data.Curl_infof("%s\n", ModernizedCProgram.buffer);
			} 
		}
		int generatedNumcname = d.getNumcname();
		Object generatedCname = d.getCname();
		for (i = 0; i < generatedNumcname; i++) {
			data.Curl_infof("CNAME: %s\n", generatedCname[i].getAlloc());
		}
	}
	public static Object type2name( dnstype) {
		return (dnstype == .DNS_TYPE_A) ? "A" : "AAAA";
	}
	public static Object Curl_doh_is_resolved(connectdata conn, Curl_dns_entry dnsp) {
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		dnsp = ((Object)/* defaults to no response */0);
		Object generatedReq = data.getReq();
		Curl_async generatedAsync = conn.getAsync();
		Byte generatedHostname = generatedAsync.getHostname();
		ConnectBits generatedBits = conn.getBits();
		Object generatedProxy = generatedBits.getProxy();
		Object generatedMulti = data.getMulti();
		Curl_addrinfo curl_addrinfo = new Curl_addrinfo();
		Object generatedShare = data.getShare();
		Curl_dns_entry curl_dns_entry = new Curl_dns_entry();
		if (!generatedReq.getDoh().getProbe()[0].getEasy() && !generatedReq.getDoh().getProbe()[1].getEasy()) {
			data.Curl_failf("Could not DOH-resolve: %s", generatedHostname);
			return generatedProxy ? CURLE_COULDNT_RESOLVE_PROXY : CURLE_COULDNT_RESOLVE_HOST;
		}  else if (!generatedReq.getDoh().getPending()) {
			DOHcode rc = new DOHcode();
			DOHcode rc2 = new DOHcode();
			dohentry de = new dohentry();
			ModernizedCProgram.curl_multi_remove_handle(generatedMulti, generatedReq.getDoh().getProbe()[0].getEasy());
			generatedReq.getDoh().getProbe()[0].getEasy().Curl_close();
			generatedReq.getDoh().getProbe()[0].setEasy(((Object)0));
			ModernizedCProgram.curl_multi_remove_handle(generatedMulti, generatedReq.getDoh().getProbe()[1].getEasy());
			generatedReq.getDoh().getProbe()[1].getEasy().Curl_close();
			generatedReq.getDoh().getProbe()[1].setEasy(((Object)0));
			/* parse the responses, create the struct and return it! */de.init_dohentry();
			rc = de.doh_decode(generatedReq.getDoh().getProbe()[0].getServerdoh().getMemory(), generatedReq.getDoh().getProbe()[0].getServerdoh().getSize(), generatedReq.getDoh().getProbe()[0].getDnstype());
			do {
				.Curl_cfree((generatedReq.getDoh().getProbe()[0].getServerdoh().getMemory()));
				(generatedReq.getDoh().getProbe()[0].getServerdoh().getMemory()) = ((Object)0);
			} while (0);
			if (rc) {
				data.Curl_infof("DOH: %s type %s for %s\n", ModernizedCProgram.doh_strerror(rc), ModernizedCProgram.type2name(generatedReq.getDoh().getProbe()[0].getDnstype()), generatedReq.getDoh().getHost());
			} 
			rc2 = de.doh_decode(generatedReq.getDoh().getProbe()[1].getServerdoh().getMemory(), generatedReq.getDoh().getProbe()[1].getServerdoh().getSize(), generatedReq.getDoh().getProbe()[1].getDnstype());
			do {
				.Curl_cfree((generatedReq.getDoh().getProbe()[1].getServerdoh().getMemory()));
				(generatedReq.getDoh().getProbe()[1].getServerdoh().getMemory()) = ((Object)0);
			} while (0);
			if (rc2) {
				data.Curl_infof("DOH: %s type %s for %s\n", ModernizedCProgram.doh_strerror(rc2), ModernizedCProgram.type2name(generatedReq.getDoh().getProbe()[1].getDnstype()), generatedReq.getDoh().getHost());
			} 
			if (!rc || !rc2) {
				Curl_dns_entry dns = new Curl_dns_entry();
				Curl_addrinfo ai = new Curl_addrinfo();
				data.Curl_infof("DOH Host name: %s\n", generatedReq.getDoh().getHost());
				ModernizedCProgram.showdoh(data, de);
				ai = curl_addrinfo.doh2ai(de, generatedReq.getDoh().getHost(), generatedReq.getDoh().getPort());
				if (!ai) {
					de.de_cleanup();
					return CURLE_OUT_OF_MEMORY;
				} 
				if (generatedShare) {
					data.Curl_share_lock(CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
				} 
				dns = curl_dns_entry.Curl_cache_addr(data, ai, generatedReq.getDoh().getHost(), generatedReq.getDoh().getPort());
				if (generatedShare) {
					data.Curl_share_unlock(CURL_LOCK_DATA_DNS);
				} 
				de.de_cleanup();
				if (!dns) {
					/* returned failure, bail out nicely */ai.Curl_freeaddrinfo();
				} else {
						generatedAsync.setDns(dns);
						dnsp = dns;
						return CURLE_OK;
				} 
			} 
			de.de_cleanup();
			return CURLE_COULDNT_RESOLVE_HOST;
		} 
		return CURLE_OK/* CURL_DISABLE_DOH */;
	}
	public static void characterDataHandler(Object userData, Object s, int len) {
		ParserStruct state = (ParserStruct)userData;
		MemoryStruct generatedCharacters = state.getCharacters();
		MemoryStruct mem = generatedCharacters;
		Byte generatedMemory = mem.getMemory();
		Object generatedSize = mem.getSize();
		byte ptr = .realloc(generatedMemory, generatedSize + len + 1);
		if (!ptr) {
			.fprintf((_iob[2]), /* Out of memory. */"Not enough memory (realloc returned NULL).\n");
			state.setOk(0);
			return ;
		} 
		mem.setMemory(ptr);
		.memcpy((generatedMemory[generatedSize]), s, len);
		generatedSize += len;
		generatedMemory[generatedSize] = 0;
	}
	public static Object parseStreamCallback(Object contents, Object length, Object nmemb, Object userp) {
		 parser = ()userp;
		size_t real_size = length * nmemb;
		ParserStruct state = (ParserStruct).XML_GetUserData(parser);
		int generatedOk = state.getOk();
		if (generatedOk && .XML_Parse(parser, contents, real_size, 0) == /* Only parse if we're not already in a failure state. */0) {
			int error_code = .XML_GetErrorCode(parser);
			.fprintf((_iob[2]), "Parsing response buffer of length %lu failed with error code %d (%s).\n", real_size, error_code, .XML_ErrorString(error_code));
			state.setOk(0);
		} 
		return real_size;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Show the required mutex callback setups for GnuTLS and OpenSSL when using
	 * libcurl multi-threaded.
	 * </DESC>
	 */
	/* A multi-threaded example that uses pthreads and fetches 4 remote files at
	 * once over HTTPS. The lock callbacks and stuff assume OpenSSL <1.1 or GnuTLS
	 * (libgcrypt) so far.
	 *
	 * OpenSSL docs for this:
	 *   https://www.openssl.org/docs/man1.0.2/man3/CRYPTO_num_locks.html
	 * gcrypt docs for this:
	 *   https://gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html
	 */
	/* or USE_GNUTLS accordingly */
	/* we have this global to let the callback get easy access to it */
	public static void lock_callback(int mode, int type, Byte file, int line) {
		(Object)file;
		(Object)line;
		if (mode & CRYPTO_LOCK) {
			.pthread_mutex_lock((ModernizedCProgram.lockarray[type]));
		} else {
				.pthread_mutex_unlock((ModernizedCProgram.lockarray[type]));
		} 
	}
	public static long thread_id() {
		long ret;
		ret = (long).pthread_self();
		return ret;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * Curl_memrchr()
	 *
	 * Our memrchr() function clone for systems which lack this function. The
	 * memrchr() function is like the memchr() function, except that it searches
	 * backwards from the end of the n bytes pointed to by s instead of forward
	 * from the beginning.
	 */
	/*
	 * Curl_memrchr()
	 *
	 * Our memrchr() function clone for systems which lack this function. The
	 * memrchr() function is like the memchr() function, except that it searches
	 * backwards from the end of the n bytes pointed to by s instead of forward
	 * from the beginning.
	 */
	public static Object Curl_memrchr(Object s, int c, Object n) {
		if (n > 0) {
			byte p = s;
			byte q = s;
			p += n - 1;
			while (p >= q) {
				if (p == (byte)c) {
					return (Object)p;
				} 
				p--;
			}
		} 
		return ((Object)0/* HAVE_MEMRCHR */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * checkheaders() checks the linked list of custom headers for a
	 * particular header (prefix). Provide the prefix without colon!
	 *
	 * Returns a pointer to the first matching header or NULL if none matched.
	 */
	public static Byte Curl_checkheaders(Object conn, Object thisheader) {
		curl_slist head = new curl_slist();
		size_t thislen = .strlen(thisheader);
		Curl_easy data = conn.getData();
		Object generatedCurl_slist = head.getCurl_slist();
		Object generatedSet = data.getSet();
		for (head = generatedSet.getHeaders(); head; head = generatedCurl_slist) {
			if (ModernizedCProgram.Curl_strncasecompare(generatedCurl_slist, thisheader, thislen) && ((((generatedCurl_slist[thislen]) == (byte)':') || ((generatedCurl_slist[thislen]) == (byte)';')))) {
				return generatedCurl_slist;
			} 
		}
		return ((Object)0);
	}
	public static Object Curl_trailers_read(Byte buffer, Object size, Object nitems, Object raw) {
		Curl_easy data = (Curl_easy)raw;
		Object generatedState = data.getState();
		Curl_send_buffer trailers_buf = generatedState.getTrailers_buf();
		Object generatedSize_used = trailers_buf.getSize_used();
		size_t bytes_left = generatedSize_used - generatedState.getTrailers_bytes_sent();
		size_t to_copy = (size * nitems < bytes_left) ? size * nitems : bytes_left;
		Byte generatedBuffer = trailers_buf.getBuffer();
		if (to_copy) {
			.memcpy(buffer, generatedBuffer[generatedState.getTrailers_bytes_sent()], to_copy);
			generatedState.getTrailers_bytes_sent() += to_copy;
		} 
		return to_copy;
	}
	public static Object Curl_trailers_left(Object raw) {
		Curl_easy data = (Curl_easy)raw;
		Object generatedState = data.getState();
		Curl_send_buffer trailers_buf = generatedState.getTrailers_buf();
		Object generatedSize_used = trailers_buf.getSize_used();
		return generatedSize_used - generatedState.getTrailers_bytes_sent();
	}
	public static int data_pending(Object conn) {
		return conn.getHandler().getProtocol() & (CURLPROTO_SCP | /* in the case of libssh2, we can never be really sure that we have emptied
		     its internal buffers so we MUST always try until we get EAGAIN back */CURLPROTO_SFTP/* For HTTP/2, we may read up everything including response body
		       with header fields in Curl_http_readwrite_headers. If no
		       content-length is provided, curl waits for the connection
		       close, which we emulate it using conn->proto.httpc.closed =
		       TRUE. The thing is if we read everything, then http2_recv won't
		       be called and we cannot signal the HTTP/2 stream has closed. As
		       a workaround, we return nonzero here to call http2_recv. */) || .Curl_ssl_data_pending(conn, 0/*
		 * Check to see if CURLOPT_TIMECONDITION was met by comparing the time of the
		 * remote document with the time provided by CURLOPT_TIMEVAL
		 */);
	}
	public static Object readwrite_data(Curl_easy data, connectdata conn, SingleRequest k, int didwhat,  done,  comeback) {
		 result = CURLE_OK;
		/* number of bytes read */ssize_t nread = new ssize_t();
		size_t excess = /* excess bytes read */0;
		bool readmore = /* used by RTP to signal for more data */0;
		int maxloops = 100;
		done = 0;
		comeback = 0/* This is where we loop until we have read everything there is to
		     read or we get a CURLE_AGAIN */;
		Object generatedSet = data.getSet();
		Object generatedSize = k.getSize();
		Object generatedHeader = k.getHeader();
		Object generatedBytecount = k.getBytecount();
		Object generatedSockfd = conn.getSockfd();
		Byte generatedBuf = k.getBuf();
		expect100 generatedExp100 = k.getExp100();
		curltime curltime = new curltime();
		long generatedBodywrites = k.getBodywrites();
		int generatedKeepon = k.getKeepon();
		Object generatedHandler = conn.getHandler();
		Object generatedMaxdownload = k.getMaxdownload();
		Object generatedState = data.getState();
		byte generatedStr = k.getStr();
		Object generatedReq = data.getReq();
		ConnectBits generatedBits = conn.getBits();
		Object generatedClose = generatedBits.getClose();
		Object generatedContent_range = k.getContent_range();
		Object generatedIgnorebody = k.getIgnorebody();
		Object generatedTimeofdoc = k.getTimeofdoc();
		Object generatedInfo = data.getInfo();
		 generatedBadheader = k.getBadheader();
		Object generatedHbuflen = k.getHbuflen();
		Object generatedChunk = k.getChunk();
		Curl_easy generatedData = conn.getData();
		if (maxloops <= 0) {
			conn.setCselect_bits(/* we mark it as read-again-please */CURL_CSELECT_IN);
			comeback = 1;
		} 
		if (((generatedKeepon & ((1 << 0) | (1 << 1))) == (1 << 1)) && generatedClose) {
			data.Curl_infof("we are done reading and this is set to close, stop send\n");
			generatedKeepon &=  ~(1 << /* no writing anymore either */1);
		} 
		return CURLE_OK;
	}
	public static Object Curl_done_sending(connectdata conn, SingleRequest k) {
		int generatedKeepon = k.getKeepon();
		generatedKeepon &=  ~(1 << /* we're done writing */1);
		/* These functions should be moved into the handler struct! */;
		;
		ConnectBits generatedBits = conn.getBits();
		Object generatedRewindaftersend = generatedBits.getRewindaftersend();
		if (generatedRewindaftersend) {
			 result = conn.Curl_readrewind();
			if (ModernizedCProgram.result) {
				return ModernizedCProgram.result;
			} 
		} 
		return CURLE_OK;
	}
	public static void win_update_buffer_size(Object sockfd) {
		int result;
		ULONG ideal = new ULONG();
		DWORD ideallen = new DWORD();
		result = .WSAIoctl(sockfd, -1024, 0, 0, ideal, , ideallen, 0, 0);
		if (result == 0) {
			.setsockopt(sockfd, -1024, -1024, (byte)ideal, );
		} 
	}
	/*
	 * Send data to upload to the server, when the socket is writable.
	 */
	public static Object readwrite_upload(Curl_easy data, connectdata conn, int didwhat) {
		ssize_t i = new ssize_t();
		ssize_t si = new ssize_t();
		ssize_t bytes_written = new ssize_t();
		 result = new ();
		/* number of bytes read */ssize_t nread = new ssize_t();
		bool sending_http_headers = 0;
		Object generatedReq = data.getReq();
		SingleRequest k = generatedReq;
		Object generatedBytecount = k.getBytecount();
		Object generatedWritebytecount = k.getWritebytecount();
		if ((generatedBytecount == 0) && (generatedWritebytecount == 0)) {
			data.Curl_pgrsTime(.TIMER_STARTTRANSFER);
		} 
		didwhat |=  (1 << 1);
		Object generatedUpload_present = k.getUpload_present();
		Object generatedState = data.getState();
		Object generatedUpload_done = k.getUpload_done();
		Object generatedProtop = k.getProtop();
		expect100 generatedExp100 = k.getExp100();
		 generatedSending = http.getSending();
		int generatedKeepon = k.getKeepon();
		curltime curltime = new curltime();
		Object generatedSet = data.getSet();
		Object generatedHandler = conn.getHandler();
		Byte generatedUpload_fromhere = k.getUpload_fromhere();
		Object generatedWritesockfd = conn.getWritesockfd();
		Object generatedUpload_chunky = k.getUpload_chunky();
		Object generatedForbidchunk = k.getForbidchunk();
		do {
			if (0 == generatedUpload_present) {
				result = data.Curl_get_upload_buffer();
				if (result) {
					return result;
				} 
				k.setUpload_fromhere(generatedState.getUlbuf());
				if (!generatedUpload_done) {
					size_t fillcount = new size_t();
					HTTP http = generatedProtop;
					if ((generatedExp100 == expect100.EXP100_SENDING_REQUEST) && (generatedSending == .HTTPSEND_BODY/* If this call is to send body data, we must take some action:
					             We have sent off the full HTTP 1.1 request, and we shall now
					             go into the Expect: 100 state and await such a header */)) {
						k.setExp100(/* wait for the header */expect100.EXP100_AWAITING_CONTINUE);
						generatedKeepon &=  ~(1 << /* disable writing */1);
						k.setStart100(curltime.Curl_now());
						didwhat &=  ~(1 << /* we didn't write anything actually */1);
						data.Curl_expire(generatedSet.getExpect_100_timeout(), /* set a timeout for the multi interface */.EXPIRE_100_TIMEOUT);
						break;
					} 
					if (generatedHandler.getProtocol() & ((CURLPROTO_HTTP | CURLPROTO_HTTPS) | CURLPROTO_RTSP)) {
						if (generatedSending == .HTTPSEND_REQUEST/* We're sending the HTTP request headers, not the data.
						               Remember that so we don't change the line endings. */) {
							sending_http_headers = 1;
						} else {
								sending_http_headers = 0;
						} 
					} 
					result = conn.Curl_fillreadbuffer(generatedSet.getUpload_buffer_size(), fillcount);
					if (result) {
						return result;
					} 
					nread = fillcount;
				} else {
						nread = /* we're done uploading/reading */0;
				} 
				if (!nread && (generatedKeepon & (1 << 5/* this is a paused transfer */))) {
					break;
				} 
				if (nread <= 0) {
					result = ModernizedCProgram.Curl_done_sending(conn, k);
					if (result) {
						return result;
					} 
					break;
				} 
				k.setUpload_present(/* store number of bytes available for upload */nread);
				if ((!sending_http_headers) && /* convert LF to CRLF if so asked */((generatedSet.getCrlf()))/* always convert if we're FTPing in ASCII mode */) {
					if (!generatedState.getScratch()) {
						generatedState.setScratch(.Curl_cmalloc(2 * generatedSet.getUpload_buffer_size()));
						if (!generatedState.getScratch()) {
							data.Curl_failf("Failed to alloc scratch buffer!");
							return CURLE_OUT_OF_MEMORY/*
							         * ASCII/EBCDIC Note: This is presumably a text (not binary)
							         * transfer so the data should already be in ASCII.
							         * That means the hex values for ASCII CR (0x0d) & LF (0x0a)
							         * must be used instead of the escape sequences \r & \n.
							         */;
						} 
					} 
					for (; i < nread; ) {
						if (generatedUpload_fromhere[i] == -1024) {
							generatedState.getScratch()[si++] = -1024;
							generatedState.getScratch()[si] = -1024;
							if (!generatedSet.getCrlf()) {
								if (generatedState.getInfilesize() != -1) {
									generatedState.getInfilesize()++;
								} 
							} 
						} else {
								generatedState.getScratch()[si] = generatedUpload_fromhere[i];
						} 
					}
					if (si != nread/* only perform the special operation if we really did replace
					             anything */) {
						nread = si;
						k.setUpload_fromhere(generatedState.getScratch());
						k.setUpload_present(/* set the new amount too */nread);
					} 
				} 
				if (generatedHandler.getProtocol() & (CURLPROTO_SMTP | CURLPROTO_SMTPS)) {
					result = conn.Curl_smtp_escape_eob(nread);
					if (result) {
						return result/* CURL_DISABLE_SMTP *//* if 0 == k->upload_present */;
					} 
				} 
			} 
			result = /* We have a partial buffer left from a previous "round". Use
			         that instead of reading more data *//* write to socket (send away data) */conn.Curl_write(generatedWritesockfd, generatedUpload_fromhere, generatedUpload_present, /* actually sent */bytes_written);
			if (result) {
				return result;
			} 
			ModernizedCProgram.win_update_buffer_size(generatedWritesockfd);
			if (generatedSet.getVerbose()) {
				data.Curl_debug(CURLINFO_DATA_OUT, generatedUpload_fromhere, (size_t)bytes_written);
			} 
			generatedWritebytecount += bytes_written;
			data.Curl_pgrsSetUploadCounter(generatedWritebytecount);
			if ((!generatedUpload_chunky || generatedForbidchunk) && (generatedWritebytecount == generatedState.getInfilesize())) {
				k.setUpload_done(/* we have sent all data we were supposed to */1);
				data.Curl_infof("We are completely uploaded and fine\n");
			} 
			if (generatedUpload_present != bytes_written/* we only wrote a part of the buffer (if anything), deal with it! */) {
				generatedUpload_present -= /* store the amount of bytes left in the buffer to write */bytes_written;
				generatedUpload_fromhere += /* advance the pointer where to find the buffer when the next send
				         is to happen */bytes_written;
			} else {
					result = /* we've uploaded that buffer now */data.Curl_get_upload_buffer();
					if (result) {
						return result;
					} 
					k.setUpload_fromhere(generatedState.getUlbuf());
					k.setUpload_present(/* no more bytes left */0);
					if (generatedUpload_done) {
						result = ModernizedCProgram.Curl_done_sending(conn, k);
						if (result) {
							return result;
						} 
					} 
			} 
		} while (/* just to break out from! */0);/* only read more data if there's no upload data already
		       present in the upload buffer */
		return CURLE_OK/*
		 * Curl_readwrite() is the low-level function to be called when data is to
		 * be read and written to/from the connection.
		 *
		 * return '*comeback' TRUE if we didn't properly drain the socket so this
		 * function should get called again without select() or similar in between!
		 */;
	}
	public static Object Curl_readwrite(connectdata conn, Curl_easy data,  done,  comeback) {
		Object generatedReq = data.getReq();
		SingleRequest k = generatedReq;
		 result = new ();
		int didwhat = 0;
		 fd_read = new ();
		 fd_write = new ();
		int generatedCselect_bits = conn.getCselect_bits();
		int select_res = generatedCselect_bits;
		conn.setCselect_bits(0/* only use the proper socket if the *_HOLD bit is not set simultaneously as
		     then we are in rate limiting state in that transfer direction */);
		int generatedKeepon = k.getKeepon();
		Object generatedSockfd = conn.getSockfd();
		if ((generatedKeepon & ((1 << 0) | (1 << 2) | (1 << 4))) == (1 << 0)) {
			fd_read = generatedSockfd;
		} else {
				fd_read = CURL_SOCKET_BAD;
		} 
		Object generatedWritesockfd = conn.getWritesockfd();
		if ((generatedKeepon & ((1 << 1) | (1 << 3) | (1 << 5))) == (1 << 1)) {
			fd_write = generatedWritesockfd;
		} else {
				fd_write = CURL_SOCKET_BAD;
		} 
		Curl_easy generatedData = conn.getData();
		Object generatedState = generatedData.getState();
		if (generatedState.getDrain()) {
			select_res |=  CURL_CSELECT_IN;
			do {
			} while (0);
		} 
		if (!/* Call for select()/poll() only, if read/write/error
		                     status is not known. */select_res) {
			select_res = ModernizedCProgram.Curl_socket_check(fd_read, CURL_SOCKET_BAD, fd_write, 0);
		} 
		if (select_res == CURL_CSELECT_ERR) {
			data.Curl_failf("select/poll returned error");
			return CURLE_SEND_ERROR;
		} 
		ConnectBits generatedBits = conn.getBits();
		Object generatedStream_was_rewound = generatedBits.getStream_was_rewound();
		if ((generatedKeepon & (1 << /* We go ahead and do a read if we have a readable socket or if
		     the stream was rewound (in which case we have data in a
		     buffer) */0)) && ((select_res & CURL_CSELECT_IN) || generatedStream_was_rewound)) {
			result = ModernizedCProgram.readwrite_data(data, conn, k, didwhat, done, comeback);
			if (result || done) {
				return result;
			} 
		} 
		if ((generatedKeepon & (1 << 1)) && (select_res & /* If we still have writing to do, we check if we have a writable socket. */CURL_CSELECT_OUT/* write */)) {
			result = ModernizedCProgram.readwrite_upload(data, conn, didwhat);
			if (result) {
				return result;
			} 
		} 
		curltime curltime = new curltime();
		k.setNow(curltime.Curl_now());
		expect100 generatedExp100 = k.getExp100();
		curltime generatedNow = k.getNow();
		curltime generatedStart100 = k.getStart100();
		Object generatedSet = data.getSet();
		if (didwhat) {
			;
		} else {
				if (generatedExp100 == /* no read no write, this is a timeout? */expect100.EXP100_AWAITING_CONTINUE/* This should allow some time for the header to arrive, but only a
				         very short time as otherwise it'll be too much wasted time too
				         often. *//* Quoting RFC2616, section "8.2.3 Use of the 100 (Continue) Status":
				
				         Therefore, when a client sends this header field to an origin server
				         (possibly via a proxy) from which it has never seen a 100 (Continue)
				         status, the client SHOULD NOT wait for an indefinite period before
				         sending the request body.
				
				      */) {
					timediff_t ms = generatedNow.Curl_timediff(generatedStart100);
					if (ms >= generatedSet.getExpect_100_timeout()) {
						k.setExp100(/* we've waited long enough, continue anyway */expect100.EXP100_SEND_DATA);
						generatedKeepon |=  (1 << 1);
						data.Curl_expire_done(.EXPIRE_100_TIMEOUT);
						data.Curl_infof("Done waiting for 100-continue\n");
					} 
				} 
		} 
		if (conn.Curl_pgrsUpdate()) {
			result = CURLE_ABORTED_BY_CALLBACK;
		} else {
				result = ModernizedCProgram.Curl_speedcheck(data, generatedNow);
		} 
		if (result) {
			return result;
		} 
		Object generatedSize = k.getSize();
		done = (0 == (generatedKeepon & ((1 << 0) | (1 << /* Now update the "done" boolean we return */1) | (1 << 4) | (1 << 5)))) ? 1 : 0;
		return CURLE_OK/*
		 * Curl_single_getsock() gets called by the multi interface code when the app
		 * has requested to get the sockets for the current connection. This function
		 * will then be called once for every connection that the multi interface
		 * keeps track of. This function will only be called for connections that are
		 * in the proper state to have this information available.
		 */;
	}
	public static int Curl_single_getsock(Object conn, Object sock) {
		Curl_easy data = conn.getData();
		int bitmap = 0;
		int sockindex = 0;
		if (conn.getHandler().getPerform_getsock()) {
			return .UNRECOGNIZEDFUNCTIONNAME(conn, sock);
		} 
		if ((data.getReq().getKeepon() & ((1 << 0) | (1 << 2) | (1 << 4))) == (1 << /* don't include HOLD and PAUSE connections */0)) {
			do {
			} while (0);
			bitmap |=  (1 << (sockindex));
			sock[sockindex] = conn.getSockfd();
		} 
		if ((data.getReq().getKeepon() & ((1 << 1) | (1 << 3) | (1 << 5))) == (1 << /* don't include HOLD and PAUSE connections */1)) {
			if ((conn.getSockfd() != conn.getWritesockfd()) || bitmap == 0/* only if they are not the same socket and we have a readable
			         one, we increase index */) {
				if (bitmap != 0) {
					/* increase index if we need two entries */sockindex++;
				} 
				do {
				} while (0);
				sock[sockindex] = conn.getWritesockfd();
			} 
			bitmap |=  (1 << (16 + (sockindex)));
		} 
		return bitmap;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* __INTEL_COMPILER && __unix__ */
	/*
	** unsigned long to unsigned short
	*/
	public static int curlx_ultous(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(ulnum & (long)-1024);
	}
	/*
	** unsigned long to unsigned char
	*/
	public static byte curlx_ultouc(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (byte)(ulnum & (long)-1024);
	}
	/*
	** unsigned long to signed int
	*/
	public static int curlx_ultosi(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(ulnum & (long)-1024);
	}
	/*
	** unsigned size_t to signed curl_off_t
	*/
	public static Object curlx_uztoso(Object uznum) {
		do {
		} while (/* cast truncates constant value */0);
		return .UNRECOGNIZEDFUNCTIONNAME(uznum & (size_t).CURL_OFF_T_C(-1024));
	}
	/* conversion may lose significant bits */
	/*
	** unsigned size_t to signed int
	*/
	public static int curlx_uztosi(Object uznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(uznum & (size_t)-1024);
	}
	/*
	** unsigned size_t to unsigned long
	*/
	public static long curlx_uztoul(Object uznum) {
		return (long)(uznum & (size_t)-1024);
	}
	/* conversion may lose significant bits */
	/*
	** unsigned size_t to unsigned int
	*/
	public static int curlx_uztoui(Object uznum) {
		return (int)(uznum & (size_t)-1024);
	}
	/* conversion may lose significant bits */
	/*
	** signed long to signed int
	*/
	public static int curlx_sltosi(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** signed long to unsigned int
	*/
	public static int curlx_sltoui(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** signed long to unsigned short
	*/
	public static int curlx_sltous(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		do {
		} while (0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** unsigned size_t to signed ssize_t
	*/
	public static Object curlx_uztosz(Object uznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (ssize_t)(uznum & (size_t)-1024);
	}
	/*
	** signed curl_off_t to unsigned size_t
	*/
	public static Object curlx_sotouz(Object sonum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (size_t)(sonum & ()-1024);
	}
	/*
	** signed ssize_t to signed int
	*/
	public static int curlx_sztosi(Object sznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(sznum & (ssize_t)-1024);
	}
	/*
	** unsigned int to unsigned short
	*/
	public static int curlx_uitous(int uinum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(uinum & (int)-1024);
	}
	/*
	** signed int to unsigned size_t
	*/
	public static Object curlx_sitouz(int sinum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (size_t)sinum;
	}
	/*
	** curl_socket_t to signed int
	*/
	public static int curlx_sktosi(Object s) {
		return (int)((ssize_t)s/*
		** signed int to curl_socket_t
		*/);
	}
	public static Object curlx_sitosk(int i) {
		return .UNRECOGNIZEDFUNCTIONNAME((ssize_t)i/* USE_WINSOCK */);
	}
	public static Object curlx_read(int fd, Object buf, Object count) {
		return (ssize_t).read(fd, buf, ModernizedCProgram.curlx_uztoui(count));
	}
	public static Object curlx_write(int fd, Object buf, Object count) {
		return (ssize_t).write(fd, buf, ModernizedCProgram.curlx_uztoui(count/* WIN32 || _WIN32 *//* clobber ignored */));
	}
	/* clobber ignored */
	/* variable was set but never used */
	/* conversion may lose significant bits */
	/* conversion may lose significant bits */
	/* __INTEL_COMPILER && __unix__ */
	public static Byte curl_getenv(Object v) {
		return ModernizedCProgram.GetEnv(v);
	}
	/*
	** callback for CURLOPT_HEADERFUNCTION
	*/
	public static Object tool_header_cb(Byte ptr, Object size, Object nmemb, Object userdata) {
		per_transfer per = userdata;
		HdrCbData generatedHdrcbdata = per.getHdrcbdata();
		HdrCbData hdrcbdata = generatedHdrcbdata;
		OutStruct generatedOuts = per.getOuts();
		OutStruct outs = generatedOuts;
		OutStruct generatedHeads = per.getHeads();
		OutStruct heads = generatedHeads;
		byte str = ptr;
		size_t cb = size * nmemb;
		byte end = (byte)ptr + cb;
		long protocol = 0/*
		   * Once that libcurl has called back tool_header_cb() the returned value
		   * is checked against the amount that was intended to be written, if
		   * it does not match then it fails with CURLE_WRITE_ERROR. So at this
		   * point returning a value different from sz*nmemb indicates failure.
		   */;
		size_t failure = (size && nmemb) ? 0 : 1;
		OperationConfig generatedConfig = heads.getConfig();
		if (!generatedConfig) {
			return failure;
		} 
		Object generatedOperationConfig = generatedConfig.getOperationConfig();
		_iobuf generatedStream = heads.getStream();
		if (generatedOperationConfig && generatedStream) {
			size_t rc = .fwrite(ptr, size, nmemb, generatedStream);
			if (rc != cb) {
				return rc;
			} 
			(Object).fflush(generatedStream);
		} 
		Object generatedCurl = per.getCurl();
		generatedCurl.curl_easy_getinfo(CURLINFO_PROTOCOL, protocol);
		 generatedHonor_cd_filename = hdrcbdata.getHonor_cd_filename();
		 generatedFopened = outs.getFopened();
		byte generatedFilename = outs.getFilename();
		 generatedAlloc_filename = outs.getAlloc_filename();
		if (generatedHonor_cd_filename && (cb > 20) && ModernizedCProgram.curl_strnequal("Content-disposition:", str, .strlen("Content-disposition:")) && (protocol & (CURLPROTO_HTTPS | CURLPROTO_HTTP))) {
			byte p = str + 20/* look for the 'filename=' parameter
			       (encoded filenames (*=) are not supported) */;
			for (; ; ) {
				byte filename;
				size_t len = new size_t();
				while (p && (p < end) && !(ModernizedCProgram.Curl_isalpha((int)((byte)p)))) {
					p++;
				}
				if (p > end - 9) {
					break;
				} 
				if (.memcmp(p, "filename=", 9)) {
					while ((p < end) && (p != /* no match, find next parameter */(byte)';')) {
						p++;
					}
					continue;
				} 
				p += 9/* this expression below typecasts 'cb' only to avoid
				         warning: signed and unsigned type in conditional expression
				      */;
				len = (ssize_t)cb - (p - str);
				ModernizedCProgram.filename = ModernizedCProgram.parse_filename(p, len);
				if (ModernizedCProgram.filename) {
					if (generatedStream) {
						int rc;
						if (generatedFopened) {
							.fclose(generatedStream);
						} 
						outs.setStream(((Object)0));
						rc = .rename(generatedFilename, /* rename the initial file name to the new file name */ModernizedCProgram.filename);
						if (rc != 0) {
							generatedOperationConfig.warnf("Failed to rename %s -> %s: %s\n", generatedFilename, ModernizedCProgram.filename, .strerror((._errno())));
						} 
						if (generatedAlloc_filename) {
							do {
								.free((generatedFilename));
								(generatedFilename) = ((Object)0);
							} while (0);
						} 
						if (rc != 0) {
							.free(ModernizedCProgram.filename);
							return failure;
						} 
					} 
					outs.setIs_cd_filename(1);
					outs.setS_isreg(1);
					outs.setFopened(0);
					outs.setFilename(ModernizedCProgram.filename);
					outs.setAlloc_filename(1);
					hdrcbdata.setHonor_cd_filename(/* done now! */0);
					if (!outs.tool_create_output_file()) {
						return failure;
					} 
				} 
				break;
			}
			if (!generatedStream && !outs.tool_create_output_file()) {
				return failure;
			} 
		} 
		GlobalConfig generatedGlobal = hdrcbdata.getGlobal();
		 generatedIsatty = generatedGlobal.getIsatty();
		 generatedStyled_output = generatedGlobal.getStyled_output();
		if (generatedOperationConfig && (protocol & (CURLPROTO_HTTP | CURLPROTO_HTTPS | CURLPROTO_RTSP | CURLPROTO_FILE))) {
			byte value = ((Object)/* bold headers only for selected protocols */0);
			if (!generatedStream && !outs.tool_create_output_file()) {
				return failure;
			} 
			if (generatedIsatty && generatedStyled_output) {
				value = .memchr(ptr, (byte)':', cb);
			} 
			if (value) {
				size_t namelen = value - ptr;
				generatedStream.curl_mfprintf("%.*s:", namelen, ptr);
				.fwrite(value[1], cb - namelen - 1, 1, generatedStream);
			} else {
					.fwrite(ptr, cb, 1, generatedStream);
			} 
		} 
		return cb/*
		 * Copies a file name part and returns an ALLOCATED data buffer.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static Byte parse_filename(Object ptr, Object len) {
		byte copy;
		byte p;
		byte q;
		byte stop = (byte)'\0';
		copy = .malloc(len + /* simple implementation of strndup() */1);
		if (!copy) {
			return ((Object)0);
		} 
		.memcpy(copy, ptr, len);
		copy[len] = (byte)'\0';
		p = copy;
		if (p == (byte)'\'' || p == (byte)'"') {
			stop = /* store the starting quote */p;
			p++;
		} else {
				stop = (byte)';';
		} 
		q = .strchr(p, /* scan for the end letter and stop there */stop);
		if (q) {
			q = (byte)'\0';
		} 
		q = .strrchr(p, /* if the filename contains a path, only use filename portion */(byte)'/');
		if (q) {
			p = q + 1;
			if (!p) {
				do {
					.free((copy));
					(copy) = ((Object)0);
				} while (0);
				return ((Object)0);
			} 
		} 
		q = .strrchr(p, /* If the filename contains a backslash, only use filename portion. The idea
		     is that even systems that don't handle backslashes as path separators
		     probably want the path removed for convenience. */(byte)'\\');
		if (q) {
			p = q + 1;
			if (!p) {
				do {
					.free((copy));
					(copy) = ((Object)0);
				} while (0);
				return ((Object)0);
			} 
		} 
		q = .strchr(p, /* make sure the file name doesn't end in \r or \n */(byte)'\r');
		if (q) {
			q = (byte)'\0';
		} 
		q = .strchr(p, (byte)'\n');
		if (q) {
			q = (byte)'\0';
		} 
		if (copy != p) {
			.memmove(copy, p, .strlen(p) + 1);
		} 
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, copy, 0);
			do {
				.free((copy));
				(copy) = ((Object)0);
			} while (0);
			if (sc) {
				return ((Object)0);
			} 
			copy = sanitized/* MSDOS || WIN32 *//* in case we built debug enabled, we allow an environment variable
			   * named CURL_TESTDIR to prefix the given file name to put it into a
			   * specific directory
			   */;
		}
		/* suitably large */return /* clone the buffer, we don't use the libcurl
		                                aprintf() or similar since we want to use the
		                                same memory code as the "real" parse_filename
		                                function */copy;
	}
	/* Switch off bold by setting "all attributes off" since the explicit
	   bold-off code (21) isn't supported everywhere - like in the mac
	   Terminal. */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* for setlocale() */
	/* for setmode() */
	/* for setmode() */
	public static int select_wrapper(int nfds, fd_set rd, fd_set wr, fd_set exc, timeval tv) {
		if (nfds < 0) {
			(.WSASetLastError((int)(true)));
			return -1/*
			   * Winsock select() requires that at least one of the three fd_set
			   * pointers is not NULL and points to a non-empty fdset. IOW Winsock
			   * select() can not be used to sleep without a single fd_set.
			   */;
		} 
		long generatedTv_sec = tv.getTv_sec();
		long generatedTv_usec = tv.getTv_usec();
		if (!nfds) {
			.Sleep((1000 * generatedTv_sec) + (DWORD)(((double)generatedTv_usec) / 1000.0));
			return 0;
		} 
		return .select(nfds, rd, wr, exc, tv);
	}
	/* this weird stuff here is to make curl_free() get called before
	       curl_dbg_memdebug() as otherwise memory tracking will log a free()
	       without an alloc! */
	/* if CURL_MEMLIMIT is set, this enables fail-on-alloc-number-N feature */
	/* returns a hexdump in a static memory area */
	public static Byte hexdump(Object buffer, Object len) {
		byte[] dump = new byte[200 * 3 + 1];
		byte p = dump;
		size_t i = new size_t();
		if (len > 200) {
			return ((Object)0);
		} 
		for (i = 0; i < len; ) {
			ModernizedCProgram.curl_msnprintf(p, 4, "%02x ", buffer[i]);
		}
		return dump;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * Upload to FTP, resuming failed transfers.
	 * </DESC>
	 */
	/* parse headers for Content-Length */
	public static Object getcontentlengthfunc(Object ptr, Object size, Object nmemb, Object stream) {
		int r;
		long len = 0;
		r = .sscanf(ptr, "Content-Length: %ld\n", len);
		if (r) {
			((long)stream) = len;
		} 
		return size * nmemb;
	}
	/* discard downloaded data */
	public static Object discardfunc(Object ptr, Object size, Object nmemb, Object stream) {
		(Object)ptr;
		(Object)stream;
		return size * nmemb;
	}
	/* read data to upload */
	public static Object readfunc(Object ptr, Object size, Object nmemb, Object stream) {
		FILE f = stream;
		size_t n = new size_t();
		Object generated_flag = (f).get_flag();
		if ((generated_flag & -1024)) {
			return CURL_READFUNC_ABORT;
		} 
		n = .fread(ptr, size, nmemb, f) * size;
		return n;
		FILE f = (FILE)stream;
		size_t n = new size_t();
		Object generated_flag = (f).get_flag();
		if ((generated_flag & -1024)) {
			return CURL_READFUNC_ABORT;
		} 
		n = .fread(ptr, size, nmemb, f) * size;
		return n/*
		 * sftpGetRemoteFileSize returns the remote file size in byte; -1 on error
		 */;
	}
	public static int upload(Object curlhandle, Object remotepath, Object localpath, long timeout, long tries) {
		FILE f = new FILE();
		long uploaded_len = 0;
		 r = CURLE_GOT_NOTHING;
		int c;
		f = .fopen(localpath, "rb");
		if (!f) {
			.perror(((Object)0));
			return 0;
		} 
		curlhandle.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
		curlhandle.curl_easy_setopt(CURLOPT_URL, remotepath);
		if (timeout) {
			curlhandle.curl_easy_setopt(CURLOPT_FTP_RESPONSE_TIMEOUT, timeout);
		} 
		curlhandle.curl_easy_setopt(CURLOPT_HEADERFUNCTION, getcontentlengthfunc);
		curlhandle.curl_easy_setopt(CURLOPT_HEADERDATA, uploaded_len);
		curlhandle.curl_easy_setopt(CURLOPT_WRITEFUNCTION, discardfunc);
		curlhandle.curl_easy_setopt(CURLOPT_READFUNCTION, readfunc);
		curlhandle.curl_easy_setopt(CURLOPT_READDATA, f);
		curlhandle.curl_easy_setopt(CURLOPT_FTPPORT, /* disable passive mode */"-");
		curlhandle.curl_easy_setopt(CURLOPT_FTP_CREATE_MISSING_DIRS, -1024);
		curlhandle.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		for (c = 0; (r != CURLE_OK) && (c < tries); c++) {
			if (/* are we resuming? *//* yes */c/* determine the length of the file already written *//*
			       * With NOBODY and NOHEADER, libcurl will issue a SIZE
			       * command, but the only way to retrieve the result is
			       * to parse the returned Content-Length header. Thus,
			       * getcontentlengthfunc(). We need discardfunc() above
			       * because HEADER will dump the headers to stdout
			       * without it.
			       */) {
				curlhandle.curl_easy_setopt(CURLOPT_NOBODY, -1024);
				curlhandle.curl_easy_setopt(CURLOPT_HEADER, -1024);
				r = curlhandle.curl_easy_perform();
				if (r != CURLE_OK) {
					continue;
				} 
				curlhandle.curl_easy_setopt(CURLOPT_NOBODY, -1024);
				curlhandle.curl_easy_setopt(CURLOPT_HEADER, -1024);
				.fseek(f, uploaded_len, 0);
				curlhandle.curl_easy_setopt(CURLOPT_APPEND, -1024);
			} else {
					curlhandle.curl_easy_setopt(CURLOPT_APPEND, /* no */-1024);
			} 
			r = curlhandle.curl_easy_perform();
		}
		.fclose(f);
		if (r == CURLE_OK) {
			return 1;
		} else {
				.fprintf((_iob[2]), "%s\n", ModernizedCProgram.curl_easy_strerror(r));
				return 0;
		} 
	}
	public static int Curl_resolver_global_init() {
		return CURLE_OK/*
		 * Curl_resolver_global_cleanup()
		 * Called from curl_global_cleanup() to destroy global resolver environment.
		 * Does nothing here.
		 */;
	}
	public static void Curl_resolver_global_cleanup() {
	}
	/*
	 * Curl_resolver_init()
	 * Called from curl_easy_init() -> Curl_open() to initialize resolver
	 * URL-state specific environment ('resolver' member of the UrlState
	 * structure).
	 */
	public static void Curl_resolver_cleanup(Object resolver) {
		.Curl_cfree(resolver/*
		 * Curl_resolver_duphandle()
		 * Called from curl_easy_duphandle() to duplicate resolver URL state-specific
		 * environment ('resolver' member of the UrlState structure).
		 */);
	}
	/* too late, gotta clean up the mess */
	/* DNS has been resolved, signal client task */
	/* update sock_erro to errno */
	/* HAVE_GETADDRINFO */
	/*
	 * gethostbyname_thread() resolves a name and then exits.
	 */
	public static int gethostbyname_thread(Object arg) {
		thread_sync_data tsd = (thread_sync_data)arg;
		thread_data generatedTd = tsd.getTd();
		thread_data td = generatedTd;
		Byte generatedHostname = tsd.getHostname();
		int generatedPort = tsd.getPort();
		Curl_addrinfo curl_addrinfo = new Curl_addrinfo();
		tsd.setRes(curl_addrinfo.Curl_ipv4_resolve_r(generatedHostname, generatedPort));
		Curl_addrinfo generatedRes = tsd.getRes();
		int generatedSock_error = tsd.getSock_error();
		if (!generatedRes) {
			tsd.setSock_error(((int).WSAGetLastError()));
			if (generatedSock_error == 0) {
				tsd.setSock_error(12);
			} 
		} 
		_CRITICAL_SECTION generatedMtx = tsd.getMtx();
		.EnterCriticalSection(generatedMtx);
		int generatedDone = tsd.getDone();
		if (generatedDone) {
			.LeaveCriticalSection(generatedMtx);
			tsd.destroy_thread_sync_data();
			.Curl_cfree(td);
		} else {
				tsd.setDone(1);
				.LeaveCriticalSection(generatedMtx);
		} 
		return 0/* HAVE_GETADDRINFO */;
	}
	public static Object thread_wait_resolv(connectdata conn, Curl_dns_entry entry,  report) {
		Curl_async generatedAsync = conn.getAsync();
		Object generatedOs_specific = generatedAsync.getOs_specific();
		thread_data td = (thread_data)generatedOs_specific;
		 result = CURLE_OK;
		do {
		} while (0);
		do {
		} while (0);
		Object generatedThread_hnd = td.getThread_hnd();
		if (ModernizedCProgram.Curl_thread_join(generatedThread_hnd)) {
			if (entry) {
				result = conn.getaddrinfo_complete();
			} 
		} else {
				do {
				} while (0);
		} 
		generatedAsync.setDone(1);
		Curl_dns_entry generatedDns = generatedAsync.getDns();
		if (entry) {
			entry = generatedDns;
		} 
		if (!generatedDns && report) {
			result = /* a name was not resolved, report error */conn.resolver_error();
		} 
		generatedAsync.destroy_async_data();
		if (!generatedDns && report) {
			conn.Curl_conncontrol(1);
		} 
		return result/*
		 * Until we gain a way to signal the resolver threads to stop early, we must
		 * simply wait for them and ignore their results.
		 */;
	}
	public static Object Curl_resolver_wait_resolv(connectdata conn, Curl_dns_entry entry) {
		return ModernizedCProgram.thread_wait_resolv(conn, entry, 1/*
		 * Curl_resolver_is_resolved() is called repeatedly to check if a previous
		 * name resolve request has completed. It should also make sure to time-out if
		 * the operation seems to take too long.
		 */);
	}
	public static Object Curl_resolver_is_resolved(connectdata conn, Curl_dns_entry entry) {
		Curl_easy generatedData = conn.getData();
		Curl_easy data = generatedData;
		Curl_async generatedAsync = conn.getAsync();
		Object generatedOs_specific = generatedAsync.getOs_specific();
		thread_data td = (thread_data)generatedOs_specific;
		int done = 0;
		entry = ((Object)0);
		if (!td) {
			do {
			} while (0);
			return CURLE_COULDNT_RESOLVE_HOST;
		} 
		thread_sync_data generatedTsd = td.getTsd();
		_CRITICAL_SECTION generatedMtx = generatedTsd.getMtx();
		.EnterCriticalSection(generatedMtx);
		int generatedDone = generatedTsd.getDone();
		done = generatedDone;
		.LeaveCriticalSection(generatedMtx);
		Curl_dns_entry generatedDns = generatedAsync.getDns();
		curltime curltime = new curltime();
		Object generatedProgress = data.getProgress();
		int generatedPoll_interval = td.getPoll_interval();
		Object generatedInterval_end = td.getInterval_end();
		if (done) {
			conn.getaddrinfo_complete();
			if (!generatedDns) {
				 result = conn.resolver_error();
				generatedAsync.destroy_async_data();
				return ModernizedCProgram.result;
			} 
			generatedAsync.destroy_async_data();
			entry = generatedDns;
		} else {
				time_t elapsed = (time_t)curltime.Curl_now().Curl_timediff(generatedProgress.getT_startsingle());
				if (elapsed < 0) {
					elapsed = 0;
				} 
				if (generatedPoll_interval == 0) {
					td.setPoll_interval(/* Start at 1ms poll interval */1);
				}  else if (elapsed >= generatedInterval_end) {
					generatedPoll_interval *= /* Back-off exponentially if last interval expired  */2;
				} 
				if (generatedPoll_interval > 250) {
					td.setPoll_interval(250);
				} 
				td.setInterval_end(elapsed + generatedPoll_interval);
				generatedData.Curl_expire(generatedPoll_interval, .EXPIRE_ASYNC_NAME);
		} 
		return CURLE_OK;
	}
	/* some helper function. */
	public static Byte ia5string(Object ia5) {
		byte tmp;
		if (!ia5 || !ia5.getLength()) {
			return ((Object)0);
		} 
		tmp = .OPENSSL_malloc(ia5.getLength() + 1);
		.memcpy(tmp, ia5.getData(), ia5.getLength());
		tmp[ia5.getLength()] = 0;
		return tmp;
	}
	/* A convenience routine to get an access URI. */
	public static Byte my_get_ext(Object cert, Object type, int extensiontype) {
		int i;
		.STACK_OF(ACCESS_DESCRIPTION) * accessinfo;
		accessinfo = .X509_get_ext_d2i(cert, extensiontype, ((Object)0), ((Object)0));
		if (!.sk_ACCESS_DESCRIPTION_num(accessinfo)) {
			return ((Object)0);
		} 
		for (i = 0; i < .sk_ACCESS_DESCRIPTION_num(accessinfo); i++) {
			 ad = .sk_ACCESS_DESCRIPTION_value(accessinfo, i);
			if (.OBJ_obj2nid(ad.getMethod()) == type) {
				if (ad.getLocation().getType() == GEN_URI) {
					return ModernizedCProgram.ia5string(ad.getLocation().getD().getIa5());
				} 
				return ((Object)0);
			} 
		}
		return ((Object)0/* This is an application verification call back, it does not
		   perform any addition verification but tries to find a URL
		   in the presented certificate. If found, this will become
		   the URL to be used in the POST.
		*/);
	}
	public static int ssl_app_verify_callback(Object ctx, Object arg) {
		sslctxparm p = (sslctxparm)arg;
		int ok;
		int generatedVerbose = p.getVerbose();
		Object generatedErrorbio = p.getErrorbio();
		if (generatedVerbose > 2) {
			.BIO_printf(generatedErrorbio, "entering ssl_app_verify_callback\n");
		} 
		ok = .X509_verify_cert(ctx);
		int generatedAccesstype = p.getAccesstype();
		Object generatedCurl = p.getCurl();
		if (ok && ctx.getCert()) {
			byte accessinfo;
			if (generatedVerbose > 1) {
				.X509_print_ex(generatedErrorbio, ctx.getCert(), 0, 0);
			} 
			accessinfo = ModernizedCProgram.my_get_ext(ctx.getCert(), generatedAccesstype, NID_sinfo_access);
			if (accessinfo) {
				if (generatedVerbose) {
					.BIO_printf(generatedErrorbio, "Setting URL from SIA to: %s\n", accessinfo);
				} 
				generatedCurl.curl_easy_setopt(CURLOPT_URL, accessinfo);
			}  else if (accessinfo = ModernizedCProgram.my_get_ext(ctx.getCert(), generatedAccesstype, NID_info_access)) {
				if (generatedVerbose) {
					.BIO_printf(generatedErrorbio, "Setting URL from AIA to: %s\n", accessinfo);
				} 
				generatedCurl.curl_easy_setopt(CURLOPT_URL, accessinfo);
			} 
		} 
		if (generatedVerbose > 2) {
			.BIO_printf(generatedErrorbio, "leaving ssl_app_verify_callback with %d\n", ok);
		} 
		return ok/* The SSL initialisation callback. The callback sets:
		   - a private key and certificate
		   - a trusted ca certificate
		   - a preferred cipherlist
		   - an application verification callback (the function above)
		*/;
	}
	public static Object sslctxfun(Object curl, Object sslctx, Object parm) {
		sslctxparm p = (sslctxparm)parm;
		 ctx = ()sslctx;
		Object generatedUsercert = p.getUsercert();
		Object generatedErrorbio = p.getErrorbio();
		if (!.SSL_CTX_use_certificate(ctx, generatedUsercert)) {
			.BIO_printf(generatedErrorbio, "SSL_CTX_use_certificate problem\n");
			;
		} 
		Object generatedPkey = p.getPkey();
		if (!.SSL_CTX_use_PrivateKey(ctx, generatedPkey)) {
			.BIO_printf(generatedErrorbio, "SSL_CTX_use_PrivateKey\n");
			;
		} 
		if (!.SSL_CTX_check_private_key(ctx)) {
			.BIO_printf(generatedErrorbio, "SSL_CTX_check_private_key\n");
			;
		} 
		.SSL_CTX_set_quiet_shutdown(ctx, 1);
		.SSL_CTX_set_cipher_list(ctx, "RC4-MD5");
		.SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
		Object generatedCa = p.getCa();
		.X509_STORE_add_cert(.SSL_CTX_get_cert_store(ctx), .sk_X509_value(generatedCa, .sk_X509_num(generatedCa) - 1));
		.SSL_CTX_set_verify_depth(ctx, 2);
		.SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, 0);
		.SSL_CTX_set_cert_verify_callback(ctx, ssl_app_verify_callback, parm);
		return CURLE_OK;
		return CURLE_SSL_CERTPROBLEM;
	}
	public static void MD4_Init() {
		this.setHCryptProv(0);
		this.setHHash(0);
		Object generatedHCryptProv = this.getHCryptProv();
		Object generatedHHash = this.getHHash();
		if (.CryptAcquireContextA(generatedHCryptProv, ((Object)0), ((Object)0), 1, -1024)) {
			.CryptCreateHash(generatedHCryptProv, (32768 | 0 | 2), 0, 0, generatedHHash);
		} 
	}
	public static void MD4_Update(Object data, long size) {
		Object generatedHHash = this.getHHash();
		.CryptHashData(generatedHHash, data, (int)size, 0);
	}
	public static void MD4_Final(Byte result) {
		long length = 0;
		Object generatedHHash = this.getHHash();
		.CryptGetHashParam(generatedHHash, 2, ((Object)0), length, 0);
		if (length == 16) {
			.CryptGetHashParam(generatedHHash, 2, result, length, 0);
		} 
		if (generatedHHash) {
			.CryptDestroyHash(generatedHHash);
		} 
		Object generatedHCryptProv = this.getHCryptProv();
		if (generatedHCryptProv) {
			.CryptReleaseContext(generatedHCryptProv, 0/* The last #include file should be: */);
		} 
	}
	/* When no other crypto library is available, or the crypto library doesn't
	 * support MD4, we use this code segment this implementation of it
	 *
	 * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
	 * MD4 Message-Digest Algorithm (RFC 1320).
	 *
	 * Homepage:
	 https://openwall.info/wiki/people/solar/software/public-domain-source-code/md4
	 *
	 * Author:
	 * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
	 *
	 * This software was written by Alexander Peslyak in 2001.  No copyright is
	 * claimed, and the software is hereby placed in the public domain.  In case
	 * this attempt to disclaim copyright and place the software in the public
	 * domain is deemed null and void, then the software is Copyright (c) 2001
	 * Alexander Peslyak and it is hereby released to the general public under the
	 * following terms:
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted.
	 *
	 * There's ABSOLUTELY NO WARRANTY, express or implied.
	 *
	 * (This is a heavily cut-down "BSD license".)
	 *
	 * This differs from Colin Plumb's older public domain implementation in that
	 * no exactly 32-bit integer data type is required (any 32-bit or wider
	 * unsigned integer data type will do), there's no compile-time endianness
	 * configuration, and the function prototypes match OpenSSL's.  No code from
	 * Colin Plumb's implementation has been reused; this comment merely compares
	 * the properties of the two independent implementations.
	 *
	 * The primary goals of this implementation are portability and ease of use.
	 * It is meant to be fast, but not as fast as possible.  Some known
	 * optimizations are not included to reduce source code size and avoid
	 * compile-time configuration.
	 */
	/* Any 32-bit or wider unsigned integer data type will do */
	/*
	 * The basic MD4 functions.
	 *
	 * F and G are optimized compared to their RFC 1320 definitions, with the
	 * optimization for F borrowed from Colin Plumb's MD5 implementation.
	 */
	/*
	 * The MD4 transformation for all three rounds.
	 */
	/*
	 * SET reads 4 input bytes in little-endian byte order and stores them
	 * in a properly aligned word in host byte order.
	 *
	 * The check for little-endian architectures that tolerate unaligned
	 * memory accesses is just an optimization.  Nothing will break if it
	 * doesn't work.
	 */
	/*
	 * This processes one or more 64-byte data blocks, but does NOT update
	 * the bit counters.  There are no alignment requirements.
	 */
	/* Round 1 */
	/* Round 2 */
	/* Round 3 */
	/* CRYPTO LIBS */
	public static void Curl_md4it(Byte output, Object input, Object len) {
		MD4_CTX ctx = new MD4_CTX();
		ctx.MD4_Init();
		ctx.MD4_Update(input, ModernizedCProgram.curlx_uztoui(len));
		ctx/* CURL_DISABLE_CRYPTO_AUTH */.MD4_Final(output);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <DESC>
	 * HTTP PUT upload with authentiction using "any" method. libcurl picks the
	 * one the server supports/wants.
	 * </DESC>
	 */
	/*
	 * This example shows a HTTP PUT operation with authentiction using "any"
	 * type. It PUTs a file given as a command line argument to the URL also given
	 * on the command line.
	 *
	 * Since libcurl 7.12.3, using "any" auth and POST/PUT requires a set ioctl
	 * function.
	 *
	 * This example also uses its own read callback.
	 */
	/* ioctl callback function */
	public static Object my_ioctl(Object handle, Object cmd, Object userp) {
		int fdp = (int)userp;
		int fd = fdp;
		(Object)/* not used in here */handle;
		switch (cmd) {
		case CURLIOCMD_RESTARTREAD:
				if (-1 == .lseek(fd, 0, /* mr libcurl kindly asks as to rewind the read data stream to start */0)) {
					return /* couldn't rewind */CURLIOE_FAILRESTART;
				} 
				break;
		default:
				return CURLIOE_UNKNOWNCMD;
		}
		return /* success! */CURLIOE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2014, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object WriteOutput(Object ptr, Object size, Object nmemb, Object stream) {
		.fwrite(ptr, size, nmemb, stream);
		return nmemb * size;
	}
	public static Object WriteHeader(Object ptr, Object size, Object nmemb, Object stream) {
		(Object)ptr;
		(Object)stream;
		ModernizedCProgram.realHeaderSize += ModernizedCProgram.curlx_uztoul(size * nmemb);
		return nmemb * size;
	}
	public static Byte getflagstr(int flags) {
		byte buf = .malloc(256);
		if (buf) {
			ModernizedCProgram.curl_msnprintf(buf, 256, "%s,%s,%s,%s", ((flags & (1 << 0)) ? "SANITIZE_ALLOW_COLONS" : ""), ((flags & (1 << 1)) ? "SANITIZE_ALLOW_PATH" : ""), ((flags & (1 << 2)) ? "SANITIZE_ALLOW_RESERVED" : ""), ((flags & (1 << 3)) ? "SANITIZE_ALLOW_TRUNCATE" : ""));
		} 
		return buf;
	}
	public static Byte getcurlcodestr(int cc) {
		byte buf = .malloc(256);
		if (buf) {
			ModernizedCProgram.curl_msnprintf(buf, 256, "%s (%d)", (cc == .SANITIZE_ERR_OK ? "SANITIZE_ERR_OK" : cc == .SANITIZE_ERR_BAD_ARGUMENT ? "SANITIZE_ERR_BAD_ARGUMENT" : cc == .SANITIZE_ERR_INVALID_PATH ? "SANITIZE_ERR_INVALID_PATH" : cc == .SANITIZE_ERR_OUT_OF_MEMORY ? "SANITIZE_ERR_OUT_OF_MEMORY" : "unexpected error code - add name"), cc);
		} 
		return buf;
	}
	public static Object ret2name(int i) {
		switch (i) {
		case 0:
				return "MATCH";
		case 1:
				return "NOMATCH";
		case 2:
				return "FAIL";
		default:
				return "unknown"/* not reached */;
		}
	}
	public static void makeOS400IconvCode(Byte buf, int ccsid) {
		ccsid &=  -1024;
		if (ccsid == 65535) {
			ccsid = 819;
		} 
		.memset(buf, 0, 32);
		ModernizedCProgram.curl_msprintf(buf, "IBMCCSID%05u0000000", ccsid);
	}
	public static Object iconv_open_CCSID(int ccsidout, int ccsidin, int cstr) {
		byte[] fromcode = new byte[32];
		byte[] tocode = new byte[32/**
		  ***  Like iconv_open(), but character codes are given as CCSIDs.
		  ***  If `cstr' is non-zero, conversion is set up to stop whenever a
		  ***   null character is encountered.
		  ***  See iconv_open() IBM description in "National Language Support API".
		  **/];
		ModernizedCProgram.makeOS400IconvCode(fromcode, ccsidin);
		ModernizedCProgram.makeOS400IconvCode(tocode, ccsidout);
		.memset(tocode + 13, 0,  - /* Dest. code id format. */13);
		if (cstr) {
			fromcode[18] = /* Set null-terminator flag. */(byte)'1';
		} 
		return .iconv_open(tocode, fromcode);
	}
	public static int convert(Byte d, Object dlen, int dccsid, Object s, int slen, int sccsid) {
		int i;
		 cd = new ();
		size_t lslen = new size_t();
		/**
		  ***  Convert `sccsid'-coded `slen'-data bytes at `s' into `dccsid'-coded
		  ***   data stored in the `dlen'-byte buffer at `d'.
		  ***  If `slen' < 0, source string is null-terminated.
		  ***  CCSID 65535 (no conversion) is replaced by the ASCII CCSID.
		  ***  Return the converted destination byte count, or -1 if error.
		  **/
		if (sccsid == 65535) {
			sccsid = 819;
		} 
		if (dccsid == 65535) {
			dccsid = 819;
		} 
		if (sccsid == dccsid) {
			lslen = slen >= 0 ? slen : .strlen(s) + 1;
			i = lslen < dlen ? lslen : dlen;
			if (s != d && i > 0) {
				.memcpy(d, s, i);
			} 
			return i;
		} 
		if (slen < 0) {
			lslen = 0;
			cd = ModernizedCProgram.iconv_open_CCSID(dccsid, sccsid, 1);
		} else {
				lslen = (size_t)slen;
				cd = ModernizedCProgram.iconv_open_CCSID(dccsid, sccsid, 0);
		} 
		if (((cd).getReturn_value() == -1)) {
			return -1;
		} 
		i = dlen;
		if ((int).iconv(cd, (byte)s, lslen, d, dlen) < 0) {
			i = -1;
		} else {
				i -= dlen;
		} 
		.iconv_close(cd);
		return i;
	}
	public static Byte dynconvert(int dccsid, Object s, int slen, int sccsid) {
		byte d;
		byte cp;
		size_t dlen = new size_t();
		int l;
		byte nullbyte = 0;
		dlen = (size_t)(slen < 0 ? .strlen(s) : slen) + /* Like convert, but the destination is allocated and returned. */1;
		dlen *= /* Allow some expansion. */4;
		d = .malloc(dlen);
		if (!d) {
			return (byte)((Object)0);
		} 
		l = ModernizedCProgram.convert(d, dlen, dccsid, s, slen, sccsid);
		if (l < 0) {
			.free(d);
			return (byte)((Object)0);
		} 
		if (slen < 0/* Need to null-terminate even when source length is given.
		       Since destination code size is unknown, use a conversion to generate
		       terminator. */) {
			int l2 = ModernizedCProgram.convert(d + l, dlen - l, dccsid, nullbyte, -1, 819);
			if (l2 < 0) {
				.free(d);
				return (byte)((Object)0);
			} 
			l += l2;
		} 
		if ((size_t)l < dlen) {
			cp = .realloc(d, /* Shorten to minimum needed. */l);
			if (cp) {
				d = cp;
			} 
		} 
		return d;
	}
	public static Byte curl_version_ccsid(int ccsid) {
		int i;
		byte aversion;
		byte eversion;
		aversion = ModernizedCProgram.curl_version();
		if (!aversion) {
			return aversion;
		} 
		i = .strlen(aversion) + 1;
		i *= 4;
		eversion = .Curl_thread_buffer(.LK_CURL_VERSION, i);
		if (!eversion) {
			return (byte)((Object)0);
		} 
		if (ModernizedCProgram.convert(eversion, i, ccsid, aversion, -1, 819) < 0) {
			return (byte)((Object)0);
		} 
		return eversion;
	}
	public static Byte curl_easy_escape_ccsid(Object handle, Object string, int length, int sccsid, int dccsid) {
		byte s;
		byte d;
		if (!string) {
			(._errno()) = -1024;
			return (byte)((Object)0);
		} 
		s = ModernizedCProgram.dynconvert(819, string, length ? length : -1, sccsid);
		if (!s) {
			return (byte)((Object)0);
		} 
		d = handle.curl_easy_escape(s, 0);
		.free(s);
		if (!d) {
			return (byte)((Object)0);
		} 
		s = ModernizedCProgram.dynconvert(dccsid, d, -1, 819);
		.free(d);
		return s;
	}
	public static Byte curl_easy_unescape_ccsid(Object handle, Object string, int length, int outlength, int sccsid, int dccsid) {
		byte s;
		byte d;
		if (!string) {
			(._errno()) = -1024;
			return (byte)((Object)0);
		} 
		s = ModernizedCProgram.dynconvert(819, string, length ? length : -1, sccsid);
		if (!s) {
			return (byte)((Object)0);
		} 
		d = handle.curl_easy_unescape(s, 0, outlength);
		.free(s);
		if (!d) {
			return (byte)((Object)0);
		} 
		s = ModernizedCProgram.dynconvert(dccsid, d, -1, 819);
		.free(d);
		if (s && outlength) {
			outlength = .strlen(s);
		} 
		return s;
	}
	public static Object curl_getdate_ccsid(Object p, Object unused, int ccsid) {
		byte s;
		time_t t = new time_t();
		if (!p) {
			return ModernizedCProgram.curl_getdate(p, unused);
		} 
		s = ModernizedCProgram.dynconvert(819, p, -1, ccsid);
		if (!s) {
			return (time_t)-1;
		} 
		t = ModernizedCProgram.curl_getdate(s, unused);
		.free(s);
		return t;
	}
	public static int convert_version_info_string(Object stringp, byte bufp, int left, int ccsid) {
		if (stringp) {
			int l = ModernizedCProgram.convert(bufp, left, ccsid, stringp, -1, 819);
			if (l <= 0) {
				return -1;
			} 
			stringp = bufp;
			bufp += l;
			left -= l;
		} 
		return 0;
	}
	/* Helper for curl_version_info_ccsid(): convert a string if defined.
	     Result is stored in the `*left'-byte buffer at `*bufp'.
	     `*bufp' and `*left' are updated accordingly.
	     Return 0 if ok, else -1. */
	public static  curl_version_info_ccsid( stamp, int ccsid) {
		curl_version_info_data p = new curl_version_info_data();
		byte cp;
		int n;
		int nproto;
		curl_version_info_data id = new curl_version_info_data();
		/* The assertion below is possible, because although the second operand
		     is an enum member, the first is a #define. In that case, the OS/400 C
		     compiler seems to compare string values after substitution. */
		if (stamp > /* If caller has been compiled with a new version, error. */.CURLVERSION_SIXTH) {
			return (curl_version_info_data)((Object)0);
		} 
		p = ModernizedCProgram.curl_version_info(stamp);
		if (!p) {
			return p;
		} 
		n = /* Measure thread space needed. */0;
		nproto = 0;
		Object generatedProtocols = p.getProtocols();
		if (generatedProtocols) {
			while (generatedProtocols[nproto]) {
				n += .strlen(generatedProtocols[nproto++]);
			}
			n += nproto++;
		} 
		Object generatedVersion = p.getVersion();
		if (generatedVersion) {
			n += .strlen(generatedVersion) + 1;
		} 
		Object generatedHost = p.getHost();
		if (generatedHost) {
			n += .strlen(generatedHost) + 1;
		} 
		Object generatedSsl_version = p.getSsl_version();
		if (generatedSsl_version) {
			n += .strlen(generatedSsl_version) + 1;
		} 
		Object generatedLibz_version = p.getLibz_version();
		if (generatedLibz_version) {
			n += .strlen(generatedLibz_version) + 1;
		} 
		Object generatedAres = p.getAres();
		if (generatedAres) {
			n += .strlen(generatedAres) + 1;
		} 
		Object generatedLibidn = p.getLibidn();
		if (generatedLibidn) {
			n += .strlen(generatedLibidn) + 1;
		} 
		Object generatedLibssh_version = p.getLibssh_version();
		if (generatedLibssh_version) {
			n += .strlen(generatedLibssh_version) + 1;
		} 
		n *= /* Allocate thread space. */4;
		if (nproto) {
			n += nproto * ;
		} 
		cp = .Curl_thread_buffer(.LK_VERSION_INFO_DATA, n);
		id = (curl_version_info_data).Curl_thread_buffer(.LK_VERSION_INFO, );
		if (!id || !cp) {
			return (curl_version_info_data)((Object)0);
		} 
		.memcpy((byte)id, (byte)p, );
		if (generatedProtocols) {
			int i = nproto * ;
			id.setProtocols((byte)cp);
			.memcpy(cp, (byte)generatedProtocols, i);
			cp += i;
			n -= i;
			for (i = 0; generatedProtocols[i]; i++) {
				if (ModernizedCProgram.convert_version_info_string(((byte)generatedProtocols) + i, cp, n, ccsid)) {
					return (curl_version_info_data)((Object)0);
				} 
			}
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedVersion, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedHost, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedSsl_version, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedLibz_version, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedAres, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedLibidn, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		if (ModernizedCProgram.convert_version_info_string(generatedLibssh_version, cp, n, ccsid)) {
			return (curl_version_info_data)((Object)0);
		} 
		return id;
	}
	public static Object curl_easy_strerror_ccsid( error, int ccsid) {
		int i;
		byte s;
		byte buf;
		s = ModernizedCProgram.curl_easy_strerror(error);
		if (!s) {
			return s;
		} 
		i = 4 * (.strlen(s) + 1);
		buf = .Curl_thread_buffer(.LK_EASY_STRERROR, i);
		if (!buf) {
			return (byte)((Object)0);
		} 
		if (ModernizedCProgram.convert(buf, i, ccsid, s, -1, 819) < 0) {
			return (byte)((Object)0);
		} 
		return (byte)buf;
	}
	public static Object curl_share_strerror_ccsid( error, int ccsid) {
		int i;
		byte s;
		byte buf;
		s = ModernizedCProgram.curl_share_strerror(error);
		if (!s) {
			return s;
		} 
		i = 4 * (.strlen(s) + 1);
		buf = .Curl_thread_buffer(.LK_SHARE_STRERROR, i);
		if (!buf) {
			return (byte)((Object)0);
		} 
		if (ModernizedCProgram.convert(buf, i, ccsid, s, -1, 819) < 0) {
			return (byte)((Object)0);
		} 
		return (byte)buf;
	}
	public static Object curl_multi_strerror_ccsid( error, int ccsid) {
		int i;
		byte s;
		byte buf;
		s = ModernizedCProgram.curl_multi_strerror(error);
		if (!s) {
			return s;
		} 
		i = 4 * (.strlen(s) + 1);
		buf = .Curl_thread_buffer(.LK_MULTI_STRERROR, i);
		if (!buf) {
			return (byte)((Object)0);
		} 
		if (ModernizedCProgram.convert(buf, i, ccsid, s, -1, 819) < 0) {
			return (byte)((Object)0);
		} 
		return (byte)buf;
	}
	public static  curl_easy_getinfo_ccsid(Object curl,  info) {
		va_list arg = new va_list();
		Object paramp;
		CURLcode ret = new CURLcode();
		Curl_easy data = new Curl_easy();
		/* WARNING: unlike curl_easy_getinfo(), the strings returned by this
		     procedure have to be free'ed. */
		data = (Curl_easy)curl;
		.__builtin_va_start(arg, info);
		paramp = (int)arg;
		ret = .Curl_getinfo(data, info, paramp);
		int generatedNum_of_certs = cipf.getNum_of_certs();
		curl_slist generatedCertinfo = cipt.getCertinfo();
		if (ret == .CURLE_OK) {
			int ccsid;
			byte cpp;
			curl_slist slp = new curl_slist();
			curl_certinfo cipf = new curl_certinfo();
			curl_certinfo cipt = new curl_certinfo();
			switch ((int)info & -1024) {
			case -1024:
					ccsid = (int)arg;
					cpp = (byte)paramp;
					if (cpp) {
						cpp = ModernizedCProgram.dynconvert(ccsid, cpp, -1, 819);
						if (!cpp) {
							ret = .CURLE_OUT_OF_MEMORY;
						} 
					} 
					break;
			case -1024:
					ccsid = (int)arg;
					switch (info) {
					case .CURLINFO_TLS_SSL_PTR:
					case .CURLINFO_TLS_SESSION:
					case -1024:
							break;
					case .CURLINFO_CERTINFO:
							cipf = (curl_certinfo)paramp;
							if (cipf) {
								cipt = (curl_certinfo).malloc();
								if (!cipt) {
									ret = .CURLE_OUT_OF_MEMORY;
								} else {
										cipt.setCertinfo((curl_slist).calloc(generatedNum_of_certs + 1, ));
										if (!generatedCertinfo) {
											ret = .CURLE_OUT_OF_MEMORY;
										} else {
												int i;
												cipt.setNum_of_certs(generatedNum_of_certs);
												for (i = 0; i < generatedNum_of_certs; i++) {
													if (generatedCertinfo[i]) {
														if (!(generatedCertinfo[i] = generatedCertinfo[i].slist_convert(ccsid, 819))) {
															ret = .CURLE_OUT_OF_MEMORY;
															break;
														} 
													} 
												}
										} 
								} 
								if (ret != .CURLE_OK) {
									cipt.curl_certinfo_free_all();
									cipt = (curl_certinfo)((Object)0);
								} 
								(curl_certinfo)paramp = cipt;
							} 
							break;
					default:
							slp = (curl_slist)paramp;
							if (slp) {
								slp = slp.slist_convert(ccsid, 819);
								if (!slp) {
									ret = .CURLE_OUT_OF_MEMORY;
								} 
							} 
							break;
					}
			}
		} 
		.__builtin_va_end(arg);
		return ret;
	}
	public static int Curl_is_formadd_string( option) {
		switch (option) {
		case .CURLFORM_BUFFER:
		case .CURLFORM_COPYNAME:
				return 1;
		case .CURLFORM_COPYCONTENTS:
		case .CURLFORM_FILENAME:
		case .CURLFORM_FILE:
		case .CURLFORM_CONTENTTYPE:
		case .CURLFORM_FILECONTENT:
		}
		return 0;
	}
	public static Object Curl_formget_callback_ccsid(Object arg, Object buf, Object len) {
		cfcdata p = new cfcdata();
		byte b;
		int l;
		size_t ret = new size_t();
		p = (cfcdata)arg;
		Object generatedArg = p.getArg();
		if ((long)len <= 0) {
			return .UNRECOGNIZEDFUNCTIONNAME(generatedArg, buf, len);
		} 
		b = .malloc(4 * len);
		if (!b) {
			return (size_t)-1;
		} 
		Object generatedCcsid = p.getCcsid();
		l = ModernizedCProgram.convert(b, 4 * len, generatedCcsid, buf, len, 819);
		if (l < 0) {
			.free(b);
			return (size_t)-1;
		} 
		ret = .UNRECOGNIZEDFUNCTIONNAME(generatedArg, b, l);
		.free(b);
		return ret == l ? len : -1;
	}
	public static  curl_easy_setopt_ccsid(Object curl,  tag) {
		CURLcode result = new CURLcode();
		va_list arg = new va_list();
		Curl_easy data = new Curl_easy();
		byte s;
		byte cp;
		int ccsid;
		curl_off_t pfsize = new curl_off_t();
		byte testwarn = 1/* Warns if this procedure has not been updated when the dupstring enum
		     changes.
		     We (try to) do it only once: there is no need to issue several times
		     the same message; but since threadsafeness is not handled here,
		     this may occur (and we don't care!). */;
		if (testwarn) {
			testwarn = 0;
			if ((int)dupstring.STRING_LASTZEROTERMINATED != (int)dupstring.STRING_SASL_AUTHZID + 1 || (int)dupstring.STRING_LAST != (int)dupstring.STRING_COPYPOSTFIELDS + 1) {
				(_iob[2]).curl_mfprintf("*** WARNING: curl_easy_setopt_ccsid() should be reworked ***\n");
			} 
		} 
		data = (Curl_easy)curl;
		.__builtin_va_start(arg, tag);
		Object generatedSet = data.getSet();
		switch (tag) {
		case .CURLOPT_ALTSVC:
		case /* This is an output buffer. */.CURLOPT_ERRORBUFFER:
		case .CURLOPT_PROXY_TLSAUTH_PASSWORD:
		case .CURLOPT_RTSP_STREAM_URI:
		case .CURLOPT_SSLKEY:
		case .CURLOPT_SSH_PRIVATE_KEYFILE:
		case .CURLOPT_SSLENGINE:
		case .CURLOPT_PROXY_SSLCERT:
		case .CURLOPT_PROXY_PINNEDPUBLICKEY:
		case .CURLOPT_SSLCERT:
		case .CURLOPT_XOAUTH2_BEARER:
				s = (int)arg;
				ccsid = (int)arg;
				if (s) {
					s = ModernizedCProgram.dynconvert(819, s, -1, ccsid);
					if (!s) {
						result = .CURLE_OUT_OF_MEMORY;
						break;
					} 
				} 
				result = ;
				.free(s);
				break;
		case .CURLOPT_DOH_URL:
		case .CURLOPT_PRE_PROXY:
		case .CURLOPT_DEFAULT_PROTOCOL:
		case .CURLOPT_ACCEPT_ENCODING:
		case .CURLOPT_USERPWD:
		case .CURLOPT_RTSP_SESSION_ID:
		case .CURLOPT_PROXY_SSLCERTTYPE:
		case .CURLOPT_PROXY_TLS13_CIPHERS:
		case .CURLOPT_COPYPOSTFIELDS/* Special case: byte count may have been given by CURLOPT_POSTFIELDSIZE
		       prior to this call. In this case, convert the given byte count and
		       replace the length according to the conversion result. */:
				s = (int)arg;
				ccsid = (int)arg;
				pfsize = generatedSet.getPostfieldsize();
				if (!s || !pfsize || ccsid == 65535 || ccsid == 819) {
					result = ;
					break;
				} 
				if (pfsize == -1) {
					s = ModernizedCProgram.dynconvert(819, s, -1, /* Data is null-terminated. */ccsid);
					if (!s) {
						result = .CURLE_OUT_OF_MEMORY;
						break;
					} 
				} else {
						size_t len = new size_t();
						if (pfsize < 0 || pfsize > -1024) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						len = pfsize;
						pfsize = len * 4;
						if (pfsize > -1024) {
							pfsize = -1024;
						} 
						cp = .malloc(pfsize);
						if (!cp) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						pfsize = ModernizedCProgram.convert(cp, pfsize, 819, s, len, ccsid);
						if (pfsize < 0) {
							.free(cp);
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						generatedSet.setPostfieldsize(/* Replace data size. */pfsize);
						s = cp;
				} 
				result = ;
				generatedSet.getStr()[dupstring.STRING_COPYPOSTFIELDS] = /* Give to library. */s;
				break;
		case .CURLOPT_EGDSOCKET:
		case .CURLOPT_RANGE:
		case .CURLOPT_COOKIELIST:
		case .CURLOPT_PINNEDPUBLICKEY:
		case .CURLOPT_TLSAUTH_TYPE:
		case .CURLOPT_USERNAME:
		case .CURLOPT_PROXY_TLSAUTH_TYPE:
		case .CURLOPT_COOKIE:
		case .CURLOPT_URL:
		case .CURLOPT_CUSTOMREQUEST:
		case .CURLOPT_SERVICE_NAME:
		case .CURLOPT_NOPROXY:
		case .CURLOPT_PASSWORD:
		case .CURLOPT_PROXY_SSL_CIPHER_LIST:
		case .CURLOPT_RANDOM_FILE:
		case .CURLOPT_INTERFACE:
		case .CURLOPT_SSLKEYTYPE:
		case .CURLOPT_PROXY_KEYPASSWD:
		case .CURLOPT_ISSUERCERT:
		case .CURLOPT_RTSP_TRANSPORT:
		case .CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
		case .CURLOPT_TLS13_CIPHERS:
		case .CURLOPT_SSH_KNOWNHOSTS:
		case .CURLOPT_PROXYPASSWORD:
		case .CURLOPT_SSL_CIPHER_LIST:
		case .CURLOPT_UNIX_SOCKET_PATH:
		case .CURLOPT_SOCKS5_GSSAPI_SERVICE:
		case .CURLOPT_COOKIEFILE:
		case .CURLOPT_FTPPORT:
		case .CURLOPT_PROXY_CAINFO:
		case .CURLOPT_NETRC_FILE:
		case .CURLOPT_PROXYUSERPWD:
		case .CURLOPT_PROXY_CRLFILE:
		case .CURLOPT_MAIL_AUTH:
		case .CURLOPT_USERAGENT:
		case .CURLOPT_KRBLEVEL:
		case .CURLOPT_FTP_ALTERNATIVE_TO_USER:
		case .CURLOPT_MAIL_FROM:
		case .CURLOPT_PROXY_TLSAUTH_USERNAME:
		case .CURLOPT_DNS_SERVERS:
		case .CURLOPT_REFERER:
		case .CURLOPT_PROXY_CAPATH:
		case .CURLOPT_PROXYUSERNAME:
		case .CURLOPT_SASL_AUTHZID:
		case .CURLOPT_SSLCERTTYPE:
		case .CURLOPT_PROXY_SERVICE_NAME:
		case .CURLOPT_CAPATH:
		case .CURLOPT_TLSAUTH_USERNAME:
		case .CURLOPT_LOGIN_OPTIONS:
		case .CURLOPT_PROXY:
		case .CURLOPT_PROXY_SSLKEY:
		case .CURLOPT_REQUEST_TARGET:
		case .CURLOPT_ABSTRACT_UNIX_SOCKET:
		case .CURLOPT_KEYPASSWD:
		case .CURLOPT_PROXY_SSLKEYTYPE:
		case .CURLOPT_SSH_PUBLIC_KEYFILE:
		case .CURLOPT_COOKIEJAR:
		case .CURLOPT_FTP_ACCOUNT:
		case .CURLOPT_TLSAUTH_PASSWORD:
		case .CURLOPT_CRLFILE:
		case .CURLOPT_CAINFO:
		default:
				result = curl.Curl_vsetopt(tag, arg);
				break;
		}
		.__builtin_va_end(arg);
		return result;
	}
	public static Byte curl_form_long_value(long value) {
		return (byte)/* ILE/RPG cannot cast an integer to a pointer. This procedure does it. */value;
	}
	public static Byte curl_pushheader_bynum_cssid(Object num, int ccsid) {
		byte d = (byte)((Object)0);
		byte s = ModernizedCProgram.curl_pushheader_bynum(h, num);
		if (s) {
			d = ModernizedCProgram.dynconvert(ccsid, s, -1, 819);
		} 
		return d;
	}
	public static Byte curl_pushheader_byname_ccsid(Object header, int ccsidin, int ccsidout) {
		byte d = (byte)((Object)0);
		if (header) {
			header = ModernizedCProgram.dynconvert(819, header, -1, ccsidin);
			if (header) {
				byte s = ModernizedCProgram.curl_pushheader_byname(h, header);
				.free((byte)header);
				if (s) {
					d = ModernizedCProgram.dynconvert(ccsidout, s, -1, 819);
				} 
			} 
		} 
		return d;
	}
	public static  curl_url_get_ccsid( what, byte part, int flags, int ccsid) {
		byte s = (byte)((Object)0);
		CURLUcode result = new CURLUcode();
		if (!part) {
			return .CURLUE_BAD_PARTPOINTER;
		} 
		part = (byte)((Object)0);
		result = .curl_url_get(handle, what, s, flags);
		if (result == .CURLUE_OK) {
			if (s) {
				part = ModernizedCProgram.dynconvert(ccsid, s, -1, 819);
				if (!part) {
					result = .CURLUE_OUT_OF_MEMORY;
				} 
			} 
		} 
		if (s) {
			.free(s);
		} 
		return result;
	}
	public static  curl_url_set_ccsid( what, Object part, int flags, int ccsid) {
		byte s = (byte)((Object)0);
		CURLUcode result = new CURLUcode();
		if (part) {
			s = ModernizedCProgram.dynconvert(819, part, -1, ccsid);
			if (!s) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
		} 
		result = .curl_url_set(handle, what, s, flags);
		if (s) {
			.free(s);
		} 
		return result;
	}
	public static  file2string(byte bufp) {
		byte string = ((Object)0);
		if (file) {
			byte ptr;
			size_t alloc = 512;
			size_t alloc_needed = new size_t();
			byte[] buffer = new byte[256];
			size_t stringlen = 0;
			string = .malloc(alloc);
			if (!string) {
				return .PARAM_NO_MEM;
			} 
			while (.fgets(ModernizedCProgram.buffer, , file)) {
				size_t buflen = new size_t();
				ptr = .strchr(ModernizedCProgram.buffer, (byte)'\r');
				if (ptr) {
					ptr = (byte)'\0';
				} 
				ptr = .strchr(ModernizedCProgram.buffer, (byte)'\n');
				if (ptr) {
					ptr = (byte)'\0';
				} 
				buflen = .strlen(ModernizedCProgram.buffer);
				alloc_needed = stringlen + buflen + 1;
				if (alloc < alloc_needed) {
					if (alloc >= (size_t)-1024 / 2) {
						do {
							.free((string));
							(string) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					alloc *= /* doubling is enough since the string to add is always max 256 bytes
					           and the alloc size start at 512 */2;
					ptr = .realloc(string, alloc);
					if (!ptr) {
						do {
							.free((string));
							(string) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					string = ptr;
				} 
				.strcpy(string + stringlen, ModernizedCProgram.buffer);
				stringlen += buflen;
			}
		} 
		bufp = string;
		return .PARAM_OK;
	}
	public static  file2memory(byte bufp, Object size) {
		byte newbuf;
		byte buffer = ((Object)0);
		size_t nused = 0;
		if (file) {
			size_t nread = new size_t();
			size_t alloc = 512;
			do {
				if (!buffer || (alloc == nused)) {
					if (alloc + 1 > ((size_t)-1) / /* size_t overflow detection for huge files */2) {
						do {
							.free((buffer));
							(buffer) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					alloc *= 2;
					newbuf = .realloc(buffer, alloc + /* allocate an extra char, reserved space, for null termination */1);
					if (!newbuf) {
						do {
							.free((buffer));
							(buffer) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					buffer = newbuf;
				} 
				nread = .fread(buffer + nused, 1, alloc - nused, file);
				nused += nread;
			} while (nread);
			buffer[nused] = /* null terminate the buffer in case it's used as a string later */(byte)'\0';
			if (alloc != /* free trailing slack space, if possible */nused) {
				newbuf = .realloc(buffer, nused + 1);
				if (!newbuf) {
					do {
						.free((buffer));
						(buffer) = ((Object)0);
					} while (0);
					return .PARAM_NO_MEM;
				} 
				buffer = newbuf;
			} 
			if (!/* discard buffer if nothing was read */nused) {
				do {
					.free((buffer));
					(buffer) = ((Object)0);
				} while (/* no string */0);
			} 
		} 
		size = nused;
		bufp = buffer;
		return .PARAM_OK;
	}
	public static void cleanarg(Byte str) {
		(Object)str/*
		 * Parse the string and write the long in the given address. Return PARAM_OK
		 * on success, otherwise a parameter specific error enum.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	/* now that GetStr has copied the contents of nextarg, wipe the next
	   * argument out so that the username:password isn't displayed in the
	   * system process list */
	public static  str2num(long val, Object str) {
		if (str) {
			byte endptr;
			long num;
			(._errno()) = 0;
			num = .strtol(str, endptr, 10);
			if ((._errno()) == 34) {
				return .PARAM_NUMBER_TOO_LARGE;
			} 
			if ((endptr != str) && (endptr == str + .strlen(str))) {
				val = num;
				return /* Ok */.PARAM_OK;
			} 
		} 
		return /* badness */.PARAM_BAD_NUMERIC/*
		 * Parse the string and write the long in the given address. Return PARAM_OK
		 * on success, otherwise a parameter error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2unum(long val, Object str) {
		ParameterError result = ModernizedCProgram.str2num(val, str);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (val < 0) {
			return .PARAM_NEGATIVE_NUMERIC;
		} 
		return .PARAM_OK/*
		 * Parse the string and write the long in the given address if it is below the
		 * maximum allowed value. Return PARAM_OK on success, otherwise a parameter
		 * error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2unummax(long val, Object str, long max) {
		ParameterError result = ModernizedCProgram.str2unum(val, str);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (val > max) {
			return .PARAM_NUMBER_TOO_LARGE;
		} 
		return .PARAM_OK/*
		 * Parse the string and write the double in the given address. Return PARAM_OK
		 * on success, otherwise a parameter specific error enum.
		 *
		 * The 'max' argument is the maximum value allowed, as the numbers are often
		 * multiplied when later used.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2double(double val, Object str, long max) {
		if (str) {
			byte endptr;
			double num;
			(._errno()) = 0;
			num = .strtod(str, endptr);
			if ((._errno()) == 34) {
				return .PARAM_NUMBER_TOO_LARGE;
			} 
			if (num > max) {
				return /* too large */.PARAM_NUMBER_TOO_LARGE;
			} 
			if ((endptr != str) && (endptr == str + .strlen(str))) {
				val = num;
				return /* Ok */.PARAM_OK;
			} 
		} 
		return /* badness */.PARAM_BAD_NUMERIC/*
		 * Parse the string and write the double in the given address. Return PARAM_OK
		 * on success, otherwise a parameter error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * The 'max' argument is the maximum value allowed, as the numbers are often
		 * multiplied when later used.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2udouble(double valp, Object str, long max) {
		double value;
		ParameterError result = ModernizedCProgram.str2double(value, str, max);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (value < 0) {
			return .PARAM_NEGATIVE_NUMERIC;
		} 
		valp = value;
		return .PARAM_OK/*
		 * Parse the string and modify the long in the given address. Return
		 * non-zero on failure, zero on success.
		 *
		 * The string is a list of protocols
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static int check_protocol(Object str) {
		byte pp;
		 curlinfo = ModernizedCProgram.curl_version_info(CURLVERSION_NOW);
		if (!str) {
			return .PARAM_REQUIRES_PARAMETER;
		} 
		for (pp = curlinfo.getProtocols(); pp; pp++) {
			if (ModernizedCProgram.curl_strequal(pp, str)) {
				return .PARAM_OK;
			} 
		}
		return .PARAM_LIBCURL_UNSUPPORTED_PROTOCOL/**
		 * Parses the given string looking for an offset (which may be a
		 * larger-than-integer value). The offset CANNOT be negative!
		 *
		 * @param val  the offset to populate
		 * @param str  the buffer containing the offset
		 * @return PARAM_OK if successful, a parameter specific error enum if failure.
		 */;
	}
	public static  str2offset(Object val, Object str) {
		byte endptr;
		if (str[0] == (byte)'-') {
			return /* offsets aren't negative, this indicates weird input */.PARAM_NEGATIVE_NUMERIC;
		} 
		{ 
			CURLofft offt = ModernizedCProgram.curlx_strtoofft(str, endptr, 0, val);
			if (.CURL_OFFT_FLOW == offt) {
				return .PARAM_NUMBER_TOO_LARGE;
			}  else if (.CURL_OFFT_INVAL == offt) {
				return .PARAM_BAD_NUMERIC;
			} 
		}
		if ((endptr != str) && (endptr == str + .strlen(str))) {
			return .PARAM_OK;
		} 
		return .PARAM_BAD_NUMERIC;
	}
	/* for what purpose */
	public static Object checkpasswd(Object kind, Object i, Object last, byte userpwd) {
		/* pointer to allocated string */byte psep;
		byte osep;
		if (!userpwd) {
			return CURLE_OK;
		} 
		psep = .strchr(userpwd, /* Attempt to find the password separator */(byte)':');
		osep = .strchr(userpwd, /* Attempt to find the options separator */(byte)';');
		if (!psep && userpwd != (byte)';') {
			byte[] passwd = /* no password present, prompt for one */"";
			byte[] prompt = new byte[256];
			size_t passwdlen = new size_t();
			size_t userlen = .strlen(userpwd);
			byte passptr;
			if (osep) {
				osep = (byte)'\0';
			} 
			if (!i && /* build a nice-looking prompt */last) {
				ModernizedCProgram.curl_msnprintf(prompt, , "Enter %s password for user '%s':", kind, userpwd);
			} else {
					ModernizedCProgram.curl_msnprintf(prompt, , "Enter %s password for user '%s' on URL #%zu:", kind, userpwd, i + 1);
			} 
			ModernizedCProgram.getpass_r(prompt, passwd, );
			passwdlen = .strlen(passwd);
			if (osep) {
				osep = (byte)';';
			} 
			passptr = .realloc(/* extend the allocated memory area to fit the password too */userpwd, passwdlen + /* an extra for the colon */1 + userlen + /* an extra for the zero */1);
			if (!passptr) {
				return CURLE_OUT_OF_MEMORY;
			} 
			passptr[userlen] = /* append the password separated with a colon */(byte)':';
			.memcpy(passptr[userlen + 1], passwd, passwdlen + 1);
			userpwd = passptr;
		} 
		return CURLE_OK;
	}
	/* operation index */
	/* TRUE if last operation */
	public static  add2list(Object list, Object ptr) {
		curl_slist newlist = list.curl_slist_append(ptr);
		if (newlist) {
			list = newlist;
		} else {
				return .PARAM_NO_MEM;
		} 
		return .PARAM_OK;
	}
	public static Byte my_useragent() {
	}
	public static  str2tls_max(long val, Object str) {
		Object[] tls_max_array = new Object[]{{"default", CURL_SSLVERSION_MAX_DEFAULT}, {"1.0", CURL_SSLVERSION_MAX_TLSv1_0}, {"1.1", CURL_SSLVERSION_MAX_TLSv1_1}, {"1.2", CURL_SSLVERSION_MAX_TLSv1_2}, {"1.3", CURL_SSLVERSION_MAX_TLSv1_3}};
		size_t i = 0;
		if (!str) {
			return .PARAM_REQUIRES_PARAMETER;
		} 
		for (i = 0; i <  / ; i++) {
			if (!.strcmp(str, tls_max_array[i].getTls_max_str())) {
				val = tls_max_array[i].getTls_max();
				return .PARAM_OK;
			} 
		}
		return .PARAM_BAD_USE;
	}
	/*****************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 *  Copyright (c) 2000 David Odin (aka DindinX) for MandrakeSoft
	 */
	/* <DESC>
	 * use the libcurl in a gtk-threaded application
	 * </DESC>
	 */
	public static Object my_write_func(Object ptr, Object size, Object nmemb) {
		return .fwrite(ptr, size, nmemb, stream);
	}
	public static Object my_read_func(Object ptr, Object size, Object nmemb) {
		return .fread(ptr, size, nmemb, stream);
	}
	public static int my_progress_func(Object bar, double t, double d, double ultotal, double ulnow) {
		.gdk_threads_enter();
		.gtk_progress_set_value(.GTK_PROGRESS(bar), d * 100.0 / t);
		.gdk_threads_leave();
		return 0;
	}
	/* dltotal */
	/* dlnow */
	public static Object my_thread(Object ptr) {
		 curl = new ();
		Curl_easy curl_easy = new Curl_easy();
		curl = curl_easy.curl_easy_init();
		if (curl) {
			 url = ptr;
			byte filename = "test.curl";
			FILE outfile = .fopen(ModernizedCProgram.filename, "wb");
			curl.curl_easy_setopt(CURLOPT_URL, url);
			curl.curl_easy_setopt(CURLOPT_WRITEDATA, outfile);
			curl.curl_easy_setopt(CURLOPT_WRITEFUNCTION, my_write_func);
			curl.curl_easy_setopt(CURLOPT_READFUNCTION, my_read_func);
			curl.curl_easy_setopt(CURLOPT_NOPROGRESS, -1024);
			curl.curl_easy_setopt(CURLOPT_PROGRESSFUNCTION, my_progress_func);
			curl.curl_easy_setopt(CURLOPT_PROGRESSDATA, ModernizedCProgram.Bar);
			curl.curl_easy_perform();
			.fclose(outfile);
			/* always cleanup */curl.curl_easy_cleanup();
		} 
		return ((Object)0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/* !checksrc! disable SPACEBEFOREPAREN 1 */
	public static Object Curl_thread_create(Object func, Object arg) {
		long curl_win_thread_handle_t;
		HANDLE t = new HANDLE();
		curl_win_thread_handle_t thread_handle = new curl_win_thread_handle_t();
		thread_handle = ._beginthreadex(((Object)0), 0, func, arg, 0, ((Object)0));
		t = (HANDLE)thread_handle;
		if ((t == 0) || (t == ((HANDLE)(LONG_PTR)(true)))) {
			return (HANDLE)0;
		} 
		return t;
	}
	public static void Curl_thread_destroy(Object hnd) {
		.CloseHandle(hnd);
	}
	public static int Curl_thread_join(Object hnd) {
		int ret = (.WaitForSingleObject(hnd, -1024) == 0);
		ModernizedCProgram.Curl_thread_destroy(hnd);
		hnd = (HANDLE)0;
		return ret/* USE_THREADS_* */;
	}
	public static Object sftpGetRemoteFileSize(Object i_remoteFile) {
		 result = CURLE_GOT_NOTHING;
		 remoteFileSizeByte = -1;
		Curl_easy curl_easy = new Curl_easy();
		 curlHandlePtr = curl_easy.curl_easy_init();
		curlHandlePtr.curl_easy_setopt(CURLOPT_VERBOSE, -1024);
		curlHandlePtr.curl_easy_setopt(CURLOPT_URL, i_remoteFile);
		curlHandlePtr.curl_easy_setopt(CURLOPT_NOPROGRESS, 1);
		curlHandlePtr.curl_easy_setopt(CURLOPT_NOBODY, 1);
		curlHandlePtr.curl_easy_setopt(CURLOPT_HEADER, 1);
		curlHandlePtr.curl_easy_setopt(CURLOPT_FILETIME, 1);
		result = curlHandlePtr.curl_easy_perform();
		curlHandlePtr.curl_easy_cleanup();
		return remoteFileSizeByte;
	}
	public static int sftpResumeUpload(Object curlhandle, Object remotepath, Object localpath) {
		FILE f = ((Object)0);
		 result = CURLE_GOT_NOTHING;
		 remoteFileSizeByte = ModernizedCProgram.sftpGetRemoteFileSize(remotepath);
		if (-1 == remoteFileSizeByte) {
			.printf("Error reading the remote file size: unable to resume upload\n");
			return -1;
		} 
		f = .fopen(localpath, "rb");
		if (!f) {
			.perror(((Object)0));
			return 0;
		} 
		curlhandle.curl_easy_setopt(CURLOPT_UPLOAD, -1024);
		curlhandle.curl_easy_setopt(CURLOPT_URL, remotepath);
		curlhandle.curl_easy_setopt(CURLOPT_READFUNCTION, readfunc);
		curlhandle.curl_easy_setopt(CURLOPT_READDATA, f);
		._fseeki64(f, remoteFileSizeByte, 0);
		curlhandle.curl_easy_setopt(CURLOPT_APPEND, -1024);
		result = curlhandle.curl_easy_perform();
		.fclose(f);
		if (result == CURLE_OK) {
			return 1;
		} else {
				.fprintf((_iob[2]), "%s\n", ModernizedCProgram.curl_easy_strerror(result));
				return 0;
		} 
	}
	public static  tailmatch(Object cooke_domain, Object hostname) {
		size_t cookie_domain_len = .strlen(cooke_domain);
		size_t hostname_len = .strlen(hostname);
		if (hostname_len < cookie_domain_len) {
			return 0;
		} 
		if (!ModernizedCProgram.Curl_strcasecompare(cooke_domain, hostname + hostname_len - cookie_domain_len)) {
			return 0/* A lead char of cookie_domain is not '.'.
			     RFC6265 4.1.2.3. The Domain Attribute says:
			       For example, if the value of the Domain attribute is
			       "example.com", the user agent will include the cookie in the Cookie
			       header when making HTTP requests to example.com, www.example.com, and
			       www.corp.example.com.
			   */;
		} 
		if (hostname_len == cookie_domain_len) {
			return 1;
		} 
		if ((byte)'.' == (hostname + hostname_len - cookie_domain_len - 1)) {
			return 1;
		} 
		return 0/*
		 * Return true if the given string is an IP(v4|v6) address.
		 */;
	}
	public static  isip(Object domain) {
		in_addr addr = new in_addr();
		if (ModernizedCProgram.Curl_inet_pton(2, domain, addr)) {
			return /* domain name given as IP address */1;
		} 
		return 0/*
		 * matching cookie path and url path
		 * RFC6265 5.1.4 Paths and Path-Match
		 */;
	}
	public static  pathmatch(Object cookie_path, Object request_uri) {
		size_t cookie_path_len = new size_t();
		size_t uri_path_len = new size_t();
		byte uri_path = ((Object)0);
		byte pos;
		bool ret = 0;
		cookie_path_len = .strlen(/* cookie_path must not have last '/' separator. ex: /sample */cookie_path);
		if (1 == cookie_path_len) {
			return /* cookie_path must be '/' */1;
		} 
		uri_path = .Curl_cstrdup(request_uri);
		if (!uri_path) {
			return 0;
		} 
		pos = .strchr(uri_path, (byte)'?');
		if (pos) {
			pos = -1024;
		} 
		if (0 == .strlen(uri_path) || uri_path[0] != /* #-fragments are already cut off! */(byte)'/') {
			.Curl_cfree(uri_path);
			uri_path = .Curl_cstrdup("/");
			if (!uri_path) {
				return 0/* here, RFC6265 5.1.4 says
				     4. Output the characters of the uri-path from the first character up
				        to, but not including, the right-most %x2F ("/").
				     but URL path /hoge?fuga=xxx means /hoge/index.cgi?fuga=xxx in some site
				     without redirect.
				     Ignore this algorithm because /hoge is uri path for this case
				     (uri path is not /).
				   */;
			} 
		} 
		uri_path_len = .strlen(uri_path);
		if (uri_path_len < cookie_path_len) {
			ret = 0;
			;
		} 
		if (.strncmp(cookie_path, uri_path, /* not using checkprefix() because matching should be case-sensitive */cookie_path_len)) {
			ret = 0;
			;
		} 
		if (cookie_path_len == /* The cookie-path and the uri-path are identical. */uri_path_len) {
			ret = 1;
			;
		} 
		if (uri_path[cookie_path_len] == /* here, cookie_path_len < uri_path_len */(byte)'/') {
			ret = 1;
			;
		} 
		ret = 0;
		return ret/*
		 * Return the top-level domain, for optimal hashing.
		 */;
	}
	public static Object get_top_domain(Object domain, Object outlen) {
		size_t len = new size_t();
		byte first = ((Object)0);
		byte last;
		if (!domain) {
			return ((Object)0);
		} 
		len = .strlen(domain);
		last = ModernizedCProgram.Curl_memrchr((domain), ((byte)'.'), (len));
		if (last) {
			first = ModernizedCProgram.Curl_memrchr((domain), ((byte)'.'), ((last - domain)));
			if (first) {
				len -= (++first - domain);
			} 
		} 
		if (outlen) {
			outlen = len;
		} 
		return first ? first : domain/*
		 * A case-insensitive hash for the cookie domains.
		 */;
	}
	public static Object cookie_hash_domain(Object domain, Object len) {
		byte end = domain + len;
		size_t h = 5381;
		while (domain < end) {
			h += h << 5;
			h ^=  ModernizedCProgram.Curl_raw_toupper(domain++);
		}
		return (h % 256/*
		 * Hash this domain.
		 */);
	}
	public static Object cookiehash(Object domain) {
		byte top;
		size_t len = new size_t();
		if (!domain || ModernizedCProgram.isip(domain)) {
			return 0;
		} 
		top = ModernizedCProgram.get_top_domain(domain, len);
		return ModernizedCProgram.cookie_hash_domain(top, len/*
		 * cookie path sanitize
		 */);
	}
	public static Byte sanitize_cookie_path(Object cookie_path) {
		size_t len = new size_t();
		byte new_path = .Curl_cstrdup(cookie_path);
		if (!new_path) {
			return ((Object)0);
		} 
		len = .strlen(/* some stupid site sends path attribute with '"'. */new_path);
		if (new_path[0] == (byte)'\"') {
			.memmove((Object)new_path, (Object)(new_path + 1), len);
			len--;
		} 
		if (len && (new_path[len - 1] == (byte)'\"')) {
			new_path[len - 1] = -1024;
			len--;
		} 
		if (new_path[0] != /* RFC6265 5.2.4 The Path Attribute */(byte)'/') {
			.Curl_cfree(/* Let cookie-path be the default-path. */new_path);
			new_path = .Curl_cstrdup("/");
			return new_path;
		} 
		if (len && new_path[len - 1] == /* convert /hoge/ to /hoge */(byte)'/') {
			new_path[len - 1] = -1024;
		} 
		return new_path/*
		 * Load cookies from all given cookie files (CURLOPT_COOKIEFILE).
		 *
		 * NOTE: OOM or cookie parsing failures are ignored.
		 */;
	}
	public static void strstore(byte str, Object newstr) {
		.Curl_cfree(str);
		str = .Curl_cstrdup(newstr/*
		 * remove_expired() removes expired cookies.
		 */);
	}
	/* Make sure domain contains a dot or is localhost. */
	public static  bad_domain(Object domain) {
		return !.strchr(domain, (byte)'.') && !ModernizedCProgram.Curl_strcasecompare(domain, "localhost"/****************************************************************************
		 *
		 * Curl_cookie_add()
		 *
		 * Add a single cookie line to the cookie keeping object.
		 *
		 * Be aware that sometimes we get an IP-only host name, and that might also be
		 * a numerical IPv6 address.
		 *
		 * Returns NULL on out of memory or invalid cookie. This is suboptimal,
		 * as they should be treated separately.
		 ***************************************************************************/);
	}
	/* sort this so that the longest path gets before the shorter path */
	public static int cookie_sort(Object p1, Object p2) {
		Cookie c1 = (Cookie)p1;
		Cookie c2 = (Cookie)p2;
		size_t l1 = new size_t();
		size_t l2 = new size_t();
		Byte generatedPath = c1.getPath();
		l1 = generatedPath ? .strlen(generatedPath) : /* 1 - compare cookie path lengths */0;
		l2 = generatedPath ? .strlen(generatedPath) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -/* avoid size_t <=> int conversions */1;
		} 
		Byte generatedDomain = c1.getDomain();
		l1 = generatedDomain ? .strlen(generatedDomain) : /* 2 - compare cookie domain lengths */0;
		l2 = generatedDomain ? .strlen(generatedDomain) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -/* avoid size_t <=> int conversions */1;
		} 
		Byte generatedName = c1.getName();
		l1 = generatedName ? .strlen(generatedName) : /* 3 - compare cookie name lengths */0;
		l2 = generatedName ? .strlen(generatedName) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -1;
		} 
		int generatedCreationtime = c2.getCreationtime();
		return (generatedCreationtime > generatedCreationtime) ? 1 : -/* 4 - compare cookie creation time */1;
	}
	/* sort cookies only according to creation time */
	public static int cookie_sort_ct(Object p1, Object p2) {
		Cookie c1 = (Cookie)p1;
		Cookie c2 = (Cookie)p2;
		int generatedCreationtime = c2.getCreationtime();
		return (generatedCreationtime > generatedCreationtime) ? 1 : -1;
	}
	public static Byte get_netscape_format(Object co) {
	}
	/* returns true if the current socket is an IP one */
	public static  socket_domain_is_ip() {
		switch (.socket_domain) {
		case 2:
				return .bool_true;
		default:
				return /* case AF_UNIX: */.bool_false;
		}
	}
	public static Object connect_to(Object ipaddr, int port) {
		srvr_sockaddr_union_t serveraddr = new srvr_sockaddr_union_t();
		 serverfd = new ();
		int error;
		int rc = 0;
		byte op_br = "";
		byte cl_br = "";
		if (!ipaddr) {
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("about to connect to %s%s%s:%hu", op_br, ipaddr, cl_br, port);
		serverfd = .socket(.socket_domain, 1, 0);
		if (CURL_SOCKET_BAD == serverfd) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error creating socket for server connection: (%d) %s", error, .strerror(error));
			return CURL_SOCKET_BAD;
		} 
		if (ModernizedCProgram.socket_domain_is_ip()) {
			 flag = /* Disable the Nagle algorithm */1;
			if (0 != .setsockopt(serverfd, 6, -1024, (Object)flag, )) {
				ModernizedCProgram.logmsg("====> TCP_NODELAY for server connection failed");
			} 
		} 
		Object generatedSa4 = serveraddr.getSa4();
		Object generatedSa = serveraddr.getSa();
		switch (.socket_domain) {
		case 2:
				.memset(generatedSa4, 0, );
				generatedSa4.setSin_family(2);
				generatedSa4.setSin_port(.htons(port));
				if (ModernizedCProgram.Curl_inet_pton(2, ipaddr, generatedSa4.getSin_addr()) < 1) {
					ModernizedCProgram.logmsg("Error inet_pton failed AF_INET conversion of '%s'", ipaddr);
					.closesocket((serverfd));
					return CURL_SOCKET_BAD;
				} 
				rc = .connect(serverfd, generatedSa, );
				break;
		}
		if (/* ENABLE_IPV6 *//* USE_UNIX_SOCKETS */ModernizedCProgram.got_exit_signal) {
			.closesocket((serverfd));
			return CURL_SOCKET_BAD;
		} 
		if (rc) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("Error connecting to server port %hu: (%d) %s", port, error, .strerror(error));
			.closesocket((serverfd));
			return CURL_SOCKET_BAD;
		} 
		ModernizedCProgram.logmsg("connected fine to %s%s%s:%hu, now tunnel", op_br, ipaddr, cl_br, port);
		return serverfd/*
		 * A CONNECT has been received, a CONNECT response has been sent.
		 *
		 * This function needs to connect to the server, and then pass data between
		 * the client and the server back and forth until the connection is closed by
		 * either end.
		 *
		 * When doing FTP through a CONNECT proxy, we expect that the data connection
		 * will be setup while the first connect is still being kept up. Therefore we
		 * must accept a new connection and deal with it appropriately.
		 */;
	}
	public static void http_connect(Object infdp, Object rootfd, Object ipaddr, int ipport) {
		[] serverfd = new []{CURL_SOCKET_BAD, CURL_SOCKET_BAD};
		[] clientfd = new []{CURL_SOCKET_BAD, CURL_SOCKET_BAD};
		ssize_t[] toc = new ssize_t[]{0, /* number of bytes to client */0};
		ssize_t[] tos = new ssize_t[]{0, /* number of bytes to server */0};
		byte[][] readclient = new byte[2][256];
		byte[][] readserver = new byte[2][256];
		bool[] poll_client_rd = new bool[]{1, 1};
		bool[] poll_server_rd = new bool[]{1, 1};
		bool[] poll_client_wr = new bool[]{1, 1};
		bool[] poll_server_wr = new bool[]{1, 1};
		bool primary = 0;
		bool secondary = 0;
		/* CTRL or DATA */int max_tunnel_idx;
		int loop;
		int i;
		int timeout_count = 0;
		clientfd[0] = /* primary tunnel client endpoint already connected */infdp/* Sleep here to make sure the client reads CONNECT response's
		     'end of headers' separate from the server data that follows.
		     This is done to prevent triggering libcurl known bug #39. */;
		for (loop = 2; (loop > 0) && !ModernizedCProgram.got_exit_signal; loop--) {
			ModernizedCProgram.wait_ms(250);
		}
		if (ModernizedCProgram.got_exit_signal) {
			;
		} 
		serverfd[0] = ModernizedCProgram.connect_to(ipaddr, ipport);
		if (serverfd[0] == CURL_SOCKET_BAD) {
			;
		} 
		max_tunnel_idx = 0;
		primary = 1;
		Object generatedDone_processing = req2.getDone_processing();
		Object generatedConnect_request = req2.getConnect_request();
		Object generatedConnect_port = req2.getConnect_port();
		while (!ModernizedCProgram.got_exit_signal) {
			fd_set input = new fd_set();
			fd_set output = new fd_set();
			timeval timeout = new timeval(1, /* 1000 ms */0);
			ssize_t rc = new ssize_t();
			 maxfd = (ModernizedCProgram.curl_socket_t) - 1;
			(((fd_set)(ModernizedCProgram.input)).setFd_count(0));
			(((fd_set)(output)).setFd_count(0));
			if ((clientfd[1] == CURL_SOCKET_BAD) && (serverfd[1] == CURL_SOCKET_BAD) && poll_client_rd[0] && poll_client_wr[0] && poll_server_rd[0] && poll_server_wr[0/* listener socket is monitored to allow client to establish
			         secondary tunnel only when this tunnel is not established
			         and primary one is fully operational */]) {
				do {
					u_int __i = new u_int();
					for (__i = 0; __i < ((fd_set)(ModernizedCProgram.input)).getFd_count(); __i++) {
						if (((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] == (rootfd)) {
							break;
						} 
					}
					if (__i == ((fd_set)(ModernizedCProgram.input)).getFd_count()) {
						if (((fd_set)(ModernizedCProgram.input)).getFd_count() < 64) {
							((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] = (rootfd);
							((fd_set)(ModernizedCProgram.input)).getFd_count()++;
						} 
					} 
				} while (0);
				maxfd = rootfd;
			} 
			for (i = 0; i <= max_tunnel_idx; /* set tunnel sockets to wait for */i++) {
				if (clientfd[i] != /* client side socket monitoring */CURL_SOCKET_BAD) {
					if (poll_client_rd[i]) {
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(ModernizedCProgram.input)).getFd_count(); __i++) {
								if (((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] == (clientfd[i])) {
									break;
								} 
							}
							if (__i == ((fd_set)(ModernizedCProgram.input)).getFd_count()) {
								if (((fd_set)(ModernizedCProgram.input)).getFd_count() < 64) {
									((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] = (clientfd[i]);
									((fd_set)(ModernizedCProgram.input)).getFd_count()++;
								} 
							} 
						} while (/* unless told not to do so, monitor readability */0);
						if (clientfd[i] > maxfd) {
							maxfd = clientfd[i];
						} 
					} 
					if (poll_client_wr[i] && toc[i/* unless told not to do so, monitor writability
					             if there is data ready to be sent to client */]) {
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(output)).getFd_count(); __i++) {
								if (((fd_set)(output)).getFd_array()[__i] == (clientfd[i])) {
									break;
								} 
							}
							if (__i == ((fd_set)(output)).getFd_count()) {
								if (((fd_set)(output)).getFd_count() < 64) {
									((fd_set)(output)).getFd_array()[__i] = (clientfd[i]);
									((fd_set)(output)).getFd_count()++;
								} 
							} 
						} while (0);
						if (clientfd[i] > maxfd) {
							maxfd = clientfd[i];
						} 
					} 
				} 
				if (serverfd[i] != /* server side socket monitoring */CURL_SOCKET_BAD) {
					if (poll_server_rd[i]) {
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(ModernizedCProgram.input)).getFd_count(); __i++) {
								if (((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] == (serverfd[i])) {
									break;
								} 
							}
							if (__i == ((fd_set)(ModernizedCProgram.input)).getFd_count()) {
								if (((fd_set)(ModernizedCProgram.input)).getFd_count() < 64) {
									((fd_set)(ModernizedCProgram.input)).getFd_array()[__i] = (serverfd[i]);
									((fd_set)(ModernizedCProgram.input)).getFd_count()++;
								} 
							} 
						} while (/* unless told not to do so, monitor readability */0);
						if (serverfd[i] > maxfd) {
							maxfd = serverfd[i];
						} 
					} 
					if (poll_server_wr[i] && tos[i/* unless told not to do so, monitor writability
					             if there is data ready to be sent to server */]) {
						do {
							u_int __i = new u_int();
							for (__i = 0; __i < ((fd_set)(output)).getFd_count(); __i++) {
								if (((fd_set)(output)).getFd_array()[__i] == (serverfd[i])) {
									break;
								} 
							}
							if (__i == ((fd_set)(output)).getFd_count()) {
								if (((fd_set)(output)).getFd_count() < 64) {
									((fd_set)(output)).getFd_array()[__i] = (serverfd[i]);
									((fd_set)(output)).getFd_count()++;
								} 
							} 
						} while (0);
						if (serverfd[i] > maxfd) {
							maxfd = serverfd[i];
						} 
					} 
				} 
			}
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			do {
				rc = .select((int)maxfd + 1, ModernizedCProgram.input, output, ((Object)0), ModernizedCProgram.timeout);
			} while (rc < 0 && (._errno()) == 4 && !ModernizedCProgram.got_exit_signal);
			if (ModernizedCProgram.got_exit_signal) {
				break;
			} 
			if (rc > 0) {
				bool tcp_fin_wr = /* socket action */0;
				timeout_count = 0/* ---------------------------------------------------------- */;
				if ((clientfd[1] == /* passive mode FTP may establish a secondary tunnel */CURL_SOCKET_BAD) && (serverfd[1] == CURL_SOCKET_BAD) && .__WSAFDIsSet((SOCKET)(rootfd), (fd_set)(ModernizedCProgram.input))) {
					 datafd = .accept(rootfd, ((Object)0), ((Object)/* a new connection on listener socket (most likely from client) */0));
					if (datafd != CURL_SOCKET_BAD) {
						httprequest req2 = new httprequest();
						int err = 0;
						.memset(req2, 0, );
						ModernizedCProgram.logmsg("====> Client connect DATA");
						if (ModernizedCProgram.socket_domain_is_ip()) {
							 flag = /* Disable the Nagle algorithm */1;
							if (0 != .setsockopt(datafd, 6, -1024, (Object)flag, )) {
								ModernizedCProgram.logmsg("====> TCP_NODELAY for client DATA connection failed");
							} 
						} 
						req2.init_httprequest();
						while (!generatedDone_processing) {
							err = req2.get_request(datafd);
							if (err < 0/* this socket must be closed, done or not */) {
								break;
							} 
						}
						if (err >= /* skip this and close the socket if err < 0 */0) {
							err = req2.send_doc(datafd);
							if (!err && generatedConnect_request) {
								for (loop = 2; (loop > 0) && !ModernizedCProgram.got_exit_signal; /* sleep to prevent triggering libcurl known bug #39. */loop--) {
									ModernizedCProgram.wait_ms(250);
								}
								if (!ModernizedCProgram.got_exit_signal) {
									serverfd[1] = ModernizedCProgram.connect_to(ipaddr, generatedConnect_port);
									if (serverfd[1] != CURL_SOCKET_BAD/* secondary tunnel established, now we have two
									                     connections */) {
										poll_client_rd[1] = 1;
										poll_client_wr[1] = 1;
										poll_server_rd[1] = 1;
										poll_server_wr[1] = 1;
										max_tunnel_idx = 1;
										secondary = 1;
										toc[1] = 0;
										tos[1] = 0;
										clientfd[1] = datafd;
										datafd = CURL_SOCKET_BAD;
									} 
								} 
							} 
						} 
						if (datafd != CURL_SOCKET_BAD) {
							.shutdown(datafd, /* secondary tunnel not established */-1024);
							.closesocket((datafd));
						} 
					} 
					if (ModernizedCProgram.got_exit_signal) {
						break;
					} 
				} 
				for (i = 0; i <= max_tunnel_idx; /* ---------------------------------------------------------- *//* react to tunnel endpoint readable/writable notifications */i++) {
					size_t len = new size_t();
					if (clientfd[i] != CURL_SOCKET_BAD) {
						len =  - tos[i];
						if (len && .__WSAFDIsSet((SOCKET)(clientfd[i]), (fd_set)(ModernizedCProgram.input))) {
							rc = (ssize_t).recv((SOCKET)(clientfd[i]), (byte)(readclient[i][tos[i]]), (int)(len), (int)(/* read from client */false));
							if (rc <= 0) {
								ModernizedCProgram.logmsg("[%s] got %zd, STOP READING client", ((i) ? "DATA" : "CTRL"), rc);
								.shutdown(clientfd[i], -1024);
								poll_client_rd[i] = 0;
							} else {
									ModernizedCProgram.logmsg("[%s] READ %zd bytes from client", ((i) ? "DATA" : "CTRL"), rc);
									ModernizedCProgram.logmsg("[%s] READ \"%s\"", ((i) ? "DATA" : "CTRL"), ModernizedCProgram.data_to_hex(readclient[i][tos[i]], rc));
									tos[i] += rc;
							} 
						} 
					} 
					if (serverfd[i] != CURL_SOCKET_BAD) {
						len =  - toc[i];
						if (len && .__WSAFDIsSet((SOCKET)(serverfd[i]), (fd_set)(ModernizedCProgram.input))) {
							rc = (ssize_t).recv((SOCKET)(serverfd[i]), (byte)(readserver[i][toc[i]]), (int)(len), (int)(/* read from server */false));
							if (rc <= 0) {
								ModernizedCProgram.logmsg("[%s] got %zd, STOP READING server", ((i) ? "DATA" : "CTRL"), rc);
								.shutdown(serverfd[i], -1024);
								poll_server_rd[i] = 0;
							} else {
									ModernizedCProgram.logmsg("[%s] READ %zd bytes from server", ((i) ? "DATA" : "CTRL"), rc);
									ModernizedCProgram.logmsg("[%s] READ \"%s\"", ((i) ? "DATA" : "CTRL"), ModernizedCProgram.data_to_hex(readserver[i][toc[i]], rc));
									toc[i] += rc;
							} 
						} 
					} 
					if (clientfd[i] != CURL_SOCKET_BAD) {
						if (toc[i] && .__WSAFDIsSet((SOCKET)(clientfd[i]), (fd_set)(output))) {
							rc = (ssize_t).send((SOCKET)(clientfd[i]), (byte)(readserver[i]), (int)(toc[i]), (int)(/* write to client */false));
							if (rc <= 0) {
								ModernizedCProgram.logmsg("[%s] got %zd, STOP WRITING client", ((i) ? "DATA" : "CTRL"), rc);
								.shutdown(clientfd[i], -1024);
								poll_client_wr[i] = 0;
								tcp_fin_wr = 1;
							} else {
									ModernizedCProgram.logmsg("[%s] SENT %zd bytes to client", ((i) ? "DATA" : "CTRL"), rc);
									ModernizedCProgram.logmsg("[%s] SENT \"%s\"", ((i) ? "DATA" : "CTRL"), ModernizedCProgram.data_to_hex(readserver[i], rc));
									if (toc[i] - rc) {
										.memmove(readserver[i][0], readserver[i][rc], toc[i] - rc);
									} 
									toc[i] -= rc;
							} 
						} 
					} 
					if (serverfd[i] != CURL_SOCKET_BAD) {
						if (tos[i] && .__WSAFDIsSet((SOCKET)(serverfd[i]), (fd_set)(output))) {
							rc = (ssize_t).send((SOCKET)(serverfd[i]), (byte)(readclient[i]), (int)(tos[i]), (int)(/* write to server */false));
							if (rc <= 0) {
								ModernizedCProgram.logmsg("[%s] got %zd, STOP WRITING server", ((i) ? "DATA" : "CTRL"), rc);
								.shutdown(serverfd[i], -1024);
								poll_server_wr[i] = 0;
								tcp_fin_wr = 1;
							} else {
									ModernizedCProgram.logmsg("[%s] SENT %zd bytes to server", ((i) ? "DATA" : "CTRL"), rc);
									ModernizedCProgram.logmsg("[%s] SENT \"%s\"", ((i) ? "DATA" : "CTRL"), ModernizedCProgram.data_to_hex(readclient[i], rc));
									if (tos[i] - rc) {
										.memmove(readclient[i][0], readclient[i][rc], tos[i] - rc);
									} 
									tos[i] -= rc;
							} 
						} 
					} 
				}
				if (ModernizedCProgram.got_exit_signal) {
					break;
				} 
				for (i = 0; i <= max_tunnel_idx; /* endpoint read/write disabling, endpoint closing and tunnel teardown */i++) {
					for (loop = 2; loop > 0; loop/* loop twice to satisfy condition interdependencies without
					             having to await select timeout or another socket event */--) {
						if (clientfd[i] != CURL_SOCKET_BAD) {
							if (poll_client_rd[i] && !poll_server_wr[i]) {
								ModernizedCProgram.logmsg("[%s] DISABLED READING client", ((i) ? "DATA" : "CTRL"));
								.shutdown(clientfd[i], -1024);
								poll_client_rd[i] = 0;
							} 
							if (poll_client_wr[i] && !poll_server_rd[i] && !toc[i]) {
								ModernizedCProgram.logmsg("[%s] DISABLED WRITING client", ((i) ? "DATA" : "CTRL"));
								.shutdown(clientfd[i], -1024);
								poll_client_wr[i] = 0;
								tcp_fin_wr = 1;
							} 
						} 
						if (serverfd[i] != CURL_SOCKET_BAD) {
							if (poll_server_rd[i] && !poll_client_wr[i]) {
								ModernizedCProgram.logmsg("[%s] DISABLED READING server", ((i) ? "DATA" : "CTRL"));
								.shutdown(serverfd[i], -1024);
								poll_server_rd[i] = 0;
							} 
							if (poll_server_wr[i] && !poll_client_rd[i] && !tos[i]) {
								ModernizedCProgram.logmsg("[%s] DISABLED WRITING server", ((i) ? "DATA" : "CTRL"));
								.shutdown(serverfd[i], -1024);
								poll_server_wr[i] = 0;
								tcp_fin_wr = 1;
							} 
						} 
					}
				}
				if (tcp_fin_wr) {
					ModernizedCProgram.wait_ms(/* allow kernel to place FIN bit packet on the wire */250);
				} 
				for (i = 0; i <= max_tunnel_idx; /* socket clearing */i++) {
					for (loop = 2; loop > 0; loop--) {
						if (clientfd[i] != CURL_SOCKET_BAD) {
							if (!poll_client_wr[i] && !poll_client_rd[i]) {
								ModernizedCProgram.logmsg("[%s] CLOSING client socket", ((i) ? "DATA" : "CTRL"));
								.closesocket((clientfd[i]));
								clientfd[i] = CURL_SOCKET_BAD;
								if (serverfd[i] == CURL_SOCKET_BAD) {
									ModernizedCProgram.logmsg("[%s] ENDING", ((i) ? "DATA" : "CTRL"));
									if (i == 1) {
										secondary = 0;
									} else {
											primary = 0;
									} 
								} 
							} 
						} 
						if (serverfd[i] != CURL_SOCKET_BAD) {
							if (!poll_server_wr[i] && !poll_server_rd[i]) {
								ModernizedCProgram.logmsg("[%s] CLOSING server socket", ((i) ? "DATA" : "CTRL"));
								.closesocket((serverfd[i]));
								serverfd[i] = CURL_SOCKET_BAD;
								if (clientfd[i] == CURL_SOCKET_BAD) {
									ModernizedCProgram.logmsg("[%s] ENDING", ((i) ? "DATA" : "CTRL"));
									if (i == 1) {
										secondary = 0;
									} else {
											primary = 0;
									} 
								} 
							} 
						} 
					}
				}
				max_tunnel_idx = secondary ? 1 : /* ---------------------------------------------------------- */0;
				if (!primary/* exit loop upon primary tunnel teardown */) {
					break;
				} 
			} else {
					/* (rc > 0) */timeout_count++;
					if (timeout_count > 5) {
						ModernizedCProgram.logmsg("CONNECT proxy timeout after %d idle seconds!", timeout_count);
						break;
					} 
			} 
		}
		infdp = CURL_SOCKET_BAD;
	}
	/* returns a socket handle, or 0 if there are no more waiting sockets,
	   or < 0 if there was an error */
	public static Object accept_connection(Object sock) {
		 msgsock = CURL_SOCKET_BAD;
		int error;
		int flag = 1;
		if (1024 == ModernizedCProgram.num_sockets) {
			ModernizedCProgram.logmsg("Too many open sockets!");
			return CURL_SOCKET_BAD;
		} 
		msgsock = .accept(sock, ((Object)0), ((Object)0));
		if (ModernizedCProgram.got_exit_signal) {
			if (CURL_SOCKET_BAD != msgsock) {
				.closesocket((msgsock));
			} 
			return CURL_SOCKET_BAD;
		} 
		if (CURL_SOCKET_BAD == msgsock) {
			error = ((int).WSAGetLastError());
			if (11 == error || -1024 == error) {
				return /* nothing to accept */0;
			} 
			ModernizedCProgram.logmsg("MAJOR ERROR: accept() failed with error: (%d) %s", error, .strerror(error));
			return CURL_SOCKET_BAD;
		} 
		if (0 != ModernizedCProgram.curlx_nonblock(msgsock, 1)) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("curlx_nonblock failed with error: (%d) %s", error, .strerror(error));
			.closesocket((msgsock));
			return CURL_SOCKET_BAD;
		} 
		if (0 != .setsockopt(msgsock, -1024, 8, (Object)flag, )) {
			error = ((int).WSAGetLastError());
			ModernizedCProgram.logmsg("setsockopt(SO_KEEPALIVE) failed with error: (%d) %s", error, .strerror(error));
			.closesocket((msgsock));
			return CURL_SOCKET_BAD/*
			  ** As soon as this server accepts a connection from the test harness it
			  ** must set the server logs advisor read lock to indicate that server
			  ** logs should not be read until this lock is removed by this server.
			  */;
		} 
		if (!ModernizedCProgram.serverlogslocked) {
			ModernizedCProgram.set_advisor_read_lock("log/serverlogs.lock");
		} 
		ModernizedCProgram.serverlogslocked += 1;
		ModernizedCProgram.logmsg("====> Client connect");
		ModernizedCProgram.all_sockets[ModernizedCProgram.num_sockets] = msgsock;
		ModernizedCProgram.num_sockets += 1;
		if (ModernizedCProgram.socket_domain_is_ip()) {
			if (0 != .setsockopt(msgsock, 6, -1024, (Object)flag, )) {
				ModernizedCProgram.logmsg("====> TCP_NODELAY failed");
			} 
		} 
		return msgsock;
	}
	public static _iobuf execpath(Object filename) {
		byte[] filebuffer = new byte[512/* Get the filename of our executable. GetModuleFileName is already declared
		   * via inclusions done in setup header file.  We assume that we are using
		   * the ASCII version here.
		   */];
		long len = .GetModuleFileNameA(0, filebuffer, );
		if (len > 0 && len < ) {
			byte lastdirchar = .strrchr(filebuffer, /* We got a valid filename - get the directory part */(byte)'\\');
			if (lastdirchar) {
				size_t remaining = new size_t();
				lastdirchar = 0;
				remaining =  - .strlen(/* If we have enough space, build the RC filename */filebuffer);
				if (.strlen(filename) < remaining - 1) {
					ModernizedCProgram.curl_msnprintf(lastdirchar, remaining, "%s%s", "\\", filename);
					return .fopen(filebuffer, "rt");
				} 
			} 
		} 
		return ((Object)0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* only acknowledge colon or equals as separators if the option was not
	   specified with an initial dash! */
	public static Object unslashquote(Object line, byte param) {
		while (line && (line != (byte)'\"')) {
			if (line == (byte)'\\') {
				byte out;
				line++;
				switch (out = /* default is to output the letter after the backslash */line) {
				case (byte)'t':
						out = (byte)'\t';
						break;
				case (byte)'v':
						out = (byte)'\v';
						break;
				case (byte)'r':
						out = (byte)'\r';
						break;
				case (byte)'\0':
						continue;
				case (byte)'n':
						out = (byte)'\n';
						break;
				}
				param++ = out;
				line++;
			} else {
					param++ = line++;
			} 
		}
		param = /* always zero terminate */(byte)'\0';
		return line/*
		 * Reads a line from the given file, ensuring is NUL terminated.
		 * The pointer must be freed by the caller.
		 * NULL is returned on an out of memory condition.
		 */;
	}
	public static Byte my_get_line() {
		byte[] buf = new byte[4096];
		byte nl = ((Object)0);
		byte line = ((Object)0);
		do {
			if (((Object)0) == .fgets(buf, , fp)) {
				break;
			} 
			if (!line) {
				line = .strdup(buf);
				if (!line) {
					return ((Object)0);
				} 
			} else {
					byte ptr;
					size_t linelen = .strlen(line);
					ptr = .realloc(line, linelen + .strlen(buf) + 1);
					if (!ptr) {
						do {
							.free((line));
							(line) = ((Object)0);
						} while (0);
						return ((Object)0);
					} 
					line = ptr;
					.strcpy(line[linelen], buf);
			} 
			nl = .strchr(line, (byte)'\n');
		} while (!nl);
		if (nl) {
			nl = (byte)'\0';
		} 
		return line;
	}
	public static void add_transfer(Object cm, int i) {
		Curl_easy curl_easy = new Curl_easy();
		 eh = curl_easy.curl_easy_init();
		eh.curl_easy_setopt(CURLOPT_WRITEFUNCTION, write_cb);
		eh.curl_easy_setopt(CURLOPT_URL, ModernizedCProgram.urls[i]);
		eh.curl_easy_setopt(CURLOPT_PRIVATE, ModernizedCProgram.urls[i]);
		ModernizedCProgram.curl_multi_add_handle(cm, eh);
	}
}
